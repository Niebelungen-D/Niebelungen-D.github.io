<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Glibc 2 20 Malloc源码分析 - Niebelungen</title><meta name="Description" content=""><meta property="og:title" content="Glibc 2 20 Malloc源码分析" />
<meta property="og:description" content="Glibc-2.20-malloc源码分析
第一次看源码，都算不上分析只是写写自己的理解。不知如何入手，所以记录的内容难免凌乱缺少条理，还请见谅。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" /><meta property="og:image" content="http://example.org/favicon.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-07T00:52:59+08:00" />
<meta property="article:modified_time" content="2021-03-07T00:52:59+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/favicon.png"/>

<meta name="twitter:title" content="Glibc 2 20 Malloc源码分析"/>
<meta name="twitter:description" content="Glibc-2.20-malloc源码分析
第一次看源码，都算不上分析只是写写自己的理解。不知如何入手，所以记录的内容难免凌乱缺少条理，还请见谅。"/>
<meta name="application-name" content="Niebelungen">
<meta name="apple-mobile-web-app-title" content="Niebelungen"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://example.org/posts/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" /><link rel="prev" href="http://example.org/posts/csapp-malloclab/" /><link rel="next" href="http://example.org/posts/challenges-100-week-7/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Glibc 2 20 Malloc源码分析",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/posts\/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\/"
        },"genre": "posts","keywords": "Pwn","wordcount":  31957 ,
        "url": "http:\/\/example.org\/posts\/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\/","datePublished": "2021-03-07T00:52:59+08:00","dateModified": "2021-03-07T00:52:59+08:00","publisher": {
            "@type": "Organization",
            "name": "Niebelungen"},"author": {
                "@type": "Person",
                "name": "Niebelungen"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Niebelungen">Niebelungen</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Niebelungen">Niebelungen</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Glibc 2 20 Malloc源码分析</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Niebelungen</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/pwning/"><i class="far fa-folder fa-fw"></i>Pwning</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-03-07">2021-03-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 31957 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 64 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#大小和对齐检查以及转换">大小和对齐检查以及转换</a>
      <ul>
        <li><a href="#struct-malloc_chunk">struct malloc_chunk</a></li>
      </ul>
    </li>
    <li><a href="#物理chunk操作">物理chunk操作</a></li>
    <li><a href="#内部数据结构">内部数据结构</a>
      <ul>
        <li><a href="#unlink">unlink</a></li>
        <li><a href="#large-binsmall-bin">large bin&amp;small bin</a></li>
        <li><a href="#unsorted-bin">unsorted bin</a></li>
        <li><a href="#top">Top</a></li>
        <li><a href="#binmap">binmap</a></li>
        <li><a href="#fast-bin">fast bin</a></li>
      </ul>
    </li>
    <li><a href="#内部状态表示与初始化">内部状态表示与初始化</a>
      <ul>
        <li><a href="#malloc_state">malloc_state</a></li>
        <li><a href="#malloc_par">malloc_par</a></li>
        <li><a href="#malloc_init_state">malloc_init_state</a></li>
        <li><a href="#__libc_mallopt">__libc_mallopt()</a></li>
        <li><a href="#ptmalloc_init">ptmalloc_init()</a></li>
      </ul>
    </li>
    <li><a href="#多分配区">多分配区</a>
      <ul>
        <li><a href="#heap_info">heap_info</a></li>
      </ul>
    </li>
    <li><a href="#公共包装">公共包装</a>
      <ul>
        <li><a href="#__libc_malloc">__libc_malloc</a></li>
        <li><a href="#_int_malloc">_int_malloc()</a>
          <ul>
            <li><a href="#sysmalloc">sysmalloc</a></li>
          </ul>
        </li>
        <li><a href="#malloc_consolidate">malloc_consolidate</a></li>
        <li><a href="#__libc_free">__libc_free</a></li>
        <li><a href="#_int_free">_int_free</a></li>
      </ul>
    </li>
    <li><a href="#end">End</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="glibc-220-malloc源码分析">Glibc-2.20-malloc源码分析</h1>
<p>第一次看源码，都算不上分析只是写写自己的理解。不知如何入手，所以记录的内容难免凌乱缺少条理，还请见谅。</p>
<h2 id="大小和对齐检查以及转换">大小和对齐检查以及转换</h2>
<h3 id="struct-malloc_chunk">struct malloc_chunk</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>	 <span class="n">INTERNAL_SIZE_T</span> <span class="n">prev_size</span><span class="p">;</span> <span class="cm">/* Size of previous chunk (if free).  */</span> <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span> <span class="cm">/* Size in bytes, including overhead. */</span>   <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span> <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span> <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span> <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span> <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;};</span>
</code></pre></td></tr></table>
</div>
</div><p>我省去了大部分的描述，只保留了结构图。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   malloc_chunk details:    An allocated chunk looks like this:    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	    |             Size of previous chunk, if allocated            | |	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	    |             Size of chunk, in bytes                       |M|P|      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	    |             User data starts here...                          .	    .                                                               .	    .             (malloc_usable_size() bytes)                      .	    .                                                               |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	    |             Size of chunk                                     |	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    Free chunks are stored in circular doubly-linked lists, and look like this:    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	    |             Size of previous chunk                            |	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    `head:&#39; |             Size of chunk, in bytes                         |P|      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	    |             Forward pointer to next chunk in list             |	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	    |             Back pointer to previous chunk in list            |	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	    |             Unused space (may be 0 bytes long)                .	    .                                                               .	    .                                                               |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    `foot:&#39; |             Size of chunk, in bytes                           |	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>prev_size</strong>：如果前一个chunk是空闲的，该域表示前一个chunk的大小，如果前一个chunk不空闲，该域无意义。<strong>注意：这里的前一个指的是存储物理相邻地址较低的那一个chunk。</strong></li>
<li><strong>size</strong>：该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示：
<ul>
<li>A: NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程（分配区/arena），1表示不属于，0表示属于。</li>
<li>M: IS_MAPPED，他表示当前chunk是从哪个内存区域获得的虚拟内存。M为1表示该chunk是从mmap映射区域分配的，否则是从heap区域分配的。</li>
<li>P: PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。</li>
</ul>
</li>
<li><strong>fd，bk</strong>： chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下
<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
</ul>
</li>
<li><strong>fd_nextsize， bk_nextsize</strong>：也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。
<ul>
<li>fd_nextsize指向下一个比当前chunk size小的第一个空闲chunk，不包含 bin 的头指针。</li>
<li>bk_nextszie指向上一个比当前chunk size大的第一个空闲chunk，不包含 bin 的头指针。</li>
<li>large bins中的空闲chunk是按照大小排序的。<strong>这样做可以避免在寻找合适chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p><strong>注意：fd所指向的是从表头到表尾方向，bk则是反过来。这样理解下一个和上一个的含义。</strong>
一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</strong>
当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前chunk使用。<strong>这就是chunk中的空间复用。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))
</span><span class="cp">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))
</span><span class="cp"></span>
<span class="cm">/* The smallest possible chunk */</span>
<span class="cp">#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))
</span><span class="cp"></span>
<span class="cm">/* The smallest size we can malloc is an aligned minimal chunk */</span>

<span class="cp">#define MINSIZE  \
</span><span class="cp">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))
</span><span class="cp"></span>
<span class="cm">/* Check if m has acceptable alignment */</span>

<span class="cp">#define aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)
</span><span class="cp"></span>
<span class="cp">#define misaligned_chunk(p) \
</span><span class="cp">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \
</span><span class="cp">   &amp; MALLOC_ALIGN_MASK)
</span></code></pre></td></tr></table>
</div>
</div><p>每次<code>malloc</code>得到的是<code>mem</code>指针，真正指向整个chunk的是<code>chunk</code>指针，可以通过上面两个宏进行转换。
<code>MIN_CHUNK_SIZE </code>定义了最小chunk的至少要包含<code>fd</code>与<code>bk</code>指针。
<code>MINSIZE</code>定义了最小的分配的内存大小，是对<code>MIN_CHUNK_SIZE</code>进行了2*<code>SIZE_SZ</code>对齐，地址对齐后与<code>MIN_CHUNK_SIZE</code>的大小仍然是一样的。
宏<code>aligned_OK</code>和<code>misaligned_chunk(p)</code>用于校验地址是否是按2*<code>SIZE_SZ</code>对齐的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Check if a request is so large that it would wrap around zero when   padded and aligned. To simplify some other code, the bound is made   low enough so that adding MINSIZE will also not wrap around zero. */</span><span class="cp">#define REQUEST_OUT_OF_RANGE(req)                                 \  ((unsigned long) (req) &gt;=						      \   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span><span class="cm">/* pad request bytes into a usable size -- internal version */</span><span class="cp">#define request2size(req)                                         \  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \   MINSIZE :                                                      \   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><span class="cm">/*  Same, except also perform argument check */</span><span class="cp">#define checked_request2size(req, sz)                             \  if (REQUEST_OUT_OF_RANGE (req)) {					      \      __set_errno (ENOMEM);						      \      return 0;								      \    }									      \  (sz) = request2size (req);
</span></code></pre></td></tr></table>
</div>
</div><p>用户申请的内存大小需要转化为真实chunk大小，在转换的时候加上了<code>SIZE_SZ</code>大小，这是因为chunk中的空间复用。所以实际一个使用中chunk size(64位下)的计算公式为<code>in_use_size = (req +16 -8) align to 8B</code>
最后，因为空闲的chunk和使用中的chunk使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即最终的分配空间<code>chunk_size = max(in_use_size, 32)</code>。</p>
<h2 id="物理chunk操作">物理chunk操作</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* size field is or&#39;ed with PREV_INUSE when previous adjacent chunk in use */</span><span class="cp">#define PREV_INUSE 0x1</span><span class="cm">/* extract inuse bit of previous chunk */</span><span class="cp">#define prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span><span class="cm">/* size field is or&#39;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span><span class="cp">#define IS_MMAPPED 0x2</span><span class="cm">/* check for mmap()&#39;ed chunk */</span><span class="cp">#define chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span><span class="cm">/* size field is or&#39;ed with NON_MAIN_ARENA if the chunk was obtained   from a non-main arena.  This is only set immediately before handing   the chunk to the user, if necessary.  */</span><span class="cp">#define NON_MAIN_ARENA 0x4</span><span class="cm">/* check for chunk from non-main arena */</span><span class="cp">#define chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)
</span></code></pre></td></tr></table>
</div>
</div><p>参考上一节</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Bits to mask off when extracting size   Note: IS_MMAPPED is intentionally not masked off from size field in   macros for which mmapped chunks should never be seen. This should   cause helpful core dumps to occur if it is tried by accident by   people extending or adapting this malloc. */</span><span class="cp">#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><span class="cm">/* Get size, ignoring use bits */</span><span class="cp">#define chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span><span class="cm">/* Ptr to next physical malloc_chunk. */</span><span class="cp">#define next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span><span class="cm">/* Ptr to previous physical malloc_chunk */</span><span class="cp">#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span><span class="cm">/* Treat space at ptr + offset as a chunk */</span><span class="cp">#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
</span></code></pre></td></tr></table>
</div>
</div><p>如果前一个邻接chunk块空闲，那么当前chunk块结构体内的<code>prev_size</code>字段记录的是前一个邻接chunk块的大小。这就是由当前chunk指针获得前一个空闲chunk地址的依据。
如果前一个邻接chunk在使用中，则当前chunk的<code>prev_size</code>的空间被前一个chunk借用中，其中的值是前一个chunk的内存内容，对当前chunk没有任何意义。
字段<code>size</code>记录了本chunk的大小，无论下一个chunk是空闲状态或是被使用状态，都可以通过本chunk的地址加上本chunk的大小，得到下一个chunk的地址，由于size的低3个bit记录了控制信息，需要屏蔽掉这些控制信息，取出实际的size在进行计算下一个chunk地址，这是<code>next_chunk(p)</code>的实现原理。<code>prev_chunk</code>同理。
宏<code>chunksize(p)</code>用于获得chunk的实际大小，需要屏蔽掉size中的控制信息。
宏<code>chunk_at_offset(p, s)</code>将p+s的地址强制看作一个chunk。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* extract p&#39;s inuse bit */</span><span class="cp">#define inuse(p)							      \  ((((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span><span class="cm">/* set/clear chunk as being inuse without otherwise disturbing */</span><span class="cp">#define set_inuse(p)							      \  ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE#define clear_inuse(p)							      \  ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span><span class="cm">/* check/set/clear inuse bits in known places */</span><span class="cp">#define inuse_bit_at_offset(p, s)					      \  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)#define set_inuse_bit_at_offset(p, s)					      \  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)#define clear_inuse_bit_at_offset(p, s)					      \  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><span class="cm">/* Set size at head, without disturbing its use bit */</span><span class="cp">#define set_head_size(p, s)  ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span><span class="cm">/* Set size/use field */</span><span class="cp">#define set_head(p, s)       ((p)-&gt;size = (s))</span><span class="cm">/* Set size at footer (only when chunk is not in use) */</span><span class="cp">#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))
</span></code></pre></td></tr></table>
</div>
</div><p>chunk头的检查与设置操作。</p>
<h2 id="内部数据结构">内部数据结构</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Bins    An array of bin headers for free chunks. Each bin is doubly    linked.  The bins are approximately proportionally (log) spaced.    There are a lot of these bins (128). This may look excessive, but    works very well in practice.  Most bins hold sizes that are    unusual as malloc request sizes, but are more usual for fragments    and consolidated sets of chunks, which is what these bins hold, so    they can be found quickly.  All procedures maintain the invariant    that no consolidated chunk physically borders another one, so each    chunk in a list is known to be preceeded and followed by either    inuse chunks or the ends of memory.    Chunks in bins are kept in size order, with ties going to the    approximately least recently used chunk. Ordering isn&#39;t needed    for the small bins, which all contain the same-sized chunks, but    facilitates best-fit allocation for larger chunks. These lists    are just sequential. Keeping them in order almost never requires    enough traversal to warrant using fancier ordered data    structures.    Chunks of the same size are linked with the most    recently freed at the front, and allocations are taken from the    back.  This results in LRU (FIFO) allocation order, which tends    to give each chunk an equal opportunity to be consolidated with    adjacent freed chunks, resulting in larger free chunks and less    fragmentation.    To simplify use in double-linked lists, each bin header acts    as a malloc_chunk. This avoids special-casing for headers.    But to conserve space and improve locality, we allocate    only the fd/bk pointers of bins, and then use repositioning tricks    to treat these as the fields of a malloc_chunk*. */</span>
</code></pre></td></tr></table>
</div>
</div><p>对于空闲块的管理ptmalloc使用了<strong>bins</strong>，根据size的大小将其放入不同类型的bin中，每种bin内部又分为不同的bin对空闲块进行更细化的管理。每个bin都是由双向链表进行组织维护，并且每个bin的头部都充当一个<code>malloc_chunk</code>结构体，在bins数组中只为每个bin预留了两个指针的内存空间用于存放bin的链表头的fb和bk指针。。
除了<code>small bin</code>外其余bin中的chunk都以大小顺序排列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="o">*</span><span class="n">mbinptr</span><span class="p">;</span><span class="cm">/* addressing -- note that bin_at(0) does not exist */</span><span class="err">#</span><span class="n">define</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="err">\</span>  <span class="p">(</span><span class="n">mbinptr</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bins</span><span class="p">[((</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]))</span>			      <span class="err">\</span>             <span class="o">-</span> <span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">malloc_chunk</span><span class="p">,</span> <span class="n">fd</span><span class="p">))</span><span class="cm">/* analog of ++bin */</span><span class="err">#</span><span class="n">define</span> <span class="n">next_bin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="p">((</span><span class="n">mbinptr</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">mchunkptr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)))</span><span class="cm">/* Reminders about list directionality within bins */</span><span class="err">#</span><span class="n">define</span> <span class="n">first</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>     <span class="p">((</span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">)</span><span class="err">#</span><span class="n">define</span> <span class="n">last</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>      <span class="p">((</span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>bin_at(m,i)</code>用来通过index来获取bin的链表头，m 指的是分配区，i 是索引。
宏<code>next_bin(b)</code>用于获得下一个bin的地址，根据前面的分析，我们知道只需要将当前bin的地址向后移动两个指针的长度就得到下一个bin的链表头地址。
bin采用双向链表，表头的fd指向的第一个可用chunk，bk指向链表中最后一个。<code>first(b)</code>和<code>last(b)</code>用来获取一个bin中第一和最后一个可用chunk。</p>
<h3 id="unlink">unlink</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Take a chunk off a bin list */</span><span class="cp">#define unlink(P, BK, FD) {                                            \    FD = P-&gt;fd;								      \    BK = P-&gt;bk;								      \    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \      malloc_printerr (check_action, &#34;corrupted double-linked list&#34;, P);      \    else {								      \        FD-&gt;bk = BK;							      \        BK-&gt;fd = FD;							      \        if (!in_smallbin_range (P-&gt;size)				      \            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {		      \            assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P);			      \            assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P);			      \            if (FD-&gt;fd_nextsize == NULL) {				      \                if (P-&gt;fd_nextsize == P)				      \                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \                else {							      \                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \                  }							      \              } else {							      \                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \              }								      \          }								      \      }									      \}
</span></code></pre></td></tr></table>
</div>
</div><p>经典<code>unlink</code>用来从链表中取出一个chunk。
<strong>注意：large bins中的空闲chunk可能处于两个双向循环链表中，<code>unlink</code>时需要从两个链表中都删除。</strong>
所以，从这里可以看出在<code>large bin</code>中chunk是用<code>fd_nextsize</code>和<code>bk_nextsize</code>来链接的。</p>
<h3 id="large-binsmall-bin">large bin&amp;small bin</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Indexing    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced    8 bytes apart. Larger bins are approximately logarithmically spaced:    64 bins of size       8    32 bins of size      64    16 bins of size     512     8 bins of size    4096     4 bins of size   32768     2 bins of size  262144     1 bin  of size what&#39;s left    There is actually a little bit of slop in the numbers in bin_index    for the sake of speed. This makes no difference elsewhere.    The bins top out around 1MB because we expect to service large    requests via mmap.    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be    a valid chunk size the small bins are bumped up one. */</span>
</code></pre></td></tr></table>
</div>
</div><p>sizes小于512 bytes的chunk属于<code>small bin</code>的管理范围，表中列出了bin之间的公差，单位byte。bin 0不存在，bin 1是<code>unsorted bin</code>的链表头。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define NBINS             128#define NSMALLBINS         64#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)#define in_smallbin_range(sz)  \  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)#define smallbin_index(sz) \  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\   + SMALLBIN_CORRECTION)#define largebin_index_32(sz)                                                \  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;&gt; 6) :\   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\   126)#define largebin_index_32_big(sz)                                            \  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45) ?  49 + (((unsigned long) (sz)) &gt;&gt; 6) :\   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\   126)</span><span class="c1">// XXX It remains to be seen whether it is good to keep the widths of// XXX the buckets the same or whether it should be scaled by a factor// XXX of two as well.#define largebin_index_64(sz)                                                \  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;&gt; 6) :\   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\   126)#define largebin_index(sz) \  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \   : largebin_index_32 (sz))#define bin_index(sz) \  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))
</span></code></pre></td></tr></table>
</div>
</div><p>所有的bin头可视为一个数组，总共有128bin，但是实际上因为bin 0和bin 127不存在，所以只有126个bin，bin 1为<code>unsorted bin</code>，bin 2-63为<code>small bin</code>，其余都是<code>large bin</code>。所以<code>small bin</code>为62个，<code>large bin</code>为63个。</p>
<h3 id="unsorted-bin">unsorted bin</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Unsorted chunks    All remainders from chunk splits, as well as all returned chunks,    are first placed in the &#34;unsorted&#34; bin. They are then placed    in regular bins after malloc gives them ONE chance to be used before    binning. So, basically, the unsorted_chunks list acts as a queue,    with chunks being placed on it in free (and malloc_consolidate),    and taken off (to be either used or placed in bins) in malloc.    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it    does not have to be taken into account in size comparisons. *//* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span><span class="cp">#define unsorted_chunks(M)          (bin_at (M, 1))
</span></code></pre></td></tr></table>
</div>
</div><p>bin 1为<code>unsorted bin</code>的链表头，chunk分割后剩余的部分会首先被放入<code>unsorted bin</code>，并且不排序。若<code>unsorted bin</code>中的chunk不能满足用户的请求，那么就会将其中的chunk进行合并，然后分配到各自属于的bin中。所以<code>unsorted bin</code>扮演一个队列的角色。</p>
<h3 id="top">Top</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Top    The top-most available chunk (i.e., the one bordering the end of    available memory) is treated specially. It is never included in    any bin, is used only if no other chunk is available, and is    released back to the system if it is very large (see    M_TRIM_THRESHOLD).  Because top initially    points to its own bin with initial zero size, thus forcing    extension on the first malloc request, we avoid having any special    code in malloc to check whether it even exists yet. But we still    need to do so when getting memory from system, so we make    initial_top treat the bin as a legal but unusable chunk during the    interval between initialization and the first call to    sysmalloc. (This is somewhat delicate, since it relies on    the 2 preceding words to be zero during this interval as well.) *//* Conveniently, the unsorted bin can be used as dummy top on first call */</span><span class="cp">#define initial_top(M)              (unsorted_chunks (M))
</span></code></pre></td></tr></table>
</div>
</div><p><code>top chunk</code>是特殊的，它不属于任何bin，当任何bin都无法满足要求时才会对其进行操作。当它很大时会释放回操作系统。根据描述，为了不再添加特殊的代码来检查<code>top chunk</code>，所以将其初始化为一个合法的<code>unsorted bin</code>。</p>
<h3 id="binmap">binmap</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Binmap    To help compensate for the large number of bins, a one-level index    structure is used for bin-by-bin searching.  `binmap&#39; is a    bitvector recording whether bins are definitely empty so they can    be skipped over during during traversals.  The bits are NOT always    cleared as soon as bins are empty, but instead only    when they are noticed to be empty during traversal in malloc. *//* Conservatively use 32 bits per map word, even if on 64bit system */</span><span class="cp">#define BINMAPSHIFT      5#define BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)#define BINMAPSIZE       (NBINS / BITSPERMAP)#define idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)#define idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))#define unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))#define get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))
</span></code></pre></td></tr></table>
</div>
</div><p><code>binmap</code>用来简化判断一个bin是否为空，<code>binmap</code>中的bit位是在malloc时进行设置的。</p>
<h3 id="fast-bin">fast bin</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Fastbins    An array of lists holding recently freed small chunks.  Fastbins    are not doubly linked.  It is faster to single-link them, and    since chunks are never removed from the middles of these lists,    double linking is not necessary. Also, unlike regular bins, they    are not even processed in FIFO order (they use faster LIFO) since    ordering doesn&#39;t much matter in the transient contexts in which    fastbins are normally used.    Chunks in fastbins keep their inuse bit set, so they cannot    be consolidated with other free chunks. malloc_consolidate    releases all chunks in fastbins and consolidates them with    other free chunks. */</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="o">*</span><span class="n">mfastbinptr</span><span class="p">;</span><span class="err">#</span><span class="n">define</span> <span class="n">fastbin</span><span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">((</span><span class="n">ar_ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fastbinsY</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="cm">/* offset 2 to use otherwise unindexable first 2 bins */</span><span class="cp">#define fastbin_index(sz) \  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)
</span></code></pre></td></tr></table>
</div>
</div><p><code>fast bin</code>用来保存最近free的<code>small chunk</code>，对于SIZE_SZ为4B的平台，小于64B的chunk分配请求，对于SIZE_SZ为8B的平台，小于128B的chunk分配请求，会首先在<code>fast bin</code>中进行<code>best fit</code>。
<code>fast bin</code>使用单链表进行维护，即仅使用<code>fd</code>域，其可以视为LIFO的链栈。并且其<code>in_use</code>位不会被置零，保证其中的chunk不会被合并。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* The maximum fastbin request size we support */</span><span class="cp">#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span><span class="cm">/*   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()   that triggers automatic consolidation of possibly-surrounding   fastbin chunks. This is a heuristic, so the exact value should not   matter too much. It is defined at half the default trim threshold as a   compromise heuristic to only attempt consolidation if it is likely   to lead to trimming. However, it is not dynamically tunable, since   consolidation reduces fragmentation surrounding large chunks even   if trimming is not used. */</span><span class="cp">#define FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)
</span></code></pre></td></tr></table>
</div>
</div><p>根据<code>SIZE_SZ</code>的不同大小，定义<code>MAX_FAST_SIZE</code>为80B或是160B，<code>fast bins</code>数组的大小<code>NFASTBINS</code>为10，即<code>fast bins</code>共有十个bin，公差为8B。
<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>为64k，当每次释放的chunk与该chunk相邻的空闲chunk合并后的大小大于64k时，就认为内存碎片可能比较多了，就需要把<code>fast bins</code>中的所有chunk都进行合并，以减少内存碎片对系统的影响。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifndef DEFAULT_MXFAST#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)#endif</span><span class="cm">/*   Set value of max_fast.   Use impossibly small value if 0.   Precondition: there are no existing fastbin chunks.   Setting the value clears fastchunk bit but preserves noncontiguous bit. */</span><span class="cp">#define set_max_fast(s) \  global_max_fast = (((s) == 0)						      \                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))#define get_max_fast() global_max_fast
</span></code></pre></td></tr></table>
</div>
</div><p><code>set_max_fast(s)</code>用来设置默认的<code>fast bins</code>中最大的chunk，在free时，大小小于默认值的chunk都会被加入到<code>fast bins</code>中。</p>
<h2 id="内部状态表示与初始化">内部状态表示与初始化</h2>
<h3 id="malloc_state">malloc_state</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">malloc_state</span><span class="p">{</span>  <span class="cm">/* Serialize access.  */</span>  <span class="n">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>  <span class="cm">/* Flags (formerly in max_fast).  */</span>  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>  <span class="cm">/* Fastbins */</span>  <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span><span class="n">NFASTBINS</span><span class="p">];</span>  <span class="cm">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>  <span class="n">mchunkptr</span> <span class="n">top</span><span class="p">;</span>  <span class="cm">/* The remainder from the most recent split of a small request */</span>  <span class="n">mchunkptr</span> <span class="n">last_remainder</span><span class="p">;</span>  <span class="cm">/* Normal bins packed as described above */</span>  <span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span><span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>  <span class="cm">/* Bitmap of bins */</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">binmap</span><span class="p">[</span><span class="n">BINMAPSIZE</span><span class="p">];</span>  <span class="cm">/* Linked list */</span>  <span class="k">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>  <span class="cm">/* Linked list for free arenas.  */</span>  <span class="k">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="n">next_free</span><span class="p">;</span>  <span class="cm">/* Memory allocated from the system in this arena.  */</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">system_mem</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">max_system_mem</span><span class="p">;};</span>
</code></pre></td></tr></table>
</div>
</div><p>ptmalloc使用<code>malloc_state</code>来管理分配区。<code>mutex</code>用于串行化访问，当有多个线程访问同一个分配区时，第一个获得这个<code>mutex</code>的线程将使用该分配区分配内存，分配完成后，释放该分配区的<code>mutex</code>，以便其它线程使用该分配区。可以理解为锁，当正在使用的线程加锁后，其他线程就无法访问，锁被释放后才可以。
<code>Flags</code>(之前记录在<code>max_fast</code>中)记录了分配区的一些标志：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Since the lowest 2 bits in max_fast don&#39;t matter in size comparisons,   they are used as flags. *//*   FASTCHUNKS_BIT held in max_fast indicates that there are probably   some fastbin chunks. It is set true on entering a chunk into any   fastbin, and cleared only in malloc_consolidate.   The truth value is inverted so that have_fastchunks will be true   upon startup (since statics are zero-filled), simplifying   initialization checks. */</span><span class="cp">#define FASTCHUNKS_BIT        (1U)#define have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)#define clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)#define set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><span class="cm">/*   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous   regions.  Otherwise, contiguity is exploited in merging together,   when possible, results from consecutive MORECORE calls.   The initial value comes from MORECORE_CONTIGUOUS, but is   changed dynamically if mmap is ever used as an sbrk substitute. */</span><span class="cp">#define NONCONTIGUOUS_BIT     (2U)#define contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)#define noncontiguous(M)       (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)#define set_noncontiguous(M)   ((M)-&gt;flags |= NONCONTIGUOUS_BIT)#define set_contiguous(M)      ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)
</span></code></pre></td></tr></table>
</div>
</div><p><code>max_fast</code>中的最后两位用作控制信息，bit0用来表示<code>fast bins</code>是否为空。如果bit0为0，表示分配区中有fast chunk，如果为1表示没有fast chunk，初始化完成后的<code>malloc_state</code>实例中，flags值为0，表示该分配区中有fast chunk，但实际上没有，试图从fast bins中分配chunk都会返回NULL，在第一次调用函数<code>malloc_consolidate()</code>对fast bins进行chunk合并时，如果max_fast大于0，会调用<code>clear_fastchunks</code>宏，标志该分配区中已经没有fast chunk，因为函数<code>malloc_consolidate()</code>会合并所有的fast bins中的chunk。<code>clear_fastchunks</code>宏只会在函数<code>malloc_consolidate()</code>中调用。当有fast chunk加入fast bins时，就是调用<code>set_fastchunks</code>宏标识分配区的fast bins中存在fast chunk。
<code>Flags</code>的bit1如果为0，表示<code>MORCORE</code>返回连续虚拟地址空间，bit1为1，表示<code>MORCORE</code>返回非连续虚拟地址空间，对于主分配区，<code>MORECORE</code>其实为<code>sbr()</code>，默认返回连续虚拟地址空间，对于非主分配区，使用<code>mmap()</code>分配大块虚拟内存，然后进行切分来模拟主分配区的行为，而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。
<code>fastbinsY</code>是有十个元素的数组，存放了<code>fastbin</code>的链表头。
<code>top</code>指向了该分配区的<code>top chunk</code>。
<code>last_remainde</code>r是一个chunk指针，分配区上次分配small chunk时，从一个chunk中分裂出一个small chunk返回给用户，分裂后的剩余部分形成一个chunk，<code>last_remainder</code>就是指向的这个chunk。
<code>bins</code>是当前分配区存储<code>unstored bin</code>，<code>small bins</code>和<code>large bins</code>的chunk链表头的数组。
<strong>注意：计算出来数组有254个元素，之前bin头被描述为一个<code>malloc chunk</code>但是要链接chunk，我们只需要<code>fd</code>和<code>bk</code>，对于<code>large bin</code>来说只需要<code>fd_nextsize</code>和<code>bk_nextsize</code>，所以只要为指针申请空间即可，其余域都是被复用的</strong>
<code>binmap</code>字段是一个int数组，共128位。ptmalloc用一个bit来标识该bit对应的bin中是否包含空闲chunk。
<code>next</code>字段用于将分配区以单向链表链接起来。
<code>next_free</code>字段空闲的分配区链接在单向链表中，只有在定义了PER_THREAD的情况下才定义该字段。
<code>system_mem</code>字段记录了当前分配区已经分配的内存大小。
<code>max_system_mem</code>记录了当前分配区最大能分配的内存大小。</p>
<h3 id="malloc_par">malloc_par</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">malloc_par</span><span class="p">{</span>  <span class="cm">/* Tunable parameters */</span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trim_threshold</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">top_pad</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">mmap_threshold</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">arena_test</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">arena_max</span><span class="p">;</span>  <span class="cm">/* Memory map support */</span>  <span class="kt">int</span> <span class="n">n_mmaps</span><span class="p">;</span>  <span class="kt">int</span> <span class="n">n_mmaps_max</span><span class="p">;</span>  <span class="kt">int</span> <span class="n">max_n_mmaps</span><span class="p">;</span>  <span class="cm">/* the mmap_threshold is dynamic, until the user sets     it manually, at which point we need to disable any     dynamic behavior. */</span>  <span class="kt">int</span> <span class="n">no_dyn_threshold</span><span class="p">;</span>  <span class="cm">/* Statistics */</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">mmapped_mem</span><span class="p">;</span>  <span class="cm">/*INTERNAL_SIZE_T  sbrked_mem;*/</span>  <span class="cm">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">max_mmapped_mem</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">max_total_mem</span><span class="p">;</span>  <span class="cm">/* only kept for NO_THREADS */</span>  <span class="cm">/* First address handed out by MORECORE/sbrk.  */</span>  <span class="kt">char</span> <span class="o">*</span><span class="n">sbrk_base</span><span class="p">;};</span>
</code></pre></td></tr></table>
</div>
</div><p><code>malloc_par</code>记录了一些参数和统计信息，<code>trim_threshold</code>字段表示收缩阈值，默认为128KB，当每个分配区的<code>top chunk</code>大小大于这个阈值时，在一定的条件下，调用free时会收缩内存，减小<code>top chunk</code>的大小。由于<code>mmap</code>分配阈值的动态调整，在<code>free</code>时可能将收缩阈值修改为<code>mmap</code>分配阈值的2倍，在64位系统上，<code>mmap</code>分配阈值最大值为32MB，所以收缩阈值的最大值为64MB，在32位系统上，<code>mmap</code>分配阈值最大值为512KB，所以收缩阈值的最大值为1MB。收缩阈值可以通过函数<code>mallopt()</code>进行设置。
<code>top_pad</code>：表示在分配内存时是否添加额外的pad，默认该字段为0。
<code>mmap_threshold</code>：表示<code>mmap</code>分配阈值，默认值为128KB，在32位系统上最大值为512KB，64位系统上的最大值为32MB，由于默认开启<code>mmap</code>分配阈值动态调整，该字段的值会动态修改，但不会超过最大值。
<code>arena_test</code>和<code>arena_max</code>用于<code>PER_THREAD</code>优化，在32位系统上<code>arena_test</code>默认值为2，64位系统上的默认值为8，当每个进程的分配区数量小于等于<code>arena_test</code>时，不会重用已有的分配区。为了限制分配区的总数，用<code>arena_max</code>来保存分配区的最大数量，当系统中的分配区数量达到<code>arena_max</code>，就不会再创建新的分配区，只会重用已有的分配区。这两个字段都可以使用<code>mallopt()</code>函数设置。
<code>n_mmaps</code>：表示当前进程使用<code>mmap()</code>函数分配的内存块的个数。
<code>n_mmaps_max</code>：表示进程使用<code>mmap()</code>函数分配的内存块的最大数量，默认值为65536，可以使用<code>mallopt()</code>函数修改。
<code>max_n_mmaps</code>：表示当前进程使用<code>mmap()</code>函数分配的内存块的数量的最大值，有关系<code>n_mmaps</code> &lt;= <code>max_n_mmaps</code>成立。这个字段是由于<code>mstats()</code>函数输出统计需要这个字段。
<code>no_dyn_threshold</code>：表示是否开启<code>mmap</code>分配阈值动态调整机制，默认值为0，也就是默认开启mmap分配阈值动态调整机制。
<code>pagesize</code>：表示系统的页大小，默认为4KB。
<code>mmapped_mem</code>和<code>max_mmapped_mem</code>都用于统计mmap分配的内存大小，一般情况下两个字段的值相等，<code>max_mmapped_mem</code>用于<code>mstats()</code>函数。
<code>max_total_mem</code>：在单线程情况下用于统计进程分配的内存总数。
<code>sbrk_base</code>：表示堆的起始地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* There are several instances of this struct (&#34;arenas&#34;) in this   malloc.  If you are adapting this malloc in a way that does NOT use   a static or mmapped malloc_state, you MUST explicitly zero-fill it   before using. This malloc relies on the property that malloc_state   is initialized to all zeroes (as is true of C statics).  */</span><span class="k">static</span> <span class="k">struct</span> <span class="n">malloc_state</span> <span class="n">main_arena</span> <span class="o">=</span><span class="p">{</span>  <span class="p">.</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">MUTEX_INITIALIZER</span><span class="p">,</span>  <span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">};</span><span class="cm">/* There is only one instance of the malloc parameters.  */</span><span class="k">static</span> <span class="k">struct</span> <span class="n">malloc_par</span> <span class="n">mp_</span> <span class="o">=</span><span class="p">{</span>  <span class="p">.</span><span class="n">top_pad</span> <span class="o">=</span> <span class="n">DEFAULT_TOP_PAD</span><span class="p">,</span>  <span class="p">.</span><span class="n">n_mmaps_max</span> <span class="o">=</span> <span class="n">DEFAULT_MMAP_MAX</span><span class="p">,</span>  <span class="p">.</span><span class="n">mmap_threshold</span> <span class="o">=</span> <span class="n">DEFAULT_MMAP_THRESHOLD</span><span class="p">,</span>  <span class="p">.</span><span class="n">trim_threshold</span> <span class="o">=</span> <span class="n">DEFAULT_TRIM_THRESHOLD</span><span class="p">,</span><span class="err">#</span><span class="n">define</span> <span class="n">NARENAS_FROM_NCORES</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">((</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">8</span><span class="p">))</span>  <span class="p">.</span><span class="n">arena_test</span> <span class="o">=</span> <span class="n">NARENAS_FROM_NCORES</span> <span class="p">(</span><span class="mi">1</span><span class="p">)};</span><span class="cm">/*  Non public mallopt parameters.  */</span><span class="cp">#define M_ARENA_TEST -7#define M_ARENA_MAX  -8</span><span class="cm">/* Maximum size of memory handled in fastbins.  */</span><span class="cp">static INTERNAL_SIZE_T global_max_fast;
</span></code></pre></td></tr></table>
</div>
</div><p><code>main_arena</code>表示主分配区，任何进程有且仅有一个全局的主分配区，<code>mp_</code>是全局唯一的一个<code>malloc_par</code>实例，用于管理参数和统计信息，<code>global_max_fast</code>全局变量表示fast bins中最大的chunk大小。</p>
<h3 id="malloc_init_state">malloc_init_state</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   Initialize a malloc_state struct.   This is called only from within malloc_consolidate, which needs   be called in the same contexts anyway.  It is never called directly   outside of malloc_consolidate because some optimizing compilers try   to inline it at all call points, which turns out not to be an   optimization at all. (Inlining it in malloc_consolidate is fine though.) */</span><span class="k">static</span> <span class="nf">voidmalloc_init_state</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">){</span>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="n">mbinptr</span> <span class="n">bin</span><span class="p">;</span>  <span class="cm">/* Establish circular links for normal bins */</span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBINS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>    <span class="p">{</span>      <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>      <span class="n">bin</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>    <span class="p">}</span><span class="err">#</span><span class="k">if</span> <span class="n">MORECORE_CONTIGUOUS</span>  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span><span class="err">#</span><span class="n">endif</span>  <span class="n">set_noncontiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>    <span class="n">set_max_fast</span> <span class="p">(</span><span class="n">DEFAULT_MXFAST</span><span class="p">);</span>  <span class="n">av</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FASTCHUNKS_BIT</span><span class="p">;</span>  <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">initial_top</span> <span class="p">(</span><span class="n">av</span><span class="p">);}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>malloc_init_state</code>将分配区中的bin链表头都指向自身。在初始化主分配区时，av默认为0，即默认分配连续的空间(也仅有主分配区才能这样做)，对于非主分配区，需要设置分配非连续的空间。如果初始化的是主分配区，需要设置<code>fast bins</code>中最大chunk大小，由于主分配区只有一个，并且一定是最先初始化，这就保证了对全局变量<code>global_max_fast</code>只初始化了一次，只要该全局变量的值非0，也就意味着主分配区初始化了。最后初始化<code>top chunk</code>。</p>
<h3 id="__libc_mallopt">__libc_mallopt()</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">int__libc_mallopt</span> <span class="p">(</span><span class="kt">int</span> <span class="n">param_number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">){</span>  <span class="n">mstate</span> <span class="n">av</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">;</span>  <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="k">if</span> <span class="p">(</span><span class="n">__malloc_initialized</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>    <span class="n">ptmalloc_init</span> <span class="p">();</span>  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>  <span class="cm">/* Ensure initialization/consolidation */</span>  <span class="n">malloc_consolidate</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>  <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">param_number</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>  <span class="k">switch</span> <span class="p">(</span><span class="n">param_number</span><span class="p">)</span>    <span class="p">{</span>    <span class="k">case</span> <span class="nl">M_MXFAST</span><span class="p">:</span>      <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">MAX_FAST_SIZE</span><span class="p">)</span>        <span class="p">{</span>          <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_mxfast</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">get_max_fast</span> <span class="p">());</span>          <span class="n">set_max_fast</span> <span class="p">(</span><span class="n">value</span><span class="p">);</span>        <span class="p">}</span>      <span class="k">else</span>        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="k">break</span><span class="p">;</span>    <span class="k">case</span> <span class="nl">M_TRIM_THRESHOLD</span><span class="p">:</span>      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_trim_threshold</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>                  <span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span><span class="p">);</span>      <span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>      <span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="k">break</span><span class="p">;</span>    <span class="k">case</span> <span class="nl">M_TOP_PAD</span><span class="p">:</span>      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_top_pad</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>                  <span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span><span class="p">);</span>      <span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>      <span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="k">break</span><span class="p">;</span>    <span class="k">case</span> <span class="nl">M_MMAP_THRESHOLD</span><span class="p">:</span>      <span class="cm">/* Forbid setting the threshold too high. */</span>      <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">HEAP_MAX_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="k">else</span>        <span class="p">{</span>          <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_mmap_threshold</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>                      <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span><span class="p">);</span>          <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>          <span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="p">}</span>      <span class="k">break</span><span class="p">;</span>    <span class="k">case</span> <span class="nl">M_MMAP_MAX</span><span class="p">:</span>      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_mmap_max</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>                  <span class="n">mp_</span><span class="p">.</span><span class="n">n_mmaps_max</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span><span class="p">);</span>      <span class="n">mp_</span><span class="p">.</span><span class="n">n_mmaps_max</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>      <span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="k">break</span><span class="p">;</span>    <span class="k">case</span> <span class="nl">M_CHECK_ACTION</span><span class="p">:</span>      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_check_action</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">check_action</span><span class="p">);</span>      <span class="n">check_action</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>      <span class="k">break</span><span class="p">;</span>    <span class="k">case</span> <span class="nl">M_PERTURB</span><span class="p">:</span>      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_perturb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">perturb_byte</span><span class="p">);</span>      <span class="n">perturb_byte</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>      <span class="k">break</span><span class="p">;</span>    <span class="k">case</span> <span class="nl">M_ARENA_TEST</span><span class="p">:</span>      <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>        <span class="p">{</span>          <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_arena_test</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">arena_test</span><span class="p">);</span>          <span class="n">mp_</span><span class="p">.</span><span class="n">arena_test</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>        <span class="p">}</span>      <span class="k">break</span><span class="p">;</span>    <span class="k">case</span> <span class="nl">M_ARENA_MAX</span><span class="p">:</span>      <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>        <span class="p">{</span>          <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_arena_max</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">arena_max</span><span class="p">);</span>          <span class="n">mp_</span><span class="p">.</span><span class="n">arena_max</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>        <span class="p">}</span>      <span class="k">break</span><span class="p">;</span>    <span class="p">}</span>  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>  <span class="k">return</span> <span class="n">res</span><span class="p">;}</span><span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">__libc_mallopt</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在<code>mallopt()</code>函数配置前，需要检查主分配区是否初始化了，如果没有初始化，调用<code>ptmalloc_init()</code>函数初始化<code>ptmalloc</code>，然后获得主分配区的锁，调用<code>malloc_consolidate()</code>函数，<code>malloc_consolidate()</code>函数会判断主分配区是否已经初始化，如果没有，则初始化主分配区。同时我们也看到，<code>mp_</code>都没有锁，对<code>mp_</code>中参数字段的修改，是通过主分配区的锁来同步的。</p>
<h3 id="ptmalloc_init">ptmalloc_init()</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="nf">voidptmalloc_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">){</span>  <span class="k">if</span> <span class="p">(</span><span class="n">__malloc_initialized</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>    <span class="k">return</span><span class="p">;</span>  <span class="n">__malloc_initialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>ptmalloc_init()</code>用于初始化<code>ptmalloc</code>，它首先检查全局变量<code>__malloc_initialized</code>是否大于等于0，如果该值大于0，表示<code>ptmalloc</code>已经初始化，如果该值为0，表示<code>ptmalloc</code>正在初始化，全局变量<code>__malloc_initialized</code>用来保证全局只初始化<code>ptmalloc</code>一次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifdef SHARED  </span><span class="cm">/* In case this libc copy is in a non-default namespace, never use brk.     Likewise if dlopened from statically linked program.  */</span><span class="cp">  Dl_info di;  struct link_map *l;  if (_dl_open_hook != NULL      || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, NULL) != 0          &amp;&amp; l-&gt;l_ns != LM_ID_BASE))    __morecore = __failing_morecore;#endif
</span></code></pre></td></tr></table>
</div>
</div><p>Ptmalloc需要保证只有主分配区才能使用<code>sbrk()</code>分配连续虚拟内存空间，如果有多个分配区使用<code>sbrk()</code>就不能获得连续的虚拟地址空间，大多数情况下Glibc库都是以动态链接库的形式加载的，处于默认命名空间，多个进程共用Glibc库，Glibc库代码段在内存中只有一份拷贝，数据段在每个用户进程都有一份拷贝。但如果Glibc库不在默认名字空间，或是用户程序是静态编译的并调用了<code>dlopen</code>函数加载Glibc库中的<code>ptamalloc_init()</code>，这种情况下的<code>ptmalloc</code>不允许使用<code>sbrk()</code>分配内存，只需修改<code>__morecore</code>函数指针指向<code>__failing_morecore</code>就可以禁止使用<code>sbrk()</code>了，<code>__morecore</code>默认指向<code>sbrk()</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="n">tsd_key_create</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arena_key</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="n">tsd_setspecific</span> <span class="p">(</span><span class="n">arena_key</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">);</span>  <span class="n">thread_atfork</span> <span class="p">(</span><span class="n">ptmalloc_lock_all</span><span class="p">,</span> <span class="n">ptmalloc_unlock_all</span><span class="p">,</span> <span class="n">ptmalloc_unlock_all2</span><span class="p">);</span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>初始化全局锁<code>list_lock</code>，<code>list_lock</code>主要用于同步分配区的单向循环链表。然后创建线程私有实例<code>arena_key</code>，该私有实例保存的是分配区（arena）的<code>malloc_state</code>实例指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针，这里将调用<code>ptmalloc_init()</code>的线程的<code>arena_key</code>绑定到主分配区上。意味着本线程首选从主分配区分配内存。
然后调用<code>thread_atfork()</code>设置当前进程在fork子线程（linux下线程是轻量级进程，使用类似fork进程的机制创建）时处理mutex的回调函数，在本进程fork子线程时，调用<code>ptmalloc_lock_all()</code>获得所有分配区的锁，禁止所有分配区分配内存，当子线程创建完毕，父进程调用<code>ptmalloc_unlock_all()</code>重新unlock每个分配区的锁<code>mutex</code>，子线程调用<code>ptmalloc_unlock_all2()</code>重新初始化每个分配区的锁<code>mutex</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_likely</span> <span class="p">(</span><span class="n">_environ</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>    <span class="p">{</span>      <span class="kt">char</span> <span class="o">**</span><span class="n">runp</span> <span class="o">=</span> <span class="n">_environ</span><span class="p">;</span>      <span class="kt">char</span> <span class="o">*</span><span class="n">envline</span><span class="p">;</span>      <span class="k">while</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">((</span><span class="n">envline</span> <span class="o">=</span> <span class="n">next_env_entry</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">runp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span>                               <span class="mi">0</span><span class="p">))</span>        <span class="p">{</span>          <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strcspn</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">);</span>          <span class="k">if</span> <span class="p">(</span><span class="n">envline</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;=&#39;</span><span class="p">)</span>            <span class="cm">/* This is a &#34;MALLOC_&#34; variable at the end of the string               without a &#39;=&#39; character.  Ignore it since otherwise we               will access invalid memory below.  */</span>            <span class="k">continue</span><span class="p">;</span>          <span class="k">switch</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>            <span class="p">{</span>            <span class="k">case</span> <span class="mi">6</span><span class="o">:</span>              <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;CHECK_&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                <span class="n">s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">envline</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>              <span class="k">break</span><span class="p">;</span>            <span class="k">case</span> <span class="mi">8</span><span class="o">:</span>              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">__libc_enable_secure</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                <span class="p">{</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;TOP_PAD_&#34;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                    <span class="n">__libc_mallopt</span> <span class="p">(</span><span class="n">M_TOP_PAD</span><span class="p">,</span> <span class="n">atoi</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">envline</span><span class="p">[</span><span class="mi">9</span><span class="p">]));</span>                  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;PERTURB_&#34;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                    <span class="n">__libc_mallopt</span> <span class="p">(</span><span class="n">M_PERTURB</span><span class="p">,</span> <span class="n">atoi</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">envline</span><span class="p">[</span><span class="mi">9</span><span class="p">]));</span>                <span class="p">}</span>              <span class="k">break</span><span class="p">;</span>            <span class="k">case</span> <span class="mi">9</span><span class="o">:</span>              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">__libc_enable_secure</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                <span class="p">{</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;MMAP_MAX_&#34;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                    <span class="n">__libc_mallopt</span> <span class="p">(</span><span class="n">M_MMAP_MAX</span><span class="p">,</span> <span class="n">atoi</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">envline</span><span class="p">[</span><span class="mi">10</span><span class="p">]));</span>                  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;ARENA_MAX&#34;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                    <span class="n">__libc_mallopt</span> <span class="p">(</span><span class="n">M_ARENA_MAX</span><span class="p">,</span> <span class="n">atoi</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">envline</span><span class="p">[</span><span class="mi">10</span><span class="p">]));</span>                <span class="p">}</span>              <span class="k">break</span><span class="p">;</span>            <span class="k">case</span> <span class="mi">10</span><span class="o">:</span>              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">__libc_enable_secure</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                <span class="p">{</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;ARENA_TEST&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                    <span class="n">__libc_mallopt</span> <span class="p">(</span><span class="n">M_ARENA_TEST</span><span class="p">,</span> <span class="n">atoi</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">envline</span><span class="p">[</span><span class="mi">11</span><span class="p">]));</span>                <span class="p">}</span>              <span class="k">break</span><span class="p">;</span>            <span class="k">case</span> <span class="mi">15</span><span class="o">:</span>              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">__libc_enable_secure</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                <span class="p">{</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;TRIM_THRESHOLD_&#34;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                    <span class="n">__libc_mallopt</span> <span class="p">(</span><span class="n">M_TRIM_THRESHOLD</span><span class="p">,</span> <span class="n">atoi</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">envline</span><span class="p">[</span><span class="mi">16</span><span class="p">]));</span>                  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">memcmp</span> <span class="p">(</span><span class="n">envline</span><span class="p">,</span> <span class="s">&#34;MMAP_THRESHOLD_&#34;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                    <span class="n">__libc_mallopt</span> <span class="p">(</span><span class="n">M_MMAP_THRESHOLD</span><span class="p">,</span> <span class="n">atoi</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">envline</span><span class="p">[</span><span class="mi">16</span><span class="p">]));</span>                <span class="p">}</span>              <span class="k">break</span><span class="p">;</span>            <span class="k">default</span><span class="o">:</span>              <span class="k">break</span><span class="p">;</span>            <span class="p">}</span>        <span class="p">}</span>    <span class="p">}</span>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>    <span class="p">{</span>      <span class="n">__libc_mallopt</span> <span class="p">(</span><span class="n">M_CHECK_ACTION</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">));</span>      <span class="k">if</span> <span class="p">(</span><span class="n">check_action</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>        <span class="n">__malloc_check_init</span> <span class="p">();</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从环境变量中读取相应的配置参数值，这些参数包括<code>MALLOC_TRIM_THRESHOLD_</code>，<code>MALLOC_TOP_PAD_</code>，<code>MALLOC_PERTURB_</code>，<code>MALLOC_MMAP_THRESHOLD_</code>，<code>MALLOC_CHECK_</code>，<code>MALLOC_MMAP_MAX_</code>，<code>MALLOC_ARENA_MAX</code>,<code>MALLOC_ ARENA_TEST</code>,如果这些选项中的某些项存在，调用mallopt()函数设置相应的选项。如果这段程序是在Glibc库初始化中执行的，会做更多的安全检查工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__malloc_initialize_hook</span><span class="p">);</span>  <span class="k">if</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>    <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)();</span>  <span class="n">__malloc_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;}</span>
</code></pre></td></tr></table>
</div>
</div><p>在<code>ptmalloc_init()</code>函数结束处，查看是否存在<code>__malloc_initialize_hook</code>函数，如果存在，执行该hook函数。最后将全局变量<code>__malloc_initialized</code>设置为1，表示<code>ptmalloc_init()</code>已经初始化完成。</p>
<h2 id="多分配区">多分配区</h2>
<p>由于只有一个主分配区从堆中分配小内存块，而稍大的内存块都必须从<code>mmap</code>映射区域分配，如果有多个线程都要分配小内存块，但多个线程是不能同时调用<code>sbrk()</code>函数的，因为只有一个函数调用<code>sbrk()</code>时才能保证分配的虚拟地址空间是连续的。如果多个线程都从主分配区中分配小内存块，效率很低效。为了解决这个问题，<code>ptmalloc</code>使用非主分配区来模拟主分配区的功能，非主分配区同样可以分配小内存块，并且可以创建多个非主分配区，从而在线程分配内存竞争比较激烈的情况下，可以创建更多的非主分配区来完成分配任务，减少分配区的锁竞争，提高分配效率。
Ptmalloc怎么用非主分配区来模拟主分配区的行为呢？首先创建一个新的非主分配区，非主分配区使用<code>mmap()</code>函数分配一大块内存来模拟堆（sub-heap），所有的从该非主分配区总分配的小内存块都从<code>sub-heap</code>中切分出来，如果一个<code>sub-heap</code>的内存用光了，或是<code>sub-heap</code>中的内存不够用时，使用<code>mmap()</code>分配一块新的内存块作为sub-heap，并将新的<code>sub-heap</code>链接在非主分配区中<code>sub-heap</code>的单向链表中。
分主分配区中的<code>sub-heap</code>所占用的内存不会无限的增长下去，同样会像主分配区那样进行<code>sub-heap</code>收缩，将<code>sub-heap</code>中<code>top chunk</code>的一部分返回给操作系统，如果<code>top chunk</code>为整个<code>sub-heap</code>，会把整个<code>sub-heap</code>还回给操作系统。收缩堆的条件是当前free的chunk大小加上前后能合并chunk的大小大于64KB，并且<code>top chunk</code>的大小达到<code>mmap</code>收缩阈值，才有可能收缩堆。
一般情况下，进程中有多个线程，也有多个分配区，线程的数据一般会比分配区数量多，所以必能保证没有线程独享一个分配区，每个分配区都有可能被多个线程使用，为了保证分配区的线程安全，对分配区的访问需要锁保护，当线程获得分配区的锁时，可以使用该分配区分配内存，并将该分配区的指针保存在线程的私有实例中。
当某一线程需要调用malloc分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜分配区索循环链表试图获得一个空闲的分配区。如果所有的分配区都已经加锁，那么malloc会开辟一个新的分配区，把该分配区加入到分配区的全局分配区循环链表并加锁，然后使用该分配区进行分配操作。在回收操作中，线程同样试图获得待回收块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行回收操作。</p>
<h3 id="heap_info">heap_info</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* A heap is a single contiguous memory region holding (coalesceable)   malloc_chunks.  It is allocated with mmap() and always starts at an   address aligned to HEAP_MAX_SIZE.  */</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_heap_info</span><span class="p">{</span>  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span> <span class="cm">/* Arena for this heap. */</span>  <span class="k">struct</span> <span class="n">_heap_info</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="cm">/* Previous heap. */</span>  <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span>   <span class="cm">/* Current size in bytes. */</span>  <span class="n">size_t</span> <span class="n">mprotect_size</span><span class="p">;</span> <span class="cm">/* Size in bytes that has been mprotected                           PROT_READ|PROT_WRITE.  */</span>  <span class="cm">/* Make sure the following data is properly aligned, particularly     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of     MALLOC_ALIGNMENT. */</span>  <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">];}</span> <span class="n">heap_info</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>ar_ptr</code>是指向所属分配区的指针;
<code>prev</code>字段用于将同一个分配区中的<code>sub_heap</code>用单向链表链接起来。<code>prev</code>指向链表中的前一个<code>sub_heap</code>。
<code>size</code>字段表示当前<code>sub_heap</code>中的内存大小，以page对齐。
<code>mprotect_size</code>字段表示当前<code>sub_heap</code>中被读写保护的内存大小，也就是说还没有被分配的内存大小。
Pad字段用于保证<code>sizeof (heap_info)</code> + 2 * <code>SIZE_SZ</code>是按<code>MALLOC_ALIGNMENT</code>对齐的。<code>MALLOC_ALIGNMENT_MASK</code>为2 *<code>SIZE_SZ</code> - 1，无论<code>SIZE_SZ</code>为4或8，-6 * <code>SIZE_SZ</code> &amp;<code> MALLOC_ALIGN_MASK</code>的值为0，如果<code>sizeof (heap_info)</code>+ 2 * <code>SIZE_SZ</code>不是按<code>MALLOC_ALIGNMENT</code>对齐，编译的时候就会报错，编译时会执行下面的宏。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Get a compile-time error if the heap_info padding is not correct   to make alignment work as expected in sYSMALLOc.  */</span><span class="k">extern</span> <span class="kt">int</span> <span class="n">sanity_check_heap_info_alignment</span><span class="p">[(</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">heap_info</span><span class="p">)</span>                                             <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">%</span> <span class="n">MALLOC_ALIGNMENT</span>                                            <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>为什么一定要保证对齐呢？作为分主分配区的第一个<code>sub_heap</code>，<code>heap_info</code>存放在<code>sub_heap</code>的头部，紧跟<code>heap_info</code>之后是该非主分配区的<code>malloc_state</code>实例，紧跟<code>malloc_state</code>实例后，是<code>sub_heap</code>中的第一个chunk，但chunk的首地址必须按照<code>MALLOC_ALIGNMENT</code>对齐，所以在<code>malloc_state</code>实例和第一个<code>chunk</code>之间可能有几个字节的pad，但如果<code>sub_heap</code>不是非主分配区的第一个<code>sub_heap</code>，则紧跟<code>heap_info</code>后是第一个chunk，但<code>sysmalloc()</code>函数默认<code>heap_info</code>是按照<code>MALLOC_ALIGNMENT</code>对齐的，没有再做对齐的工作，直接将<code>heap_info</code>后的内存强制转换成一个chunk。所以这里在编译时保证<code>sizeof (heap_info)</code> + 2 * <code>SIZE_SZ</code>是按<code>MALLOC_ALIGNMENT</code>对齐的，在运行时就不用再做检查了，也不必再做对齐。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Thread specific data */</span><span class="k">static</span> <span class="n">tsd_key_t</span> <span class="n">arena_key</span><span class="p">;</span><span class="k">static</span> <span class="n">mutex_t</span> <span class="n">list_lock</span> <span class="o">=</span> <span class="n">MUTEX_INITIALIZER</span><span class="p">;</span><span class="k">static</span> <span class="n">size_t</span> <span class="n">narenas</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="k">static</span> <span class="n">mstate</span> <span class="n">free_list</span><span class="p">;</span><span class="cm">/* Mapped memory in non-main arenas (reliable only for NO_THREADS). */</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arena_mem</span><span class="p">;</span><span class="cm">/* Already initialized? */</span><span class="kt">int</span> <span class="n">__malloc_initialized</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>arena_key</code>存放的是线程的私用实例，该私有实例保存的是分配区（arena）的<code>malloc_state</code>实例的指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针。
<code>list_lock</code>用于同步分配区的单向环形链表。
如果定义了<code>PRE_THREAD</code>，<code>narenas</code>全局变量表示当前分配区的数量，<code>free_list</code>全局变量是空闲分配区的单向链表，这些空闲的分配区可能是从父进程那里继承来的。全局变量<code>narenas</code>和<code>free_list</code>都用锁<code>list_lock</code>同步。
<code>arena_mem</code>只用于单线程的<code>ptmalloc</code>版本，记录了非主分配区所分配的内存大小。
<code>__malloc_initializd</code>全局变量用来标识是否<code>ptmalloc</code>已经初始化了，其值大于0时表示已经初始化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* arena_get() acquires an arena and locks the corresponding mutex.   First, try the one last locked successfully by this thread.  (This   is the common case and handled with a macro for speed.)  Then, loop   once over the circularly linked list of arenas.  If no arena is   readily available, create a new one.  In this latter case, `size&#39;   is just a hint as to how much memory will be required immediately   in the new arena. */</span><span class="cp">#define arena_get(ptr, size) do { \      arena_lookup (ptr);						      \      arena_lock (ptr, size);						      \  } while (0)#define arena_lookup(ptr) do { \      void *vptr = NULL;						      \      ptr = (mstate) tsd_getspecific (arena_key, vptr);			      \  } while (0)#define arena_lock(ptr, size) do {					      \      if (ptr)								      \        (void) mutex_lock (&amp;ptr-&gt;mutex);				      \      else								      \        ptr = arena_get2 (ptr, (size), NULL);				      \  } while (0)
</span></code></pre></td></tr></table>
</div>
</div><p>上述用以获得一个分配区。</p>
<h2 id="公共包装">公共包装</h2>
<h3 id="__libc_malloc">__libc_malloc</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* malloc(size_t n) Returns a pointer to a newly allocated chunk of at least n bytes, or null if no space is available. Additionally, on failure, errno is set to ENOMEM on ANSI C systems. If n is zero, malloc returns a minumum-sized chunk. (The minimum size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit systems.)  On most systems, size_t is an unsigned type, so calls with negative arguments are interpreted as requests for huge amounts of space, which will often fail. The maximum supported value of n differs across systems, but is in all cases less than the maximum representable value of a size_t.*/</span><span class="kt">void</span> <span class="o">*</span>  <span class="nf">__libc_malloc</span><span class="p">(</span><span class="n">size_t</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code> __libc_malloc</code>是<code>malloc</code>的真正调用的函数，这里是关于其功能的概述。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">__libc_malloc</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">bytes</span><span class="p">){</span>  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span>  <span class="kt">void</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>  <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="n">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>    <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__malloc_hook</span><span class="p">);</span>  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>  <span class="n">arena_lookup</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">);</span>  <span class="n">arena_lock</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ar_ptr</span><span class="p">)</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">victim</span> <span class="o">=</span> <span class="n">_int_malloc</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span><span class="p">)</span>    <span class="p">{</span>      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_malloc_retry</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>      <span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">arena_get_retry</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>      <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">ar_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>        <span class="p">{</span>          <span class="n">victim</span> <span class="o">=</span> <span class="n">_int_malloc</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>          <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>        <span class="p">}</span>    <span class="p">}</span>  <span class="k">else</span>    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>  <span class="n">assert</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span> <span class="o">||</span> <span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">mem2chunk</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">||</span>          <span class="n">ar_ptr</span> <span class="o">==</span> <span class="n">arena_for_chunk</span> <span class="p">(</span><span class="n">mem2chunk</span> <span class="p">(</span><span class="n">victim</span><span class="p">)));</span>  <span class="k">return</span> <span class="n">victim</span><span class="p">;}</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，检查<code>__malloc_hook</code>是否为空，是则向下执行，否则执行<code>__malloc_hook</code>指向的函数。这个功能是为了让使用者定义自己的<code>malloc</code>，其也存在于<code>free</code>、<code>realloc</code>等函数中。在进程初始化时<code>__malloc_hook</code>指向的函数为<code>malloc_hook_ini()</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* arena_get() acquires an arena and locks the corresponding mutex.   First, try the one last locked successfully by this thread.  (This   is the common case and handled with a macro for speed.)  Then, loop   once over the circularly linked list of arenas.  If no arena is   readily available, create a new one.  In this latter case, `size&#39;   is just a hint as to how much memory will be required immediately   in the new arena. */</span><span class="cp">#define arena_get(ptr, size) do { \      arena_lookup (ptr);						      \      arena_lock (ptr, size);						      \  } while (0)#define arena_lookup(ptr) do { \      void *vptr = NULL;						      \      ptr = (mstate) tsd_getspecific (arena_key, vptr);			      \  } while (0)#define arena_lock(ptr, size) do {					      \      if (ptr)								      \        (void) mutex_lock (&amp;ptr-&gt;mutex);				      \      else								      \        ptr = arena_get2 (ptr, (size), NULL);				      \  } while (0)
</span></code></pre></td></tr></table>
</div>
</div><p>调用<code>arena_lookup</code>查找本线程的私用实例中是否包含一个分配区的指针，返回该指针，调用<code>arena_lock</code>尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果对该分配区加锁失败，调用<code>arena_get2</code>获得一个分配区指针。
之后调用了<code>_int_malloc</code>从分配区中获取内存。如果<code>_int_malloc()</code>函数分配内存失败，并且使用的分配区不是主分配区，这种情况可能是mmap区域的内存被用光了，当主分配区可以从堆中分配内存，所以需要再尝试从主分配区中分配内存。首先释放所使用分配区的锁，然后获得主分配区的锁，并调用<code>_int_malloc()</code>函数分配内存，最后释放主分配区的锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* If we don&#39;t have the main arena, then maybe the failure is due to running   out of mmapped areas, so we can try allocating on the main arena.   Otherwise, it is likely that sbrk() has failed and there is still a chance   to mmap(), so try one of the other arenas.  */</span><span class="k">static</span> <span class="nf">mstatearena_get_retry</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">){</span>  <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_arena_retry</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">ar_ptr</span><span class="p">);</span>  <span class="k">if</span> <span class="p">(</span><span class="n">ar_ptr</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>    <span class="p">{</span>      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>      <span class="n">ar_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">;</span>      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>    <span class="p">}</span>  <span class="k">else</span>    <span class="p">{</span>      <span class="cm">/* Grab ar_ptr-&gt;next prior to releasing its lock.  */</span>      <span class="n">mstate</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">?</span> <span class="nl">ar_ptr</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>      <span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">arena_get2</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">ar_ptr</span><span class="p">);</span>    <span class="p">}</span>  <span class="k">return</span> <span class="n">ar_ptr</span><span class="p">;}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>_int_malloc()</code>函数分配内存失败，并且使用的分配区是主分配区，查看是否有非主分配区，如果有，调用<code>arena_get2()</code>获取分配区，然后对主分配区解锁，如果<code>arena_get2()</code>返回一个非主分配区，尝试调用<code>_int_malloc()</code>函数从该非主分配区分配内存，最后释放该非主分配区的锁。
如果<code>_int_malloc()</code>函数分配内存成功，释放所使用的分配区的锁。
可以发现真正分配内存的函数是<code>_int_malloc()</code>，而<code>__libc_malloc()</code>只是其简单的封装。</p>
<h3 id="_int_malloc">_int_malloc()</h3>
<p>下面重点分析<code>_int_malloc()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   ------------------------------ malloc ------------------------------ */</span><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_int_malloc</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">){</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">nb</span><span class="p">;</span>               <span class="cm">/* normalized request size */</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>                 <span class="cm">/* associated bin index */</span>  <span class="n">mbinptr</span> <span class="n">bin</span><span class="p">;</span>                      <span class="cm">/* associated bin */</span>  <span class="n">mchunkptr</span> <span class="n">victim</span><span class="p">;</span>                 <span class="cm">/* inspected/selected chunk */</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>             <span class="cm">/* its size */</span>  <span class="kt">int</span> <span class="n">victim_index</span><span class="p">;</span>                 <span class="cm">/* its bin index */</span>  <span class="n">mchunkptr</span> <span class="n">remainder</span><span class="p">;</span>              <span class="cm">/* remainder from a split */</span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remainder_size</span><span class="p">;</span>     <span class="cm">/* its size */</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">;</span>               <span class="cm">/* bit map traverser */</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>                 <span class="cm">/* bit map traverser */</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">map</span><span class="p">;</span>                 <span class="cm">/* current word of binmap */</span>  <span class="n">mchunkptr</span> <span class="n">fwd</span><span class="p">;</span>                    <span class="cm">/* misc temp for linking */</span>  <span class="n">mchunkptr</span> <span class="n">bck</span><span class="p">;</span>                    <span class="cm">/* misc temp for linking */</span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errstr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这里是定义的一些变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*     Convert request size to internal form by adding SIZE_SZ bytes     overhead plus possibly more to obtain necessary alignment and/or     to obtain a size of at least MINSIZE, the smallest allocatable     size. Also, checked_request2size traps (returning 0) request sizes     that are so large that they wrap around zero when padded and     aligned.   */</span>  <span class="n">checked_request2size</span> <span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>checked_request2size()</code>将请求的大小转化为chunk的大小，在<code>_int_malloc()</code>内部分配内存是以chunk为单位的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*     If the size qualifies as a fastbin, first check corresponding bin.     This code is safe to execute even if av is not yet initialized, so we     can try it without checking, which saves some time on this fast path.   */</span>  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">get_max_fast</span> <span class="p">()))</span>    <span class="p">{</span>      <span class="n">idx</span> <span class="o">=</span> <span class="n">fastbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>      <span class="n">mfastbinptr</span> <span class="o">*</span><span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>      <span class="n">mchunkptr</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>      <span class="k">do</span>        <span class="p">{</span>          <span class="n">victim</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>          <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>            <span class="k">break</span><span class="p">;</span>        <span class="p">}</span>      <span class="k">while</span> <span class="p">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">catomic_compare_and_exchange_val_acq</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">victim</span><span class="p">))</span>             <span class="o">!=</span> <span class="n">victim</span><span class="p">);</span>      <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>        <span class="p">{</span>          <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fastbin_index</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>            <span class="p">{</span>              <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;malloc(): memory corruption (fast)&#34;</span><span class="p">;</span>            <span class="nl">errout</span><span class="p">:</span>              <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">));</span>              <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>            <span class="p">}</span>          <span class="n">check_remalloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>          <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>          <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>          <span class="k">return</span> <span class="n">p</span><span class="p">;</span>        <span class="p">}</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果chunk的大小在<code>fast bins</code>的范围内，首先尝试在<code>fast bins</code>中寻找适合的chunk。
首先根据所需chunk的大小获得该chunk所属<code>fast bin</code>的index，根据该index获得所需<code>fast bin</code>的空闲chunk链表的头指针，然后将头指针的下一个chunk作为空闲chunk链表的头部。为了加快从<code>fast bins</code>中分配chunk，处于fast bins中chunk的状态仍然保持为inuse状态，避免被相邻的空闲chunk合并，从<code>fast bins</code>中分配chunk，只需取出第一个chunk，并调用<code>chunk2mem()</code>函数返回用户所需的内存块。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*     If a small request, check regular bin.  Since these &#34;smallbins&#34;     hold one size each, no searching within bins is necessary.     (For a large request, we need to wait until unsorted chunks are     processed to find best fit. But for small ones, fits are exact     anyway, so we can check now, which is faster.)   */</span>  <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>    <span class="p">{</span>      <span class="n">idx</span> <span class="o">=</span> <span class="n">smallbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>      <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>      <span class="k">if</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">last</span> <span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span><span class="p">)</span>        <span class="p">{</span>          <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* initialization check */</span>            <span class="n">malloc_consolidate</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>          <span class="k">else</span>            <span class="p">{</span>              <span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>	<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">victim</span><span class="p">))</span>                <span class="p">{</span>                  <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;malloc(): smallbin double linked list corrupted&#34;</span><span class="p">;</span>                  <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>                <span class="p">}</span>              <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>              <span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>              <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>              <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>                <span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">|=</span> <span class="n">NON_MAIN_ARENA</span><span class="p">;</span>              <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>              <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>              <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>              <span class="k">return</span> <span class="n">p</span><span class="p">;</span>            <span class="p">}</span>        <span class="p">}</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果分配的chunk属于<code>small bin</code>，首先查找chunk所对应<code>small bins</code>数组的index，然后根据index获得某个<code>small bin</code>的空闲chunk双向循环链表表头，然后将最后一个chunk赋值给victim，如果victim与表头相同，表示该链表为空，不能从<code>small bin</code>的空闲chunk链表中分配。若victim为0，表示<code>small bin</code>并没有初始化。所以调用<code>malloc_consolidate</code>将该分配区<code>fast bins</code>中chunk进行合并。否则对该bin中最后一个chunk进行双向链表检查，检查上一个chunk的后一个是否是<code>victim</code>。正确之后，设置其控制位。最后将指针转化位<code>mem</code>返回给用户。
可以发现，这里并没有链表为空时的相应处理，这种情况会在之后进行处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*     If this is a large request, consolidate fastbins before continuing.     While it might look excessive to kill all fastbins before     even seeing if there is space available, this avoids     fragmentation problems normally associated with fastbins.     Also, in practice, programs tend to have runs of either small or     large requests, but less often mixtures, so consolidation is not     invoked all that often in most programs. And the programs that     it is called frequently in otherwise tend to fragment.   */</span>  <span class="k">else</span>    <span class="p">{</span>      <span class="n">idx</span> <span class="o">=</span> <span class="n">largebin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>      <span class="k">if</span> <span class="p">(</span><span class="n">have_fastchunks</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>        <span class="n">malloc_consolidate</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>若请求大小不在<code>small bin</code>的范围内，那必然就在<code>large bins</code>中。但不会直接遍历<code>large bins</code>。在<code>fast bins</code>和<code>small bins</code>中存在很多较小的chunk，若不对这些进行处理就会浪费很多的空间，降低内存的利用率，所以首先检查<code>fast bins</code>中是否有chunk，若有则进行合并，加入到<code>unsorted bin</code>中。合并中的细节我们将之后再分析。
之后就进入了一个大循环中
<strong>大循环</strong>
大循环会最终实现内存的分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*     Process recently freed or remaindered chunks, taking one only if     it is exact fit, or, if this a small request, the chunk is remainder from     the most recent non-exact fit.  Place other traversed chunks in     bins.  Note that this step is the only place in any routine where     chunks are placed in bins.     The outer loop here is needed because we might not realize until     near the end of malloc that we should have consolidated, so must     do so and retry. This happens at most once, and only when we would     otherwise need to expand memory to service a &#34;small&#34; request.   */</span>  <span class="k">for</span> <span class="p">(;;</span> <span class="p">)</span>    <span class="p">{</span>      <span class="kt">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="k">while</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">)</span> <span class="o">!=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>        <span class="p">{</span>          <span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>          <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>              <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>            <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="s">&#34;malloc(): memory corruption&#34;</span><span class="p">,</span>                             <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">));</span>          <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，反向遍历<code>unsorted bin</code>，直到只剩链表头。并要求大小大于<code>2*SIZE_SZ</code>且不超过分配区的边界。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="cm">/*             If a small request, try to use last remainder if it is the             only chunk in unsorted bin.  This helps promote locality for             runs of consecutive small requests. This is the only             exception to best-fit, and applies only when there is             no exact fit for a small chunk.           */</span>          <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>              <span class="n">bck</span> <span class="o">==</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span>              <span class="n">victim</span> <span class="o">==</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">&amp;&amp;</span>              <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span>            <span class="p">{</span>
</code></pre></td></tr></table>
</div>
</div><p>如果需要分配一个<code>small bin chunk</code>，在之前的判断中中没有匹配到合适的chunk，并且<code>unsorted bin</code>中只有一个chunk，并且这个chunk为<code>last remainder chunk</code>，并且这个chunk的大小大于所需chunk的大小加上<code>MINSIZE</code>，在满足这些条件的情况下，可以使用<code>last remainder chunk</code>切分出需要的<code>small bin chunk</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* split and reattach remainder */</span>              <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>              <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>              <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>              <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>              <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">remainder_size</span><span class="p">))</span>                <span class="p">{</span>                  <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                  <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                <span class="p">}</span>              <span class="n">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>                        <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>              <span class="n">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>              <span class="n">set_foot</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span><span class="p">);</span>              <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>              <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>              <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>              <span class="k">return</span> <span class="n">p</span><span class="p">;</span>            <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>将分割后剩下的部分作为新的<code>last remainder chunk</code>，更新<code>last remainder chunk</code>的size等一些相关的设置。若剩余部分的大小属于<code>large bin</code>将其的<code>fd_nextsize</code>和<code>fd_nextsize</code>都设置为NULL，因为<code>last remainder chunk</code>只能存在于<code>unsorted bin</code>中。最后，设置分割好的chunk的头部信息，对于<code>last remainder chunk</code>还要设置foot即<code>prev_size</code>域。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="cm">/* remove from unsorted list */</span>          <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>          <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>          <span class="cm">/* Take now instead of binning if exact fit */</span>          <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">nb</span><span class="p">)</span>            <span class="p">{</span>              <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>              <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>                <span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">|=</span> <span class="n">NON_MAIN_ARENA</span><span class="p">;</span>              <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>              <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>              <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>              <span class="k">return</span> <span class="n">p</span><span class="p">;</span>            <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从<code>unsorted bins</code>中取出最后的那个chunk。若其大小正好满足要求，设置其后一chunk的标志位，然后设置该chunk的控制信息等，转化为<code>mem</code>返回给用户。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="cm">/* place chunk in bin */</span>          <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">size</span><span class="p">))</span>            <span class="p">{</span>              <span class="n">victim_index</span> <span class="o">=</span> <span class="n">smallbin_index</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>              <span class="n">bck</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>              <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>            <span class="p">}</span>          <span class="k">else</span>            <span class="p">{</span>              <span class="n">victim_index</span> <span class="o">=</span> <span class="n">largebin_index</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>              <span class="n">bck</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>              <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>若取出的chunk属于<code>small bins</code>，获得当前chunk所属<code>small bin</code>的index，并将该<code>small bin</code>的链表表头赋值给bck，第一个chunk赋值给fwd，也就是当前的chunk会插入到bck和fwd之间，作为<code>small bin</code>链表的第一个chunk。
若属于<code>large bins</code>,也会进行相应的操作，不过还要设置<code>fd_nextsize</code>和<code>bk_nextsize</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* maintain large bins in sorted order */</span>              <span class="k">if</span> <span class="p">(</span><span class="n">fwd</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">)</span>                <span class="p">{</span>                  <span class="cm">/* Or with inuse bit to speed comparisons */</span>                  <span class="n">size</span> <span class="o">|=</span> <span class="n">PREV_INUSE</span><span class="p">;</span>                  <span class="cm">/* if smaller than smallest, bypass loop below */</span>                  <span class="n">assert</span> <span class="p">((</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">NON_MAIN_ARENA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>fwd!=bck</code>则说明当前<code>large bin</code>不为空。，由于<code>large bin</code>中的空闲chunk是按照大小顺序排序的，需要将当前从<code>unsorted bin</code>中取出的chunk插入到<code>large bin</code>中合适的位置。将当前chunk的size的<code>inuse</code>标志bit置位，相当于加1，便于加快chunk大小的比较，找到合适的地方插入当前chunk。这里还做了一次检查，断言在<code>large bin</code>双向循环链表中的最后一个chunk的size字段中的非主分配区的标志bit没有置位，因为所有在<code>large bin</code>中的chunk都处于空闲状态，该标志位一定是清零的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>                    <span class="p">{</span>                      <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>                      <span class="n">bck</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>                      <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>                      <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>                      <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>                    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前chunk比large bin的最后一个chunk的大小还小，那么当前chunk就插入到large bin的链表的最后，作为最后一个chunk。</p>
<blockquote>
<p>这里可能会对large bin中的四个指针产生迷惑，所以进行详细的说明：
在<code>large bins</code>中，chunk都是从大到小排序的，不同大小的chunk通过<code>fd_nextsize</code>和<code>bk_nextsize</code>进行链接，<code>fd_nextsize</code>指向下一个比当前<code>chunk size</code>小的第一个空闲chunk，不包含 bin 的头指针。<code>bk_nextszie</code>指向上一个比当前<code>chunk size</code>大的第一个空闲chunk，不包含 bin 的头指针。先被free的chunk会成为堆头，而大小与堆头相等的chunk会通过<code>fd</code>和<code>bk</code>链接到堆头的后面。所以说一个<code>large bin chunk</code>存在于两个链表中。其四个指针都被利用了起来。这加快了<code>large bins</code>中的搜索。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                  <span class="k">else</span>                    <span class="p">{</span>                      <span class="n">assert</span> <span class="p">((</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">NON_MAIN_ARENA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>                      <span class="k">while</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>                        <span class="p">{</span>                          <span class="n">fwd</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>                          <span class="n">assert</span> <span class="p">((</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">NON_MAIN_ARENA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>                        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>正向遍历chunk size链表，直到找到第一个chunk大小小于等于当前chunk大小的chunk退出循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                      <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>                        <span class="cm">/* Always insert in the second position.  */</span>                        <span class="n">fwd</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果从large bin链表中找到了与当前chunk大小相同的chunk，则同一大小的chunk已经存在，那么chunk size链表中一定包含了fwd所指向的chunk，为了不修改chunk size链表，当前chunk只能插入fwd之后。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                      <span class="k">else</span>                        <span class="p">{</span>                          <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>                          <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>                          <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>                          <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>                        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果chunk size链表中还没有包含当前chunk大小的chunk，也就是说当前chunk的大小大于fwd的大小，则将当前chunk作为该chunk size的代表加入chunk size链表，chunk size链表也是按照由大到小的顺序排序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                      <span class="n">bck</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>                    <span class="p">}</span>                <span class="p">}</span>              <span class="k">else</span>                <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>            <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>large bin</code>中没有chunk，那么直接将其作为堆头加入链表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="n">mark_bin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>          <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>          <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>          <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>          <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码最终完成了将chunk加入到对应的链表中，并设置了<code>binmap</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define MAX_ITERS       10000          if (++iters &gt;= MAX_ITERS)            break;        }
</span></code></pre></td></tr></table>
</div>
</div><p>这里设置了一个计数器，默认最多遍历<code>unsorted bin</code>中的10000个chunk，避免影响分配效率。</p>
<blockquote>
<p>为了避免混乱，现在可以思考一下循环中之前的代码做了什么。虽然现在仍在分析循环。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="cm">/*         If a large request, scan through the chunks of current bin in         sorted order to find smallest that fits.  Use the skip list for this.       */</span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>        <span class="p">{</span>          <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>          <span class="cm">/* skip scan if empty or largest chunk is too small */</span>          <span class="k">if</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">first</span> <span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span> <span class="o">&amp;&amp;</span>              <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>            <span class="p">{</span>              <span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>              <span class="k">while</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">&lt;</span>                      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)))</span>                <span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果请求的大小在<code>large bins</code>的范围内，判断对应<code>large bin</code>是否为空且其中最大的chunk是否大于请求大小，若是，则说明在这个bin中存在满足要求的chunk。反向遍历链表，找到第一个大于等于请求大小的chunk，跳出循环。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* Avoid removing the first entry for a size so that the skip                 list does not have to be rerouted.  */</span>              <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">!=</span> <span class="n">last</span> <span class="p">(</span><span class="n">bin</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>                <span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果从large bin链表中选取的chunk victim不是链表中的最后一个chunk，并且与victim大小相同的chunk不止一个，那么意味着victim为chunk size链表中的节点，为了不调整chunk size链表，需要避免将chunk size链表中的节点取出，所以取<code>victim-&gt;fd</code>节点对应的chunk作为候选chunk。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>              <span class="n">unlink</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>计算分割后的<code>remainder_size</code>，并使用<code>unlink()</code>将其从<code>large bin</code>中取出.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* Exhaust */</span>              <span class="k">if</span> <span class="p">(</span><span class="n">remainder_size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span><span class="p">)</span>                <span class="p">{</span>                  <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>                    <span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">|=</span> <span class="n">NON_MAIN_ARENA</span><span class="p">;</span>                <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>若剩余的大小小于<code>MINSIZE</code>，那么就要将整个chunk给用户，相比于多给一部分内存，切割后产生的小碎片对内存管理的影响更大。并设置相应的标志位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* Split */</span>              <span class="k">else</span>                <span class="p">{</span>                  <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>                  <span class="cm">/* We cannot assume the unsorted list is empty and therefore                     have to perform a complete insert here.  */</span>                  <span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>                  <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>	  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">))</span>                    <span class="p">{</span>                      <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;malloc(): corrupted unsorted chunks&#34;</span><span class="p">;</span>                      <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>                    <span class="p">}</span>                  <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>                  <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>                  <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>                  <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">remainder_size</span><span class="p">))</span>                    <span class="p">{</span>                      <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                      <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                    <span class="p">}</span>                  <span class="n">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>                            <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>                  <span class="n">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>                  <span class="n">set_foot</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span><span class="p">);</span>                <span class="p">}</span>              <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>              <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>              <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>              <span class="k">return</span> <span class="n">p</span><span class="p">;</span>            <span class="p">}</span>        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>切分出需要的chunk，剩余部分加入<code>unsorted bin</code>中。同时检查了头部的双向链接。如果剩余大小在<code>large bins</code>的范围，但是因为加入了<code>unsorted bin</code>，要把<code>fd_nextsize</code>和<code>bk_nextsize</code>清空。最后设置控制相关的控制信息和标志位，将<code>mem</code>返回给用户。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="cm">/*         Search for a chunk by scanning bins, starting with next largest         bin. This search is strictly by best-fit; i.e., the smallest         (with ties going to approximately the least recently used) chunk         that fits is selected.         The bitmap avoids needing to check that most blocks are nonempty.         The particular case of skipping all bins during warm-up phases         when no chunks have been returned yet is faster than it might look.       */</span>      <span class="o">++</span><span class="n">idx</span><span class="p">;</span>      <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>      <span class="n">block</span> <span class="o">=</span> <span class="n">idx2block</span> <span class="p">(</span><span class="n">idx</span><span class="p">);</span>      <span class="n">map</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">binmap</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>      <span class="n">bit</span> <span class="o">=</span> <span class="n">idx2bit</span> <span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>如果在对应的<code>small bin</code>和<code>large bin</code>中都没找到满足要求的chunk，则需要在更大bin中寻找是否有chunk可以分配。这里通过查询binmap快速判断较大的bin中是否有空闲的chunk。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="k">for</span> <span class="p">(;;</span> <span class="p">)</span>        <span class="p">{</span>          <span class="cm">/* Skip rest of block if there are no more set bits in this block.  */</span>          <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;</span> <span class="n">map</span> <span class="o">||</span> <span class="n">bit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>            <span class="p">{</span>              <span class="k">do</span>                <span class="p">{</span>                  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">BINMAPSIZE</span><span class="p">)</span> <span class="cm">/* out of bins */</span>                    <span class="k">goto</span> <span class="n">use_top</span><span class="p">;</span>                <span class="p">}</span>              <span class="k">while</span> <span class="p">((</span><span class="n">map</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">binmap</span><span class="p">[</span><span class="n">block</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>              <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="n">BINMAPSHIFT</span><span class="p">));</span>              <span class="n">bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>            <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Idx2bit()宏将idx指定的位设置为1，其它位清零，map表示一个<code>block（unsigned int）</code>值，如果bit大于map，意味着map为0，该block所对应的所有bins中都没有空闲chunk，于是遍历binmap的下一个block，直到找到一个不为0的block或者遍历完所有的block。退出循环遍历后，设置bin指向block的第一个bit对应的bin，并将bit置为1，表示该block中bit 1对应的bin，这个bin中如果有空闲chunk，该chunk的大小一定满足要求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="cm">/* Advance to bin with set bit. There must be one. */</span>          <span class="k">while</span> <span class="p">((</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>            <span class="p">{</span>              <span class="n">bin</span> <span class="o">=</span> <span class="n">next_bin</span> <span class="p">(</span><span class="n">bin</span><span class="p">);</span>              <span class="n">bit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>              <span class="n">assert</span> <span class="p">(</span><span class="n">bit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>            <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在一个block遍历对应的bin，直到找到一个bit不为0退出遍历，则该bit对于的bin中有空闲chunk存在。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="cm">/* Inspect the bin. It is likely to be non-empty */</span>          <span class="n">victim</span> <span class="o">=</span> <span class="n">last</span> <span class="p">(</span><span class="n">bin</span><span class="p">);</span>          <span class="cm">/*  If a false alarm (empty bin), clear the bit. */</span>          <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="n">bin</span><span class="p">)</span>            <span class="p">{</span>              <span class="n">av</span><span class="o">-&gt;</span><span class="n">binmap</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bit</span><span class="p">;</span> <span class="cm">/* Write through */</span>              <span class="n">bin</span> <span class="o">=</span> <span class="n">next_bin</span> <span class="p">(</span><span class="n">bin</span><span class="p">);</span>              <span class="n">bit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>            <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>找到了不为空的bin，将最后一个chunk赋值给victim，并判断bin是否为空。若为空则表示binmap相应位设置不准确，重新进行设置。并寻找下一个bin。这里与之前讲的对应了，当malloc时binmap才会更新。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="k">else</span>            <span class="p">{</span>              <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>              <span class="cm">/*  We know the first chunk in this bin is big enough to use. */</span>              <span class="n">assert</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">));</span>              <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>              <span class="cm">/* unlink */</span>              <span class="n">unlink</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>              <span class="cm">/* Exhaust */</span>              <span class="k">if</span> <span class="p">(</span><span class="n">remainder_size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span><span class="p">)</span>                <span class="p">{</span>                  <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>                    <span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">|=</span> <span class="n">NON_MAIN_ARENA</span><span class="p">;</span>                <span class="p">}</span>              <span class="cm">/* Split */</span>              <span class="k">else</span>                <span class="p">{</span>                  <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>                  <span class="cm">/* We cannot assume the unsorted list is empty and therefore                     have to perform a complete insert here.  */</span>                  <span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>                  <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>	  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">))</span>                    <span class="p">{</span>                      <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;malloc(): corrupted unsorted chunks 2&#34;</span><span class="p">;</span>                      <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>                    <span class="p">}</span>                  <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>                  <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>                  <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>                  <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>                  <span class="cm">/* advertise as last remainder */</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>                    <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">remainder_size</span><span class="p">))</span>                    <span class="p">{</span>                      <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                      <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                    <span class="p">}</span>                  <span class="n">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>                            <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>                  <span class="n">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>                  <span class="n">set_foot</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span><span class="p">);</span>                <span class="p">}</span>              <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>              <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>              <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>              <span class="k">return</span> <span class="n">p</span><span class="p">;</span>            <span class="p">}</span>        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>若不为空，则满足要求的chunk就在其中了。于是重复了与之前找到<code>large bin</code>时的相同的操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="nl">use_top</span><span class="p">:</span>      <span class="cm">/*         If large enough, split off the chunk bordering the end of memory         (held in av-&gt;top). Note that this is in accord with the best-fit         search rule.  In effect, av-&gt;top is treated as larger (and thus         less well fitting) than any other available chunk since it can         be extended to be as large as necessary (up to system         limitations).         We require that av-&gt;top always exists (i.e., has size &gt;=         MINSIZE) after initialization, so if it would otherwise be         exhausted by current request, it is replenished. (The main         reason for ensuring it exists is that we may need MINSIZE space         to put in fenceposts in sysmalloc.)       */</span>      <span class="n">victim</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>      <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>最后若以上，都没能找到满足要求的chunk。这说明即使取出<code>unsorted bin</code>最后一个chunk，有可能满足要求的bins仍然为空或是用户请求的空间过大。这时需要切割<code>top chunk</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span>        <span class="p">{</span>          <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>          <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>          <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>          <span class="n">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>                    <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>          <span class="n">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>          <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>          <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>          <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>          <span class="k">return</span> <span class="n">p</span><span class="p">;</span>        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由于<code>top chunk</code>切分出所需chunk后，还需要<code>MINSIZE</code>的空间来作为<code>fencepost</code>，所需必须满足<code>top chunk</code>的大小大于所需chunk的大小加上<code>MINSIZE</code>这个条件，才能从<code>top chunk</code>中分配所需chunk。从<code>top chunk</code>切分出所需chunk的处理过程跟前面的chunk切分类似，不同的是，原<code>top chunk</code>切分后的剩余部分将作为新的<code>top chunk</code>，原<code>top chunk</code>的<code>fencepost</code>仍然作为新的<code>top chunk</code>的<code>fencepost</code>，所以切分之后剩余的chunk不用<code>set_foot</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="cm">/* When we are using atomic ops to free fast chunks we can get         here for all block sizes.  */</span>      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">have_fastchunks</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>        <span class="p">{</span>          <span class="n">malloc_consolidate</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>          <span class="cm">/* restore original bin index */</span>          <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>            <span class="n">idx</span> <span class="o">=</span> <span class="n">smallbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>          <span class="k">else</span>            <span class="n">idx</span> <span class="o">=</span> <span class="n">largebin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里再次判断<code>fast bins</code>是否为空。并将其合并到<code>unsorted bin</code>中回到外层大循环。
在进入大循环之前，已经对<code>fast bins</code>和<code>small bins</code>进行了遍历，但是没有找到符合要求的chunk。之后，进入大循环，从<code>unsorted bin</code>中取出一个chunk，首先判断是否满足要求，再将其放入对应得bin中。然后对<code>small bins</code>和<code>large bins</code>进行遍历。仍然没有满足要求。同时切割<code>top chunk</code>得条件未满足，这时或许有其他线程向<code>fast bins</code>中加入了chunk。所以重新尝试分配<code>small bin chunk</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="cm">/*         Otherwise, relay to handle system-dependent cases       */</span>      <span class="k">else</span>        <span class="p">{</span>          <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sysmalloc</span> <span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>          <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>            <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>          <span class="k">return</span> <span class="n">p</span><span class="p">;</span>        <span class="p">}</span>    <span class="p">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后，请系统分配内存。</p>
<h4 id="sysmalloc">sysmalloc</h4>
<p>难理解，参考《ptmalloc源码分析》</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*   sysmalloc handles malloc cases requiring more memory from the system.   On entry, it is assumed that av-&gt;top does not have enough   space to service request for nb bytes, thus requiring that av-&gt;top   be extended or replaced. */</span><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">sysmalloc</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span> <span class="n">nb</span><span class="p">,</span> <span class="n">mstate</span> <span class="n">av</span><span class="p">){</span>  <span class="n">mchunkptr</span> <span class="n">old_top</span><span class="p">;</span>              <span class="cm">/* incoming value of av-&gt;top */</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">old_size</span><span class="p">;</span>       <span class="cm">/* its size */</span>  <span class="kt">char</span> <span class="o">*</span><span class="n">old_end</span><span class="p">;</span>                  <span class="cm">/* its end address */</span>  <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>                      <span class="cm">/* arg to first MORECORE or mmap call */</span>  <span class="kt">char</span> <span class="o">*</span><span class="n">brk</span><span class="p">;</span>                      <span class="cm">/* return value from MORECORE */</span>  <span class="kt">long</span> <span class="n">correction</span><span class="p">;</span>                <span class="cm">/* arg to 2nd MORECORE call */</span>  <span class="kt">char</span> <span class="o">*</span><span class="n">snd_brk</span><span class="p">;</span>                  <span class="cm">/* 2nd return val */</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">front_misalign</span><span class="p">;</span> <span class="cm">/* unusable bytes at front of new space */</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">end_misalign</span><span class="p">;</span>   <span class="cm">/* partial page left at end of new space */</span>  <span class="kt">char</span> <span class="o">*</span><span class="n">aligned_brk</span><span class="p">;</span>              <span class="cm">/* aligned offset into brk */</span>  <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">;</span>                    <span class="cm">/* the allocated/returned chunk */</span>  <span class="n">mchunkptr</span> <span class="n">remainder</span><span class="p">;</span>            <span class="cm">/* remainder from allocation */</span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remainder_size</span><span class="p">;</span>   <span class="cm">/* its size */</span>  <span class="n">size_t</span> <span class="n">pagemask</span> <span class="o">=</span> <span class="n">GLRO</span> <span class="p">(</span><span class="n">dl_pagesize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="kt">bool</span> <span class="n">tried_mmap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>当<code>top chunk</code>都无法满足要求时，证明<code>top chunk</code>没有足够的空间，所以需要替换或拓展。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*     If have mmap, and the request size meets the mmap threshold, and     the system supports mmap, and there are few enough currently     allocated mmapped regions, try to directly map this request     rather than expanding top.   */</span>  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">)</span> <span class="o">&amp;&amp;</span>      <span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">n_mmaps</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">n_mmaps_max</span><span class="p">))</span>    <span class="p">{</span>      <span class="kt">char</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>           <span class="cm">/* return value from mmap call*/</span>
</code></pre></td></tr></table>
</div>
</div><p>若当前请求满足<code>mmap</code>的分配阈值（默认为128k），并且当前进程<code>mmap()</code>分配的内存小于设定的最大值，则尝试使用<code>mmap()</code>进行分配，从而避免拓展<code>top chunk</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="nl">try_mmap</span><span class="p">:</span>      <span class="cm">/*         Round up size to nearest page.  For mmapped chunks, the overhead         is one SIZE_SZ unit larger than for normal chunks, because there         is no following chunk whose prev_size field could be used.         See the front_misalign handling below, for glibc there is no         need for further alignments unless we have have high alignment.       */</span>      <span class="k">if</span> <span class="p">(</span><span class="n">MALLOC_ALIGNMENT</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span>        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">SIZE_SZ</span> <span class="o">+</span> <span class="n">pagemask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pagemask</span><span class="p">;</span>      <span class="k">else</span>        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">SIZE_SZ</span> <span class="o">+</span> <span class="n">MALLOC_ALIGN_MASK</span> <span class="o">+</span> <span class="n">pagemask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pagemask</span><span class="p">;</span>      <span class="n">tried_mmap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>由于nb为所需chunk的大小，在<code>_int_malloc()</code>函数中已经将用户需要分配的大小转化为chunk大小，当如果这个chunk直接使用<code>mmap()</code>分配的话，该chunk不存在下一个相邻的chunk，也就没有<code>prev_size</code>的内存空间可以复用，所以还需要额外<code>SIZE_SZ</code>大小的内存。由于<code>mmap()</code>分配的内存块必须页对齐。如果使用<code>mmap()</code>分配内存，需要重新计算分配的内存大小size。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="cm">/* Don&#39;t try if size wraps around 0 */</span>      <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>        <span class="p">{</span>          <span class="n">mm</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MMAP</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>          <span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="n">MAP_FAILED</span><span class="p">)</span>            <span class="p">{</span>              <span class="cm">/*                 The offset to the start of the mmapped region is stored                 in the prev_size field of the chunk. This allows us to adjust                 returned start address to meet alignment requirements here                 and in memalign(), and still be able to compute proper                 address argument for later munmap in free() and realloc().               */</span>              <span class="k">if</span> <span class="p">(</span><span class="n">MALLOC_ALIGNMENT</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span>                <span class="p">{</span>                  <span class="cm">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and                     MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#39;ed area is page                     aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span>                  <span class="n">assert</span> <span class="p">(((</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>                  <span class="n">front_misalign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                <span class="p">}</span>              <span class="k">else</span>                <span class="n">front_misalign</span> <span class="o">=</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>              <span class="k">if</span> <span class="p">(</span><span class="n">front_misalign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>                <span class="p">{</span>                  <span class="n">correction</span> <span class="o">=</span> <span class="n">MALLOC_ALIGNMENT</span> <span class="o">-</span> <span class="n">front_misalign</span><span class="p">;</span>                  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">mchunkptr</span><span class="p">)</span> <span class="p">(</span><span class="n">mm</span> <span class="o">+</span> <span class="n">correction</span><span class="p">);</span>                  <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_size</span> <span class="o">=</span> <span class="n">correction</span><span class="p">;</span>                  <span class="n">set_head</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">correction</span><span class="p">)</span> <span class="o">|</span> <span class="n">IS_MMAPPED</span><span class="p">);</span>                <span class="p">}</span>              <span class="k">else</span>                <span class="p">{</span>                  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">mchunkptr</span><span class="p">)</span> <span class="n">mm</span><span class="p">;</span>                  <span class="n">set_head</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">IS_MMAPPED</span><span class="p">);</span>                <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果重新计算所需分配的size小于nb，表示溢出了，不分配内存，否则，调用<code>mmap()</code>分配所需大小的内存。如果<code>mmap()</code>分配内存成功，将<code>mmap()</code>返回的内存指针强制转换为chunk指针，并设置该chunk的大小为size，同时设置该chunk的<code>IS_MMAPPED</code>标志位，表示本chunk是通过<code>mmap()</code>函数直接从系统分配的。由于<code>mmap()</code>返回的内存地址是按照页对齐的，也一定是按照2*<code>SIZE_SZ</code>对齐的，满足chunk的边界对齐规则，使用<code>chunk2mem()</code>获取chunk中实际可用的内存也没有问题，所以这里不需要做额外的对齐操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* update statistics */</span>              <span class="kt">int</span> <span class="n">new</span> <span class="o">=</span> <span class="n">atomic_exchange_and_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mp_</span><span class="p">.</span><span class="n">n_mmaps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>              <span class="n">atomic_max</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mp_</span><span class="p">.</span><span class="n">max_n_mmaps</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>              <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span><span class="p">;</span>              <span class="n">sum</span> <span class="o">=</span> <span class="n">atomic_exchange_and_add</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mp_</span><span class="p">.</span><span class="n">mmapped_mem</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>              <span class="n">atomic_max</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mp_</span><span class="p">.</span><span class="n">max_mmapped_mem</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>              <span class="n">check_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>              <span class="k">return</span> <span class="nf">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>            <span class="p">}</span>        <span class="p">}</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>之后更新统计信息，<code>mmap()</code>分配的chunk数和总量都进行了更新。最后返回分配<code>chunk</code>的<code>mem</code>指针。到这里<code>mmap()</code>成功了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/* Record incoming configuration of top */</span>  <span class="n">old_top</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>  <span class="n">old_size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">old_top</span><span class="p">);</span>  <span class="n">old_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span><span class="p">));</span>  <span class="n">brk</span> <span class="o">=</span> <span class="n">snd_brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE_FAILURE</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>若<code>mmap()</code>也没有成功那么只能拓展<code>top chunk</code>，将<code>top chunk</code>的起始地址、大小和终止地址保存在局部变量中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*     If not the first time through, we require old_size to be     at least MINSIZE and to have prev_inuse set.   */</span>  <span class="n">assert</span> <span class="p">((</span><span class="n">old_top</span> <span class="o">==</span> <span class="n">initial_top</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">old_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>          <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">old_size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MINSIZE</span> <span class="o">&amp;&amp;</span>           <span class="n">prev_inuse</span> <span class="p">(</span><span class="n">old_top</span><span class="p">)</span> <span class="o">&amp;&amp;</span>           <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">old_end</span> <span class="o">&amp;</span> <span class="n">pagemask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>  <span class="cm">/* Precondition: not enough current space to satisfy nb request */</span>  <span class="n">assert</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">old_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>检查<code>top chunk</code>的合法性，如果第一次调用本函数，<code>top chunk</code>可能没有初始化，可能<code>old_size</code>为0，如果<code>top chunk</code>已经初始化，则<code>top chunk</code>的大小必须大于等于<code>MINSIZE</code>，因为<code>top chunk</code>中包含了<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存。<code>Top chun</code>k必须标识前一个chunk处于inuse状态，这是规定，并且<code>top chunk</code>的结束地址必定是页对齐的。另外top chunk的除去<code>fencepost</code>的大小必定小于所需chunk的大小，不然在<code>_int_malloc()</code>函数中就应该使用<code>top chunk</code>获得所需的chunk。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>    <span class="p">{</span>      <span class="n">heap_info</span> <span class="o">*</span><span class="n">old_heap</span><span class="p">,</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>      <span class="n">size_t</span> <span class="n">old_heap_size</span><span class="p">;</span>      <span class="cm">/* First try to extend the current heap. */</span>      <span class="n">old_heap</span> <span class="o">=</span> <span class="n">heap_for_ptr</span> <span class="p">(</span><span class="n">old_top</span><span class="p">);</span>      <span class="n">old_heap_size</span> <span class="o">=</span> <span class="n">old_heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>      <span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">MINSIZE</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">old_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>          <span class="o">&amp;&amp;</span> <span class="n">grow_heap</span> <span class="p">(</span><span class="n">old_heap</span><span class="p">,</span> <span class="n">MINSIZE</span> <span class="o">+</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">old_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>        <span class="p">{</span>          <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">old_heap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">old_heap_size</span><span class="p">;</span>          <span class="n">arena_mem</span> <span class="o">+=</span> <span class="n">old_heap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">old_heap_size</span><span class="p">;</span>          <span class="n">set_head</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">old_heap</span> <span class="o">+</span> <span class="n">old_heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">old_top</span><span class="p">)</span>                    <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>若当前分配区非主分配区，获取<code>heap_info</code>，如果<code>top chunk</code>的剩余有效空间不足以分配出所需的chunk（前面已经断言，这个肯定成立），尝试增长<code>sub_heap</code>的可读可写区域大小，如果成功，修改过内存分配的统计信息，并更新新的<code>top chunk</code>的size。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="k">else</span> <span class="nf">if</span> <span class="p">((</span><span class="n">heap</span> <span class="o">=</span> <span class="n">new_heap</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="p">(</span><span class="n">MINSIZE</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">heap</span><span class="p">)),</span> <span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span><span class="p">)))</span>        <span class="p">{</span>          <span class="cm">/* Use a newly allocated heap.  */</span>          <span class="n">heap</span><span class="o">-&gt;</span><span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">av</span><span class="p">;</span>          <span class="n">heap</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">old_heap</span><span class="p">;</span>          <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>          <span class="n">arena_mem</span> <span class="o">+=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>          <span class="cm">/* Set up the new top.  */</span>          <span class="n">top</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">heap</span><span class="p">));</span>          <span class="n">set_head</span> <span class="p">(</span><span class="n">top</span> <span class="p">(</span><span class="n">av</span><span class="p">),</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">heap</span><span class="p">))</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>调用<code>new_heap()</code>函数创建一个新的<code>sub_heap</code>，由于这个<code>sub_heap</code>中至少需要容下大小为nb的chunk，大小为<code>MINSIZE</code>的<code>fencepost</code>和大小为<code>sizeof(*heap)</code>的<code>heap_info</code>实例，所以传入<code>new_heap()</code>函数的分配大小为<code>nb + (MINSIZE + sizeof(*heap))</code>。
使新创建的<code>sub_heap</code>保存当前的分配区指针，将该<code>sub_heap</code>加入当前分配区的<code>sub_heap</code>链表中，更新当前分配区内存分配统计，将新创建的<code>sub_heap</code>仅有的一个空闲chunk作为当前分配区的<code>top chunk</code>，并设置<code>top chunk</code>的状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="cm">/* Setup fencepost and free the old top chunk with a multiple of             MALLOC_ALIGNMENT in size. */</span>          <span class="cm">/* The fencepost takes at least MINSIZE bytes, because it might             become the top chunk again later.  Note that a footer is set             up, too, although the chunk is marked in use. */</span>          <span class="n">old_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">-</span> <span class="n">MINSIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>          <span class="n">set_head</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">),</span> <span class="mi">0</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>          <span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">&gt;=</span> <span class="n">MINSIZE</span><span class="p">)</span>            <span class="p">{</span>              <span class="n">set_head</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>              <span class="n">set_foot</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">));</span>              <span class="n">set_head</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span> <span class="n">NON_MAIN_ARENA</span><span class="p">);</span>              <span class="n">_int_free</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">old_top</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>            <span class="p">}</span>          <span class="k">else</span>            <span class="p">{</span>              <span class="n">set_head</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>              <span class="n">set_foot</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">));</span>            <span class="p">}</span>        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>设置原<code>top chunk</code>的<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存空间，将该<code>old_size</code>减去<code>MINSIZE</code>得到原<code>top chunk</code>的有效内存空间，首先设置<code>fencepost</code>的第二个chunk的size为0，并标识前一个chunk处于inuse状态。接着判断原<code>top chunk</code>的有效内存空间上是否大于等于<code>MINSIZE</code>，如果是，表示原<code>top chunk</code>可以分配出大于等于<code>MINSIZE</code>大小的chunk，于是将原<code>top chunk</code>切分成空闲chunk和<code>fencepost</code>两部分，先设置<code>fencepost</code>的第一个chunk的大小为<code>2*SIZE_SZ</code>，并标识前一个chunk处于inuse状态，<code>fencepost</code>的第一个chunk还需要设置foot，表示该chunk处于空闲状态，而<code>fencepost</code>的第二个chunk却标识第一个chunk处于inuse状态，因为不能有两个空闲chunk相邻，才会出现这么奇怪的<code>fencepost</code>。另外其实<code>top chunk</code>切分出来的chunk也是处于空闲状态，但<code>fencepost</code>的第一个chunk却标识前一个chunk为inuse状态，然后强制将该处于inuse状态的chunk调用<code>_int_free()</code>函数释放掉。这样做完全是要遵循不能有两个空闲chunk相邻的约定。
如果原<code>top chunk</code>中有效空间不足<code>MINSIZE</code>，则将整个原<code>top chunk</code>作为<code>fencepost</code>，并设置<code>fencepost</code>的第一个chunk的相关状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tried_mmap</span><span class="p">)</span>        <span class="cm">/* We can at least try to use to mmap memory.  */</span>        <span class="k">goto</span> <span class="n">try_mmap</span><span class="p">;</span>    <span class="p">}</span>  <span class="k">else</span>     <span class="cm">/* av == main_arena */</span>    <span class="p">{</span> <span class="cm">/* Request enough space for nb + pad + overhead */</span>      <span class="n">size</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">+</span> <span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">;</span>      <span class="cm">/*         If contiguous, we can subtract out existing space that we hope to         combine with new space. We add it back later only if         we don&#39;t actually get contiguous space.       */</span>      <span class="k">if</span> <span class="p">(</span><span class="n">contiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>        <span class="n">size</span> <span class="o">-=</span> <span class="n">old_size</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果增长<code>sub_heap</code>的可读可写区域大小和创建新<code>sub_heap</code>都失败了，尝试使用<code>mmap()</code>函数直接从系统分配所需chunk。
如果为当前分配区为主分配区，重新计算需要分配的size。
一般情况下，主分配区使用<code>sbrk()</code>从heap中分配内存，sbrk()返回连续的虚拟内存，这里调整需要分配的size，减掉<code>top chunk</code>中已有空闲内存大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="cm">/*         Round to a multiple of page size.         If MORECORE is not contiguous, this ensures that we only call it         with whole-page arguments.  And if MORECORE is contiguous and         this is not first time through, this preserves page-alignment of         previous calls. Otherwise, we correct to page-align below.       */</span>      <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">pagemask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pagemask</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>将size按照页对齐，<code>sbrk()</code>必须以页为单位分配连续虚拟内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="cm">/*         Don&#39;t try to call MORECORE if argument is so big as to appear         negative. Note that since mmap takes size_t arg, it may succeed         below even if we cannot call MORECORE.       */</span>      <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>        <span class="p">{</span>          <span class="n">brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE</span> <span class="p">(</span><span class="n">size</span><span class="p">));</span>          <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_sbrk_more</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>        <span class="p">}</span>      <span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span>        <span class="p">{</span>          <span class="cm">/* Call the `morecore&#39; hook if necessary.  */</span>          <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__after_morecore_hook</span><span class="p">);</span>          <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>            <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)();</span>        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用<code>sbrk()</code>从heap中分配size大小的虚拟内存块。如果<code>sbrk()</code>分配成功，并且<code>morecore</code>的hook函数存在，调用<code>morecore</code>的hook函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="k">else</span>        <span class="p">{</span>          <span class="cm">/*             If have mmap, try using it as a backup when MORECORE fails or             cannot be used. This is worth doing on systems that have &#34;holes&#34; in             address space, so sbrk cannot extend to give contiguous space, but             space is available elsewhere.  Note that we ignore mmap max count             and threshold limits, since the space will not be used as a             segregated mmap region.           */</span>          <span class="cm">/* Cannot merge with old top, so add its size back in */</span>          <span class="k">if</span> <span class="p">(</span><span class="n">contiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>            <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">old_size</span> <span class="o">+</span> <span class="n">pagemask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pagemask</span><span class="p">;</span>          <span class="cm">/* If we are relying on mmap as backup, then use larger units */</span>          <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">MMAP_AS_MORECORE_SIZE</span><span class="p">))</span>            <span class="n">size</span> <span class="o">=</span> <span class="n">MMAP_AS_MORECORE_SIZE</span><span class="p">;</span>          <span class="cm">/* Don&#39;t try if size wraps around 0 */</span>          <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>            <span class="p">{</span>              <span class="kt">char</span> <span class="o">*</span><span class="n">mbrk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MMAP</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>              <span class="k">if</span> <span class="p">(</span><span class="n">mbrk</span> <span class="o">!=</span> <span class="n">MAP_FAILED</span><span class="p">)</span>                <span class="p">{</span>                  <span class="cm">/* We do not need, and cannot use, another sbrk call to find end */</span>                  <span class="n">brk</span> <span class="o">=</span> <span class="n">mbrk</span><span class="p">;</span>                  <span class="n">snd_brk</span> <span class="o">=</span> <span class="n">brk</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>                  <span class="cm">/*                     Record that we no longer have a contiguous sbrk region.                     After the first time mmap is used as backup, we do not                     ever rely on contiguous space since this could incorrectly                     bridge regions.                   */</span>                  <span class="n">set_noncontiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>                <span class="p">}</span>            <span class="p">}</span>        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>sbrk(</code>)返回失败，或是<code>sbrk()</code>不可用，使用<code>mmap()</code>代替，重新计算所需分配的内存大小并按页对齐，如果重新计算的size小于1M，将size设为1M，也就是说使用mmap()作为<code>morecore</code>函数分配的最小内存块大小为1M。如果所需分配的内存大小合法，使用<code>mmap()</code>函数分配内存。如果分配成功，更新brk和snd_brk，并将当前分配区属性设置为可分配不连续虚拟内存块。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span>        <span class="p">{</span>          <span class="k">if</span> <span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">sbrk_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>            <span class="n">mp_</span><span class="p">.</span><span class="n">sbrk_base</span> <span class="o">=</span> <span class="n">brk</span><span class="p">;</span>          <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果brk合法，即<code>sbrk()</code>或<code>mmap()</code>分配成功，如果<code>sbrk_base</code>还没有初始化，更新<code>sbrk_base</code>和当前分配区的内存分配总量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="cm">/*             If MORECORE extends previous space, we can likewise extend top size.           */</span>          <span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">==</span> <span class="n">old_end</span> <span class="o">&amp;&amp;</span> <span class="n">snd_brk</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span>            <span class="n">set_head</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">old_size</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>          <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">contiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">old_size</span> <span class="o">&amp;&amp;</span> <span class="n">brk</span> <span class="o">&lt;</span> <span class="n">old_end</span><span class="p">)</span>            <span class="p">{</span>              <span class="cm">/* Oops!  Someone else killed our space..  Can&#39;t touch anything.  */</span>              <span class="n">malloc_printerr</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#34;break adjusted to free malloc space&#34;</span><span class="p">,</span> <span class="n">brk</span><span class="p">);</span>            <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>sbrk()</code>分配成功，更新<code>top chunk</code>的大小，并设定<code>top chunk</code>的前一个chunk处于inuse状态。如果当前分配区可分配连续虚拟内存，原<code>top chunk</code>的大小大于0，但新的brk值小于原<code>top chunk</code>的结束地址，出错了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">          <span class="cm">/*             Otherwise, make adjustments:           * If the first time through or noncontiguous, we need to call sbrk              just to find out where the end of memory lies.           * We need to ensure that all returned chunks from malloc will meet              MALLOC_ALIGNMENT           * If there was an intervening foreign sbrk, we need to adjust sbrk              request size to account for fact that we will not be able to              combine new space with existing space in old_top.           * Almost all systems internally allocate whole pages at a time, in              which case we might as well use the whole last page of request.              So we allocate enough more memory to hit a page boundary now,              which in turn causes future contiguous calls to page-align.           */</span>          <span class="k">else</span>            <span class="p">{</span>              <span class="n">front_misalign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>              <span class="n">end_misalign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>              <span class="n">correction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>              <span class="n">aligned_brk</span> <span class="o">=</span> <span class="n">brk</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>执行到这个分支，意味着<code>sbrk()</code>返回的brk值大于原<code>top chunk</code>的结束地址，那么新的地址与原<code>top chunk</code>的地址不连续，可能是由于外部其它地方调用<code>sbrk()</code>函数，这里需要处理地址的重新对齐问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* handle contiguous cases */</span>              <span class="k">if</span> <span class="p">(</span><span class="n">contiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>                <span class="p">{</span>                  <span class="cm">/* Count foreign sbrk as system_mem.  */</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">old_size</span><span class="p">)</span>                    <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">brk</span> <span class="o">-</span> <span class="n">old_end</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果本分配区可分配连续虚拟内存，并且有外部调用了<code>sbrk()</code>函数，将外部调用<code>sbrk()</code>分配的内存计入当前分配区所分配内存统计中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                  <span class="cm">/* Guarantee alignment of first new chunk made from this space */</span>                  <span class="n">front_misalign</span> <span class="o">=</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">brk</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">front_misalign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>                    <span class="p">{</span>                      <span class="cm">/*                         Skip over some bytes to arrive at an aligned position.                         We don&#39;t need to specially mark these wasted front bytes.                         They will never be accessed anyway because                         prev_inuse of av-&gt;top (and any chunk created from its start)                         is always true after initialization.                       */</span>                      <span class="n">correction</span> <span class="o">=</span> <span class="n">MALLOC_ALIGNMENT</span> <span class="o">-</span> <span class="n">front_misalign</span><span class="p">;</span>                      <span class="n">aligned_brk</span> <span class="o">+=</span> <span class="n">correction</span><span class="p">;</span>                    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计算当前的brk要矫正的字节数据，保证brk地址按<code>MALLOC_ALIGNMENT</code>对齐。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                  <span class="cm">/*                     If this isn&#39;t adjacent to existing space, then we will not                     be able to merge with old_top space, so must add to 2nd request.                   */</span>                  <span class="n">correction</span> <span class="o">+=</span> <span class="n">old_size</span><span class="p">;</span>                  <span class="cm">/* Extend the end address to hit a page boundary */</span>                  <span class="n">end_misalign</span> <span class="o">=</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span> <span class="p">(</span><span class="n">brk</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">correction</span><span class="p">);</span>                  <span class="n">correction</span> <span class="o">+=</span> <span class="p">((</span><span class="n">end_misalign</span> <span class="o">+</span> <span class="n">pagemask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pagemask</span><span class="p">)</span> <span class="o">-</span> <span class="n">end_misalign</span><span class="p">;</span>                  <span class="n">assert</span> <span class="p">(</span><span class="n">correction</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>                  <span class="n">snd_brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE</span> <span class="p">(</span><span class="n">correction</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>由于原<code>top chunk</code>的地址与当前brk不相邻，也就不能再使用原<code>top chunk</code>的内存了，需要重新为所需chunk分配足够的内存，将原<code>top chunk</code>的大小加到矫正值中，从当前brk中分配所需chunk，计算出未对齐的chunk结束地址<code>end_misalign</code>，然后将<code>end_misalign</code>按照页对齐计算出需要矫正的字节数加到矫正值上。然后再调用<code>sbrk()</code>分配矫正值大小的内存，如果<code>sbrk()</code>分配成功，则当前的top chunk中可以分配出所需的连续内存的chunk。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                  <span class="cm">/*                     If can&#39;t allocate correction, try to at least find out current                     brk.  It might be enough to proceed without failing.                     Note that if second sbrk did NOT fail, we assume that space                     is contiguous with first sbrk. This is a safe assumption unless                     program is multithreaded but doesn&#39;t use locks and a foreign sbrk                     occurred between our first and second calls.                   */</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">snd_brk</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span>                    <span class="p">{</span>                      <span class="n">correction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                      <span class="n">snd_brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>                    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>sbrk()</code>执行失败，更新当前brk的结束地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                  <span class="k">else</span>                    <span class="p">{</span>                      <span class="cm">/* Call the `morecore&#39; hook if necessary.  */</span>                      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__after_morecore_hook</span><span class="p">);</span>                      <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                        <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)();</span>                    <span class="p">}</span>                <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>sbrk(</code>)执行成功，并且有<code>morecore hook</code>函数存在，执行该hook函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* handle non-contiguous cases */</span>              <span class="k">else</span>                <span class="p">{</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">MALLOC_ALIGNMENT</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span>                    <span class="cm">/* MORECORE/mmap must correctly align */</span>                    <span class="n">assert</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">brk</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>                  <span class="k">else</span>                    <span class="p">{</span>                      <span class="n">front_misalign</span> <span class="o">=</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">brk</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>                      <span class="k">if</span> <span class="p">(</span><span class="n">front_misalign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>                        <span class="p">{</span>                          <span class="cm">/*                             Skip over some bytes to arrive at an aligned position.                             We don&#39;t need to specially mark these wasted front bytes.                             They will never be accessed anyway because                             prev_inuse of av-&gt;top (and any chunk created from its start)                             is always true after initialization.                           */</span>                          <span class="n">aligned_brk</span> <span class="o">+=</span> <span class="n">MALLOC_ALIGNMENT</span> <span class="o">-</span> <span class="n">front_misalign</span><span class="p">;</span>                        <span class="p">}</span>                    <span class="p">}</span>                  <span class="cm">/* Find out current end of memory */</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">snd_brk</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span>                    <span class="p">{</span>                      <span class="n">snd_brk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>                    <span class="p">}</span>                <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>执行到这里，意味着brk是用<code>mmap()</code>分配的，断言brk一定是按<code>MALLOC_ALIGNMENT</code>对齐的，因为<code>mmap()</code>返回的地址按页对齐。如果brk的结束地址非法，使用<code>morecore</code>获得当前brk的结束地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">              <span class="cm">/* Adjust top based on results of second sbrk */</span>              <span class="k">if</span> <span class="p">(</span><span class="n">snd_brk</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">MORECORE_FAILURE</span><span class="p">))</span>                <span class="p">{</span>                  <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="p">(</span><span class="n">mchunkptr</span><span class="p">)</span> <span class="n">aligned_brk</span><span class="p">;</span>                  <span class="n">set_head</span> <span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span> <span class="p">(</span><span class="n">snd_brk</span> <span class="o">-</span> <span class="n">aligned_brk</span> <span class="o">+</span> <span class="n">correction</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>                  <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">+=</span> <span class="n">correction</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果brk的结束地址合法，设置当前分配区的<code>top chunk</code>为brk，设置<code>top chunk</code>的大小，并更新分配区的总分配内存量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">                  <span class="cm">/*                     If not the first time through, we either have a                     gap due to foreign sbrk or a non-contiguous region.  Insert a                     double fencepost at old_top to prevent consolidation with space                     we don&#39;t own. These fenceposts are artificial chunks that are                     marked as inuse and are in any case too small to use.  We need                     two to make sizes and alignments work out.                   */</span>                  <span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>                    <span class="p">{</span>                      <span class="cm">/*                         Shrink old_top to insert fenceposts, keeping size a                         multiple of MALLOC_ALIGNMENT. We know there is at least                         enough space in old_top to do this.                       */</span>                      <span class="n">old_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MALLOC_ALIGN_MASK</span><span class="p">;</span>                      <span class="n">set_head</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>                      <span class="cm">/*                         Note that the following assignments completely overwrite                         old_top when old_size was previously MINSIZE.  This is                         intentional. We need the fencepost, even if old_top otherwise gets                         lost.                       */</span>                      <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span>                        <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">;</span>                      <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">old_top</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span>                        <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">)</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">;</span>                      <span class="cm">/* If possible, release the rest. */</span>                      <span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">&gt;=</span> <span class="n">MINSIZE</span><span class="p">)</span>                        <span class="p">{</span>                          <span class="n">_int_free</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">old_top</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>                        <span class="p">}</span>                    <span class="p">}</span>                <span class="p">}</span>            <span class="p">}</span>        <span class="p">}</span>    <span class="p">}</span> <span class="cm">/* if (av !=  &amp;main_arena) */</span>
</code></pre></td></tr></table>
</div>
</div><p>设置原<code>top chunk</code>的<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存空间，将该<code>old_size</code>减去<code>MINSIZE</code>得到原<code>top chunk</code>的有效内存空间，我们可以确信原<code>top chunk</code>的有效内存空间一定大于<code>MINSIZE</code>，将原<code>top chunk</code>切分成空闲chunk和<code>fencepost</code>两部分，首先设置切分出来的chunk的大小为<code>old_size</code>，并标识前一个chunk处于inuse状态，原 <code>top chunk</code>切分出来的chunk本应处于空闲状态，但<code>fencepost</code>的第一个chunk却标识前一个chunk为inuse状态，然后强制将该处于inuse状态的chunk调用<code>_int_free()</code>函数释放掉。然后设置<code>fencepost</code>的第一个chunk的大小为2*<code>SIZE_SZ</code>，并标识前一个chunk处于inuse状态，然后设置<code>fencepost</code>的第二个chunk的size为2*<code>SIZE_SZ</code>，并标识前一个chunk处于inuse状态。这里的主分配区的<code>fencepost</code>与非主分配区的<code>fencepost</code>不同，主分配区<code>fencepost</code>的第二个chunk的大小设置为2*<code>SIZE_SZ</code>，而非主分配区的<code>fencepost</code>的第二个chunk的大小设置为0。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">max_system_mem</span><span class="p">))</span>    <span class="n">av</span><span class="o">-&gt;</span><span class="n">max_system_mem</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">;</span>  <span class="n">check_malloc_state</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>  <span class="cm">/* finally, do the allocation */</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>  <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="cm">/* check that one of the above allocation paths succeeded */</span>  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span>    <span class="p">{</span>      <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>      <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>      <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>      <span class="n">set_head</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>      <span class="n">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>      <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>      <span class="k">return</span> <span class="nf">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>    <span class="p">}</span>  <span class="cm">/* catch all failure paths */</span>  <span class="n">__set_errno</span> <span class="p">(</span><span class="n">ENOMEM</span><span class="p">);</span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前分配区所分配的内存量大于设置的最大值，更新当前分配区最大分配的内存量，如果当前<code>top chunk</code>中已经有足够的内存来分配所需的chunk，从当前的<code>top chunk</code>中分配所需的chunk并返回。</p>
<h3 id="malloc_consolidate">malloc_consolidate</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">malloc_consolidate</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">){</span>  <span class="n">mfastbinptr</span><span class="o">*</span>    <span class="n">fb</span><span class="p">;</span>                 <span class="cm">/* current fastbin being consolidated */</span>  <span class="n">mfastbinptr</span><span class="o">*</span>    <span class="n">maxfb</span><span class="p">;</span>              <span class="cm">/* last fastbin (for loop control) */</span>  <span class="n">mchunkptr</span>       <span class="n">p</span><span class="p">;</span>                  <span class="cm">/* current chunk being consolidated */</span>  <span class="n">mchunkptr</span>       <span class="n">nextp</span><span class="p">;</span>              <span class="cm">/* next chunk to consolidate */</span>  <span class="n">mchunkptr</span>       <span class="n">unsorted_bin</span><span class="p">;</span>       <span class="cm">/* bin header */</span>  <span class="n">mchunkptr</span>       <span class="n">first_unsorted</span><span class="p">;</span>     <span class="cm">/* chunk to link to */</span>  <span class="cm">/* These have same use as in free() */</span>  <span class="n">mchunkptr</span>       <span class="n">nextchunk</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">nextsize</span><span class="p">;</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">prevsize</span><span class="p">;</span>  <span class="kt">int</span>             <span class="n">nextinuse</span><span class="p">;</span>  <span class="n">mchunkptr</span>       <span class="n">bck</span><span class="p">;</span>  <span class="n">mchunkptr</span>       <span class="n">fwd</span><span class="p">;</span>  <span class="cm">/*    If max_fast is 0, we know that av hasn&#39;t    yet been initialized, in which case do so below  */</span>  <span class="k">if</span> <span class="p">(</span><span class="n">get_max_fast</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>    <span class="n">clear_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>    <span class="n">unsorted_bin</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>    <span class="cm">/*      Remove each chunk from fast bin and consolidate it, placing it      then in unsorted bin. Among other reasons for doing this,      placing in unsorted bin avoids needing to calculate actual bins      until malloc is sure that chunks aren&#39;t immediately going to be      reused anyway.    */</span>    <span class="n">maxfb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">NFASTBINS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>    <span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>将分配区最大的一个<code>fast bin</code>赋值给<code>maxfb</code>，第一个<code>fast bin</code>赋值给fb，然后遍历<code>fast bins</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="k">do</span> <span class="p">{</span>      <span class="n">p</span> <span class="o">=</span> <span class="n">atomic_exchange_acq</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>      <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="k">do</span> <span class="p">{</span>	  <span class="n">check_inuse_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>	  <span class="n">nextp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>将空闲chunk链表的下一个chunk赋值给<code>nextp</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	  <span class="cm">/* Slightly streamlined version of consolidation code in free() */</span>	  <span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PREV_INUSE</span><span class="o">|</span><span class="n">NON_MAIN_ARENA</span><span class="p">);</span>	  <span class="n">nextchunk</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>	  <span class="n">nextsize</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>获得当前chunk的size，需要去除size中的<code>PREV_INUSE</code>和<code>NON_MAIN_ARENA</code>标志，并获取相邻的下一个chunk和下一个chunk的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>	    <span class="n">prevsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_size</span><span class="p">;</span>	    <span class="n">size</span> <span class="o">+=</span> <span class="n">prevsize</span><span class="p">;</span>	    <span class="n">p</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">prevsize</span><span class="p">));</span>	    <span class="n">unlink</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>	  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前chunk的前一个chunk空闲，则将当前chunk与前一个chunk合并成一个空闲chunk，由于前一个chunk空闲，则当前chunk的<code>prev_size</code>保存了前一个chunk的大小，计算出合并后的chunk大小，并获取前一个chunk的指针，将前一个chunk从空闲链表中删除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	  <span class="k">if</span> <span class="p">(</span><span class="n">nextchunk</span> <span class="o">!=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span>	    <span class="n">nextinuse</span> <span class="o">=</span> <span class="n">inuse_bit_at_offset</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="n">nextsize</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>如果与当前chunk相邻的下一个chunk不是分配区的<code>top chunk</code>，查看与当前chunk相邻的下一个chunk是否处于inuse状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextinuse</span><span class="p">)</span> <span class="p">{</span>	      <span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>	      <span class="n">unlink</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>	    <span class="p">}</span> <span class="k">else</span>	      <span class="n">clear_inuse_bit_at_offset</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	    <span class="n">first_unsorted</span> <span class="o">=</span> <span class="n">unsorted_bin</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>	    <span class="n">unsorted_bin</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>	    <span class="n">first_unsorted</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果与当前chunk相邻的下一个chunk处于inuse状态，清除当前chunk的inuse状态，则当前chunk空闲了。否则，将相邻的下一个空闲chunk从空闲链表中删除，并计算当前chunk与下一个chunk合并后的chunk大小。将合并后的chunk加入<code>unsorted bin</code>的双向循环链表中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>	      <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	      <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果合并后的chunk属于large bin，将chunk的<code>fd_nextsize</code>和<code>bk_nextsize</code>设置为NULL，因为在<code>unsorted bin</code>中这两个字段无用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	    <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>	    <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">unsorted_bin</span><span class="p">;</span>	    <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">first_unsorted</span><span class="p">;</span>	    <span class="n">set_foot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>	  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>设置合并后的空闲chunk大小，并标识前一个chunk处于inuse状态，因为必须保证不能有两个相邻的chunk都处于空闲状态。然后将合并后的chunk加入<code>unsorted bin</code>的双向循环链表中。最后设置合并后的空闲chunk的foot，chunk空闲时必须设置foot，该foot处于下一个chunk的<code>prev_size</code>中，只有chunk空闲是foot才是有效的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	  <span class="k">else</span> <span class="p">{</span>	    <span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>	    <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>	    <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>	  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前chunk的下一个chunk为<code>top chunk</code>，则将当前chunk合并入<code>top chunk</code>，修改<code>top chunk</code>的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">nextp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>直到遍历完当前<code>fast bin</code>中的所有空闲chunk。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="p">}</span>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">fb</span><span class="o">++</span> <span class="o">!=</span> <span class="n">maxfb</span><span class="p">);</span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>直到遍历完所有的fast bins。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="k">else</span> <span class="p">{</span>    <span class="n">malloc_init_state</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>    <span class="n">check_malloc_state</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>  <span class="p">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>ptmalloc</code>没有初始化，初始化<code>ptmalloc</code>。</p>
<h3 id="__libc_free">__libc_free</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">void__libc_free</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">){</span>  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span>  <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">;</span>                          <span class="cm">/* chunk corresponding to mem */</span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>    <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__free_hook</span><span class="p">);</span>  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>    <span class="p">{</span>      <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">mem</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>      <span class="k">return</span><span class="p">;</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>同样，这里检查了用户是否实现自定义的<code>__free_hook</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                              <span class="cm">/* free(0) has no effect */</span>    <span class="k">return</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">mem2chunk</span> <span class="p">(</span><span class="n">mem</span><span class="p">);</span>  <span class="k">if</span> <span class="p">(</span><span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span>                       <span class="cm">/* release mmapped memory. */</span>    <span class="p">{</span>      <span class="cm">/* see if the dynamic brk/mmap threshold needs adjusting */</span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span>          <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span>          <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">DEFAULT_MMAP_THRESHOLD_MAX</span><span class="p">)</span>        <span class="p">{</span>          <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>          <span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">;</span>          <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_free_dyn_thresholds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>                      <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span><span class="p">);</span>        <span class="p">}</span>      <span class="n">munmap_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>      <span class="k">return</span><span class="p">;</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前free的chunk是通过<code>mmap()</code>分配的，调用<code>munmap_chunk()</code>函数unmap本chunk。<code>munmap_chunk()</code>函数调用<code>munmap()</code>函数释放<code>mmap()</code>分配的内存块。同时查看是否开启了mmap分配阈值动态调整机制，默认是开启的，如果当前free的chunk的大小大于设置的mmap分配阈值，小于mmap分配阈值的最大值，将当前chunk的大小赋值给mmap分配阈值，并修改mmap收缩阈值为mmap分配阈值的2倍。默认情况下mmap分配阈值与mmap收缩阈值相等，都为128KB。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">arena_for_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="n">_int_free</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);}</span>
</code></pre></td></tr></table>
</div>
</div><p>获取当前分配区指针，最后调用<code>_int_free</code>。</p>
<h3 id="_int_free">_int_free</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="nf">void_int_free</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">have_lock</span><span class="p">){</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>        <span class="cm">/* its size */</span>  <span class="n">mfastbinptr</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>             <span class="cm">/* associated fastbin */</span>  <span class="n">mchunkptr</span> <span class="n">nextchunk</span><span class="p">;</span>         <span class="cm">/* next contiguous chunk */</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">nextsize</span><span class="p">;</span>    <span class="cm">/* its size */</span>  <span class="kt">int</span> <span class="n">nextinuse</span><span class="p">;</span>               <span class="cm">/* true if nextchunk is used */</span>  <span class="n">INTERNAL_SIZE_T</span> <span class="n">prevsize</span><span class="p">;</span>    <span class="cm">/* size of previous contiguous chunk */</span>  <span class="n">mchunkptr</span> <span class="n">bck</span><span class="p">;</span>               <span class="cm">/* misc temp for linking */</span>  <span class="n">mchunkptr</span> <span class="n">fwd</span><span class="p">;</span>               <span class="cm">/* misc temp for linking */</span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errstr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="kt">int</span> <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>获取其chunk size</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/* Little security check which won&#39;t hurt performance: the     allocator never wrapps around at the end of the address space.     Therefore we can exclude some size values which might appear     here by accident or by &#34;design&#34; from some intruder.  */</span>  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">((</span><span class="n">uintptr_t</span><span class="p">)</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span> <span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>      <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">misaligned_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>    <span class="p">{</span>      <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): invalid pointer&#34;</span><span class="p">;</span>    <span class="nl">errout</span><span class="p">:</span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">locked</span><span class="p">)</span>        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>      <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">));</span>      <span class="k">return</span><span class="p">;</span>    <span class="p">}</span>  <span class="cm">/* We know that each chunk is at least MINSIZE bytes in size or a     multiple of MALLOC_ALIGNMENT.  */</span>  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span> <span class="o">||</span> <span class="o">!</span><span class="n">aligned_OK</span> <span class="p">(</span><span class="n">size</span><span class="p">)))</span>    <span class="p">{</span>      <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): invalid size&#34;</span><span class="p">;</span>      <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>    <span class="p">}</span>  <span class="n">check_inuse_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码用于安全检查，chunk的指针地址不能溢出，chunk的大小必须大于等于<code>MINSIZE</code>且要求对齐。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*    If eligible, place chunk on a fastbin so it can be found    and used quickly in malloc.  */</span>  <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">get_max_fast</span> <span class="p">())</span><span class="err">#</span><span class="k">if</span> <span class="n">TRIM_FASTBINS</span>      <span class="cm">/*	If TRIM_FASTBINS set, don&#39;t place chunks	bordering top into fastbins      */</span>      <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span><span class="err">#</span><span class="n">endif</span>      <span class="p">)</span> <span class="p">{</span>    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>	<span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>			     <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>      <span class="p">{</span>	<span class="cm">/* We might not have a lock at this point and concurrent modifications	   of system_mem might have let to a false positive.  Redo the test	   after getting the lock.  */</span>	<span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span>	    <span class="o">||</span> <span class="p">({</span> <span class="n">assert</span> <span class="p">(</span><span class="n">locked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>		  <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>		  <span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		  <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span>		    <span class="o">||</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">;</span>	      <span class="p">}))</span>	  <span class="p">{</span>	    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): invalid next size (fast)&#34;</span><span class="p">;</span>	    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>	  <span class="p">}</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">have_lock</span><span class="p">)</span>	  <span class="p">{</span>	    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>	    <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	  <span class="p">}</span>      <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前free的chunk属于<code>fast bins</code>，查看下一个相邻的chunk的大小是否小于等于2*<code>SIZE_SZ</code>，下一个相邻chunk的大小是否大于分配区所分配的内存总量，如果是，报错。这里计算下一个相邻chunk的大小似乎有点问题，因为chunk的size字段中包含了一些标志位，正常情况下下一个相邻chunk的size中的<code>PREV_INUSE</code>标志位会置位，但这里就是要检出错的情况，也就是下一个相邻chunk的size中标志位都没有置位，并且该chunk大小为2*<code>SIZE_SZ</code>的错误情况。如果调用本函数前没有对分配区加锁， 所以读取分配区所分配的内存总量需要对分配区加锁，检查完以后，释放分配区的锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="n">free_perturb</span> <span class="p">(</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">);</span>    <span class="n">set_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">fastbin_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>    <span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>设置当前分配区的<code>fast bin flag</code>，表示当前分配区的<code>fast bins</code>中已有空闲chunk。然后根据当前free的chunk大小获取所属的<code>fast bin</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="cm">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span>    <span class="n">mchunkptr</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">fb</span><span class="p">,</span> <span class="n">old2</span><span class="p">;</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_idx</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0u</span><span class="p">;</span>    <span class="k">do</span>      <span class="p">{</span>	<span class="cm">/* Check that the top of the bin is not the record we are going to add	   (i.e., double free).  */</span>	<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>	  <span class="p">{</span>	    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;double free or corruption (fasttop)&#34;</span><span class="p">;</span>	    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>	  <span class="p">}</span>	<span class="cm">/* Check that size of fastbin chunk at the top is the same as	   size of the chunk that we are adding.  We can dereference OLD	   only if we have the lock, otherwise it might have already been	   deallocated.  See use of OLD_IDX below for the actual check.  */</span>	<span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>	  <span class="n">old_idx</span> <span class="o">=</span> <span class="n">fastbin_index</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">old</span><span class="p">));</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">old2</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>      <span class="p">}</span>    <span class="k">while</span> <span class="p">((</span><span class="n">old</span> <span class="o">=</span> <span class="n">catomic_compare_and_exchange_val_rel</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">old2</span><span class="p">))</span> <span class="o">!=</span> <span class="n">old2</span><span class="p">);</span>    <span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">old_idx</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>      <span class="p">{</span>	<span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;invalid fastbin entry (free)&#34;</span><span class="p">;</span>	<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>      <span class="p">}</span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里检查了当前释放的chunk和之前释放的<code>fastbin chunk</code>是否相同，相同则触发了<code>double free</code>，校验表头不为NULL情况下，保证表头chunk的所属的<code>fast bin</code>与当前free的chunk所属的<code>fast bin</code>相同。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="cm">/*    Consolidate other non-mmapped chunks as they arrive.  */</span>  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk_is_mmapped</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>      <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>      <span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="p">}</span>    <span class="n">nextchunk</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前free的chunk不是通过<code>mmap()</code>分配的，并且当前还没有获得分配区的锁，获取分配区的锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="cm">/* Lightweight tests: check whether the block is already the       top block.  */</span>    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">))</span>      <span class="p">{</span>	<span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;double free or corruption (top)&#34;</span><span class="p">;</span>	<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>      <span class="p">}</span>    <span class="cm">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span>    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">contiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span>			  <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nextchunk</span>			  <span class="o">&gt;=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)),</span> <span class="mi">0</span><span class="p">))</span>      <span class="p">{</span>	<span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;double free or corruption (out)&#34;</span><span class="p">;</span>	<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>      <span class="p">}</span>    <span class="cm">/* Or whether the block is actually not marked used.  */</span>    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">)))</span>      <span class="p">{</span>	<span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;double free or corruption (!prev)&#34;</span><span class="p">;</span>	<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>      <span class="p">}</span>    <span class="n">nextsize</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">);</span>    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">nextchunk</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>	<span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">nextsize</span> <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>      <span class="p">{</span>	<span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): invalid next size (normal)&#34;</span><span class="p">;</span>	<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>      <span class="p">}</span>    <span class="n">free_perturb</span> <span class="p">(</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>一系列的安全检查，当前free的chunk不能为<code>top chunk</code>，因为<code>top chunk</code>为空闲chunk，如果再次free就可能为<code>double free</code>错误了。
如果当前free的chunk是通过<code>sbrk()</code>分配的，并且下一个相邻的chunk的地址已经超过了top chunk的结束地址，超过了当前分配区的结束地址，报错。
如果当前free的chunk的下一个相邻chunk的size中标志位没有标识当前<code>free chunk</code>为inuse状态，可能为<code>double free</code>错误。
计算当前free的chunk的下一个相邻chunk的大小，该大小如果小于等于2*<code>SIZE_SZ</code>或是大于了分配区所分配区的内存总量，报错。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="cm">/* consolidate backward */</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>      <span class="n">prevsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_size</span><span class="p">;</span>      <span class="n">size</span> <span class="o">+=</span> <span class="n">prevsize</span><span class="p">;</span>      <span class="n">p</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">prevsize</span><span class="p">));</span>      <span class="n">unlink</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>    <span class="p">}</span>    <span class="k">if</span> <span class="p">(</span><span class="n">nextchunk</span> <span class="o">!=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span>      <span class="cm">/* get and clear inuse bit */</span>      <span class="n">nextinuse</span> <span class="o">=</span> <span class="n">inuse_bit_at_offset</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="n">nextsize</span><span class="p">);</span>      <span class="cm">/* consolidate forward */</span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextinuse</span><span class="p">)</span> <span class="p">{</span>	<span class="n">unlink</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>	<span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>      <span class="p">}</span> <span class="k">else</span>	<span class="n">clear_inuse_bit_at_offset</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>前向合并与后向合并</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="cm">/*	Place the chunk in unsorted chunk list. Chunks are	not placed into regular bins until after they have	been given one chance to be used in malloc.      */</span>      <span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>      <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>      <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">))</span>	<span class="p">{</span>	  <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): corrupted unsorted chunks&#34;</span><span class="p">;</span>	  <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>	<span class="p">}</span>      <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>      <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>	<span class="p">{</span>	  <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	  <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="p">}</span>      <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>      <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>      <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>      <span class="n">set_foot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>      <span class="n">check_free_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>合并后的chunk加入到<code>unsorted bin</code>的双向链表中。如果合并后的chunk属于<code>large bins</code>，将chunk的<code>fd_nextsize</code>和<code>bk_nextsize</code>设置为NULL，因为在<code>unsorted bin</code>中这两个字段无用。
设置合并后的空闲chunk大小，并标识前一个chunk处于inuse状态，因为必须保证不能有两个相邻的chunk都处于空闲状态。然后将合并后的chunk加入<code>unsorted bin</code>的双向循环链表中。最后设置合并后的空闲chunk的foot，chunk空闲时必须设置foot，该foot处于下一个chunk的<code>prev_size</code>中，只有chunk空闲是foot才是有效的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="cm">/*      If the chunk borders the current high end of memory,      consolidate into top    */</span>    <span class="k">else</span> <span class="p">{</span>      <span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>      <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>      <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>      <span class="n">check_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前chunk与<code>top chunk</code>相邻则要将其合并入<code>top chunk</code>，并修改<code>top chunk</code>的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="cm">/*      If freeing a large space, consolidate possibly-surrounding      chunks. Then, if the total unused topmost memory exceeds trim      threshold, ask malloc_trim to reduce top.      Unless max_fast is 0, we don&#39;t know if there are fastbins      bordering top, so we cannot tell for sure whether threshold      has been reached unless fastbins are consolidated.  But we      don&#39;t want to consolidate on each free.  As a compromise,      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD      is reached.    */</span>    <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">FASTBIN_CONSOLIDATION_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>      <span class="k">if</span> <span class="p">(</span><span class="n">have_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">))</span>	<span class="n">malloc_consolidate</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>如果合并后的chunk大小大于64KB，并且<code>fast bins</code>中存在空闲chunk，调用<code>malloc_consolidate()</code>函数合并<code>fast bins</code>中的空闲chunk到<code>unsorted bin</code>中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">      <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="p">{</span><span class="err">#</span><span class="n">ifndef</span> <span class="n">MORECORE_CANNOT_TRIM</span>	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">))</span> <span class="o">&gt;=</span>	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span><span class="p">))</span>	  <span class="n">systrim</span><span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前分配区为主分配区，并且<code>top chunk</code>的大小大于heap的收缩阈值，调用<code>systrim()</code>函数首先heap。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#endif      } else {	</span><span class="cm">/* Always try heap_trim(), even if the top chunk is not	   large, because the corresponding heap might go away.  */</span><span class="cp">	heap_info *heap = heap_for_ptr(top(av));	assert(heap-&gt;ar_ptr == av);	heap_trim(heap, mp_.top_pad);      }    }
</span></code></pre></td></tr></table>
</div>
</div><p>如果为非主分配区，调用<code>heap_trim()</code>函数收缩非主分配区的<code>sub_heap</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>      <span class="n">assert</span> <span class="p">(</span><span class="n">locked</span><span class="p">);</span>      <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>    <span class="p">}</span>  <span class="p">}</span>  <span class="cm">/*    If the chunk was allocated via mmap, release via munmap().  */</span>  <span class="k">else</span> <span class="p">{</span>    <span class="n">munmap_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="p">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果当前free的chunk是通过<code>mmap()</code>分配的，调用<code>munma_chunk()</code>释放内存。</p>
<h2 id="end">End</h2>
<p>到这里，malloc的只要框架与逻辑就分析完了。在很多难懂得地方都参考了《ptmalloc源码分析》，推荐读一下。不过想要深入的理解堆的话，还是要自己动手实现一个内存分配器。这样才能知道哪一部分是要干什么的，也能更好的理解源码。这次仅仅是glibc-2.20，在新的glibc中有了新的机制，这部分在之后进行补充分析。</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-03-07</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/pwn/">Pwn</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/csapp-malloclab/" class="prev" rel="prev" title="CSAPP Malloclab"><i class="fas fa-angle-left fa-fw"></i>CSAPP Malloclab</a>
            <a href="/posts/challenges-100-week-7/" class="next" rel="next" title="Challenges 100 Week 7">Challenges 100 Week 7<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.87.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Niebelungen</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":100},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
