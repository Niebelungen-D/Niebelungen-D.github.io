<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">UCore Lab 1 - Niebelungen</title><meta name="Description" content="Niebelungen"><meta property="og:title" content="UCore Lab 1" />
<meta property="og:description" content="
    启动" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/ucore-lab-1/" /><meta property="og:image" content="http://example.org/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-10T01:21:18+08:00" />
<meta property="article:modified_time" content="2021-07-10T01:21:18+08:00" /><meta property="og:site_name" content="Niebelungen" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/logo.png"/>

<meta name="twitter:title" content="UCore Lab 1"/>
<meta name="twitter:description" content="
    启动"/>
<meta name="application-name" content="Niebelungen">
<meta name="apple-mobile-web-app-title" content="Niebelungen">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/favicon.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="http://example.org/ucore-lab-1/" /><link rel="prev" href="http://example.org/ucore-lab-0/" /><link rel="next" href="http://example.org/ucore-lab-2/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "UCore Lab 1",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/ucore-lab-1\/"
        },"genre": "posts","keywords": "Pwn","wordcount":  16653 ,
        "url": "http:\/\/example.org\/ucore-lab-1\/","datePublished": "2021-07-10T01:21:18+08:00","dateModified": "2021-07-10T01:21:18+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Niebelungen"
            },"description": ""
    }
    </script></head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme);}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('dark' === 'light' || 'dark' === 'dark' || 'dark' === 'black') setTheme('dark'), saveTheme('dark'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Niebelungen">Niebelungen</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/"> Home </a><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-select" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                    <select class="color-theme-select" id="theme-select-desktop" title="切换主题">
                        <option value="light">浅色</option>
                        <option value="dark">深色</option>
                        <option value="black">黑色</option>
                        <option value="auto">跟随系统</option>
                    </select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Niebelungen">Niebelungen</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/" title="">Home</a><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a href="#" onclick="return false;" class="menu-item theme-select" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
                <select class="color-theme-select" id="theme-select-mobile" title="切换主题">
                    <option value="light">浅色</option>
                    <option value="dark">深色</option>
                    <option value="black">黑色</option>
                    <option value="auto">跟随系统</option>
                </select>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#bios">BIOS</a></li>
    <li><a href="#mbr主引导记录">MBR（主引导记录）</a></li>
    <li><a href="#加载程序bootloader">加载程序（bootloader）</a></li>
    <li><a href="#保护模式的开启">保护模式的开启</a>
      <ul>
        <li><a href="#建立段映射">建立段映射</a>
          <ul>
            <li>
              <ul>
                <li><a href="#段描述符">段描述符</a></li>
              </ul>
            </li>
            <li><a href="#段选择子">段选择子</a></li>
            <li><a href="#全局描述符表gdt">全局描述符表（GDT）</a></li>
          </ul>
        </li>
        <li><a href="#保护模式使能">保护模式使能</a></li>
      </ul>
    </li>
    <li><a href="#加载elf格式的ucore-kernel">加载ELF格式的uCore kernel</a>
      <ul>
        <li>
          <ul>
            <li><a href="#elf文件格式概述">ELF文件格式概述</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#中断">中断</a>
      <ul>
        <li><a href="#bios中断dos中断linux中断的区别">BIOS中断、DOS中断、Linux中断的区别</a></li>
        <li><a href="#中断描述符表">中断描述符表</a></li>
        <li><a href="#idt-gate-descriptors">IDT gate descriptors</a></li>
        <li><a href="#中断的处理流程">中断的处理流程</a></li>
        <li><a href="#不同特权级的中断切换对堆栈的影响">不同特权级的中断切换对堆栈的影响</a>
          <ul>
            <li><a href="#内核态中断">内核态中断</a></li>
            <li><a href="#用户态中断">用户态中断</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#异常">异常</a></li>
    <li><a href="#系统调用">系统调用</a>
      <ul>
        <li><a href="#实现">实现</a></li>
        <li><a href="#系统调用与函数调用">系统调用与函数调用</a></li>
        <li><a href="#系统调用开销">系统调用开销：</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#tss简介">TSS简介</a></li>
    <li><a href="#dplrplcpliopl">DPL、RPL、CPL、IOPL</a></li>
    <li><a href="#trapframe">trapFrame</a></li>
    <li><a href="#中断处理例程的入口代码">中断处理例程的入口代码</a></li>
    <li><a href="#切换特权级的过程">切换特权级的过程</a>
      <ul>
        <li><a href="#特权级提升">特权级提升</a></li>
        <li><a href="#特权级降低">特权级降低</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#syntax">Syntax</a></li>
    <li><a href="#example-1">Example 1</a></li>
    <li><a href="#example-2">Example 2</a></li>
    <li><a href="#example-3">Example 3</a></li>
  </ul>

  <ul>
    <li><a href="#练习1">练习1</a>
      <ul>
        <li><a href="#dd命令">dd命令</a></li>
        <li><a href="#ucoreimg">ucore.img</a></li>
        <li><a href="#bootblock">bootblock</a></li>
        <li><a href="#sign">sign</a></li>
        <li><a href="#kernel">kernel</a></li>
      </ul>
    </li>
    <li><a href="#练习2">练习2</a></li>
    <li><a href="#练习3">练习3</a>
      <ul>
        <li><a href="#有关a20">有关A20？</a></li>
        <li><a href="#如何初始化gdt表">如何初始化GDT表？</a></li>
      </ul>
    </li>
    <li><a href="#练习4">练习4</a>
      <ul>
        <li>
          <ul>
            <li><a href="#分析bootloader加载elf格式的os的过程">分析bootloader加载ELF格式的OS的过程</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#练习5">练习5</a></li>
    <li><a href="#练习6">练习6</a></li>
    <li><a href="#challenge-1">Challenge 1</a></li>
    <li><a href="#challenge-2">Challenge 2</a></li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">UCore Lab 1</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">Niebelungen</a>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/pwning/"><i class="far fa-folder fa-fw"></i>Pwning</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-07-10">2021-07-10</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2021-07-10">2021-07-10</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 16653 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 34 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#bios">BIOS</a></li>
    <li><a href="#mbr主引导记录">MBR（主引导记录）</a></li>
    <li><a href="#加载程序bootloader">加载程序（bootloader）</a></li>
    <li><a href="#保护模式的开启">保护模式的开启</a>
      <ul>
        <li><a href="#建立段映射">建立段映射</a>
          <ul>
            <li>
              <ul>
                <li><a href="#段描述符">段描述符</a></li>
              </ul>
            </li>
            <li><a href="#段选择子">段选择子</a></li>
            <li><a href="#全局描述符表gdt">全局描述符表（GDT）</a></li>
          </ul>
        </li>
        <li><a href="#保护模式使能">保护模式使能</a></li>
      </ul>
    </li>
    <li><a href="#加载elf格式的ucore-kernel">加载ELF格式的uCore kernel</a>
      <ul>
        <li>
          <ul>
            <li><a href="#elf文件格式概述">ELF文件格式概述</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#中断">中断</a>
      <ul>
        <li><a href="#bios中断dos中断linux中断的区别">BIOS中断、DOS中断、Linux中断的区别</a></li>
        <li><a href="#中断描述符表">中断描述符表</a></li>
        <li><a href="#idt-gate-descriptors">IDT gate descriptors</a></li>
        <li><a href="#中断的处理流程">中断的处理流程</a></li>
        <li><a href="#不同特权级的中断切换对堆栈的影响">不同特权级的中断切换对堆栈的影响</a>
          <ul>
            <li><a href="#内核态中断">内核态中断</a></li>
            <li><a href="#用户态中断">用户态中断</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#异常">异常</a></li>
    <li><a href="#系统调用">系统调用</a>
      <ul>
        <li><a href="#实现">实现</a></li>
        <li><a href="#系统调用与函数调用">系统调用与函数调用</a></li>
        <li><a href="#系统调用开销">系统调用开销：</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#tss简介">TSS简介</a></li>
    <li><a href="#dplrplcpliopl">DPL、RPL、CPL、IOPL</a></li>
    <li><a href="#trapframe">trapFrame</a></li>
    <li><a href="#中断处理例程的入口代码">中断处理例程的入口代码</a></li>
    <li><a href="#切换特权级的过程">切换特权级的过程</a>
      <ul>
        <li><a href="#特权级提升">特权级提升</a></li>
        <li><a href="#特权级降低">特权级降低</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#syntax">Syntax</a></li>
    <li><a href="#example-1">Example 1</a></li>
    <li><a href="#example-2">Example 2</a></li>
    <li><a href="#example-3">Example 3</a></li>
  </ul>

  <ul>
    <li><a href="#练习1">练习1</a>
      <ul>
        <li><a href="#dd命令">dd命令</a></li>
        <li><a href="#ucoreimg">ucore.img</a></li>
        <li><a href="#bootblock">bootblock</a></li>
        <li><a href="#sign">sign</a></li>
        <li><a href="#kernel">kernel</a></li>
      </ul>
    </li>
    <li><a href="#练习2">练习2</a></li>
    <li><a href="#练习3">练习3</a>
      <ul>
        <li><a href="#有关a20">有关A20？</a></li>
        <li><a href="#如何初始化gdt表">如何初始化GDT表？</a></li>
      </ul>
    </li>
    <li><a href="#练习4">练习4</a>
      <ul>
        <li>
          <ul>
            <li><a href="#分析bootloader加载elf格式的os的过程">分析bootloader加载ELF格式的OS的过程</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#练习5">练习5</a></li>
    <li><a href="#练习6">练习6</a></li>
    <li><a href="#challenge-1">Challenge 1</a></li>
    <li><a href="#challenge-2">Challenge 2</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="启动" class="headerLink">
    <a href="#%e5%90%af%e5%8a%a8" class="header-mark"></a>启动</h1><p><img
        class="lazyload"
        data-src="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606141617.png"
        data-srcset="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606141617.png, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606141617.png 1.5x, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606141617.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606141617.png"
        title="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606141617.png"></p>
<p>在CPU加电后，寄存器CS:IP被强制初始化为<code>0xf000:0xfff0</code>，此时CPU处于实模式，有20位地址线可用，可以访问1MB的地址空间，<code>PC = 16*CS + IP</code>。这时的地址也是真实的物理地址。</p>
<p>各个段寄存器和IP都是16位的。</p>
<h2 id="bios" class="headerLink">
    <a href="#bios" class="header-mark"></a>BIOS</h2><p>在这个位置是一个<code>jmp far f000：e05b</code>指令，它会让CPU跳转到BIOS程序的位置。接下来，BIOS就开始运行</p>
<p>BIOS实际上是被固化在计算机ROM（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，BIOS就是PC计算机硬件与上层软件程序之间的一个&quot;桥梁&quot;，负责访问和控制硬件。它做了这些工作</p>
<ul>
<li>硬件自检POST
<ul>
<li>检测系统中内存和显卡等关键部件的存在和工作状态</li>
<li>查找并执行显卡等接口卡BIOS，进行设备初始化</li>
</ul>
</li>
<li>执行系统BIOS，进行系统检测
<ul>
<li>检测和配置系统中安装的即插即用设备</li>
<li>检测并初始化外设、在<code>0x000-0x3ff</code>建立数据结构，中断向量表IVT并填写中断例程。</li>
</ul>
</li>
<li>更新CMOS中的扩展系统配置数据ESCD</li>
<li>按照指定启动顺序从软盘、硬盘和光驱启动</li>
<li>加载第一个扇区，MBR，将其512字节加载到内存中</li>
<li>跳转到0x7c00的第一条指令开始执行</li>
</ul>
<h2 id="mbr主引导记录" class="headerLink">
    <a href="#mbr%e4%b8%bb%e5%bc%95%e5%af%bc%e8%ae%b0%e5%bd%95" class="header-mark"></a>MBR（主引导记录）</h2><p>MBR（主引导记录），它固定在0盘0道1扇区。BIOS结束后，没有直接将CPU的控制权给操作系统，而是给了MBR。MBR知道操作系统被加载到了哪个分区，也会有多个操作系统需要你去选择加载哪一个。
MBR共512字节（一个扇区大小）包含</p>
<ul>
<li>启动代码：446字节
<ul>
<li>检查分许表的正确性</li>
<li>加载并跳转到磁盘上的引导程序bootloder</li>
<li>当安装了多个操作系统时，需要选择加载哪个系统，MBR会跳转到对应的分区执行bootloader</li>
</ul>
</li>
<li>硬盘分区表：64字节
<ul>
<li>描述分区状态和位置</li>
<li>每个分区描述信息占据16字节</li>
</ul>
</li>
<li>结束标志(魔数)：0xaa55
<ul>
<li>主引导记录的有效标志</li>
</ul>
</li>
</ul>
<h2 id="加载程序bootloader" class="headerLink">
    <a href="#%e5%8a%a0%e8%bd%bd%e7%a8%8b%e5%ba%8fbootloader" class="header-mark"></a>加载程序（bootloader）</h2><ul>
<li>切换到保护模式，启用分段机制</li>
<li>从文件系统中读取启动配置信息（与操作系统有关）
<ul>
<li>各分区都有超级块，一般位于本分区的第2个扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，通过比较即可得知文件系统类型。</li>
<li>对于uCore来说就是ELF格式</li>
</ul>
</li>
<li>启动并显示菜单，可选系统内核列表和参数</li>
<li>依据选择的配置加载内核</li>
</ul>
<p>之后，CPU就交给操作系统内核了。下面我们进一步看看bootloader的过程</p>
<h2 id="保护模式的开启" class="headerLink">
    <a href="#%e4%bf%9d%e6%8a%a4%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%bc%80%e5%90%af" class="header-mark"></a>保护模式的开启</h2><p>在进入保护模式前，要建立各段的映射关系，从而开启段机制。有关其内存管理的细节在lab2中。</p>
<h3 id="建立段映射" class="headerLink">
    <a href="#%e5%bb%ba%e7%ab%8b%e6%ae%b5%e6%98%a0%e5%b0%84" class="header-mark"></a>建立段映射</h3><p>各段寄存器指向了不同段的基址，而在每个段的开始有段描述符。</p>
<h5 id="段描述符" class="headerLink">
    <a href="#%e6%ae%b5%e6%8f%8f%e8%bf%b0%e7%ac%a6" class="header-mark"></a>段描述符</h5><ul>
<li>在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址(Base Address)、段界限(Limit)和段属性(Attributes)
<ul>
<li>段基地址：规定线性地址空间中段的起始地址。任何一个段都可以从32位线性地址空间中的任何一个字节开始，不用像实模式下规定边界必须被16整除。</li>
<li>段界限：规定段的大小。可以以字节为单位或以4K字节为单位。</li>
<li>段属性：确定段的各种性质。
<ul>
<li>段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。</li>
<li>类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。其4bit从左到右分别是
<ul>
<li>执行位：置1时表示可执行，置0时表示不可执行；</li>
<li>一致位：置1时表示一致码段，置0时表示非一致码段；</li>
<li>读写位：置1时表示可读可写，置0时表示只读；</li>
<li>访问位：置1时表示已访问，置0时表示未访问。</li>
</ul>
</li>
<li>描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。</li>
<li>段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。</li>
<li>已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="段选择子" class="headerLink">
    <a href="#%e6%ae%b5%e9%80%89%e6%8b%a9%e5%ad%90" class="header-mark"></a>段选择子</h4><p>在一个段寄存器中，会保存一块区域叫段选择子。</p>
<ul>
<li>线性地址部分的选择子是用来选择哪个描述符表和在该表中索引哪个描述符的。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由连接加载器来设置的。</li>
<li>段选择子结构
<ul>
<li>索引（Index）：高13位，在描述符表中从8192个描述符中选择一个描述符。处理器自动将这个索引值乘以8（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。</li>
<li>表指示位（Table Indicator，TI）：1位，选择应该访问哪一个描述符表。0代表应该访问全局描述符表（GDT），1代表应该访问局部描述符表（LDT）。</li>
<li>请求特权级（Requested Privilege Level，RPL）：低两位，保护机制。</li>
</ul>
</li>
</ul>
<p>由段选择子得到的段描述符，再得到段的基址，最后加上偏移就得到了一个线性地址。在未开启分页机制时，线性地址即为物理地址。</p>
<h4 id="全局描述符表gdt" class="headerLink">
    <a href="#%e5%85%a8%e5%b1%80%e6%8f%8f%e8%bf%b0%e7%ac%a6%e8%a1%a8gdt" class="header-mark"></a>全局描述符表（GDT）</h4><p>我们需要一个大数组来管理那么多的段，这个数组我们称为全局描述符表（GDT），它保存了各段的段描述符，简称段表。</p>
<p>全局描述符表的起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。</p>
<h3 id="保护模式使能" class="headerLink">
    <a href="#%e4%bf%9d%e6%8a%a4%e6%a8%a1%e5%bc%8f%e4%bd%bf%e8%83%bd" class="header-mark"></a>保护模式使能</h3><p>建立映射后，使能保护模式。通过一个特定的寄存器，<strong>系统性寄存器CRT</strong>，将其bit 0置1，则代表CPU进入保护模式。段机制，是在保护模式下自动使能的。</p>
<h2 id="加载elf格式的ucore-kernel" class="headerLink">
    <a href="#%e5%8a%a0%e8%bd%bdelf%e6%a0%bc%e5%bc%8f%e7%9a%84ucore-kernel" class="header-mark"></a>加载ELF格式的uCore kernel</h2><p>这里不是文件系统，因为我们还没有为kernel进行编写。</p>
<h4 id="elf文件格式概述" class="headerLink">
    <a href="#elf%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f%e6%a6%82%e8%bf%b0" class="header-mark"></a>ELF文件格式概述</h4><p>ELF(Executable and linking format)文件格式是Linux系统下的一种常用目标文件(object file)格式，有三种主要类型:</p>
<ul>
<li>用于执行的可执行文件(executable file)，用于提供程序的进程映像，加载的内存执行。 这也是本实验的OS文件类型。</li>
<li>用于连接的可重定位文件(relocatable file)，可与其它目标文件一起创建可执行文件和共享目标文件。</li>
<li>共享目标文件(shared object file)，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。</li>
</ul>
<p>这里只分析与本实验相关的ELF可执行文件类型。ELF header在文件开始处描述了整个文件的组织。ELF的文件头包含整个执行文件的控制结构，其定义在elf.h中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">elfhdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">magic</span><span class="p">;</span>  			<span class="c1">// must equal ELF_MAGIC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uchar</span> <span class="n">elf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">ushort</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ushort</span> <span class="n">machine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">entry</span><span class="p">;</span>  			<span class="c1">// 程序入口的虚拟地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint</span> <span class="n">phoff</span><span class="p">;</span>  			<span class="c1">// program header 表的位置偏移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint</span> <span class="n">shoff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ushort</span> <span class="n">ehsize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ushort</span> <span class="n">phentsize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ushort</span> <span class="n">phnum</span><span class="p">;</span> 		<span class="c1">//program header表中的入口数目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ushort</span> <span class="n">shentsize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ushort</span> <span class="n">shnum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ushort</span> <span class="n">shstrndx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>program header</code>描述与程序执行直接相关的目标文件结构信息，用来在文件中定位各个段的映像，同时包含其他一些用来为程序创建进程映像所必需的信息。</p>
<p>可执行文件的程序头部是一个<code>program header</code>结构的数组， 每个结构描述了一个段或者系统准备程序执行所必需的其它信息。目标文件的 “段” 包含一个或者多个 “节区”（section） ，也就是“段内容（Segment Contents）” 。程序头部仅对于可执行文件和共享目标文件有意义。可执行目标文件在ELF头部的<code>e_phentsize</code>和<code>e_phnum</code>成员中给出其自身程序头部的大小。程序头部的数据结构如下表所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">proghdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">type</span><span class="p">;</span>   			<span class="c1">// 段类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint</span> <span class="n">offset</span><span class="p">;</span>  		<span class="c1">// 段相对文件头的偏移值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint</span> <span class="n">va</span><span class="p">;</span>     			<span class="c1">// 段的第一个字节将被放到内存中的虚拟地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint</span> <span class="n">pa</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">filesz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">memsz</span><span class="p">;</span>  			<span class="c1">// 段在内存映像中占用的字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">uint</span> <span class="n">align</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据<code>elfhdr</code>和<code>proghdr</code>的结构描述，bootloader就可以完成对ELF格式的ucore操作系统的加载过程（参见boot/bootmain.c中的bootmain函数）。</p>
<h1 id="中断异常和系统调用" class="headerLink">
    <a href="#%e4%b8%ad%e6%96%ad%e5%bc%82%e5%b8%b8%e5%92%8c%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" class="header-mark"></a>中断、异常和系统调用</h1><p><strong>为什么需要中断、异常和系统调用？</strong></p>
<ul>
<li>在计算机运行中，内核是被信任的第三方</li>
<li>只有内核可以执行特权指令</li>
<li>方便应用程序</li>
</ul>
<p>中断和异常希望解决，外设连接计算机时的加载问题和应对程序的意外行为。如，当计算机希望你按回车键时，按下键盘的时间是不确定的，计算机不能永远等待。
系统调用希望解决用户使用内核服务时，不会对内核造成威胁的问题。</p>
<p><img
        class="lazyload"
        data-src="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606140816.png"
        data-srcset="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606140816.png, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606140816.png 1.5x, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606140816.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210606140816.png"
        title="image-20210606140809300"></p>
<h2 id="中断" class="headerLink">
    <a href="#%e4%b8%ad%e6%96%ad" class="header-mark"></a>中断</h2><h3 id="bios中断dos中断linux中断的区别" class="headerLink">
    <a href="#bios%e4%b8%ad%e6%96%addos%e4%b8%ad%e6%96%adlinux%e4%b8%ad%e6%96%ad%e7%9a%84%e5%8c%ba%e5%88%ab" class="header-mark"></a>BIOS中断、DOS中断、Linux中断的区别</h3><ul>
<li>BIOS和DOS都存在于实模式下，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的，都是通过软中断指令 int 中断号来调用。</li>
<li>BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。</li>
<li>DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和BIOS的不能冲突。</li>
<li>Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）。Linux 的系统调用和DOS中断调用类似，不过Linux是通过<code>int 0x80</code>指令进入一个中断程序后再根据eax寄存器的值来调用不同的子功能函数的。</li>
</ul>
<h3 id="中断描述符表" class="headerLink">
    <a href="#%e4%b8%ad%e6%96%ad%e6%8f%8f%e8%bf%b0%e7%ac%a6%e8%a1%a8" class="header-mark"></a>中断描述符表</h3><ul>
<li>中断描述符表（Interrupt Descriptor Table, IDT）把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。</li>
<li>IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。</li>
</ul>
<h3 id="idt-gate-descriptors" class="headerLink">
    <a href="#idt-gate-descriptors" class="header-mark"></a>IDT gate descriptors</h3><ul>
<li>
<p>中断/异常应该使用<code>Interrupt Gate</code>或<code>Trap Gate</code>。其中的唯一区别就是：当调用<code>Interrupt Gate</code>时，Interrupt会被CPU自动禁止；而调用<code>Trap Gate</code>时，CPU则不会去禁止或打开中断，而是保留原样。</p>
<blockquote>
<p>这其中的原理是当CPU跳转至<code>Interrupt Gate</code>时，其eflag上的IF位会被清除。而<code>Trap Gate</code>则不改变。</p>
</blockquote>
</li>
<li>
<p>IDT中包含了3种类型的Descriptor</p>
<ul>
<li>Task-gate descriptor</li>
<li>Interrupt-gate descriptor （中断方式用到）</li>
<li>Trap-gate descriptor（系统调用用到）</li>
</ul>
</li>
</ul>
<h3 id="中断的处理流程" class="headerLink">
    <a href="#%e4%b8%ad%e6%96%ad%e7%9a%84%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b" class="header-mark"></a>中断的处理流程</h3><ul>
<li>产生中断后，会通过其中断号，查找其ISR在IDT的哪一项。</li>
<li>找到响应的<code>Interrupt Gate</code>或<code>Trap Gate</code>，取出段选择子</li>
<li>根据段选择子查找GDT，得到基地址</li>
<li>基地址+偏移得到中断服务例程的地址。</li>
</ul>
<h3 id="不同特权级的中断切换对堆栈的影响" class="headerLink">
    <a href="#%e4%b8%8d%e5%90%8c%e7%89%b9%e6%9d%83%e7%ba%a7%e7%9a%84%e4%b8%ad%e6%96%ad%e5%88%87%e6%8d%a2%e5%af%b9%e5%a0%86%e6%a0%88%e7%9a%84%e5%bd%b1%e5%93%8d" class="header-mark"></a>不同特权级的中断切换对堆栈的影响</h3><p>堆栈的不同特权级记录在段描述符中。如果低两位为0，则运行为内核态，若为3，则运行在用户态。</p>
<p>在用户态产生的中断会进入内核态进行处理，而在内核态产生的中断还是在内核态。这是两种不同的处理方式，因为其中产生了特权级的变化。</p>
<h4 id="内核态中断" class="headerLink">
    <a href="#%e5%86%85%e6%a0%b8%e6%80%81%e4%b8%ad%e6%96%ad" class="header-mark"></a>内核态中断</h4><ul>
<li>
<p>栈没有变换</p>
</li>
<li>
<p>如果产生的是异常，压入Error code</p>
</li>
<li>
<p>压入cs和eip，即压入pc值</p>
</li>
<li>
<p>压入标志寄存器的值</p>
</li>
<li>
<p>通过<code>iret</code>返回，会弹出<code>EFLAGS</code>和SS/EIP（根据是否改变特权级）</p>
</li>
</ul>
<h4 id="用户态中断" class="headerLink">
    <a href="#%e7%94%a8%e6%88%b7%e6%80%81%e4%b8%ad%e6%96%ad" class="header-mark"></a>用户态中断</h4><ul>
<li>
<p>切换到内核堆栈</p>
</li>
<li>
<p>在内核中断的基础上额外压入用户栈的ss和esp，保存用户态的栈信息</p>
</li>
<li>
<p>通过<code>ret</code>或<code>retf</code>返回，仅弹出EIP，<code>retf</code>弹出CS和EIP</p>
</li>
</ul>
<h2 id="异常" class="headerLink">
    <a href="#%e5%bc%82%e5%b8%b8" class="header-mark"></a>异常</h2><p>一般源于程序的错误执行，或非法访问。</p>
<p>异常处理的例程也多数只会中止程序的执行。</p>
<h2 id="系统调用" class="headerLink">
    <a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" class="header-mark"></a>系统调用</h2><p>系统调用也是特殊的中断，通过<code>Trap Gate</code>进入，所以通过系统调用进入内核态也称为陷入内核。</p>
<p><strong>一个例子</strong>：在调用<code>printf</code>时，会触发系统调用<code>write</code>。</p>
<ul>
<li>操作系统的服务的编程接口</li>
<li>通常由高级语言编写（C/C++）</li>
<li>通常通过更高层次的API封装而不是直接调用</li>
</ul>
<h3 id="实现" class="headerLink">
    <a href="#%e5%ae%9e%e7%8e%b0" class="header-mark"></a>实现</h3><ul>
<li>每个系统调用对应一个系统调用号
<ul>
<li>系统调用接口根据系统调用号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果</li>
<li>用户不需要知道，系统调用的实现，只需设置参数获取返回结果。</li>
</ul>
<h3 id="系统调用与函数调用" class="headerLink">
    <a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e4%b8%8e%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8" class="header-mark"></a>系统调用与函数调用</h3><ul>
<li>系统调用：使用<code>int</code>和<code>iret</code>，有堆栈切换和特权级的切换（内核堆栈和用户堆栈不同）</li>
<li>函数调用：使用<code>call</code>和<code>ret</code>，没有堆栈和特权级的切换</li>
</ul>
<h3 id="系统调用开销" class="headerLink">
    <a href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%bc%80%e9%94%80" class="header-mark"></a>系统调用开销：</h3><ul>
<li>超过函数调用</li>
<li>引导机制，用户到内核</li>
<li>建立内核堆栈</li>
<li>验证参数</li>
<li>内核态映射到用户态的地址空间，更新页面映射权限</li>
<li>内核独立地址空间，TLB变化</li>
</ul>
<h1 id="特权级" class="headerLink">
    <a href="#%e7%89%b9%e6%9d%83%e7%ba%a7" class="header-mark"></a>特权级</h1><p>特权级共分为四档，分别为0-3，其中<code>Kernel</code>为第0特权级（ring 0），用户程序为第3特权级（ring 3），系统程序分别为第1和第2特权级。</p>
<p>特权级的区别</p>
<ul>
<li>一些指令（例如特权指令<code>lgdt</code>）只能运行在ring 0下。</li>
<li>CPU在如下时刻会检查特权级
<ul>
<li>访问数据段</li>
<li>访问页</li>
<li>进入中断服务例程（ISRs）</li>
<li>…</li>
</ul>
</li>
<li>如果检查失败，则会产生<strong>保护异常（General Protection Fault）</strong></li>
</ul>
<h2 id="tss简介" class="headerLink">
    <a href="#tss%e7%ae%80%e4%bb%8b" class="header-mark"></a>TSS简介</h2><p>TSS，即 Task State Segment，意为任务状态段，TSS 是一种数据结构，它用于存储任务的环境。TSS 是每个任务都有的结构，它用于一个任务的标识，相当于任务的身份证，程序拥有此结构才能运行，这是处理器硬件上用于任务管理的系统结构，处理器能够识别其中每一个字段。</p>
<p><img
        class="lazyload"
        data-src="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210616224957.png"
        data-srcset="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210616224957.png, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210616224957.png 1.5x, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210616224957.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210616224957.png"
        title="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210616224957.png"></p>
<p>其中包含了三个栈指针，分别为ring0、ring1、ring2的特权栈。当低特权级向高特权级转换的时候，才会用到这些栈指针进行栈的切换。切换完成后，低特权级的栈指针会被保存在切换后的栈中，通过<code>retf</code>或<code>iret</code>返回。并不是每个任务都有三个栈指针，因为这些栈指针只有低特权级向高特权级转移时才会用到，所以对于本身就处在ring2的程序是没有ring2的栈指针的，其他同理。切换栈的操作从开始中断的那一瞬间就已完成。</p>
<p>TSS 是硬件支持的系统数据结构，它和GDT 等一样，由软件填写其内容，由硬件使用。GDT 也要加载到寄存器 GDTR 中才能被处理器找到，TSS也是一样，它是由 TR（Task Register）寄存器加载的，每次处理器执行不同任务时，将TR寄存器加载不同任务的TSS就成了。</p>
<p>Code:mmu.h</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* task state segment format (as described by the Pentium architecture book) */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">taskstate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ts_link</span><span class="p">;</span>        <span class="c1">// old ts selector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">uintptr_t</span> <span class="n">ts_esp0</span><span class="p">;</span>        <span class="c1">// stack pointers and segment selectors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">ts_ss0</span><span class="p">;</span>        <span class="c1">// after an increase in privilege level
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">ts_padding1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uintptr_t</span> <span class="n">ts_esp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_ss1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_padding2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uintptr_t</span> <span class="n">ts_esp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_ss2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_padding3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uintptr_t</span> <span class="n">ts_cr3</span><span class="p">;</span>        <span class="c1">// page directory base
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">uintptr_t</span> <span class="n">ts_eip</span><span class="p">;</span>        <span class="c1">// saved state from last task switch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">ts_eflags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ts_eax</span><span class="p">;</span>        <span class="c1">// more saved state (registers)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">ts_ecx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ts_edx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ts_ebx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uintptr_t</span> <span class="n">ts_esp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uintptr_t</span> <span class="n">ts_ebp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ts_esi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ts_edi</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_es</span><span class="p">;</span>            <span class="c1">// even more saved state (segment selectors)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">ts_padding4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_cs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_padding5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_ss</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_padding6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_ds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_padding7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_fs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_padding8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_gs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_padding9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_ldt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_padding10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">ts_t</span><span class="p">;</span>            <span class="c1">// trap on task switch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">ts_iomb</span><span class="p">;</span>        <span class="c1">// i/o map base address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="dplrplcpliopl" class="headerLink">
    <a href="#dplrplcpliopl" class="header-mark"></a>DPL、RPL、CPL、IOPL</h2><p>首先要明确一点，在计算机中具备“能动性”的只有计算机指令，只有指令才具备访问、请求其他资源的能力，指令便是资源的请求者。指令“请求”、“访问”其他资源的能力等级便称之为请求特 权级，指令存放在代码段中，所以，就用代码段寄存器 CS 中选择子的 RPL 位表示代码请求别人资源能力的等级。</p>
<ul>
<li>DPL，即 Descriptor Privilege Level，描述符特权级，它存在于段描述符中。标识了访问该段的门槛。</li>
<li>CPL，Current Privilege Level，它表示处理器正在执行的代码的特权级别。它与当前段的DPL是相同的。</li>
<li>RPL，请求特权级，来自发出请求的CS.RPL。</li>
<li>IOPL，该位存在于<code>eflags</code>字段中。指当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。</li>
</ul>
<p>对于受访者为数据段（段描述符中 type 字段中未有X可执行属性）来说：</p>
<p>只有访问者的权限大于等于该 DPL 表示的最低权限才能够继续访问，否则连这个门槛都迈不过去。比如，DPL 为 1 的段描述符，只有特权级为 0、1 的访问者才有资格访问它所代表的资源，特权为 2、3 的访问者会被 CPU 拒之门外。</p>
<p>对于受访者为代码段（段描述符中 type 字段中含有X可执行属性）来说：</p>
<p>只有访问者的权限等于该 DPL 表示的最低权限才能够继续访问，即只能平级访问。任何权限大于或小于它的访问者都将被 CPU 拒之门外。这是为什么呢？自问自答之前先明确一个概念，对于受访者为代码段一这说法，实际上是指处理器从当前运行的代码段上转移到受访者这个目标代码段上去执行，并不是 说把该目标代码段当数据一样访问，在真实物理机器上，代码段通常情况下是不被当成数据来处理的，但确实可以这么做（话说虚拟机中会把代码当成数据来处理）。</p>
<p>对于数据段和代码段的要求不同，在执行代码时，高特权级的程序几乎不会主动降低自己的特权级，中断的返回除外。</p>
<h2 id="trapframe" class="headerLink">
    <a href="#trapframe" class="header-mark"></a>trapFrame</h2><ul>
<li>
<p><code>trapframe</code>结构是进入中断门所必须的结构，其结构如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">COPYstruct</span> <span class="n">trapframe</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// tf_regs保存了基本寄存器的值，包括eax,ebx,esi,edi寄存器等等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">pushregs</span> <span class="n">tf_regs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_gs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_padding0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_fs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_padding1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_es</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_padding2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_ds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_padding3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">tf_trapno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 以下这些信息会被CPU硬件自动压入切换后的栈。包括下面切换特权级所使用的esp、ss等数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">tf_err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uintptr_t</span> <span class="n">tf_eip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_cs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_padding4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">tf_eflags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 以下这些信息会在切换特权级时被使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">uintptr_t</span> <span class="n">tf_esp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_ss</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">tf_padding5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="中断处理例程的入口代码" class="headerLink">
    <a href="#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e4%be%8b%e7%a8%8b%e7%9a%84%e5%85%a5%e5%8f%a3%e4%bb%a3%e7%a0%81" class="header-mark"></a>中断处理例程的入口代码</h2><ul>
<li>
<p>中断处理例程的入口代码用于保存上下文并构建一个<code>trapframe</code>，其源代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">COPY</span>  <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">memlayout</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp"># vectors.S sends all traps here.
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">.</span><span class="n">text</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="n">globl</span> <span class="n">__alltraps</span>
</span></span><span class="line"><span class="cl"><span class="nl">__alltraps</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="cp"># push registers to build a trap frame
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp"># therefore make the stack look like a struct trapframe
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">pushl</span> <span class="o">%</span><span class="n">ds</span>
</span></span><span class="line"><span class="cl">    <span class="n">pushl</span> <span class="o">%</span><span class="n">es</span>
</span></span><span class="line"><span class="cl">    <span class="n">pushl</span> <span class="o">%</span><span class="n">fs</span>
</span></span><span class="line"><span class="cl">    <span class="n">pushl</span> <span class="o">%</span><span class="n">gs</span>
</span></span><span class="line"><span class="cl">    <span class="n">pushal</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># load GD_KDATA into %ds and %es to set up data segments for kernel
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">movl</span> <span class="err">$</span><span class="n">GD_KDATA</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span></span><span class="line"><span class="cl">    <span class="n">movw</span> <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">ds</span>
</span></span><span class="line"><span class="cl">    <span class="n">movw</span> <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">es</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># push %esp to pass a pointer to the trapframe as an argument to trap()
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">pushl</span> <span class="o">%</span><span class="n">esp</span>
</span></span><span class="line"><span class="cl">    <span class="cp"># call trap(tf), where tf=%esp
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">call</span> <span class="n">trap</span>
</span></span><span class="line"><span class="cl">    <span class="cp"># pop the pushed stack pointer
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">popl</span> <span class="o">%</span><span class="n">esp</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># return falls through to trapret...
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">.</span><span class="n">globl</span> <span class="n">__trapret</span>
</span></span><span class="line"><span class="cl"><span class="nl">__trapret</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="cp"># restore registers from stack
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">popal</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># restore %ds, %es, %fs and %gs
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">popl</span> <span class="o">%</span><span class="n">gs</span>
</span></span><span class="line"><span class="cl">    <span class="n">popl</span> <span class="o">%</span><span class="n">fs</span>
</span></span><span class="line"><span class="cl">    <span class="n">popl</span> <span class="o">%</span><span class="n">es</span>
</span></span><span class="line"><span class="cl">    <span class="n">popl</span> <span class="o">%</span><span class="n">ds</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># get rid of the trap number and error code
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">addl</span> <span class="err">$</span><span class="mh">0x8</span><span class="p">,</span> <span class="o">%</span><span class="n">esp</span>
</span></span><span class="line"><span class="cl">    <span class="n">iret</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="切换特权级的过程" class="headerLink">
    <a href="#%e5%88%87%e6%8d%a2%e7%89%b9%e6%9d%83%e7%ba%a7%e7%9a%84%e8%bf%87%e7%a8%8b" class="header-mark"></a>切换特权级的过程</h2><h3 id="特权级提升" class="headerLink">
    <a href="#%e7%89%b9%e6%9d%83%e7%ba%a7%e6%8f%90%e5%8d%87" class="header-mark"></a>特权级提升</h3><p>当通过陷入门<strong>从ring3切换至ring0（特权提升）</strong> 时</p>
<ul>
<li>
<p>在陷入的一瞬间，CPU会因为特权级的改变，索引TSS，切换<code>ss</code>和<code>esp</code>为内核栈，并<strong>按顺序自动</strong>压入<code>user_ss</code>、<code>user_esp</code>、<code>user_eflags</code>、<code>user_cs</code>、<code>old_eip</code>以及<code>err</code>。</p>
<blockquote>
<p>需要注意的是，CPU先切换到内核栈，此时的<code>esp</code>与<code>ss</code>不再指向用户栈。但此时CPU却可以再将用户栈地址存入内核栈。这种操作可能是依赖硬件来完成的。</p>
</blockquote>
<blockquote>
<p>如果没有err，则CPU会自动压入0。</p>
</blockquote>
</li>
<li>
<p>之后CPU会在中断处理例程入口处，先将剩余的段寄存器以及所有的通用寄存器压栈，构成一个<code>trapframe</code>。然后将该<code>trapframe</code>传入给真正的中断处理例程并执行。</p>
</li>
<li>
<p>该处理例程会判断传入的中断数(<code>trapno</code>)并执行特定的代码。在<strong>提升特权级的代码</strong>中，程序会处理传入的<code>trapframe</code>信息中的<code>CS、DS、eflags</code>寄存器，修改上面的<strong>DPL、CPL与IOPL</strong>以达到提升特权的目的。</p>
</li>
<li>
<p>将修改后的<code>trapframe</code><strong>压入用户栈</strong>（这一步没有修改<code>user_esp</code>寄存器），并设置中断处理例程结束后将要弹出<code>esp</code>寄存器的值为<strong>用户栈的新地址</strong>（与刚刚不同，这一步修改了<strong>将要恢复</strong>的<code>user_esp</code>寄存器）。</p>
<blockquote>
<p>注意此时的用户栈地址指向的是修改后的<code>trapframe</code>。</p>
</blockquote>
<p>这样在退出中断处理程序，准备恢复上下文的时候，首先弹出的栈寄存器值是修改后的用户栈地址，其次弹出的通用寄存器、段寄存器等等都是存储于用户栈中的<code>trapframe</code>。</p>
<blockquote>
<p>为什么要做这么奇怪的操作呢？ 因为恢复<code>esp</code>寄存器的指令<strong>只有一条<code>pop %esp</code></strong></p>
<p>(当前环境下的<code>iret</code>指令不会弹出栈地址)。</p>
<p>正常情况下，中断处理例程结束，恢复<code>esp</code>寄存器后，<code>esp</code>指向的还是内核栈。</p>
<p>但我们的目的是切换回用户栈，则此时只能修改原先要恢复的<code>esp</code>值，通过该指令切换到用户栈。</p>
</blockquote>
<blockquote>
<p>思考一下，进入中断处理程序前，上下文<strong>保存在内核栈</strong>。但将要恢复回上下文的数据却<strong>存储于用户栈</strong>。</p>
</blockquote>
</li>
<li>
<p>在内核中，将修改后的``trapframe<code>压入用户栈这一步，需要舍弃</code>trapframe<code>中末尾两个旧的</code>ss<code>和</code>esp<code>寄存器数据，因为</code>iret`指令的特殊性：</p>
<ul>
<li>
<p><code>iret</code>指令的功能如下</p>
<blockquote>
<p><code>iret</code>指令会按顺序依次弹出<code>eip</code>、<code>cs</code>以及<code>eflag</code>的值到特定寄存器中，然后从新的<code>cs:ip</code>处开始执行。如果特权级发生改变，则还会在弹出<code>eflag</code>后再依次弹出<code>esp</code>与<code>ss</code>寄存器值。</p>
</blockquote>
</li>
<li>
<p>由于<code>iret</code>前后特权级不发生改变（<strong>[中断中]ring0 -&gt; ring0 [中断后]</strong>），故<code>iret</code>指令不会弹出<code>esp</code>和<code>ss</code>寄存器值。如果这两个寄存器也被复制进用户栈，则相比于进入中断前的用户栈地址，<code>esp</code>最终会抬高8个字节，可能造成很严重的错误。</p>
</li>
</ul>
</li>
</ul>
<h3 id="特权级降低" class="headerLink">
    <a href="#%e7%89%b9%e6%9d%83%e7%ba%a7%e9%99%8d%e4%bd%8e" class="header-mark"></a>特权级降低</h3><p>通过陷入门<strong>从ring0切换至ring3（特权降低）</strong> 的过程与特权提升的操作基本一样，不过有几个不同点需要注意一下</p>
<ul>
<li>
<p>与ring3调用中断不同，当ring0调用中断时，进入中断前和进入中断后的这个过程，栈不发生改变。</p>
<blockquote>
<p>因为在调用中断前的权限已经处于ring0了，而中断处理程序里的权限也是ring0，所以这一步陷入操作的特权级没有发生改变，故不需要访问TSS并重新设置<code>ss</code> 、<code>esp</code>寄存器。</p>
</blockquote>
</li>
<li>
<p>修改后的<code>trapFrame</code>不需要像上面那样保存至将要使用的栈，因为当前环境下<code>iret</code>前后特权级会发生改变，执行该命令会弹出<code>ss</code>和<code>esp</code>，所以可以通过<code>iret</code>来设置返回时的栈地址。</p>
</li>
</ul>
<h1 id="c函数调用的实现" class="headerLink">
    <a href="#c%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>C函数调用的实现</h1><ul>
<li><a href="http://www.cnblogs.com/clover-toeic/p/3755401.html" target="_blank" rel="noopener noreffer">C 语言函数调用栈 (一)</a></li>
<li><a href="http://www.cnblogs.com/clover-toeic/p/3756668.html" target="_blank" rel="noopener noreffer">C 语言函数调用栈 (二)</a></li>
</ul>
<h1 id="gcc内联汇编" class="headerLink">
    <a href="#gcc%e5%86%85%e8%81%94%e6%b1%87%e7%bc%96" class="header-mark"></a>GCC内联汇编</h1><p>在c语言中插入汇编代码，完成c语言无法做到的指令。</p>
<h2 id="syntax" class="headerLink">
    <a href="#syntax" class="header-mark"></a>Syntax</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">asm</span><span class="p">(</span><span class="n">assembler</span> <span class="nl">template</span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="n">output</span> <span class="n">operands</span>		<span class="p">(</span><span class="n">optional</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span><span class="n">input</span> <span class="n">operands</span> 		<span class="p">(</span><span class="n">optional</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span><span class="n">clobbers</span>				<span class="p">(</span><span class="n">optional</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="example-1" class="headerLink">
    <a href="#example-1" class="header-mark"></a>Example 1</h2><p>对于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movl $0xffff, %eax
</span></span></code></pre></td></tr></table>
</div>
</div><p>转化为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">asm</span><span class="p">(</span><span class="s">&#34;movl $0xffff, %%eax</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="example-2" class="headerLink">
    <a href="#example-2" class="header-mark"></a>Example 2</h2><p>对于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movl %cr0, %ebx
</span></span><span class="line"><span class="cl">movl %ebx, 12(%esp)
</span></span><span class="line"><span class="cl">orl  $-2147483648, 12(%esp)
</span></span><span class="line"><span class="cl">movl 12(%esp), %eax
</span></span><span class="line"><span class="cl">movl %eax, %cr0
</span></span></code></pre></td></tr></table>
</div>
</div><p>转化为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">uint32_t</span> <span class="n">cr0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">&#34;movl %%cr0, %0</span><span class="se">\n</span><span class="s">&#34;</span><span class="o">:</span> <span class="s">&#34;=r&#34;</span><span class="p">(</span><span class="n">cr0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">cr0</span> <span class="o">|=</span> <span class="mh">0x80000000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">&#34;movl %0, %%cr0</span><span class="se">\n</span><span class="s">&#34;</span><span class="o">::</span> <span class="s">&#34;=r&#34;</span><span class="p">(</span><span class="n">cr0</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>volatile：不需要优化，不需要调整顺序</li>
<li>%0：第一个用到的寄存器</li>
<li>r：任意寄存器</li>
</ul>
<h2 id="example-3" class="headerLink">
    <a href="#example-3" class="header-mark"></a>Example 3</h2><p>对于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">movl $11, %eax
</span></span><span class="line"><span class="cl">movl -28(%ebp), %ebx
</span></span><span class="line"><span class="cl">movl -24(%ebp), %ecx
</span></span><span class="line"><span class="cl">movl -20(%ebp), %edx
</span></span><span class="line"><span class="cl">movl -16(%ebp), %esi
</span></span><span class="line"><span class="cl">int $0x80
</span></span><span class="line"><span class="cl">movl %edi, -12(%ebp)
</span></span></code></pre></td></tr></table>
</div>
</div><p>转化为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">long_res</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">arg2</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span> <span class="n">arg3</span> <span class="o">=</span> <span class="mi">222</span><span class="p">,</span> <span class="n">arg4</span> <span class="o">=</span> <span class="mi">233</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">_asm_volatile</span><span class="p">(</span><span class="s">&#34;int $0x80&#34;</span>
</span></span><span class="line"><span class="cl">             <span class="o">:</span><span class="s">&#34;=a&#34;</span><span class="p">(</span><span class="n">_res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="o">:</span><span class="s">&#34;0&#34;</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="s">&#34;b&#34;</span><span class="p">(</span><span class="n">arg1</span><span class="p">),</span> <span class="s">&#34;c&#34;</span><span class="p">(</span><span class="n">arg2</span><span class="p">),</span> <span class="s">&#34;d&#34;</span><span class="p">(</span><span class="n">arg3</span><span class="p">),</span> <span class="s">&#34;S&#34;</span><span class="p">(</span><span class="n">arg4</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>a = %eax</li>
<li>b = %ebx</li>
<li>c = %ecx</li>
<li>d = %edx</li>
<li>S = %esi</li>
<li>D = %edi</li>
</ul>
<h1 id="lab-1" class="headerLink">
    <a href="#lab-1" class="header-mark"></a>Lab 1:</h1><h2 id="练习1" class="headerLink">
    <a href="#%e7%bb%83%e4%b9%a01" class="header-mark"></a>练习1</h2><p><strong>理解通过make生成执行文件的过程</strong></p>
<p>这个练习需要对Makefile有一定的了解。</p>
<p>首先，我们使用<code>make V=</code>看一下<code>make</code>执行了什么命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">+ cc kern/init/init.c
</span></span><span class="line"><span class="cl">gcc -Ikern/init/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o
</span></span><span class="line"><span class="cl">+ cc kern/libs/stdio.c
</span></span><span class="line"><span class="cl">gcc -Ikern/libs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o
</span></span><span class="line"><span class="cl">+ cc kern/libs/readline.c
</span></span><span class="line"><span class="cl">gcc -Ikern/libs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o
</span></span><span class="line"><span class="cl">+ cc kern/debug/panic.c
</span></span><span class="line"><span class="cl">gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o
</span></span><span class="line"><span class="cl">+ cc kern/debug/kdebug.c
</span></span><span class="line"><span class="cl">gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o
</span></span><span class="line"><span class="cl">+ cc kern/debug/kmonitor.c
</span></span><span class="line"><span class="cl">gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o
</span></span><span class="line"><span class="cl">+ cc kern/driver/clock.c
</span></span><span class="line"><span class="cl">gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o
</span></span><span class="line"><span class="cl">+ cc kern/driver/console.c
</span></span><span class="line"><span class="cl">gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o
</span></span><span class="line"><span class="cl">+ cc kern/driver/picirq.c
</span></span><span class="line"><span class="cl">gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o
</span></span><span class="line"><span class="cl">+ cc kern/driver/intr.c
</span></span><span class="line"><span class="cl">gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o
</span></span><span class="line"><span class="cl">+ cc kern/trap/trap.c
</span></span><span class="line"><span class="cl">gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o
</span></span><span class="line"><span class="cl">+ cc kern/trap/vectors.S
</span></span><span class="line"><span class="cl">gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o
</span></span><span class="line"><span class="cl">+ cc kern/trap/trapentry.S
</span></span><span class="line"><span class="cl">gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o
</span></span><span class="line"><span class="cl">+ cc kern/mm/pmm.c
</span></span><span class="line"><span class="cl">gcc -Ikern/mm/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o
</span></span><span class="line"><span class="cl">+ cc libs/string.c
</span></span><span class="line"><span class="cl">gcc -Ilibs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o
</span></span><span class="line"><span class="cl">+ cc libs/printfmt.c
</span></span><span class="line"><span class="cl">gcc -Ilibs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o
</span></span><span class="line"><span class="cl">+ ld bin/kernel
</span></span><span class="line"><span class="cl">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o
</span></span><span class="line"><span class="cl">+ cc boot/bootasm.S
</span></span><span class="line"><span class="cl">gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o
</span></span><span class="line"><span class="cl">+ cc boot/bootmain.c
</span></span><span class="line"><span class="cl">gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o
</span></span><span class="line"><span class="cl">+ cc tools/sign.c
</span></span><span class="line"><span class="cl">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
</span></span><span class="line"><span class="cl">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign
</span></span><span class="line"><span class="cl">+ ld bin/bootblock
</span></span><span class="line"><span class="cl">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
</span></span><span class="line"><span class="cl"><span class="s1">&#39;obj/bootblock.out&#39;</span> size: <span class="m">500</span> bytes
</span></span><span class="line"><span class="cl">build <span class="m">512</span> bytes boot sector: <span class="s1">&#39;bin/bootblock&#39;</span> success!
</span></span><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>bin/ucore.img <span class="nv">count</span><span class="o">=</span><span class="m">10000</span>
</span></span><span class="line"><span class="cl">10000+0 records in
</span></span><span class="line"><span class="cl">10000+0 records out
</span></span><span class="line"><span class="cl"><span class="m">5120000</span> bytes <span class="o">(</span>5.1 MB, 4.9 MiB<span class="o">)</span> copied, 0.0333522 s, <span class="m">154</span> MB/s
</span></span><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>bin/bootblock <span class="nv">of</span><span class="o">=</span>bin/ucore.img <span class="nv">conv</span><span class="o">=</span>notrunc
</span></span><span class="line"><span class="cl">1+0 records in
</span></span><span class="line"><span class="cl">1+0 records out
</span></span><span class="line"><span class="cl"><span class="m">512</span> bytes copied, 0.000129699 s, 3.9 MB/s
</span></span><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>bin/kernel <span class="nv">of</span><span class="o">=</span>bin/ucore.img <span class="nv">seek</span><span class="o">=</span><span class="m">1</span> <span class="nv">conv</span><span class="o">=</span>notrunc
</span></span><span class="line"><span class="cl">154+1 records in
</span></span><span class="line"><span class="cl">154+1 records out
</span></span><span class="line"><span class="cl"><span class="m">78964</span> bytes <span class="o">(</span><span class="m">79</span> kB, <span class="m">77</span> KiB<span class="o">)</span> copied, 0.000418797 s, <span class="m">189</span> MB/s
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="dd命令" class="headerLink">
    <a href="#dd%e5%91%bd%e4%bb%a4" class="header-mark"></a>dd命令</h3><p>dd 命令用于读取、转换并输出数据。dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p>
<p>仅针对出现的参数进行解释：</p>
<ul>
<li>if=文件名：输入文件名，默认为标准输入。即指定源文件。</li>
<li>of=文件名：输出文件名，默认为标准输出。即指定目的文件。</li>
<li>seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</li>
<li>count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li>
</ul>
<p>这样可以看出，我们最后生成的文件就是<code>bin/ucore.img</code>这个镜像文件，而最后的三个<code>dd</code>命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>bin/ucore.img <span class="nv">count</span><span class="o">=</span><span class="m">10000</span>
</span></span><span class="line"><span class="cl">// 将文件bin/ucore.img进行清空
</span></span><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>bin/bootblock <span class="nv">of</span><span class="o">=</span>bin/ucore.img <span class="nv">conv</span><span class="o">=</span>notrunc
</span></span><span class="line"><span class="cl">// 向img的开始写入512字节的bootloader
</span></span><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>bin/kernel <span class="nv">of</span><span class="o">=</span>bin/ucore.img <span class="nv">seek</span><span class="o">=</span><span class="m">1</span> <span class="nv">conv</span><span class="o">=</span>notrunc
</span></span><span class="line"><span class="cl">// 跳过第一个块512字节，写入内核
</span></span></code></pre></td></tr></table>
</div>
</div><p>接着，我们就从Makefile中看看，为了得到<code>bin/ucore.img</code>，我们要提前准备那些文件</p>
<blockquote>
<p>Makefile就是这样的，在其中指定了代码编译的规则，更重要的是指定了程序之间的依赖关系，所以从头看是不行的，要从最后的结果来推导整个文件的结构。</p>
</blockquote>
<h3 id="ucoreimg" class="headerLink">
    <a href="#ucoreimg" class="header-mark"></a>ucore.img</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="c"># create ucore.img
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nv">UCOREIMG</span>	<span class="o">:=</span> <span class="k">$(</span>call totarget,ucore.img<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">$(UCOREIMG)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">kernel</span><span class="k">)</span> <span class="k">$(</span><span class="nv">bootblock</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">$(</span>V<span class="k">)</span>dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span><span class="nv">$@</span> <span class="nv">count</span><span class="o">=</span><span class="m">10000</span>
</span></span><span class="line"><span class="cl">	<span class="k">$(</span>V<span class="k">)</span>dd <span class="k">if</span><span class="o">=</span><span class="k">$(</span>bootblock<span class="k">)</span> <span class="nv">of</span><span class="o">=</span><span class="nv">$@</span> <span class="nv">conv</span><span class="o">=</span>notrunc
</span></span><span class="line"><span class="cl">	<span class="k">$(</span>V<span class="k">)</span>dd <span class="k">if</span><span class="o">=</span><span class="k">$(</span>kernel<span class="k">)</span> <span class="nv">of</span><span class="o">=</span><span class="nv">$@</span> <span class="nv">seek</span><span class="o">=</span><span class="m">1</span> <span class="nv">conv</span><span class="o">=</span>notrunc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">$(</span><span class="nv">call</span> <span class="nv">create_target</span>,<span class="nv">ucore</span>.<span class="nv">img</span><span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了得到<code>ucore.img</code>，需要<code>kernel</code>和<code>bootblock</code>。</p>
<h3 id="bootblock" class="headerLink">
    <a href="#bootblock" class="header-mark"></a>bootblock</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="c"># create bootblock
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nv">bootfiles</span> <span class="o">=</span> <span class="k">$(</span>call listf_cc,boot<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="k">$(</span><span class="nv">foreach</span> <span class="nv">f</span>,<span class="k">$(</span><span class="nv">bootfiles</span><span class="k">)</span>,<span class="k">$(</span><span class="nv">call</span> <span class="nv">cc_compile</span>,<span class="k">$(</span><span class="nv">f</span><span class="k">)</span>,<span class="k">$(</span><span class="nv">CC</span><span class="k">)</span>,<span class="k">$(</span><span class="nv">CFLAGS</span><span class="k">)</span> -<span class="nv">Os</span> -<span class="nv">nostdinc</span><span class="k">))</span>
</span></span><span class="line"><span class="cl"><span class="c"># 这里遍历 boot 目录下的所有文件 asm.h bootasm.S bootmain.c
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nv">bootblock</span> <span class="o">=</span> <span class="k">$(</span>call totarget,bootblock<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="c"># 生成目标文件 asm.o bootasm.o bootmain.o sign.o
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nf">$(bootblock)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">call</span> <span class="nv">toobj</span>,<span class="k">$(</span><span class="nv">bootfiles</span><span class="k">))</span> <span class="p">|</span> <span class="k">$(</span><span class="nv">call</span> <span class="nv">totarget</span>,<span class="nv">sign</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">	@echo + ld <span class="nv">$@</span>
</span></span><span class="line"><span class="cl">	<span class="k">$(</span>V<span class="k">)$(</span>LD<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -N -e start -Ttext 0x7C00 $^ -o <span class="k">$(</span>call toobj,bootblock<span class="k">)</span>
</span></span><span class="line"><span class="cl">	@<span class="k">$(</span>OBJDUMP<span class="k">)</span> -S <span class="k">$(</span>call objfile,bootblock<span class="k">)</span> &gt; <span class="k">$(</span>call asmfile,bootblock<span class="k">)</span>
</span></span><span class="line"><span class="cl">	@<span class="k">$(</span>OBJDUMP<span class="k">)</span> -t <span class="k">$(</span>call objfile,bootblock<span class="k">)</span> <span class="p">|</span> <span class="k">$(</span>SED<span class="k">)</span> <span class="s1">&#39;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#39;</span> &gt; <span class="k">$(</span>call symfile,bootblock<span class="k">)</span>
</span></span><span class="line"><span class="cl">	@<span class="k">$(</span>OBJCOPY<span class="k">)</span> -S -O binary <span class="k">$(</span>call objfile,bootblock<span class="k">)</span> <span class="k">$(</span>call outfile,bootblock<span class="k">)</span>
</span></span><span class="line"><span class="cl">	@<span class="k">$(</span>call totarget,sign<span class="k">)</span> <span class="k">$(</span>call outfile,bootblock<span class="k">)</span> <span class="k">$(</span>bootblock<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="c"># 将目标文件 链接起来 同时指定代码段开始地址 为 0x7c00
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">$(</span><span class="nv">call</span> <span class="nv">create_target</span>,<span class="nv">bootblock</span><span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>生成<code>bootblock</code>，需要<code>bootasm.o</code>、<code>bootmain.o</code>、<code>sign</code></p>
<p>生成<code>bootasm.o</code>需要<code>bootasm.S</code>，实际执行命令为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中关键的参数为</p>
<ul>
<li>-ggdb  生成可供gdb使用的调试信息。这样才能用qemu+gdb来调试bootloader or ucore。</li>
<li>-m32  生成适用于32位环境的代码。我们用的模拟硬件是32bit的80386，所以ucore也要是32位的软件。</li>
<li>-gstabs  生成stabs格式的调试信息。这样要ucore的monitor可以显示出便于开发者阅读的函数调用栈信息</li>
<li>-nostdinc  不使用标准库。标准库是给应用程序用的，我们是编译ucore内核，OS内核是提供服务的，所以所有的服务要自给自足。</li>
<li>-fno-stack-protector  不生成用于检测缓冲区溢出的代码。这是for 应用程序的，我们是编译内核，ucore内核好像还用不到此功能。</li>
<li>-Os  为减小代码大小而进行优化。根据硬件spec，主引导扇区只有512字节，我们写的简单bootloader的最终大小不能大于510字节。</li>
<li>-I&lt;dir&gt;  添加搜索头文件的路径</li>
</ul>
<p>生成<code>bootmain.o</code>需要<code>bootmain.c</code></p>
<p>实际执行命令为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>-fno-builtin  除非用__builtin_前缀，否则不进行builtin函数的优化</li>
</ul>
<h3 id="sign" class="headerLink">
    <a href="#sign" class="header-mark"></a>sign</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="c"># create &#39;sign&#39; tools
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="k">$(</span><span class="nv">call</span> <span class="nv">add_files_host</span>,<span class="nv">tools</span>/<span class="nv">sign</span>.<span class="nv">c</span>,<span class="nv">sign</span>,<span class="nv">sign</span><span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="k">$(</span><span class="nv">call</span> <span class="nv">create_target_host</span>,<span class="nv">sign</span>,<span class="nv">sign</span><span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际执行命令为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
</span></span><span class="line"><span class="cl">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先生成bootblock.o</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中关键的参数为</p>
<ul>
<li>-m &lt;emulation&gt;  模拟为i386上的连接器</li>
<li>-nostdlib  不使用标准库</li>
<li>-N  设置代码段和数据段均可读写</li>
<li>-e &lt;entry&gt;  指定入口</li>
<li>-Ttext  制定代码段开始位置</li>
</ul>
<p>拷贝二进制代码bootblock.o到bootblock.out</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">objcopy -S -O binary obj/bootblock.o obj/bootblock.out
</span></span><span class="line"><span class="cl">其中关键的参数为
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>-S  移除所有符号和重定位信息</li>
<li>-O &lt;bfdname&gt;  指定输出格式</li>
</ul>
<p>使用sign工具处理bootblock.out，生成bootblock</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">bin/sign obj/bootblock.out bin/bootblock
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="kernel" class="headerLink">
    <a href="#kernel" class="header-mark"></a>kernel</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="c"># create kernel target
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nv">kernel</span> <span class="o">=</span> <span class="k">$(</span>call totarget,kernel<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">$(kernel)</span><span class="o">:</span> <span class="n">tools</span>/<span class="n">kernel</span>.<span class="n">ld</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">$(kernel)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">KOBJS</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">	@echo + ld <span class="nv">$@</span>
</span></span><span class="line"><span class="cl">	<span class="k">$(</span>V<span class="k">)$(</span>LD<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -T tools/kernel.ld -o <span class="nv">$@</span> <span class="k">$(</span>KOBJS<span class="k">)</span>
</span></span><span class="line"><span class="cl">	@<span class="k">$(</span>OBJDUMP<span class="k">)</span> -S <span class="nv">$@</span> &gt; <span class="k">$(</span>call asmfile,kernel<span class="k">)</span>
</span></span><span class="line"><span class="cl">	@<span class="k">$(</span>OBJDUMP<span class="k">)</span> -t <span class="nv">$@</span> <span class="p">|</span> <span class="k">$(</span>SED<span class="k">)</span> <span class="s1">&#39;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#39;</span> &gt; <span class="k">$(</span>call symfile,kernel<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">$(</span><span class="nv">call</span> <span class="nv">create_target</span>,<span class="nv">kernel</span><span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>kernel.ld</code>是已存在的链接器，这一步将<code>kern</code>目录下生成的所有<code>.o</code>文件，通过<code>kernel.ld</code>链接为<code>kernel</code>。</p>
<ul>
<li>-T&lt;链接器路径&gt;，使用指定的链接器</li>
</ul>
<p>其前置命令就是将<code>kern</code>下面的所有文件编译，生成目标文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="c"># kernel
</span></span></span><span class="line"><span class="cl"><span class="c"></span>
</span></span><span class="line"><span class="cl"><span class="nv">KINCLUDE</span>	<span class="o">+=</span> kern/debug/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>			   kern/driver/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>			   kern/trap/ <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>			   kern/mm/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">KSRCDIR</span>		<span class="o">+=</span> kern/init <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>			   kern/libs <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>			   kern/debug <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>			   kern/driver <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>			   kern/trap <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>			   kern/mm
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">KCFLAGS</span>		<span class="o">+=</span> <span class="k">$(</span>addprefix -I,<span class="k">$(</span>KINCLUDE<span class="k">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">$(</span><span class="nv">call</span> <span class="nv">add_files_cc</span>,<span class="k">$(</span><span class="nv">call</span> <span class="nv">listf_cc</span>,<span class="k">$(</span><span class="nv">KSRCDIR</span><span class="k">))</span>,<span class="nv">kernel</span>,<span class="k">$(</span><span class="nv">KCFLAGS</span><span class="k">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">KOBJS</span>	<span class="o">=</span> <span class="k">$(</span>call read_packet,kernel libs<span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</strong></p>
<p>code: sign.c</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="n">buf</span><span class="p">[</span><span class="mi">510</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x55</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">buf</span><span class="p">[</span><span class="mi">511</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xAA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="练习2" class="headerLink">
    <a href="#%e7%bb%83%e4%b9%a02" class="header-mark"></a>练习2</h2><p><strong>使用qemu执行并调试lab1中的软件</strong></p>
<p>在开始debug之前，我们参考其实验报告中的提示将<code>/tools/gdbinit</code>的内容修改如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">file bin/kernel
</span></span><span class="line"><span class="cl"><span class="nb">set</span> architecture i8086
</span></span><span class="line"><span class="cl">target remote :1234
</span></span><span class="line"><span class="cl">b* 0x7c00
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">define hook-stop
</span></span><span class="line"><span class="cl">x/i <span class="nv">$eip</span>
</span></span><span class="line"><span class="cl">end
</span></span><span class="line"><span class="cl"><span class="k">continue</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后使用<code>make debug</code>就可以进行调试。</p>
<blockquote>
<p>这里pwndbg插件无法进行调试，只能使用peda了</p>
</blockquote>
<p><img
        class="lazyload"
        data-src="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210610205649.png"
        data-srcset="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210610205649.png, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210610205649.png 1.5x, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210610205649.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210610205649.png"
        title="image-20210610205636075"></p>
<p>也可以直接对答案进行调试，使用<code>make lab1-mon</code>。</p>
<p>下面我们将反汇编得到的代码与bootasm.S和 bootblock.asm进行比较：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">gdb-peda$ x/10i
</span></span><span class="line"><span class="cl">   0x7c02:	xor    eax,eax
</span></span><span class="line"><span class="cl">   0x7c04:	mov    ds,eax
</span></span><span class="line"><span class="cl">   0x7c06:	mov    es,eax
</span></span><span class="line"><span class="cl">   0x7c08:	mov    ss,eax
</span></span><span class="line"><span class="cl">   0x7c0a:	in     al,0x64
</span></span><span class="line"><span class="cl">   0x7c0c:	test   al,0x2
</span></span><span class="line"><span class="cl">   0x7c0e:	jne    0x7c0a
</span></span><span class="line"><span class="cl">   0x7c10:	mov    al,0xd1
</span></span><span class="line"><span class="cl">   0x7c12:	out    0x64,al
</span></span><span class="line"><span class="cl">   0x7c14:	in     al,0x64
</span></span></code></pre></td></tr></table>
</div>
</div><p>而在<code>bootblock.asm</code>中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">00007c00 &lt;start&gt;:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader
</span></span><span class="line"><span class="cl">.globl start
</span></span><span class="line"><span class="cl">start:
</span></span><span class="line"><span class="cl">.code16                                             # Assemble for 16-bit mode
</span></span><span class="line"><span class="cl">    cli                                             # Disable interrupts
</span></span><span class="line"><span class="cl">    7c00:	fa                   	cli    
</span></span><span class="line"><span class="cl">    cld                                             # String operations increment
</span></span><span class="line"><span class="cl">    7c01:	fc                   	cld    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # Set up the important data segment registers (DS, ES, SS).
</span></span><span class="line"><span class="cl">    xorw %ax, %ax                                   # Segment number zero
</span></span><span class="line"><span class="cl">    7c02:	31 c0                	xor    %eax,%eax
</span></span><span class="line"><span class="cl">    movw %ax, %ds                                   # -&gt; Data Segment
</span></span><span class="line"><span class="cl">    7c04:	8e d8                	mov    %eax,%ds
</span></span><span class="line"><span class="cl">    movw %ax, %es                                   # -&gt; Extra Segment
</span></span><span class="line"><span class="cl">    7c06:	8e c0                	mov    %eax,%es
</span></span><span class="line"><span class="cl">    movw %ax, %ss                                   # -&gt; Stack Segment
</span></span><span class="line"><span class="cl">    7c08:	8e d0                	mov    %eax,%ss
</span></span></code></pre></td></tr></table>
</div>
</div><p>当你删除<code>gdbinit</code>中的<code>continue</code>后，就可以调试从BIOS开始的指令。非常有趣的一点是，记得吗，执行BIOS时，cpu还在实模式，而gdb默认只输出<code>$ip</code> 所指向地址的指针，而不是<code>cs:ip</code>。正确的指令应该是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gdb-peda$ x/5i <span class="o">((</span><span class="nv">$cs</span><span class="s">&lt;&lt;4)+$eip)
</span></span></span><span class="line"><span class="cl"><span class="s">   0xffff0:     jmp    0x3630:0xf000e05b
</span></span></span><span class="line"><span class="cl"><span class="s">   0xffff7:     das
</span></span></span><span class="line"><span class="cl"><span class="s">   0xffff8:     xor    dh,BYTE PTR [ebx]
</span></span></span><span class="line"><span class="cl"><span class="s">   0xffffa:     das
</span></span></span><span class="line"><span class="cl"><span class="s">   0xffffb:     cmp    DWORD PTR [ecx],edi
</span></span></span><span class="line"><span class="cl"><span class="s">   
</span></span></span><span class="line"><span class="cl"><span class="s">gdb-peda$ x/5i (($cs&lt;&lt;4</span><span class="o">)</span>+<span class="nv">$eip</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">   0xfe05b:     cmp    WORD PTR cs:<span class="o">[</span>esi<span class="o">]</span>,0xffc8
</span></span><span class="line"><span class="cl">   0xfe060:     bound  eax,QWORD PTR <span class="o">[</span>eax<span class="o">]</span>
</span></span><span class="line"><span class="cl">   0xfe062:     jne    0xd241d0b2
</span></span><span class="line"><span class="cl">   0xfe068:     mov    ss,edx
</span></span><span class="line"><span class="cl">   0xfe06a:     mov    sp,0x7000
</span></span></code></pre></td></tr></table>
</div>
</div><p>（感谢<a href="https://github.com/M-ouse" target="_blank" rel="noopener noreffer">@2st</a>&amp;<a href="https://github.com/Kiprey" target="_blank" rel="noopener noreffer">@kiprey</a>）</p>
<h2 id="练习3" class="headerLink">
    <a href="#%e7%bb%83%e4%b9%a03" class="header-mark"></a>练习3</h2><p><strong>分析bootloader进入保护模式的过程</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">start:
</span></span><span class="line"><span class="cl">.code16                                             # Assemble for 16-bit mode
</span></span><span class="line"><span class="cl">    cli                                             # Disable interrupts
</span></span><span class="line"><span class="cl">    cld                                             # String operations increment
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # Set up the important data segment registers (DS, ES, SS).
</span></span><span class="line"><span class="cl">    xorw %ax, %ax                                   # Segment number zero
</span></span><span class="line"><span class="cl">    movw %ax, %ds                                   # -&gt; Data Segment
</span></span><span class="line"><span class="cl">    movw %ax, %es                                   # -&gt; Extra Segment
</span></span><span class="line"><span class="cl">    movw %ax, %ss                                   # -&gt; Stack Segment
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，<code>cli</code>禁用中断，它的全称为<code>Clear Interupt</code>。<code>cld(Clear Direction)</code>设置了字节的传输从低位开始。清空重要的段寄存器。</p>
<blockquote>
<p>cld指令使变址寄存器SI或DI的地址指针自动增加，从前向后处理。</p>
</blockquote>
<h3 id="有关a20" class="headerLink">
    <a href="#%e6%9c%89%e5%85%b3a20" class="header-mark"></a>有关A20？</h3><ul>
<li>
<p>为什么要开启A20？</p>
<p>Intel早期的8086 CPU提供了20根地址线，但寄存器只有16位，所以使用<strong>段寄存器值 &laquo; 4 + 段内偏移值</strong>的方法来访问到所有内存，但按这种方式来计算出的地址的最大值为1088KB，超过20根地址线所能表示的范围，会发生“回卷”(memory wraparound)（和整数溢出有点类似）。但下一代的基于Intel 80286 CPU的计算机系统提供了24根地址线，当CPU计算出的地址超过1MB时便<strong>不会发生回卷</strong>，而这就造成了<strong>向下不兼容</strong>。为了保持完全的向下兼容性，IBM在计算机系统上加个硬件逻辑来模仿早期的回绕特征，而这就是<strong>A20 Gate</strong>。</p>
</li>
<li>
<p>如何开启A20？</p>
<ul>
<li>A20 Gate的方法是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它。当A20 地址线控制禁止时，则程序就像在8086中运行，1MB以上的地址不可访问；保护模式下A20地址线控制必须打开。A20控制打开后，内存寻址将不会发生回卷。</li>
<li>通常的方法是通过设置键盘控制器的端口值，不过有些系统觉得键盘控制器很慢，为此引入了一个Fast Gate A20，它用IO端口的0x92来处理A20信号线。还有一种方法是通过读取0xee端口来开启A20地址线，写端口则会禁止地址线。</li>
<li>从理论上讲，打开A20 Gate的方法是通过设置8042芯片输出端口（64h）的2nd-bit，但事实上，当你向8042芯片输出端口进行写操作的时候，在键盘缓冲区中或许还有别的数据尚未处理，因此你必须首先处理这些数据。  所以，激活A20地址线的流程为：  1.禁止中断；2.等待，直到8042 Input buffer为空为止； 3.发送Write 8042 Output Port命令到8042 Input buffer；4.等待，直到8042 Input buffer为空为止；5.向P2写入数据，将OR2置1</li>
</ul>
<p>（关于激活我没有找到很详细的资料，只有<a href="https://wenku.baidu.com/view/d6efe68fcc22bcd126ff0c00.html" target="_blank" rel="noopener noreffer">A20激活详解</a>）</p>
</li>
</ul>
<p><img
        class="lazyload"
        data-src="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611190136.png"
        data-srcset="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611190136.png, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611190136.png 1.5x, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611190136.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611190136.png"
        title="image-20210611190136028"></p>
<p>启动A20的汇编代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # Enable A20:
</span></span><span class="line"><span class="cl">    #  For backwards compatibility with the earliest PCs, physical
</span></span><span class="line"><span class="cl">    #  address line 20 is tied low, so that addresses higher than
</span></span><span class="line"><span class="cl">    #  1MB wrap around to zero by default. This code undoes this.
</span></span><span class="line"><span class="cl">seta20.1:               # 等待8042键盘控制器不忙
</span></span><span class="line"><span class="cl">    inb $0x64, %al      # 从0x64键盘缓冲区接收消息
</span></span><span class="line"><span class="cl">    testb $0x2, %al     # 如果接受到2则表明键盘缓冲区为空
</span></span><span class="line"><span class="cl">    jnz seta20.1        #
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    movb $0xd1, %al     # 发送写8042输出端口的指令
</span></span><span class="line"><span class="cl">    outb %al, $0x64     # 0xd1表示写输出端口P2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">seta20.1:               # 等待8042键盘控制器不忙
</span></span><span class="line"><span class="cl">    inb $0x64, %al      # 
</span></span><span class="line"><span class="cl">    testb $0x2, %al     #
</span></span><span class="line"><span class="cl">    jnz seta20.1        #
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    movb $0xdf, %al     # 0xdf --&gt; P2
</span></span><span class="line"><span class="cl">    outb %al, $0x60     # 1101 1111 ，P2的P21置为1
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="如何初始化gdt表" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e5%88%9d%e5%a7%8b%e5%8c%96gdt%e8%a1%a8" class="header-mark"></a>如何初始化GDT表？</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Bootstrap GDT
</span></span><span class="line"><span class="cl">.p2align 2                                          # force 4 byte alignment
</span></span><span class="line"><span class="cl">gdt:
</span></span><span class="line"><span class="cl">    SEG_NULLASM                                     # null seg
</span></span><span class="line"><span class="cl">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
</span></span><span class="line"><span class="cl">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">gdtdesc:
</span></span><span class="line"><span class="cl">    .word 0x17                                      # sizeof(gdt) - 1
</span></span><span class="line"><span class="cl">    .long gdt                                       # address gdt
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>设置表中第一项为<code>NULL</code></li>
<li>表中第二项为代码段描述符，可读可执行</li>
<li>表中第二项为数据段描述符，可写</li>
</ul>
<p>回到bootloader的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # Switch from real to protected mode, using a bootstrap GDT
</span></span><span class="line"><span class="cl">    # and segment translation that makes virtual addresses
</span></span><span class="line"><span class="cl">    # identical to physical addresses, so that the
</span></span><span class="line"><span class="cl">    # effective memory map does not change during the switch.
</span></span><span class="line"><span class="cl">    lgdt gdtdesc
</span></span><span class="line"><span class="cl">    movl %cr0, %eax
</span></span><span class="line"><span class="cl">    orl $CR0_PE_ON, %eax
</span></span><span class="line"><span class="cl">    movl %eax, %cr0
</span></span></code></pre></td></tr></table>
</div>
</div><p>在开启A20之后，加载了<code>GDT</code>全局描述符表，它是被静态储存在引导区中的，载入即可。</p>
<p>接着，将<code>cr0</code>寄存器的bit 0置为1，标志着从实模式转换到保护模式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    # Jump to next instruction, but in 32-bit code segment.
</span></span><span class="line"><span class="cl">    # Switches processor into 32-bit mode.
</span></span><span class="line"><span class="cl">    ljmp $PROT_MODE_CSEG, $protcseg
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为长跳转可以设置其<code>cs</code>寄存器，所以使用一个长跳转进入32位指令模式执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.code32                                             # Assemble for 32-bit mode
</span></span><span class="line"><span class="cl">protcseg:
</span></span><span class="line"><span class="cl">    # Set up the protected-mode data segment registers
</span></span><span class="line"><span class="cl">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
</span></span><span class="line"><span class="cl">    movw %ax, %ds                                   # -&gt; DS: Data Segment
</span></span><span class="line"><span class="cl">    movw %ax, %es                                   # -&gt; ES: Extra Segment
</span></span><span class="line"><span class="cl">    movw %ax, %fs                                   # -&gt; FS
</span></span><span class="line"><span class="cl">    movw %ax, %gs                                   # -&gt; GS
</span></span><span class="line"><span class="cl">    movw %ax, %ss                                   # -&gt; SS: Stack Segment
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
</span></span><span class="line"><span class="cl">    movl $0x0, %ebp
</span></span><span class="line"><span class="cl">    movl $start, %esp
</span></span><span class="line"><span class="cl">    call bootmain
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    # If bootmain returns (it shouldn&#39;t), loop.
</span></span><span class="line"><span class="cl">spin:
</span></span><span class="line"><span class="cl">    jmp spin
</span></span></code></pre></td></tr></table>
</div>
</div><p>设置各段寄存器，并建立堆栈（0~0x7c00），最后进入<code>bootmain</code>函数（in bootmain.c）中。</p>
<h2 id="练习4" class="headerLink">
    <a href="#%e7%bb%83%e4%b9%a04" class="header-mark"></a>练习4</h2><h4 id="分析bootloader加载elf格式的os的过程" class="headerLink">
    <a href="#%e5%88%86%e6%9e%90bootloader%e5%8a%a0%e8%bd%bdelf%e6%a0%bc%e5%bc%8f%e7%9a%84os%e7%9a%84%e8%bf%87%e7%a8%8b" class="header-mark"></a>分析bootloader加载ELF格式的OS的过程</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">SECTSIZE</span>  <span class="o">=</span>      <span class="mi">512</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span> <span class="n">ELFHDR</span>    <span class="o">=</span>      <span class="p">((</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x10000</span><span class="p">)</span> <span class="p">;</span>     <span class="c1">// scratch space
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* bootmain - the entry of bootloader */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">bootmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// read the 1st page off disk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">readseg</span><span class="p">((</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">ELFHDR</span><span class="p">,</span> <span class="n">SECTSIZE</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// is this a valid ELF?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// load each program segment (ignores ph flags)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="p">)((</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">ELFHDR</span> <span class="o">+</span> <span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">readseg</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_va</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// call the entry point from the ELF header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// note: does not return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_entry</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">))();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">bad</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">outw</span><span class="p">(</span><span class="mh">0x8A00</span><span class="p">,</span> <span class="mh">0x8A00</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">outw</span><span class="p">(</span><span class="mh">0x8A00</span><span class="p">,</span> <span class="mh">0x8E00</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* do nothing */</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，从硬盘读取一页（512*8）的内容加载到<code>0x10000</code>。</p>
<p>现在考虑它是如何读取的？</p>
<p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。</p>
<p>一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。</p>
<p>第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1</p>
<table>
<thead>
<tr>
<th style="text-align:center">IO地址</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x1f0</td>
<td style="text-align:left">读数据，当0x1f7不为忙状态时，可以读。</td>
</tr>
<tr>
<td style="text-align:center">0x1f2</td>
<td style="text-align:left">要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td>
</tr>
<tr>
<td style="text-align:center">0x1f3</td>
<td style="text-align:left">如果是LBA模式，就是LBA参数的0-7位</td>
</tr>
<tr>
<td style="text-align:center">0x1f4</td>
<td style="text-align:left">如果是LBA模式，就是LBA参数的8-15位</td>
</tr>
<tr>
<td style="text-align:center">0x1f5</td>
<td style="text-align:left">如果是LBA模式，就是LBA参数的16-23位</td>
</tr>
<tr>
<td style="text-align:center">0x1f6</td>
<td style="text-align:left">第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td>
</tr>
<tr>
<td style="text-align:center">0x1f7</td>
<td style="text-align:left">状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td>
</tr>
<tr>
<td style="text-align:center">当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程大致如下：</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<p>在c代码中是这样实现的，<code>readseg()</code>是<code>readsect()</code>的一个封装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* readsect - read a single sector at @secno into @dst */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">readsect</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">secno</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// wait for disk to be ready
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">waitdisk</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>                         <span class="c1">// count = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F3</span><span class="p">,</span> <span class="n">secno</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F4</span><span class="p">,</span> <span class="p">(</span><span class="n">secno</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F5</span><span class="p">,</span> <span class="p">(</span><span class="n">secno</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F6</span><span class="p">,</span> <span class="p">((</span><span class="n">secno</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xE0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F7</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>                      <span class="c1">// cmd 0x20 - read sectors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// wait for disk to be ready
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">waitdisk</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// read a sector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">insl</span><span class="p">(</span><span class="mh">0x1F0</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">SECTSIZE</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* waitdisk - wait for disk ready */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">waitdisk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="mh">0x1F7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x40</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* do nothing */</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">outb</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&#34;outb %0, %1&#34;</span> <span class="o">::</span> <span class="s">&#34;a&#34;</span> <span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s">&#34;d&#34;</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>加载到磁盘后，判断其是否是一个合法的ELF：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="c1">// is this a valid ELF?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果合法则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="c1">// load each program segment (ignores ph flags)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 在ELF文件头中，有描述符表记录了ELF文件应该加载到什么位置 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将描述符表保存到ph中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="p">)((</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">ELFHDR</span> <span class="o">+</span> <span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 按照描述表将ELF文件中数据载入内存 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">readseg</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_va</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// call the entry point from the ELF header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// note: does not return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 内核入口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_entry</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFF</span><span class="p">))();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="练习5" class="headerLink">
    <a href="#%e7%bb%83%e4%b9%a05" class="header-mark"></a>练习5</h2><p><strong>实现函数调用堆栈跟踪函数</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">print_stackframe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ebp</span> <span class="o">=</span> <span class="n">read_ebp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">eip</span> <span class="o">=</span> <span class="n">read_eip</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ebp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">STACKFRAME_DEPTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;ebp: 0x%08x eip: 0x%08x, arg:&#34;</span><span class="p">,</span> <span class="n">ebp</span><span class="p">,</span> <span class="n">eip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ebp</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;0x%08x &#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">print_debuginfo</span><span class="p">(</span><span class="n">eip</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">eip</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ebp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ebp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ebp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里需要对32位c的函数调用有充分的理解</p>
<p><img
        class="lazyload"
        data-src="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611230013.jpeg"
        data-srcset="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611230013.jpeg, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611230013.jpeg 1.5x, https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611230013.jpeg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611230013.jpeg"
        title="https://raw.githubusercontent.com/Niebelungen-D/Imgbed-blog/main/img/20210611230013.jpeg"></p>
<p>涉及到很多指针操作，还有一点要注意的是，<code>eip</code>指向的是即将执行的指令，所以如果想要查看当前函数需要<code>-1</code>。</p>
<h2 id="练习6" class="headerLink">
    <a href="#%e7%bb%83%e4%b9%a06" class="header-mark"></a>练习6</h2><p><strong>完善中断初始化和处理</strong></p>
<ul>
<li>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</li>
</ul>
<p>code in /kern/mm/mmu.h：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Gate descriptors for interrupts and traps */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">gatedesc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="nl">gd_off_15_0</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>        <span class="c1">// low 16 bits of offset in segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">gd_ss</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>            <span class="c1">// segment selector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">gd_args</span> <span class="p">:</span> <span class="mi">5</span><span class="p">;</span>            <span class="c1">// # args, 0 for interrupt/trap gates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">gd_rsv1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>            <span class="c1">// reserved(should be zero I guess)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">gd_type</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>            <span class="c1">// type(STS_{TG,IG32,TG32})
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">gd_s</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>                <span class="c1">// must be 0 (system)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">gd_dpl</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>            <span class="c1">// descriptor(meaning new) privilege level
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">gd_p</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>                <span class="c1">// Present
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">gd_off_31_16</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>        <span class="c1">// high bits of offset in segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个表项共有<code>8*8 = 64 bit</code>即8字节。其中<code>gd_ss</code>是段选择子，<code>gd_off_15_0</code>是偏移，通过这两项我们就可以找到中断处理代码的入口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">idt_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">extern</span> <span class="n">uintptr_t</span> <span class="n">__vectors</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">idt</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gatedesc</span><span class="p">);</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>	<span class="c1">// 使用宏设置IDT的每一项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// IDT的每一项都是中断且在内核态处理的所以设为`GD_LTEXT`，特权级为`DPL_KERNEL`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">SETGATE</span><span class="p">(</span><span class="n">idt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GD_KTEXT</span><span class="p">,</span> <span class="n">__vectors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DPL_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 系统调用是提供给用户，供其调用的，所以我们要修改其特权级，使其可以在用户态调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SETGATE</span><span class="p">(</span><span class="n">idt</span><span class="p">[</span><span class="n">T_SWITCH_TOK</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GD_KTEXT</span><span class="p">,</span> <span class="n">__vectors</span><span class="p">[</span><span class="n">T_SWITCH_TOK</span><span class="p">],</span> <span class="n">DPL_USER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加载idt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lidt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idt_pd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权限；而ucore的应用程序处于特权级３，需要采用｀int 0x80`指令操作（这种方式称为软中断，软件中断，Tra中断，在lab5会碰到）来发出系统调用请求，并要能实现从特权级３到特权级０的转换，所以系统调用中断(T_SYSCALL)所对应的中断门描述符中的特权级（DPL）需要设置为３。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_trapno</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">IRQ_OFFSET</span> <span class="o">+</span> <span class="nl">IRQ_TIMER</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">ticks</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">ticks</span> <span class="o">%</span> <span class="n">TICK_NUM</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">print_ticks</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每100次时钟中断调用<code>print_ticks</code>，这部分看其代码中给的提示很容易编写出来，实验指导中的很模糊。</p>
<h2 id="challenge-1" class="headerLink">
    <a href="#challenge-1" class="header-mark"></a>Challenge 1</h2><blockquote>
<p>为完成挑战请仔细阅读trap相关的代码、test相关代码以及《操作系统真象还原》-特权级深入浅出一章</p>
</blockquote>
<p>在所有中断处理程序中都使用<code>__alltraps</code>，它将<code>trapframe</code>保存在栈上。在由内核态切换成用户态的时候，一开始调用中断时，由于是从内核态调用的，没有权限切换，故ss、esp没有压栈，而iret返回时，是返回到用户态，故ss、esp会出栈，于是为了保证栈的正确性，需要在调用中断前将esp减8以预留空间，中断返回后，由于esp被修改，还需要手动恢复esp为正确值。</p>
<p>这样之后，系统特权级已经成功切换，但是由于切换到了用户态，导致IO操作没有权限，故之后的printf无法成功输出，为了能够正常输出，我们需要将eflags中的IOPL设成用户级别，即3，同样也是通过修改栈中值来达到修改的目的。</p>
<p><strong>ring3 -&gt; ring0</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 全局变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">trapframe</span> <span class="n">switchk2u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">case</span> <span class="nl">T_SWITCH_TOK</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_cs</span> <span class="o">!=</span> <span class="n">KERNEL_CS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_cs</span> <span class="o">=</span> <span class="n">KERNEL_CS</span><span class="p">;</span>			<span class="c1">// 修改CPL DPL IOPL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_ds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_es</span> <span class="o">=</span> <span class="n">KERNEL_DS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_eflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FL_IOPL_MASK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算将要保存新trapFrame的用户栈地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 数值减8是因为内核调用中断时CPU没有压入ss和esp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">switchu2k</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trapframe</span> <span class="o">*</span><span class="p">)(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_esp</span> <span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trapframe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将修改后的trapFrame写入用户栈(注意当前是内核栈)。注意trapFrame中ss和esp的值不需要写入。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">memmove</span><span class="p">(</span><span class="n">switchu2k</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trapframe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置弹出esp的值为用户栈的新地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">switchu2k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">break</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>ring0 -&gt; ring3</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 全局变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">trapframe</span> <span class="o">*</span><span class="n">switchu2k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">case</span> <span class="nl">T_SWITCH_TOU</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_cs</span> <span class="o">!=</span> <span class="n">USER_CS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将中断的栈帧赋给临时中断帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">switchk2u</span> <span class="o">=</span> <span class="o">*</span><span class="n">tf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改可执行代码段为USER_CS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_cs</span> <span class="o">=</span> <span class="n">USER_CS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改数据段为USER_DS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_ds</span> <span class="o">=</span> <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_es</span> <span class="o">=</span> <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_ss</span> <span class="o">=</span> <span class="n">USER_DS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置从中断处理程序返回时的栈地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 数值减8是因为iret不会弹出ss和esp，所以不需要这8个字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_esp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">tf</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trapframe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了使得程序在低CPL的情况下仍然能够使用IO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 需要将eflags中对应的IOPL位置成表示用户态的3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_eflags</span> <span class="o">|=</span> <span class="n">FL_IOPL_MASK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置中断处理例程结束时pop出的%esp，这样可以用修改后的数据来恢复上下文。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">switchk2u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 事实上上述代码并没有实际完成一个从内核栈到用户态栈的切换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 仅仅是完成了特权级的切换。这属于正常现象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">break</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>中断</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">lab1_switch_to_user</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	    <span class="s">&#34;sub $0x8, %%esp </span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">	    <span class="s">&#34;int %0 </span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">	    <span class="s">&#34;movl %%ebp, %%esp&#34;</span>
</span></span><span class="line"><span class="cl">	    <span class="o">:</span> 
</span></span><span class="line"><span class="cl">	    <span class="o">:</span> <span class="s">&#34;i&#34;</span><span class="p">(</span><span class="n">T_SWITCH_TOU</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">lab1_switch_to_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	    <span class="s">&#34;int %0 </span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">	    <span class="s">&#34;movl %%ebp, %%esp </span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">	    <span class="o">:</span> 
</span></span><span class="line"><span class="cl">	    <span class="o">:</span> <span class="s">&#34;i&#34;</span><span class="p">(</span><span class="n">T_SWITCH_TOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后为了完成挑战不要忘了在<code>kern_init</code>中，开启test。</p>
<h2 id="challenge-2" class="headerLink">
    <a href="#challenge-2" class="header-mark"></a>Challenge 2</h2><p>使用键盘完成用户态与内核态的切换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">   <span class="k">case</span> <span class="n">IRQ_OFFSET</span> <span class="o">+</span> <span class="nl">IRQ_KBD</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span> <span class="o">=</span> <span class="n">cons_getc</span><span class="p">();</span>		<span class="c1">// 从控制台获取键盘消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;kbd [%03d] %c</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>			<span class="c1">// 输入 0 进行 用户态到内核态的切换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_cs</span> <span class="o">!=</span> <span class="n">KERNEL_CS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;+++ switch to  kernel  mode +++</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_cs</span> <span class="o">=</span> <span class="n">KERNEL_CS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_ds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_es</span> <span class="o">=</span> <span class="n">KERNEL_DS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_eflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FL_IOPL_MASK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">switchu2k</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trapframe</span> <span class="o">*</span><span class="p">)(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_esp</span> <span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trapframe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="n">memmove</span><span class="p">(</span><span class="n">switchu2k</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trapframe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">switchu2k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;3&#39;</span><span class="p">)</span>		<span class="c1">// 输入 3 进行 内核态到用户态的切换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_cs</span> <span class="o">!=</span> <span class="n">USER_CS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;+++ switch to  user  mode +++</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">switchk2u</span> <span class="o">=</span> <span class="o">*</span><span class="n">tf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_cs</span> <span class="o">=</span> <span class="n">USER_CS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_ds</span> <span class="o">=</span> <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_es</span> <span class="o">=</span> <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_ss</span> <span class="o">=</span> <span class="n">USER_DS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_esp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">tf</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trapframe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">switchk2u</span><span class="p">.</span><span class="n">tf_eflags</span> <span class="o">|=</span> <span class="n">FL_IOPL_MASK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">switchk2u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>切换部分的代码与challenge1相同。</p>
<p><strong>check</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">neibelungen@neibelungen:~/os_kernel_lab/labcodes/lab1$ make grade
</span></span><span class="line"><span class="cl">Check Output:            <span class="o">(</span>2.5s<span class="o">)</span>
</span></span><span class="line"><span class="cl">  -check ring 0:                             OK
</span></span><span class="line"><span class="cl">  -check switch to ring 3:                   OK
</span></span><span class="line"><span class="cl">  -check switch to ring 0:                   OK
</span></span><span class="line"><span class="cl">  -check ticks:                              OK
</span></span><span class="line"><span class="cl">Total Score: 40/40
</span></span></code></pre></td></tr></table>
</div>
</div></div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-07-10</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span><a class="link-to-mardown" href=/ucore-lab-1/index.md target="_blank" rel="noopener noreferrer">阅读原始文档</a>
                    </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/pwn/">Pwn</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/ucore-lab-0/" class="prev" rel="prev" title="UCore Lab 0"><i class="fas fa-angle-left fa-fw"></i>UCore Lab 0</a>
            <a href="/ucore-lab-2/" class="next" rel="next" title="UCore Lab 2">UCore Lab 2<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer">Niebelungen</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div id="cookieconsent-container"></div><div class="assets"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/fuse/fuse.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/tablesort/tablesort.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script type="text/javascript" src="/lib/topbar/topbar.min.js"></script><script type="text/javascript" src="/lib/pjax/pjax.min.js"></script><script type="text/javascript" src="/js/theme.min.js" defer></script></div>

<div class="pjax-assets"><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":100},"comment":{},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/index.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":50,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"table":{"sort":true}};</script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.js" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.js" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/cookieconsent.min.js" defer></script><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.css">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"></noscript></div>
</body>

</html>