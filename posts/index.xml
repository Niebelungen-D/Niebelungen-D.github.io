<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Niebelungen</title>
        <link>http://example.org/posts/</link>
        <description>所有文章 | Niebelungen</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 08 Apr 2022 22:36:49 &#43;0800</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Niebelungenのjournal</title>
    <link>http://example.org/jounal/</link>
    <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/jounal/</guid>
    <description><![CDATA[<p>普普通通的周报</p>
<p><strong>Keep going, never stop.</strong></p>
<p><strong>続けて、止まらない。</strong></p>]]></description>
</item><item>
    <title>HITCON2020 Spark</title>
    <link>http://example.org/hitcon2020-spark/</link>
    <pubDate>Fri, 08 Apr 2022 22:36:49 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/hitcon2020-spark/</guid>
    <description><![CDATA[Spark]]></description>
</item><item>
    <title>CorCTF2021 Msg_msg</title>
    <link>http://example.org/corctf2021-msg_msg/</link>
    <pubDate>Fri, 18 Mar 2022 16:09:07 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/corctf2021-msg_msg/</guid>
    <description><![CDATA[corCTF2021-msg_msg在D^3CTF2022中的d3kheap，看上去是比较简单的一道题目，我（A Linux kernel newbie）一直苦于如]]></description>
</item><item>
    <title>D^3CTF2022-d3bpf&amp;v2</title>
    <link>http://example.org/d-3ctf2022-d3bpf/</link>
    <pubDate>Mon, 07 Mar 2022 13:08:08 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/d-3ctf2022-d3bpf/</guid>
    <description><![CDATA[d3bpfpatch1 2 3 4 5 6 7 8 9 10 11 12 13 case BPF_RSH: if (umin_val &gt;= insn_bitness) { if (alu32) __mark_reg32_known(dst_reg, 0); else __mark_reg_known_zero(dst_reg); break; } if (alu32) scalar32_min_max_rsh(dst_reg, &amp;src_reg); else scalar_min_max_rsh(dst_reg, &amp;src_reg); break; 似乎在不同的架构上右移64的结果不一样，但是在本题中，右移64位会保]]></description>
</item><item>
    <title>DiceCTF2022-containment/breach</title>
    <link>http://example.org/dicectf2022-containment-breach/</link>
    <pubDate>Mon, 07 Mar 2022 10:23:52 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/dicectf2022-containment-breach/</guid>
    <description><![CDATA[DiceCTF2022-containment/breach一个不一样的虚拟机。一个简单的虚拟机的二进制文件通过利用它来 &ldquo;突破 &]]></description>
</item><item>
    <title>DiceCTF2022</title>
    <link>http://example.org/dicectf2022/</link>
    <pubDate>Tue, 08 Feb 2022 20:49:59 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/dicectf2022/</guid>
    <description><![CDATA[DiceCTF2020DiceCTF题目好怪啊 interview在主函数有一个溢出，覆盖main的返回地址为_libc_strat_main]]></description>
</item><item>
    <title>RealWorldCTF2022-QLaaS</title>
    <link>http://example.org/realworldctf2022-qlaas/</link>
    <pubDate>Thu, 27 Jan 2022 17:46:53 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/realworldctf2022-qlaas/</guid>
    <description><![CDATA[QLaaS这是我比较感兴趣的一个题目。在比赛时，我的思路是类似虚拟机逃逸，通过读写内存从而实现CPU的逃逸，为此我还去寻找了Unicorn的]]></description>
</item><item>
    <title>RealWorldCTF2021-SVME</title>
    <link>http://example.org/realworldctf2022-svme/</link>
    <pubDate>Thu, 27 Jan 2022 17:46:07 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/realworldctf2022-svme/</guid>
    <description><![CDATA[SVME程序为一个简易的虚拟机，在Github上可以找到作者的源码，程序也没有去除符号。这个虚拟机更接近一个栈机器，它没有实现任何通用寄存器]]></description>
</item><item>
    <title>SECCON2021-kone_gadget</title>
    <link>http://example.org/seccon2021-kone-gadget/</link>
    <pubDate>Fri, 21 Jan 2022 02:54:45 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/seccon2021-kone-gadget/</guid>
    <description><![CDATA[kone_gadgetAdded to arch/x86/entry/syscalls/syscall_64.tbl 1 1337 64 seccon sys_seccon Added to kernel/sys.c: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(&#34;xor %%edx, %%edx;&#34; &#34;xor %%ebx, %%ebx;&#34; &#34;xor %%ecx, %%ecx;&#34; &#34;xor %%edi, %%edi;&#34; &#34;xor %%esi, %%esi;&#34; &#34;xor %%r8d, %%r8d;&#34; &#34;xor %%r9d, %%r9d;&#34; &#34;xor %%r10d, %%r10d;&#34; &#34;xor %%r11d, %%r11d;&#34; &#34;xor %%r12d, %%r12d;&#34; &#34;xor]]></description>
</item><item>
    <title>eebpf-Tokyowesterns CTF 2020</title>
    <link>http://example.org/eebpf-tokyowesterns-ctf-2020/</link>
    <pubDate>Mon, 17 Jan 2022 17:53:03 &#43;0800</pubDate><author>
        <name>Niebelungen</name>
    </author><guid>http://example.org/eebpf-tokyowesterns-ctf-2020/</guid>
    <description><![CDATA[eebpf一道来自Tokyowesterns CTF 2020的内核题目。在做题之前，需要学习ebpf的相关知识。这里有一篇我的笔记。 Bug题目pa]]></description>
</item></channel>
</rss>
